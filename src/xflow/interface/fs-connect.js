(function(){



/**
 * The output configuration of a FragmentShader generated by Xflow.
 * @constructor
 */
Xflow.FSConfig = function(shaderCode){
    this._shaderSourceCode = shaderCode;
    this._inputIndices = {};
};

Xflow.FSConfig.prototype.setInputIndices = function(inputIndices){
    return this._inputIndices = inputIndices;
}

Xflow.FSConfig.prototype.setShaderSourceCode = function(shaderSourceCode){
    return this._shaderSourceCode = shaderSourceCode;
}

Xflow.FSConfig.prototype.getKey = function(){
    return this._shaderSourceCode;
}

var c_fs_operator_cache = {};

Xflow.FSConfig.prototype.getOperator = function(xflowNode){
    var key = this.getKey();
    if(c_fs_operator_cache[key])
    	return c_fs_operator_cache[key];

    var converter = new Shade.SnippetConverter();
    var convertedShaderCode = converter.convertShaderToSnippedAst(this._shaderSourceCode);
    
    var outputs = [], params = [], glslCode = convertedShaderCode.code;
    name = "FSConnect";
    
    if (convertedShaderCode.params.length == 0)
    	name+=this._shaderSourceCode;
    else{
	    for (var param in convertedShaderCode.params){
	    	var name = convertedShaderCode.params[param];
	    	var attr = xflowNode.getOutputChannelInfo(name);
	    	if (attr){
	    		type = Xflow.getTypeName(attr.type);
	    		deferred = false;
	    	}
	    	else{
	    		//TODO We have to do it another way. It may happen its a type of vector2 and some functionalities of vector2 is not available in vector3
	    		type ="float3"; // It doesn't matter if it is right type or not. Shadejs will figure it out
	    		deferred = true;
	    	}
			params.push( { type: type, source: name,optional: false,deferred: deferred} ); 
			name += "T" + type + "N" + name + "O" + false + ".";	
	    }
    }
    outputs.push( { type: "float4", name: "output"} );
    var operator = Xflow.initAnonymousOperator(name,
    {
        outputs: outputs,
        params:  params,
        evaluate_shadejs: glslCode
    });
    c_fs_operator_cache[key] = operator;
    return operator;
}


Xflow.FragmentShader = function(programData){
    this._programData = programData;
    this._glslCode = null;
    this._inputNames = [];
    this._outputNames = [];
    this._inputInfo = {};
    this._outputInfo = {};
}

Object.defineProperty(Xflow.FragmentShader.prototype, "inputNames", {
    set: function(v){
        throw new Error("inputNames is readonly");
    },
    get: function(){ return this._inputNames; }
});

Object.defineProperty(Xflow.FragmentShader.prototype, "outputNames", {
    set: function(v){
        throw new Error("outputNames is readonly");
    },
    get: function(){ return this._outputNames; }
});

Xflow.FragmentShader.prototype.isInputUniform = function(name){
    return this._inputInfo[name].uniform;
}
Xflow.FragmentShader.prototype.getInputData = function(name){
    return this._programData.getDataEntry(this._inputInfo[name].index);
}

Xflow.FragmentShader.prototype.isOutputNull = function(name){
    return this._outputInfo[name].iteration == Xflow.ITERATION_TYPE.NULL;
}
Xflow.FragmentShader.prototype.isOutputFragmentUniform = function(name){
    return this._outputInfo[name].iteration == Xflow.ITERATION_TYPE.ONE;
}
Xflow.FragmentShader.prototype.getUniformOutputData = function(name){
    return this._programData.getDataEntry(this._outputInfo[name].index);
}
Xflow.FragmentShader.prototype.getOutputType = function(name){
    return this._outputInfo[name].type;
}
Xflow.FragmentShader.prototype.getOutputSourceName = function(name){
    return this._outputInfo[name].sourceName;
}
Xflow.FragmentShader.prototype.getGLSLCode = function(){
    return this._glslCode;
}


}());