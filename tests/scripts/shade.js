!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Shade=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib');

},{"./lib":5}],2:[function(require,module,exports){

var walkes = require('walkes');
var worklist = require('../');
var Set = require('../set');

module.exports = availableExpressions;

/*
So here is the story:
Each node is supposed to have a `Set` of expressions. And for each expression,
I want to save the `Set` of contained variables for easier killing.

Since JS has no records yet (see http://wiki.ecmascript.org/doku.php?id=strawman:records )
and no concept of structural equality, an expression represented by an AST node
is *never ever* equal to an structurally equal expression unless its the
identical node.
The same goes for `Set`s. Since they are just shimmed using normal Objects, they
are *never ever* equal, although they contain the exact same members.

So as a workaround, I `JSON.stringify` the expression to save it in the Set and
use a mapping table to get to the expression object and the corresponding set of
variables.

Of course, I could just use a custom Set implementation which uses a custom
equality check function. But I want to be forward-compatible with the upcoming
ES6 standard, which should provide a O(1) Sets, instead of the O(n) shim.
*/

function availableExpressions(cfg) {
	var expressionMap = {};

	function findExpressions(ast) {
		var expressions = new Set();
		// FIXME: just handling binary expressions so far
		walkes(ast, {
			Identifier: function () {
				return new Set(this.name);
			},
			Literal: function () {
				return new Set();
			},
			BinaryExpression: function (recurse) {
				var stringified = JSON.stringify(this);
				expressions.add(stringified);
				if (stringified in expressionMap) {
					return expressionMap[stringified].variables;
				}
				var right = recurse(this.right);
				var left = recurse(this.left);
				var variables = Set.union(left, right);
				expressionMap[stringified] = {
					expression: this,
					variables: variables
				};
				return variables;
			}
		});
		return expressions;
	}

	// run the algorithm
	var output = worklist(cfg, function (input, list) {
		if (this.type || !this.astNode)
			return input;
		var kill = this.kill = this.kill || findAssignments(this.astNode);
		var generate = this.generate = this.generate || findExpressions(this.astNode);
		var killed = new Set(input.values().filter(function (expr) {
			var variables = expressionMap[expr].variables;
			return !Set.intersect(variables, kill).size;
		}));
		return Set.union(killed, generate);
	}, {direction: 'forward', merge: worklist.merge(Set.intersect)});

	// go over all the nodes and push down the real objects into the output
	cfg[2].forEach(function (node) {
		var out = output.get(node);
		output.set(node, new Set(out.values().map(function (expr) {
			return expressionMap[expr].expression;
		})));
	});

	return output;
}

function findAssignments(ast) {
	var variables = new Set();
	walkes(ast, {
		AssignmentExpression: function (recurse) {
			if (this.left.type === 'Identifier')
				variables.add(this.left.name);
			recurse(this.right);
		},
		VariableDeclarator: function (recurse) {
			variables.add(this.id.name);
			if (this.init)
				recurse(this.init);
		}
	});
	return variables;
}


},{"../":5,"../set":7,"walkes":53}],3:[function(require,module,exports){

exports.liveVariables = require('./livevariables');
exports.availableExpressions = require('./availableexpressions');


},{"./availableexpressions":2,"./livevariables":4}],4:[function(require,module,exports){

var walkes = require('walkes');
var worklist = require('../');
var Set = require('../set');

module.exports = liveVariables;

function liveVariables(cfg) {
	return worklist(cfg, function (input) {
		if (this.type || !this.astNode)
			return input;
		var kill = this.kill = this.kill || findAssignments(this.astNode);
		var generate = this.generate = this.generate || findVariables(this.astNode);
		return Set.union(Set.minus(input, kill), generate);
	}, {direction: 'backward'});
}

function findAssignments(astNode) {
	var variables = new Set();
	walkes(astNode, {
		AssignmentExpression: function (recurse) {
			if (this.left.type === 'Identifier')
				variables.add(this.left.name);
			recurse(this.right);
		},
		FunctionDeclaration: function () {},
		FunctionExpression: function () {},
		VariableDeclarator: function (recurse) {
			variables.add(this.id.name);
			if (this.init)
				recurse(this.init);
		}
	});
	return variables;
}
function findVariables(astNode) {
	var variables = new Set();
	walkes(astNode, {
		AssignmentExpression: function (recurse) {
			if (this.left.type !== 'Identifier')
				recurse(this.left);
			recurse(this.right);
		},
		FunctionDeclaration: function () {},
		FunctionExpression: function () {},
		Identifier: function () {
			variables.add(this.name);
		},
		MemberExpression: function (recurse) {
			recurse(this.object);
		},
		Property: function (recurse) {
			recurse(this.value);
		},
		VariableDeclarator: function (recurse) {
			recurse(this.init);
		}
	});
	return variables;
}


},{"../":5,"../set":7,"walkes":53}],5:[function(require,module,exports){

var Queue = require('./queue');
var Set = require('./set');

var exports = module.exports = worklist;

// expose the utilities to have them tested separately
exports.Queue = Queue;
exports.Set = Set;
exports.examples = require('./examples');

/**
 * Implementation of a general worklist algorithm
 * `cfg` is a control flow graph created by `esgraph`,
 * `transferFunction` gets called with (this = node, input, worklist)
 * it operates on the input `Set` and can return an output set, in which case
 * the worklist algorithm automatically enqueues all the successor nodes, or it
 * might return an {output: output, enqueue: false} object in which case it is
 * itself responsible to enqueue the successor nodes.
 * `options` defines the `direction`, a `merge` function and an `equals`
 * function which merge the inputs to a node and determine if a node has changed
 * its output respectively.
 * Returns a `Map` from node -> output
 */
function worklist(cfg, transferFunction, options) {
	options = options || {};
	var direction = options.direction || 'forward';
	var merge = options.merge || worklist.merge(Set.union);
	var equals = options.equals || Set.equals;
	var list = new Queue();
	if (direction === 'forward') {
		list.push(cfg[0]);
		var predecessors = worklist.predecessors;
		var successors = worklist.successors;
	} else {
		list.push(cfg[1]);
		var predecessors = worklist.successors;
		var successors = worklist.predecessors;
	}
	var start = options.start || new Set();

	var output = new Map();
	while (list.length) {
		var node = list.shift();
		var pre = predecessors(node)
			.map(function (n) { return output.get(n); });
		var input = pre.length ? merge(pre) : start;
		var oldOutput = output.get(node);
		var out = transferFunction.call(node, input, list, oldOutput);
		if (!out || out instanceof Set)
			out = {output: out, enqueue: true};
		output.set(node, out.output);
		if (out.enqueue && (!oldOutput || !equals(out.output, oldOutput)))
			successors(node).forEach(list.push.bind(list));
	}
	return output;
};

worklist.predecessors = function (node) {
	return node.prev;
};
worklist.successors = function (node) {
	return node.next;
};

worklist.merge = function (fn) {
	return function (inputs) {
		if (inputs.length == 1)
			return new Set(inputs[0]);
		return inputs.reduce(fn);
	};
};


},{"./examples":3,"./queue":6,"./set":7}],6:[function(require,module,exports){

module.exports = Queue;

/**
 * This is a really small priority queue that makes sure that duplicate elements
 * are being inserted at the end
 */
function Queue() {
	var q = [];
	q.__proto__ = Queue.prototype;
	return q;
}

Queue.prototype = Object.create(Array.prototype);
Queue.prototype.push = function Queue_push(elem) {
	var pos = this.indexOf(elem);
	if (pos != -1)
		this.splice(pos, 1);
	Array.prototype.push.call(this, elem);
};

},{}],7:[function(require,module,exports){

module.exports = Set;

/**
 * ES6 Sets in `node --harmony` do not provide `.values()` or `for of` iteration
 * yet, so they are pretty useless :-(
 * This Set also does not use `Object.is`; we do not care about NaN, -0, +0
 */
function Set(elements) {
	this._values = [];
	if (Array.isArray(elements))
		elements.forEach(this.add.bind(this));
	else if (elements instanceof Set)
		elements._values.forEach(this.add.bind(this));
}
Object.defineProperty(Set.prototype, 'size', {
	enumerable: false,
	configurable: false,
	get: function () {
		return this._values.length;
	}
});
Set.prototype._i = function Set__i(elem) {
	return this._values.indexOf(elem);
};
Set.prototype.add = function Set_add(elem) {
	if (!this.has(elem))
		this._values.push(elem);
};
Set.prototype.has = function Set_has(elem) {
	return !!~this._i(elem);
};
Set.prototype.delete = function Set_delete(elem) {
	var i = this._i(elem);
	if (!~i)
		return;
	this._values.splice(i, 1);
};
Set.prototype.values = function Set_values() {
	return [].concat(this._values);
};

// forward some convenience functions from Array.prototype
[
	'some',
	'map',
	'every',
	'filter',
	'forEach'
].forEach(function (method) {
	Set.prototype[method] = function () {
		return Array.prototype[method].apply(this._values, arguments);
	}
});

// some convenience functions
Set.prototype.first = function Set_first() {
	return this._values[0];
};
Set.intersect = function intersect(a, b) {
	if (!a && b)
		return new Set(b);
	if (!b && a)
		return new Set(a);
	var s = new Set();
	a.forEach(function (val) {
		if (b.has(val))
			s.add(val);
	});
	return s;
};
Set.union = function union(a, b) {
	if (!a && b)
		return new Set(b);
	var s = new Set(a);
	if (b)
		b.forEach(s.add.bind(s));
	return s;
};
Set.equals = function equals(a, b) {
	if (a.size != b.size)
		return false;
	return a.every(function (val) {
		return b.has(val);
	});
};
Set.minus = function minus(a, b) {
	var s = new Set(a);
	b.forEach(s.delete.bind(s));
	return s;
};


},{}],8:[function(require,module,exports){
(function (global){
//! Copyright 2012 Eric Wendelin - MIT License

/**
 * es6-map-shim.js is a DESTRUCTIVE shim that follows the latest Map specification as closely as possible.
 * It is destructive in the sense that it overrides native implementations.
 *
 * This library assumes ES5 functionality: Object.create, Object.defineProperty, Array.indexOf, Function.bind
 */
(function(module) {
    function Map(iterable) {
        var _items = [];
        var _keys = [];
        var _values = [];

        // Object.is polyfill, courtesy of @WebReflection
        var is = Object.is || function(a, b) {
            return a === b ?
                a !== 0 || 1 / a == 1 / b :
                a != a && b != b;
        };

        // More reliable indexOf, courtesy of @WebReflection
        var betterIndexOf = function(value) {
            if(value != value || value === 0) {
                for(var i = this.length; i-- && !is(this[i], value););
            } else {
                i = [].indexOf.call(this, value);
            }
            return i;
        };

        var MapIterator = function MapIterator(map, kind) {
            var _index = 0;

            return Object.create({}, {
                next: {
                    value: function() {
                        // check if index is within bounds
                        if (_index < map.items().length) {
                            switch(kind) {
                                case 'keys': return map.keys()[_index++];
                                case 'values': return map.values()[_index++];
                                case 'keys+values': return [].slice.call(map.items()[_index++]);
                                default: throw new TypeError('Invalid iterator type');
                            }
                        }
                        // TODO: make sure I'm interpreting the spec correctly here
                        throw new Error('Stop Iteration');
                    }
                },
                iterator: {
                    value: function() {
                        return this;
                    }
                },
                toString: {
                    value: function() {
                        return '[object Map Iterator]';
                    }
                }
            });
        };

        var _set = function(key, value) {
            // check if key exists and overwrite
            var index = betterIndexOf.call(_keys, key);
            if (index > -1) {
                _items[index] = value;
                _values[index] = value;
            } else {
                _items.push([key, value]);
                _keys.push(key);
                _values.push(value);
            }
        };

        var setItem = function(item) {
            if (item.length !== 2) {
                throw new TypeError('Invalid iterable passed to Map constructor');
            }

            _set(item[0], item[1]);
        };

        // FIXME: accommodate any class that defines an @@iterator method that returns
        //      an iterator object that produces two element array-like objects
        if (Array.isArray(iterable)) {
            iterable.forEach(setItem);
        } else if (iterable !== undefined) {
            throw new TypeError('Invalid Map');
        }

        return Object.create(MapPrototype, {
            items:{
                value:function() {
                    return [].slice.call(_items);
                }
            },
            keys:{
                value:function() {
                    return [].slice.call(_keys);
                }
            },
            values:{
                value:function() {
                    return [].slice.call(_values);
                }
            },
            has:{
                value:function(key) {
                    // TODO: check how spec reads about null values
                    var index = betterIndexOf.call(_keys, key);
                    return index > -1;
                }
            },
            get:{
                value:function(key) {
                    var index = betterIndexOf.call(_keys, key);
                    return index > -1 ? _values[index] : undefined;
                }
            },
            set:{
                value: _set
            },
            size:{
                get:function() {
                    return _items.length;
                }
            },
            clear:{
                value:function() {
                    _keys.length = _values.length = _items.length = 0;
                }
            },
            'delete':{
                value:function(key) {
                    var index = betterIndexOf.call(_keys, key);
                    if (index > -1) {
                        _keys.splice(index, 1);
                        _values.splice(index, 1);
                        _items.splice(index, 1);
                        return true;
                    }
                    return false;
                }
            },
            forEach:{
                value:function(callbackfn /*, thisArg*/) {
                    if (typeof callbackfn != 'function') {
                        throw new TypeError('Invalid callback function given to forEach');
                    }

                    function tryNext() {
                        try {
                            return iter.next();
                        } catch(e) {
                            return undefined;
                        }
                    }

                    var iter = this.iterator();
                    var current = tryNext();
                    var next = tryNext();
                    while(current !== undefined) {
                        callbackfn.apply(arguments[1], [current[1], current[0], this]);
                        current = next;
                        next = tryNext();
                    }
                }
            },
            iterator:{
                value: function() {
                    return new MapIterator(this, 'keys+values');
                }
            },
            toString:{
                value: function() {
                    return '[Object Map]';
                }
            }
        });
    }

    var notInNode = module == 'undefined';
    var window = notInNode ? this : global;
    var module = notInNode ? {} : exports;
    var MapPrototype = Map.prototype;

    Map.prototype = MapPrototype = Map();

    window.Map = module.Map = window.Map || Map;
}.call(this, typeof exports));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],9:[function(require,module,exports){
(function (global){
/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        isArray,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        sourceCode,
        preserveBlankLines,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = estraverse.Syntax;

    // Generation is done by generateExpression.
    function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
    }

    // Generation is done by generateStatement.
    function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
    }

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Await: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        TaggedTemplate: 17,
        Member: 18,
        Primary: 19
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    //Flags
    var F_ALLOW_IN = 1,
        F_ALLOW_CALL = 1 << 1,
        F_ALLOW_UNPARATH_NEW = 1 << 2,
        F_FUNC_BODY = 1 << 3,
        F_DIRECTIVE_CTX = 1 << 4,
        F_SEMICOLON_OPT = 1 << 5;

    //Expression flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_ALLOW_CALL
    // F_ALLOW_UNPARATH_NEW
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
        E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
        E_TFF = F_ALLOW_IN,
        E_FFT = F_ALLOW_UNPARATH_NEW,
        E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;

    //Statement flag sets
    //NOTE: Flag order:
    // F_ALLOW_IN
    // F_FUNC_BODY
    // F_DIRECTIVE_CTX
    // F_SEMICOLON_OPT
    var S_TFFF = F_ALLOW_IN,
        S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
        S_FFFF = 0x00,
        S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
        S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false,
                preserveBlankLines: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null,
            sourceCode: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function merge(target, override) {
        var key;
        for (key in override) {
            if (override.hasOwnProperty(key)) {
                target[key] = override[key];
            }
        }
        return target;
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex;

        if (code === 0x08  /* \b */) {
            return '\\b';
        }

        if (code === 0x0C  /* \f */) {
            return '\\f';
        }

        if (code === 0x09  /* \t */) {
            return '\\t';
        }

        hex = code.toString(16).toUpperCase();
        if (json || code > 0xFF) {
            return '\\u' + '0000'.slice(hex.length) + hex;
        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
            return '\\0';
        } else if (code === 0x000B  /* \v */) { // '\v'
            return '\\x0B';
        } else {
            return '\\x' + '00'.slice(hex.length) + hex;
        }
    }

    function escapeDisallowedCharacter(code) {
        if (code === 0x5C  /* \ */) {
            return '\\\\';
        }

        if (code === 0x0A  /* \n */) {
            return '\\n';
        }

        if (code === 0x0D  /* \r */) {
            return '\\r';
        }

        if (code === 0x2028) {
            return '\\u2028';
        }

        if (code === 0x2029) {
            return '\\u2029';
        }

        throw new Error('Incorrectly classified character');
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if ((json && code < 0x20  /* SP */) || !(json || escapeless || (code >= 0x20  /* SP */ && code <= 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource,
            rightSource,
            leftCharCode,
            rightCharCode;

        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
            return [right];
        }

        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
            return [left];
        }

        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
            esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) ||
            leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase;
        previousBase = base;
        base += indent;
        fn(base);
        base = previousBase;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                var result = '//' + comment.value;
                if (!preserveBlankLines) {
                    result += '\n';
                }
                return result;
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment,
            extRange, range, prevRange, prefix, infix, suffix, count;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            if (preserveBlankLines) {
                comment = stmt.leadingComments[0];
                result = [];

                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;
                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }

                prevRange = range;

                for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
                    comment = stmt.leadingComments[i];
                    range = comment.range;

                    infix = sourceCode.substring(prevRange[1], range[0]);
                    count = (infix.match(/\n/g) || []).length;
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));

                    prevRange = range;
                }

                suffix = sourceCode.substring(range[1], extRange[1]);
                count = (suffix.match(/\n/g) || []).length;
                result.push(stringRepeat('\n', count));
            } else {
                comment = stmt.leadingComments[0];
                result = [];
                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                    result.push('\n');
                }
                result.push(generateComment(comment));
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push('\n');
                }

                for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                    comment = stmt.leadingComments[i];
                    fragment = [generateComment(comment)];
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        fragment.push('\n');
                    }
                    result.push(addIndent(fragment));
                }
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {

            if (preserveBlankLines) {
                comment = stmt.trailingComments[0];
                extRange = comment.extendedRange;
                range = comment.range;

                prefix = sourceCode.substring(extRange[0], range[0]);
                count = (prefix.match(/\n/g) || []).length;

                if (count > 0) {
                    result.push(stringRepeat('\n', count));
                    result.push(addIndent(generateComment(comment)));
                } else {
                    result.push(prefix);
                    result.push(generateComment(comment));
                }
            } else {
                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
                specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
                for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                    comment = stmt.trailingComments[i];
                    if (tailingToStatement) {
                        // We assume target like following script
                        //
                        // var t = 20;  /**
                        //               * This is comment of t
                        //               */
                        if (i === 0) {
                            // first case
                            result = [result, indent];
                        } else {
                            result = [result, specialBase];
                        }
                        result.push(generateComment(comment, specialBase));
                    } else {
                        result = [result, addIndent(generateComment(comment))];
                    }
                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result = [result, '\n'];
                    }
                }
            }
        }

        return result;
    }

    function generateBlankLines(start, end, result) {
        var j, newlineCount = 0;

        for (j = start; j < end; j++) {
            if (sourceCode[j] === '\n') {
                newlineCount++;
            }
        }

        for (j = 1; j < newlineCount; j++) {
            result.push(newline);
        }
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }

    function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];

        if (typeof verbatim === 'string') {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, precedence);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function CodeGenerator() {
    }

    // Helpers.

    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, this.generateStatement(stmt, flags)];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [
                newline,
                addIndent(that.generateStatement(stmt, flags))
            ];
        });

        return result;
    };

    CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    };

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
    }

    function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? '*' + space : '';
    }

    function generateMethodPrefix(prop) {
        var func = prop.value;
        if (func.async) {
            return generateAsyncPrefix(func, !prop.computed);
        } else {
            // avoid space before method name
            return generateStarSuffix(func) ? '*' : '';
        }
    }

    CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
        if (node.type === Syntax.Identifier) {
            return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
    };

    CodeGenerator.prototype.generateFunctionParams = function (node) {
        var i, iz, result, hasDefault;

        hasDefault = false;

        if (node.type === Syntax.ArrowFunctionExpression &&
                !node.rest && (!node.defaults || node.defaults.length === 0) &&
                node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
            result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
            result.push('(');
            if (node.defaults) {
                hasDefault = true;
            }
            for (i = 0, iz = node.params.length; i < iz; ++i) {
                if (hasDefault && node.defaults[i]) {
                    // Handle default values.
                    result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
                } else {
                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
                }
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }

            if (node.rest) {
                if (node.params.length) {
                    result.push(',' + space);
                }
                result.push('...');
                result.push(generateIdentifier(node.rest));
            }

            result.push(')');
        }

        return result;
    };

    CodeGenerator.prototype.generateFunctionBody = function (node) {
        var result, expr;

        result = this.generateFunctionParams(node);

        if (node.type === Syntax.ArrowFunctionExpression) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(this.maybeBlock(node.body, S_TTFF));
        }

        return result;
    };

    CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
        var result = ['for' + space + '('], that = this;
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
                });
            } else {
                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
            }

            result = join(result, operator);
            result = [join(
                result,
                that.generateExpression(stmt.right, Precedence.Sequence, E_TTT)
            ), ')'];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
    };

    CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
        var result = [];

        if (computed) {
            result.push('[');
        }

        result.push(this.generateExpression(expr, Precedence.Sequence, E_TTT));
        if (computed) {
            result.push(']');
        }

        return result;
    };

    CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
            flags |= F_ALLOW_IN;
        }

        return parenthesize(
            [
                this.generateExpression(left, Precedence.Call, flags),
                space + operator + space,
                this.generateExpression(right, Precedence.Assignment, flags)
            ],
            Precedence.Assignment,
            precedence
        );
    };

    CodeGenerator.prototype.semicolon = function (flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
            return '';
        }
        return ';';
    };

    // Statements.

    CodeGenerator.Statement = {

        BlockStatement: function (stmt, flags) {
            var range, content, result = ['{', newline], that = this;

            withIndent(function () {
                // handle functions without any code
                if (stmt.body.length === 0 && preserveBlankLines) {
                    range = stmt.range;
                    if (range[1] - range[0] > 2) {
                        content = sourceCode.substring(range[0] + 1, range[1] - 1);
                        if (content[0] === '\n') {
                            result = ['{'];
                        }
                        result.push(content);
                    }
                }

                var i, iz, fragment, bodyFlags;
                bodyFlags = S_TFFF;
                if (flags & F_FUNC_BODY) {
                    bodyFlags |= F_DIRECTIVE_CTX;
                }

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    if (preserveBlankLines) {
                        // handle spaces before the first line
                        if (i === 0) {
                            if (stmt.body[0].leadingComments) {
                                range = stmt.body[0].leadingComments[0].extendedRange;
                                content = sourceCode.substring(range[0], range[1]);
                                if (content[0] === '\n') {
                                    result = ['{'];
                                }
                            }
                            if (!stmt.body[0].leadingComments) {
                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                            }
                        }

                        // handle spaces between lines
                        if (i > 0) {
                            if (!stmt.body[i - 1].trailingComments  && !stmt.body[i].leadingComments) {
                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                            }
                        }
                    }

                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }

                    if (stmt.body[i].leadingComments && preserveBlankLines) {
                        fragment = that.generateStatement(stmt.body[i], bodyFlags);
                    } else {
                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
                    }

                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        if (preserveBlankLines && i < iz - 1) {
                            // don't add a new line if there are leading coments
                            // in the next statement
                            if (!stmt.body[i + 1].leadingComments) {
                                result.push(newline);
                            }
                        } else {
                            result.push(newline);
                        }
                    }

                    if (preserveBlankLines) {
                        // handle spaces after the last line
                        if (i === iz - 1) {
                            if (!stmt.body[i].trailingComments) {
                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                            }
                        }
                    }
                }
            });

            result.push(addIndent('}'));
            return result;
        },

        BreakStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'break ' + stmt.label.name + this.semicolon(flags);
            }
            return 'break' + this.semicolon(flags);
        },

        ContinueStatement: function (stmt, flags) {
            if (stmt.label) {
                return 'continue ' + stmt.label.name + this.semicolon(flags);
            }
            return 'continue' + this.semicolon(flags);
        },

        ClassBody: function (stmt, flags) {
            var result = [ '{', newline], that = this;

            withIndent(function (indent) {
                var i, iz;

                for (i = 0, iz = stmt.body.length; i < iz; ++i) {
                    result.push(indent);
                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(newline);
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        ClassDeclaration: function (stmt, flags) {
            var result, fragment;
            result  = ['class ' + stmt.id.name];
            if (stmt.superClass) {
                fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(stmt.body, S_TFFT));
            return result;
        },

        DirectiveStatement: function (stmt, flags) {
            if (extra.raw && stmt.raw) {
                return stmt.raw + this.semicolon(flags);
            }
            return escapeDirective(stmt.directive) + this.semicolon(flags);
        },

        DoWhileStatement: function (stmt, flags) {
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
            result = this.maybeBlockSuffix(stmt.body, result);
            return join(result, [
                'while' + space + '(',
                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                ')' + this.semicolon(flags)
            ]);
        },

        CatchClause: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                var guard;

                result = [
                    'catch' + space + '(',
                    that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                    ')'
                ];

                if (stmt.guard) {
                    guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                    result.splice(2, 0, ' if ', guard);
                }
            });
            result.push(this.maybeBlock(stmt.body, S_TFFF));
            return result;
        },

        DebuggerStatement: function (stmt, flags) {
            return 'debugger' + this.semicolon(flags);
        },

        EmptyStatement: function (stmt, flags) {
            return ';';
        },

        ExportDeclaration: function (stmt, flags) {
            var result = [ 'export' ], bodyFlags, that = this;

            bodyFlags = (flags & F_SEMICOLON_OPT) ? S_TFFT : S_TFFF;

            // export default HoistableDeclaration[Default]
            // export default AssignmentExpression[In] ;
            if (stmt['default']) {
                result = join(result, 'default');
                if (isStatement(stmt.declaration)) {
                    result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
                } else {
                    result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
                }
                return result;
            }

            // export VariableStatement
            // export Declaration[Default]
            if (stmt.declaration) {
                return join(result, this.generateStatement(stmt.declaration, bodyFlags));
            }

            // export * FromClause ;
            // export ExportClause[NoReference] FromClause ;
            // export ExportClause ;
            if (stmt.specifiers) {
                if (stmt.specifiers.length === 0) {
                    result = join(result, '{' + space + '}');
                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
                } else {
                    result = join(result, '{');
                    withIndent(function (indent) {
                        var i, iz;
                        result.push(newline);
                        for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                            result.push(indent);
                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                            if (i + 1 < iz) {
                                result.push(',' + newline);
                            }
                        }
                    });
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                        result.push(newline);
                    }
                    result.push(base + '}');
                }

                if (stmt.source) {
                    result = join(result, [
                        'from' + space,
                        // ModuleSpecifier
                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                        this.semicolon(flags)
                    ]);
                } else {
                    result.push(this.semicolon(flags));
                }
            }
            return result;
        },

        ExpressionStatement: function (stmt, flags) {
            var result, fragment;

            function isClassPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 5) !== 'class') {
                    return false;
                }
                code = fragment.charCodeAt(5);
                return code === 0x7B  /* '{' */ || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
            }

            function isFunctionPrefixed(fragment) {
                var code;
                if (fragment.slice(0, 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            function isAsyncPrefixed(fragment) {
                var code, i, iz;
                if (fragment.slice(0, 5) !== 'async') {
                    return false;
                }
                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
                    return false;
                }
                for (i = 6, iz = fragment.length; i < iz; ++i) {
                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
                        break;
                    }
                }
                if (i === iz) {
                    return false;
                }
                if (fragment.slice(i, i + 8) !== 'function') {
                    return false;
                }
                code = fragment.charCodeAt(i + 8);
                return code === 0x28 /* '(' */ || esutils.code.isWhiteSpace(code) || code === 0x2A  /* '*' */ || esutils.code.isLineTerminator(code);
            }

            result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
            // 12.4 '{', 'function', 'class' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charCodeAt(0) === 0x7B  /* '{' */ ||  // ObjectExpression
                    isClassPrefixed(fragment) ||
                    isFunctionPrefixed(fragment) ||
                    isAsyncPrefixed(fragment) ||
                    (directive && (flags & F_DIRECTIVE_CTX) && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + this.semicolon(flags)];
            } else {
                result.push(this.semicolon(flags));
            }
            return result;
        },

        ImportDeclaration: function (stmt, flags) {
            // ES6: 15.2.1 valid import declarations:
            //     - import ImportClause FromClause ;
            //     - import ModuleSpecifier ;
            var result, cursor, that = this;

            // If no ImportClause is present,
            // this should be `import ModuleSpecifier` so skip `from`
            // ModuleSpecifier is StringLiteral.
            if (stmt.specifiers.length === 0) {
                // import ModuleSpecifier ;
                return [
                    'import',
                    space,
                    // ModuleSpecifier
                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                    this.semicolon(flags)
                ];
            }

            // import ImportClause FromClause ;
            result = [
                'import'
            ];
            cursor = 0;

            // ImportedBinding
            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
                result = join(result, [
                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                ]);
                ++cursor;
            }

            if (stmt.specifiers[cursor]) {
                if (cursor !== 0) {
                    result.push(',');
                }

                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
                    // NameSpaceImport
                    result = join(result, [
                            space,
                            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
                    ]);
                } else {
                    // NamedImports
                    result.push(space + '{');

                    if ((stmt.specifiers.length - cursor) === 1) {
                        // import { ... } from "...";
                        result.push(space);
                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                        result.push(space + '}' + space);
                    } else {
                        // import {
                        //    ...,
                        //    ...,
                        // } from "...";
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                                result.push(indent);
                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                                if (i + 1 < iz) {
                                    result.push(',' + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + '}' + space);
                    }
                }
            }

            result = join(result, [
                'from' + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
            ]);
            return result;
        },

        VariableDeclarator: function (stmt, flags) {
            var itemFlags = (flags & F_ALLOW_IN) ? E_TTT : E_FTT;
            if (stmt.init) {
                return [
                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
                    space,
                    '=',
                    space,
                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
                ];
            }
            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },

        VariableDeclaration: function (stmt, flags) {
            // VariableDeclarator is typed as Statement,
            // but joined with comma (not LineTerminator).
            // So if comment is attached to target node, we should specialize.
            var result, i, iz, node, bodyFlags, that = this;

            result = [ stmt.kind ];

            bodyFlags = (flags & F_ALLOW_IN) ? S_TFFF : S_FFFF;

            function block() {
                node = stmt.declarations[0];
                if (extra.comment && node.leadingComments) {
                    result.push('\n');
                    result.push(addIndent(that.generateStatement(node, bodyFlags)));
                } else {
                    result.push(noEmptySpace());
                    result.push(that.generateStatement(node, bodyFlags));
                }

                for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
                    node = stmt.declarations[i];
                    if (extra.comment && node.leadingComments) {
                        result.push(',' + newline);
                        result.push(addIndent(that.generateStatement(node, bodyFlags)));
                    } else {
                        result.push(',' + space);
                        result.push(that.generateStatement(node, bodyFlags));
                    }
                }
            }

            if (stmt.declarations.length > 1) {
                withIndent(block);
            } else {
                block();
            }

            result.push(this.semicolon(flags));

            return result;
        },

        ThrowStatement: function (stmt, flags) {
            return [join(
                'throw',
                this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
        },

        TryStatement: function (stmt, flags) {
            var result, i, iz, guardedHandlers;

            result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
            result = this.maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
                    if (stmt.finalizer || i + 1 !== iz) {
                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (isArray(stmt.handler)) {
                        for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                            if (stmt.finalizer || i + 1 !== iz) {
                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                        if (stmt.finalizer) {
                            result = this.maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
            }
            return result;
        },

        SwitchStatement: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                bodyFlags = S_TFFF;
                for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
                    if (i === iz - 1) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            return result;
        },

        SwitchCase: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags, that = this;
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                iz = stmt.consequent.length;
                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                bodyFlags = S_TFFF;
                for (; i < iz; ++i) {
                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                        bodyFlags |= F_SEMICOLON_OPT;
                    }
                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
                    result.push(fragment);
                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            return result;
        },

        IfStatement: function (stmt, flags) {
            var result, bodyFlags, semicolonOptional, that = this;
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            semicolonOptional = flags & F_SEMICOLON_OPT;
            bodyFlags = S_TFFF;
            if (semicolonOptional) {
                bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.alternate) {
                result.push(this.maybeBlock(stmt.consequent, S_TFFF));
                result = this.maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
                } else {
                    result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
                }
            } else {
                result.push(this.maybeBlock(stmt.consequent, bodyFlags));
            }
            return result;
        },

        ForStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(that.generateStatement(stmt.init, S_FFFF));
                    } else {
                        // F_ALLOW_IN becomes false.
                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        ForInStatement: function (stmt, flags) {
            return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        ForOfStatement: function (stmt, flags) {
            return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },

        LabeledStatement: function (stmt, flags) {
            return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },

        Program: function (stmt, flags) {
            var result, fragment, i, iz, bodyFlags;
            iz = stmt.body.length;
            result = [safeConcatenation && iz > 0 ? '\n' : ''];
            bodyFlags = S_TFTF;
            for (i = 0; i < iz; ++i) {
                if (!safeConcatenation && i === iz - 1) {
                    bodyFlags |= F_SEMICOLON_OPT;
                }

                if (preserveBlankLines) {
                    // handle spaces before the first line
                    if (i === 0) {
                        if (!stmt.body[0].leadingComments) {
                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                        }
                    }

                    // handle spaces between lines
                    if (i > 0) {
                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                        }
                    }
                }

                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
                result.push(fragment);
                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    if (preserveBlankLines) {
                        if (!stmt.body[i + 1].leadingComments) {
                            result.push(newline);
                        }
                    } else {
                        result.push(newline);
                    }
                }

                if (preserveBlankLines) {
                    // handle spaces after the last line
                    if (i === iz - 1) {
                        if (!stmt.body[i].trailingComments) {
                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                        }
                    }
                }
            }
            return result;
        },

        FunctionDeclaration: function (stmt, flags) {
            return [
                generateAsyncPrefix(stmt, true),
                'function',
                generateStarSuffix(stmt) || noEmptySpace(),
                generateIdentifier(stmt.id),
                this.generateFunctionBody(stmt)
            ];
        },

        ReturnStatement: function (stmt, flags) {
            if (stmt.argument) {
                return [join(
                    'return',
                    this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
                ), this.semicolon(flags)];
            }
            return ['return' + this.semicolon(flags)];
        },

        WhileStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        },

        WithStatement: function (stmt, flags) {
            var result, that = this;
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
                    ')'
                ];
            });
            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
            return result;
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Statement);

    // Expressions.

    CodeGenerator.Expression = {

        SequenceExpression: function (expr, precedence, flags) {
            var result, i, iz;
            if (Precedence.Sequence < precedence) {
                flags |= F_ALLOW_IN;
            }
            result = [];
            for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            return parenthesize(result, Precedence.Sequence, precedence);
        },

        AssignmentExpression: function (expr, precedence, flags) {
            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },

        ArrowFunctionExpression: function (expr, precedence, flags) {
            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },

        ConditionalExpression: function (expr, precedence, flags) {
            if (Precedence.Conditional < precedence) {
                flags |= F_ALLOW_IN;
            }
            return parenthesize(
                [
                    this.generateExpression(expr.test, Precedence.LogicalOR, flags),
                    space + '?' + space,
                    this.generateExpression(expr.consequent, Precedence.Assignment, flags),
                    space + ':' + space,
                    this.generateExpression(expr.alternate, Precedence.Assignment, flags)
                ],
                Precedence.Conditional,
                precedence
            );
        },

        LogicalExpression: function (expr, precedence, flags) {
            return this.BinaryExpression(expr, precedence, flags);
        },

        BinaryExpression: function (expr, precedence, flags) {
            var result, currentPrecedence, fragment, leftSource;
            currentPrecedence = BinaryPrecedence[expr.operator];

            if (currentPrecedence < precedence) {
                flags |= F_ALLOW_IN;
            }

            fragment = this.generateExpression(expr.left, currentPrecedence, flags);

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = this.generateExpression(expr.right, currentPrecedence + 1, flags);

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, currentPrecedence, precedence);
        },

        CallExpression: function (expr, precedence, flags) {
            var result, i, iz;
            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
            result.push('(');
            for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
                result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                if (i + 1 < iz) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!(flags & F_ALLOW_CALL)) {
                return ['(', result, ')'];
            }
            return parenthesize(result, Precedence.Call, precedence);
        },

        NewExpression: function (expr, precedence, flags) {
            var result, length, i, iz, itemFlags;
            length = expr['arguments'].length;

            // F_ALLOW_CALL becomes false.
            // F_ALLOW_UNPARATH_NEW may become false.
            itemFlags = (flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0) ? E_TFT : E_TFF;

            result = join(
                'new',
                this.generateExpression(expr.callee, Precedence.New, itemFlags)
            );

            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
                result.push('(');
                for (i = 0, iz = length; i < iz; ++i) {
                    result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            return parenthesize(result, Precedence.New, precedence);
        },

        MemberExpression: function (expr, precedence, flags) {
            var result, fragment;

            // F_ALLOW_UNPARATH_NEW becomes false.
            result = [this.generateExpression(expr.object, Precedence.Call, (flags & F_ALLOW_CALL) ? E_TTF : E_TFF)];

            if (expr.computed) {
                result.push('[');
                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
                result.push(']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push('.');
                    }
                }
                result.push('.');
                result.push(generateIdentifier(expr.property));
            }

            return parenthesize(result, Precedence.Member, precedence);
        },

        UnaryExpression: function (expr, precedence, flags) {
            var result, fragment, rightCharCode, leftSource, leftCharCode;
            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            return parenthesize(result, Precedence.Unary, precedence);
        },

        YieldExpression: function (expr, precedence, flags) {
            var result;
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
                );
            }
            return parenthesize(result, Precedence.Yield, precedence);
        },

        AwaitExpression: function (expr, precedence, flags) {
            var result = join(
                expr.delegate ? 'await*' : 'await',
                this.generateExpression(expr.argument, Precedence.Await, E_TTT)
            );
            return parenthesize(result, Precedence.Await, precedence);
        },

        UpdateExpression: function (expr, precedence, flags) {
            if (expr.prefix) {
                return parenthesize(
                    [
                        expr.operator,
                        this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
                    ],
                    Precedence.Unary,
                    precedence
                );
            }
            return parenthesize(
                [
                    this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
                    expr.operator
                ],
                Precedence.Postfix,
                precedence
            );
        },

        FunctionExpression: function (expr, precedence, flags) {
            var result = [
                generateAsyncPrefix(expr, true),
                'function'
            ];
            if (expr.id) {
                result.push(generateStarSuffix(expr) || noEmptySpace());
                result.push(generateIdentifier(expr.id));
            } else {
                result.push(generateStarSuffix(expr) || space);
            }
            result.push(this.generateFunctionBody(expr));
            return result;
        },

        ExportBatchSpecifier: function (expr, precedence, flags) {
            return '*';
        },

        ArrayPattern: function (expr, precedence, flags) {
            return this.ArrayExpression(expr, precedence, flags);
        },

        ArrayExpression: function (expr, precedence, flags) {
            var result, multiline, that = this;
            if (!expr.elements.length) {
                return '[]';
            }
            multiline = expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.elements.length; i < iz; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === iz) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
                    }
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            return result;
        },

        ClassExpression: function (expr, precedence, flags) {
            var result, fragment;
            result = ['class'];
            if (expr.id) {
                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
            }
            if (expr.superClass) {
                fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Assignment, E_TTT));
                result = join(result, fragment);
            }
            result.push(space);
            result.push(this.generateStatement(expr.body, S_TFFT));
            return result;
        },

        MethodDefinition: function (expr, precedence, flags) {
            var result, fragment;
            if (expr['static']) {
                result = ['static' + space];
            } else {
                result = [];
            }
            if (expr.kind === 'get' || expr.kind === 'set') {
                fragment = [
                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
                    this.generateFunctionBody(expr.value)
                ];
            } else {
                fragment = [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }
            return join(result, fragment);
        },

        Property: function (expr, precedence, flags) {
            if (expr.kind === 'get' || expr.kind === 'set') {
                return [
                    expr.kind, noEmptySpace(),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            if (expr.shorthand) {
                return this.generatePropertyKey(expr.key, expr.computed);
            }

            if (expr.method) {
                return [
                    generateMethodPrefix(expr),
                    this.generatePropertyKey(expr.key, expr.computed),
                    this.generateFunctionBody(expr.value)
                ];
            }

            return [
                this.generatePropertyKey(expr.key, expr.computed),
                ':' + space,
                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
            ];
        },

        ObjectExpression: function (expr, precedence, flags) {
            var multiline, result, fragment, that = this;

            if (!expr.properties.length) {
                return '{}';
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    return [ '{', space, fragment, space, '}' ];
                }
            }

            withIndent(function (indent) {
                var i, iz;
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                        result.push(indent);
                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                        if (i + 1 < iz) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            return result;
        },

        ObjectPattern: function (expr, precedence, flags) {
            var result, i, iz, multiline, property, that = this;
            if (!expr.properties.length) {
                return '{}';
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                var i, iz;
                for (i = 0, iz = expr.properties.length; i < iz; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            return result;
        },

        ThisExpression: function (expr, precedence, flags) {
            return 'this';
        },

        Identifier: function (expr, precedence, flags) {
            return generateIdentifier(expr);
        },

        ImportDefaultSpecifier: function (expr, precedence, flags) {
            return generateIdentifier(expr.id);
        },

        ImportNamespaceSpecifier: function (expr, precedence, flags) {
            var result = ['*'];
            if (expr.id) {
                result.push(space + 'as' + noEmptySpace() + generateIdentifier(expr.id));
            }
            return result;
        },

        ImportSpecifier: function (expr, precedence, flags) {
            return this.ExportSpecifier(expr, precedence, flags);
        },

        ExportSpecifier: function (expr, precedence, flags) {
            var result = [ expr.id.name ];
            if (expr.name) {
                result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(expr.name));
            }
            return result;
        },

        Literal: function (expr, precedence, flags) {
            var raw;
            if (expr.hasOwnProperty('raw') && parse && extra.raw) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            return expr.raw;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                return 'null';
            }

            if (typeof expr.value === 'string') {
                return escapeString(expr.value);
            }

            if (typeof expr.value === 'number') {
                return generateNumber(expr.value);
            }

            if (typeof expr.value === 'boolean') {
                return expr.value ? 'true' : 'false';
            }

            return generateRegExp(expr.value);
        },

        GeneratorExpression: function (expr, precedence, flags) {
            return this.ComprehensionExpression(expr, precedence, flags);
        },

        ComprehensionExpression: function (expr, precedence, flags) {
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6

            var result, i, iz, fragment, that = this;
            result = (expr.type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
                result = join(result, [ '(', fragment, ')' ]);
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);

                result = join(result, fragment);
            }

            result.push((expr.type === Syntax.GeneratorExpression) ? ')' : ']');
            return result;
        },

        ComprehensionBlock: function (expr, precedence, flags) {
            var fragment;
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    this.generateStatement(expr.left.declarations[0], S_FFFF)
                ];
            } else {
                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));

            return [ 'for' + space + '(', fragment, ')' ];
        },

        SpreadElement: function (expr, precedence, flags) {
            return [
                '...',
                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
            ];
        },

        TaggedTemplateExpression: function (expr, precedence, flags) {
            var itemFlags = E_TTF;
            if (!(flags & F_ALLOW_CALL)) {
                itemFlags = E_TFF;
            }
            var result = [
                this.generateExpression(expr.tag, Precedence.Call, itemFlags),
                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
            ];
            return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },

        TemplateElement: function (expr, precedence, flags) {
            // Don't use "cooked". Since tagged template can use raw template
            // representation. So if we do so, it breaks the script semantics.
            return expr.value.raw;
        },

        TemplateLiteral: function (expr, precedence, flags) {
            var result, i, iz;
            result = [ '`' ];
            for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
                if (i + 1 < iz) {
                    result.push('${' + space);
                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
                    result.push(space + '}');
                }
            }
            result.push('`');
            return result;
        },

        ModuleSpecifier: function (expr, precedence, flags) {
            return this.Literal(expr, precedence, flags);
        }

    };

    merge(CodeGenerator.prototype, CodeGenerator.Expression);

    CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
        var result, type;

        type = expr.type || Syntax.Property;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, precedence);
        }

        result = this[type](expr, precedence, flags);


        if (extra.comment) {
            result = addComments(expr,result);
        }
        return toSourceNodeWhenNeeded(result, expr);
    };

    CodeGenerator.prototype.generateStatement = function (stmt, flags) {
        var result,
            fragment;

        result = this[stmt.type](stmt, flags);

        // Attach comments

        if (extra.comment) {
            result = addComments(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    };

    function generateInternal(node) {
        var codegen;

        codegen = new CodeGenerator();
        if (isStatement(node)) {
            return codegen.generateStatement(node, S_TFFF);
        }

        if (isExpression(node)) {
            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }

        throw new Error('Unknown node type: ' + node.type);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        sourceCode = options.sourceCode;
        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        result = generateInternal(node);

        if (!sourceMap) {
            pair = {code: result.toString(), map: null};
            return options.sourceMapWithCode ? pair : pair.code;
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./package.json":26,"estraverse":10,"esutils":14,"source-map":15}],10:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        objectKeys(from).forEach(function (key) {
            to[key] = from[key];
        });
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportBatchSpecifier: 'ExportBatchSpecifier',
        ExportDeclaration: 'ExportDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportBatchSpecifier: [],
        ExportDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['id', 'name'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['id'],
        ImportNamespaceSpecifier: ['id'],
        ImportSpecifier: ['id', 'name'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return type of current node
    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    // API:
    // remove node
    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = objectKeys(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                // When the reference is an element of an array.
                key = element.ref.key;
                parent = element.ref.parent;

                // If removed from array, then decrease following items' keys.
                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = objectKeys(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.8.1-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],11:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],12:[function(require,module,exports){
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var Regex, NON_ASCII_WHITESPACES;

    // See `tools/generate-identifier-regex.js`.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) ||    // 0..9
            (97 <= ch && ch <= 102) ||  // a..f
            (65 <= ch && ch <= 70);     // A..F
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],13:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierName(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierName(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":12}],14:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./ast":11,"./code":12,"./keyword":13}],15:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":21,"./source-map/source-map-generator":22,"./source-map/source-node":23}],16:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":24,"amdefine":25}],17:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aOutParam) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aStr.slice(i);
  };

});

},{"./base64":18,"amdefine":25}],18:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":25}],19:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return mid;
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0 ? -1 : aLow;
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of next lowest value checked if there is no exact hit. This is
   * because mappings between original and generated line/col pairs are single
   * points, and there is an implicit region between each of them, so a miss
   * just means that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    if (aHaystack.length === 0) {
      return -1;
    }
    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
  };

});

},{"amdefine":25}],20:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    var mapping;
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositions);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;

});

},{"./util":24,"amdefine":25}],21:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
      smc.__originalMappings = aSourceMap._mappings.toArray().slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._nextCharIsMappingSeparator =
    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
      var c = aStr.charAt(0);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var str = aStr;
      var temp = {};
      var mapping;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          base64VLQ.decode(str, temp);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
            // Original source.
            base64VLQ.decode(str, temp);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            base64VLQ.decode(str, temp);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            base64VLQ.decode(str, temp);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              // Original name.
              base64VLQ.decode(str, temp);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  SourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle,
                                    this._generatedMappings,
                                    "generatedLine",
                                    "generatedColumn",
                                    util.compareByGeneratedPositions);

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source != null && this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  /**
   * Returns all generated line and column information for the original source
   * and line provided. The only argument is an object with the following
   * properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      // When there is no exact match, SourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to Infinity, we thus find the last
      // mapping for the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: Infinity
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        while (mapping && mapping.originalLine === needle.originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[--index];
        }
      }

      return mappings.reverse();
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":16,"./base64-vlq":17,"./binary-search":19,"./util":24,"amdefine":25}],22:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();

      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":16,"./base64-vlq":17,"./mapping-list":20,"./util":24,"amdefine":25}],23:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":22,"./util":24,"amdefine":25}],24:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // XXX: It is possible to remove this block, and the tests still pass!
    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":25}],25:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules\\escodegen\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js")

},{"_process":50,"path":49}],26:[function(require,module,exports){
module.exports={
  "name": "escodegen",
  "description": "ECMAScript code generator",
  "homepage": "http://github.com/estools/escodegen",
  "main": "escodegen.js",
  "bin": {
    "esgenerate": "./bin/esgenerate.js",
    "escodegen": "./bin/escodegen.js"
  },
  "files": [
    "LICENSE.BSD",
    "LICENSE.source-map",
    "README.md",
    "bin",
    "escodegen.js",
    "package.json"
  ],
  "version": "1.6.1",
  "engines": {
    "node": ">=0.10.0"
  },
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/estools/escodegen.git"
  },
  "dependencies": {
    "estraverse": "^1.9.1",
    "esutils": "^1.1.6",
    "esprima": "^1.2.2",
    "optionator": "^0.5.0",
    "source-map": "~0.1.40"
  },
  "optionalDependencies": {
    "source-map": "~0.1.40"
  },
  "devDependencies": {
    "acorn-6to5": "^0.11.1-25",
    "bluebird": "^2.3.11",
    "bower-registry-client": "^0.2.1",
    "chai": "^1.10.0",
    "commonjs-everywhere": "^0.9.7",
    "esprima-moz": "*",
    "gulp": "^3.8.10",
    "gulp-eslint": "^0.2.0",
    "gulp-mocha": "^2.0.0",
    "semver": "^4.1.0"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/estools/escodegen/raw/master/LICENSE.BSD"
    }
  ],
  "scripts": {
    "test": "gulp travis",
    "unit-test": "gulp test",
    "lint": "gulp lint",
    "release": "node tools/release.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js"
  },
  "gitHead": "1ca664f68dcf220b76c9dc562b2337c5e0b4227d",
  "bugs": {
    "url": "https://github.com/estools/escodegen/issues"
  },
  "_id": "escodegen@1.6.1",
  "_shasum": "367de17d8510540d12bc6dcb8b3f918391265815",
  "_from": "escodegen@1.6.1",
  "_npmVersion": "2.0.0-alpha-5",
  "_npmUser": {
    "name": "constellation",
    "email": "utatane.tea@gmail.com"
  },
  "dist": {
    "shasum": "367de17d8510540d12bc6dcb8b3f918391265815",
    "tarball": "http://registry.npmjs.org/escodegen/-/escodegen-1.6.1.tgz"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/escodegen/-/escodegen-1.6.1.tgz"
}

},{}],27:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"./lib":29,"d:\\Code\\htdocs\\shadejs\\node_modules\\analyses\\index.js":1}],28:[function(require,module,exports){

module.exports = dot;

var codegen = require('escodegen');

function dot(cfg, options) {
	options = options || {};
	var counter = options.counter || 0;
	var source = options.source;
	var generateSource = !source && options.generateSource;
	
	var output = [];
	var nodes = cfg[2];

	// print all the nodes:
	for (var i = 0; i < nodes.length; i++) {
		var node = nodes[i];
		var label = node.label || node.type;
		if (!label && source && node.astNode.range) {
			var ast = node.astNode;
			var range = ast.range;
			var add = '';
			// special case some statements to get them properly printed
			if (ast.type == 'SwitchCase') {
				if (ast.test) {
					range = [range[0], ast.test.range[1]];
					add = ':';
				} else {
					range = [range[0], range[0]];
					add ='default:';
				}
			} else if (ast.type == 'ForInStatement') {
				range = [range[0], ast.right.range[1]];
				add = ')';
			} else if (ast.type == 'CatchClause') {
				range = [range[0], ast.param.range[1]];
				add = ')';
			}

			label = source.slice(range[0], range[1])
				.replace(/\n/g, '\\n')
				.replace(/\t/g, '    ')
				.replace(/"/g, '\\"') + add;
		}
		if (!label && node.astNode) {
			label = generateSource ? codegen.generate(node.astNode) : node.astNode.type;
		}
		output.push('n' + (counter + i) + ' [label="' + label + '"');
		if (~['entry', 'exit'].indexOf(node.type))
			output.push(', style="rounded"');
		output.push(']\n');
	}

	// print all the edges:
	for (var i = 0; i < nodes.length; i++) {
		var node = nodes[i];
		['normal', 'true', 'false', 'exception'].forEach(function (type) {
			var next = node[type];
			if (!next)
				return;

		output.push('n' + (counter + i) + ' -> n' + (counter + nodes.indexOf(next)) + ' [');
		if (type === 'exception')
			output.push('color="red", label="exception"')
		else if (~['true', 'false'].indexOf(type))
			output.push('label="' + type + '"');
		output.push(']\n');
		});
	}

	if (options.counter !== undefined)
		options.counter+= nodes.length;

	return output.join('');
}


},{"escodegen":30}],29:[function(require,module,exports){

var walker = require('walkes');

module.exports = ControlFlowGraph;
module.exports.dot = require('./dot');

// FIXME: switch/case with default before other cases?
// FIXME: catch creates a new scope, so should somehow be handled differently

// TODO: try/finally: finally follows try, but does not return to normal flow?

// TODO: labeled break/continue
// TODO: WithStatement

// TODO: avoid adding and deleting properties on ast nodes

/**
 * Returns [entry, exit] `FlowNode`s for the passed in AST
 */
function ControlFlowGraph(astNode, options) {
    options = options || {};
    var parentStack = [];
	var exitNode = new FlowNode(undefined, undefined, 'exit');
	var catchStack = [exitNode];
	var omitExceptions = !!options.omitExceptions;

	createNodes(astNode);
	linkSiblings(astNode);
	
	walker(astNode, {
		CatchClause: function (recurse) {
			this.cfg.connect(getEntry(this.body));
			recurse(this.body);
		},
		DoWhileStatement: function (recurse) {
			mayThrow(this.test);
			this.test.cfg
				.connect(getEntry(this.body), 'true')
				.connect(getSuccessor(this), 'false');
			recurse(this.body);
		},
		ExpressionStatement: connectNext,
		FunctionDeclaration: function () {},
		ForStatement: function (recurse) {
			if (this.test) {
				mayThrow(this.test);
				this.test.cfg
					.connect(getEntry(this.body), 'true')
					.connect(getSuccessor(this), 'false');
				if (this.update)
					this.update.cfg.connect(this.test.cfg);
			} else if (this.update)
				this.update.cfg.connect(getEntry(this.body));
			if (this.update)
				mayThrow(this.update);
			if (this.init) {
				mayThrow(this.init);
				this.init.cfg.connect(this.test && this.test.cfg || getEntry(this.body));
			}
			recurse(this.body);
		},
		ForInStatement: function (recurse) {
			mayThrow(this)
			this.cfg
				.connect(getEntry(this.body), 'true')
				.connect(getSuccessor(this), 'false');
			recurse(this.body);
		},
		IfStatement: function (recurse) {
			recurse(this.consequent);
			mayThrow(this.test);
			this.test.cfg.connect(getEntry(this.consequent), 'true');
			if (this.alternate) {
				recurse(this.alternate);
				this.test.cfg.connect(getEntry(this.alternate), 'false');
			} else {
				this.test.cfg.connect(getSuccessor(this), 'false');
			}
		},
		ReturnStatement: function () {
			mayThrow(this);
			this.cfg.connect(exitNode);
		},
		SwitchCase: function (recurse) {
			if (this.test) {
				// if this is a real case, connect `true` to the body
				// or the body of the next case
				var check = this;
				while (!check.consequent.length && check.cfg.nextSibling)
					check = check.cfg.nextSibling.astNode;

				this.cfg.connect(check.consequent.length && getEntry(check.consequent[0]) || getSuccessor(this.cfg.parent), 'true');

				// and connect false to the next `case`
				this.cfg.connect(getSuccessor(this), 'false');
			} else {
				// this is the `default` case, connect it to the body, or the
				// successor of the parent
				this.cfg.connect(this.consequent.length && getEntry(this.consequent[0]) || getSuccessor(this.cfg.parent));
			}
			this.consequent.forEach(recurse);
		},
		SwitchStatement: function (recurse) {
			this.cfg.connect(this.cases[0].cfg);
			this.cases.forEach(recurse);
		},
		ThrowStatement: function () {
			this.cfg.connect(getExceptionTarget(this), 'exception');
		},
		TryStatement: function (recurse) {
			var handler = this.handlers[0] && this.handlers[0].cfg || getEntry(this.finalizer);
			catchStack.push(handler);
			recurse(this.block);
			catchStack.pop();
			
			if (this.handlers.length)
				recurse(this.handlers[0]);
			if (this.finalizer) {
				//this.finalizer.cfg.connect(getSuccessor(this));
				recurse(this.finalizer);
			}
		},
		VariableDeclaration: connectNext,
		WhileStatement: function (recurse) {
			mayThrow(this.test);
			this.test.cfg
				.connect(getEntry(this.body), 'true')
				.connect(getSuccessor(this), 'false');
			recurse(this.body);
		}
	});
	
	var entryNode = new FlowNode(astNode, undefined, 'entry');
	entryNode.normal = getEntry(astNode);
	walker(astNode, {default: function () {
		if (!this.cfg)
			return;
		// ExpressionStatements should refer to their expression directly
		if (this.type === 'ExpressionStatement')
			this.cfg.astNode = this.expression;
		delete this.cfg;
		walker.checkProps.apply(this, arguments);
	}});

	var allNodes = [];
	var reverseStack = [entryNode];
	while (reverseStack.length) {
		var cfgNode = reverseStack.pop();
		allNodes.push(cfgNode);
		cfgNode.next = [];
		['exception', 'false', 'true', 'normal'].forEach(function (type) {
			var next = cfgNode[type];
			if (!next)
				return;
			if (!~cfgNode.next.indexOf(next))
				cfgNode.next.push(next);
			if (!~next.prev.indexOf(cfgNode))
				next.prev.push(cfgNode);
			if (!~reverseStack.indexOf(next) && !next.next)
				reverseStack.push(next);
		});
	}

	function getExceptionTarget(astNode) {
		return catchStack[catchStack.length - 1];
	}

	function mayThrow(astNode) {
		if (!omitExceptions && expressionThrows(astNode))
			astNode.cfg.connect(getExceptionTarget(this), 'exception');
	}
	function expressionThrows(astNode) {
		if (typeof astNode !== 'object' || 'FunctionExpression' === astNode.type)
			return false;
		if (astNode.type && ~throwTypes.indexOf(astNode.type))
			return true;
		var self = astNode;
		return Object.keys(self).some(function (key) {
			var prop = self[key];
			if (prop instanceof Array) {
				return prop.some(expressionThrows);
			} else if (typeof prop === 'object' && prop)
				return expressionThrows(prop);
			else
				return false;
		});
	}

	function getJumpTarget(astNode, types) {
		var parent = astNode.cfg.parent;
		while (!~types.indexOf(parent.type) && parent.cfg.parent)
			parent = parent.cfg.parent;
		return ~types.indexOf(parent.type) ? parent : null;
	}

	function connectNext() {
		mayThrow(this);
		this.cfg.connect(getSuccessor(this));
	}

	/**
	 * Returns the entry node of a statement
	 */
	function getEntry(astNode) {
		switch (astNode.type) {
			case 'BreakStatement':
				var target = getJumpTarget(astNode, breakTargets);
				return target ? getSuccessor(target) : exitNode;
			case 'ContinueStatement':
				var target = getJumpTarget(astNode, continueTargets);
				switch (target.type) {
					case 'ForStatement':
						// continue goes to the update, test or body
						return target.update && target.update.cfg || target.test && target.test.cfg || getEntry(target.body);
					case 'ForInStatement':
						return target.cfg;
					case 'DoWhileStatement':
					case 'WhileStatement':
						return target.test.cfg;
				}
				// unreached
			case 'BlockStatement':
			case 'Program':
				return astNode.body.length && getEntry(astNode.body[0]) || getSuccessor(astNode);
			case 'DoWhileStatement':
				return getEntry(astNode.body);
			case 'EmptyStatement':
				return getSuccessor(astNode);
			case 'ForStatement':
				return astNode.init && astNode.init.cfg || astNode.test && astNode.test.cfg || getEntry(astNode.body);
			case 'FunctionDeclaration':
				return getSuccessor(astNode);
			case 'IfStatement':
				return astNode.test.cfg;
			case 'SwitchStatement':
				return getEntry(astNode.cases[0]);
			case 'TryStatement':
				return getEntry(astNode.block);
			case 'WhileStatement':
				return astNode.test.cfg;
			default:
				return astNode.cfg;
		}
	}
	/**
	 * Returns the successor node of a statement
	 */
	function getSuccessor(astNode) {
		// part of a block -> it already has a nextSibling
		if (astNode.cfg.nextSibling)
			return astNode.cfg.nextSibling;
		var parent = astNode.cfg.parent;
		if (!parent) // it has no parent -> exitNode
			return exitNode;
		switch (parent.type) {
			case 'DoWhileStatement':
				return parent.test.cfg;
			case 'ForStatement':
				return parent.update && parent.update.cfg || parent.test && parent.test.cfg || getEntry(parent.body);
			case 'ForInStatement':
				return parent.cfg;
			case 'TryStatement':
				return parent.finalizer && astNode !== parent.finalizer && getEntry(parent.finalizer) || getSuccessor(parent);
			case 'SwitchCase':
				// the sucessor of a statement at the end of a case block is
				// the entry of the next cases consequent
				if (!parent.cfg.nextSibling)
					return getSuccessor(parent);
				var check = parent.cfg.nextSibling.astNode;
				while (!check.consequent.length && check.cfg.nextSibling)
					check = check.cfg.nextSibling.astNode;
				// or the next statement after the switch, if there are no more cases
				return check.consequent.length && getEntry(check.consequent[0]) || getSuccessor(parent.parent);
			case 'WhileStatement':
				return parent.test.cfg;
			default:
				return getSuccessor(parent);
		}
	}

	/**
	 * Creates a FlowNode for every AST node
	 */
	function createNodes(astNode) {
		walker(astNode, { default: function () {
			var parent = parentStack.length ? parentStack[parentStack.length - 1] : undefined;
			createNode(this, parent);
			// do not recurse for FunctionDeclaration or any sub-expression
			if (this.type == 'FunctionDeclaration' || ~this.type.indexOf('Expression'))
				return;
			parentStack.push(this);
			walker.checkProps.apply(this, arguments);
			parentStack.pop();
		}});
	}
	function createNode(astNode, parent) {
		if (!astNode.cfg)
			Object.defineProperty(astNode, 'cfg', {value: new FlowNode(astNode, parent), configurable: true});
	}

	/**
	 * Links in the next sibling for nodes inside a block
	 */
	function linkSiblings(astNode) {
		function backToFront(list, recurse) {
			// link all the children to the next sibling from back to front,
			// so the nodes already have .nextSibling
			// set when their getEntry is called
			for (var i = list.length - 1; i >= 0; i--) {
				var child = list[i];
				if (i < list.length - 1)
					child.cfg.nextSibling = getEntry(list[i + 1]);
				recurse(child);
			}
		}
		function BlockOrProgram(recurse) {
			backToFront(this.body, recurse);
		}
		walker(astNode, {
			BlockStatement: BlockOrProgram,
			Program: BlockOrProgram,
			FunctionDeclaration: function () {},
			FunctionExpression: function () {},
			SwitchCase: function (recurse) {
				backToFront(this.consequent, recurse);
			},
			SwitchStatement: function (recurse) {
				backToFront(this.cases, recurse);
			},
		});
	}
	return [entryNode, exitNode, allNodes];
};

function FlowNode(astNode, parent, type) {
	this.astNode = astNode;
	this.parent = parent;
	this.type = type;
	this.prev = [];
}
FlowNode.prototype.connect = function (next, type) {
	this[type || 'normal'] = next;
	return this;
};

var continueTargets = [
	'ForStatement',
	'ForInStatement',
	'DoWhileStatement',
	'WhileStatement'];
var breakTargets = continueTargets.concat(['SwitchStatement']);
var throwTypes = [
	'AssignmentExpression', // assigning to undef or non-writable prop
	'BinaryExpression', // instanceof and in on non-objects
	'CallExpression', // obviously
	'MemberExpression', // getters may throw
	'NewExpression', // obviously
	'UnaryExpression' // delete non-deletable prop
];


},{"./dot":28,"walkes":53}],30:[function(require,module,exports){
(function (global){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, generateStatement:true, generateExpression:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        Regex,
        SourceNode,
        estraverse,
        isArray,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'

    };

    Precedence = {
        Sequence: 0,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        Member: 17,
        Primary: 18
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    Regex = {
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
    };

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false
            },
            moz: {
                starlessGenerator: false,
                parenthesizedComprehensionBlock: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            verbatim: null
        };
    }

    function stringToArray(str) {
        var length = str.length,
            result = [],
            i;
        for (i = 0; i < length; i += 1) {
            result[i] = str.charAt(i);
        }
        return result;
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    // Fallback for the non SourceMap environment
    function SourceNodeMock(line, column, filename, chunk) {
        var result = [];

        function flatten(input) {
            var i, iz;
            if (isArray(input)) {
                for (i = 0, iz = input.length; i < iz; ++i) {
                    flatten(input[i]);
                }
            } else if (input instanceof SourceNodeMock) {
                result.push(input);
            } else if (typeof input === 'string' && input) {
                result.push(input);
            }
        }

        flatten(chunk);
        this.children = result;
    }

    SourceNodeMock.prototype.toString = function toString() {
        var res = '', i, iz, node;
        for (i = 0, iz = this.children.length; i < iz; ++i) {
            node = this.children[i];
            if (node instanceof SourceNodeMock) {
                res += node.toString();
            } else {
                res += node;
            }
        }
        return res;
    };

    SourceNodeMock.prototype.replaceRight = function replaceRight(pattern, replacement) {
        var last = this.children[this.children.length - 1];
        if (last instanceof SourceNodeMock) {
            last.replaceRight(pattern, replacement);
        } else if (typeof last === 'string') {
            this.children[this.children.length - 1] = last.replace(pattern, replacement);
        } else {
            this.children.push(''.replace(pattern, replacement));
        }
        return this;
    };

    SourceNodeMock.prototype.join = function join(sep) {
        var i, iz, result;
        result = [];
        iz = this.children.length;
        if (iz > 0) {
            for (i = 0, iz -= 1; i < iz; ++i) {
                result.push(this.children[i], sep);
            }
            result.push(this.children[iz]);
            this.children = result;
        }
        return this;
    };

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var ch = str.charAt(str.length - 1);
        return ch && isLineTerminator(ch);
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charAt(0) === '0' && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charAt(temp.length + pos - 1) === '0') {
            pos -= 1;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(ch, next) {
        var code = ch.charCodeAt(0), hex = code.toString(16), result = '\\';

        switch (ch) {
        case '\b':
            result += 'b';
            break;
        case '\f':
            result += 'f';
            break;
        case '\t':
            result += 't';
            break;
        default:
            if (json || code > 0xff) {
                result += 'u' + '0000'.slice(hex.length) + hex;
            } else if (ch === '\u0000' && '0123456789'.indexOf(next) < 0) {
                result += '0';
            } else if (ch === '\x0B') { // '\v'
                result += 'x0B';
            } else {
                result += 'x' + '00'.slice(hex.length) + hex;
            }
            break;
        }

        return result;
    }

    function escapeDisallowedCharacter(ch) {
        var result = '\\';
        switch (ch) {
        case '\\':
            result += '\\';
            break;
        case '\n':
            result += 'n';
            break;
        case '\r':
            result += 'r';
            break;
        case '\u2028':
            result += 'u2028';
            break;
        case '\u2029':
            result += 'u2029';
            break;
        default:
            throw new Error('Incorrectly classified character');
        }

        return result;
    }

    function escapeDirective(str) {
        var i, iz, ch, buf, quote;

        buf = str;
        if (typeof buf[0] === 'undefined') {
            buf = stringToArray(buf);
        }

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = buf.length; i < iz; i += 1) {
            ch = buf[i];
            if (ch === '\'') {
                quote = '"';
                break;
            } else if (ch === '"') {
                quote = '\'';
                break;
            } else if (ch === '\\') {
                i += 1;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, ch, singleQuotes = 0, doubleQuotes = 0, single;

        if (typeof str[0] === 'undefined') {
            str = stringToArray(str);
        }

        for (i = 0, len = str.length; i < len; i += 1) {
            ch = str[i];
            if (ch === '\'') {
                singleQuotes += 1;
            } else if (ch === '"') {
                doubleQuotes += 1;
            } else if (ch === '/' && json) {
                result += '\\';
            } else if ('\\\n\r\u2028\u2029'.indexOf(ch) >= 0) {
                result += escapeDisallowedCharacter(ch);
                continue;
            } else if ((json && ch < ' ') || !(json || escapeless || (ch >= ' ' && ch <= '~'))) {
                result += escapeAllowedCharacter(ch, str[i + 1]);
                continue;
            }
            result += ch;
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        str = result;
        result = single ? '\'' : '"';

        if (typeof str[0] === 'undefined') {
            str = stringToArray(str);
        }

        for (i = 0, len = str.length; i < len; i += 1) {
            ch = str[i];
            if ((ch === '\'' && single) || (ch === '"' && !single)) {
                result += '\\';
            }
            result += ch;
        }

        return result + (single ? '\'' : '"');
    }

    function isWhiteSpace(ch) {
        // Use `\x0B` instead of `\v` for IE < 9 compatibility
        return '\t\x0B\f \xa0'.indexOf(ch) >= 0 || (ch.charCodeAt(0) >= 0x1680 && '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\ufeff'.indexOf(ch) >= 0);
    }

    function isLineTerminator(ch) {
        return '\n\r\u2028\u2029'.indexOf(ch) >= 0;
    }

    function isIdentifierPart(ch) {
        return (ch === '$') || (ch === '_') || (ch === '\\') ||
            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
            ((ch >= '0') && (ch <= '9')) ||
            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));
    }

    // takes char code
    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function toSourceNode(generated, node) {
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource = toSourceNode(left).toString(),
            rightSource = toSourceNode(right).toString(),
            leftChar = leftSource.charAt(leftSource.length - 1),
            rightChar = rightSource.charAt(0);

        if ((leftChar === '+' || leftChar === '-') && leftChar === rightChar ||
        isIdentifierPart(leftChar) && isIdentifierPart(rightChar) ||
        leftChar === '/' && rightChar === 'i') { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (isWhiteSpace(leftChar) || isLineTerminator(leftChar) || isWhiteSpace(rightChar) || isLineTerminator(rightChar)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase, result;
        previousBase = base;
        base += indent;
        result = fn.call(this, base);
        base = previousBase;
        return result;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; i -= 1) {
            if (isLineTerminator(str.charAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; i += 1) {
            line = array[i];
            j = 0;
            while (j < line.length && isWhiteSpace(line[j])) {
                j += 1;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                spaces -= 1;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; i += 1) {
            array[i] = toSourceNode(addIndent(array[i].slice(spaces))).join('');
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                return '//' + comment.value + '\n';
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addCommentsToStatement(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            comment = stmt.leadingComments[0];
            result = [];
            if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                result.push('\n');
            }
            result.push(generateComment(comment));
            if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push('\n');
            }

            for (i = 1, len = stmt.leadingComments.length; i < len; i += 1) {
                comment = stmt.leadingComments[i];
                fragment = [generateComment(comment)];
                if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                    fragment.push('\n');
                }
                result.push(addIndent(fragment));
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {
            tailingToStatement = !endsWithLineTerminator(toSourceNode(result).toString());
            specialBase = stringRepeat(' ', calculateSpaces(toSourceNode([base, result, indent]).toString()));
            for (i = 0, len = stmt.trailingComments.length; i < len; i += 1) {
                comment = stmt.trailingComments[i];
                if (tailingToStatement) {
                    // We assume target like following script
                    //
                    // var t = 20;  /**
                    //               * This is comment of t
                    //               */
                    if (i === 0) {
                        // first case
                        result = [result, indent];
                    } else {
                        result = [result, specialBase];
                    }
                    result.push(generateComment(comment, specialBase));
                } else {
                    result = [result, addIndent(generateComment(comment))];
                }
                if (i !== len - 1 && !endsWithLineTerminator(toSourceNode(result).toString())) {
                    result = [result, '\n'];
                }
            }
        }

        return result;
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function maybeBlock(stmt, semicolonOptional, functionBody) {
        var result, noLeadingComment;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, generateStatement(stmt, { functionBody: functionBody })];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [newline, addIndent(generateStatement(stmt, { semicolonOptional: semicolonOptional, functionBody: functionBody }))];
        });

        return result;
    }

    function maybeBlockSuffix(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNode(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    }

    function generateVerbatim(expr, option) {
        var i, result;
        result = expr[extra.verbatim].split(/\r\n|\n/);
        for (i = 1; i < result.length; i++) {
            result[i] = newline + base + result[i];
        }

        result = parenthesize(result, Precedence.Sequence, option.precedence);
        return toSourceNode(result, expr);
    }

    function generateIdentifier(node) {
        return toSourceNode(node.name, node);
    }

    function generateFunctionBody(node) {
        var result, i, len, expr, arrow;

        arrow = node.type === Syntax.ArrowFunctionExpression;

        if (arrow && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateIdentifier(node.params[0])];
        } else {
            result = ['('];
            for (i = 0, len = node.params.length; i < len; i += 1) {
                result.push(generateIdentifier(node.params[i]));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');
        }

        if (arrow) {
            result.push(space, '=>');
        }

        if (node.expression) {
            result.push(space);
            expr = generateExpression(node.body, {
                precedence: Precedence.Assignment,
                allowIn: true,
                allowCall: true
            });
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(maybeBlock(node.body, false, true));
        }
        return result;
    }

    function generateExpression(expr, option) {
        var result,
            precedence,
            type,
            currentPrecedence,
            i,
            len,
            raw,
            fragment,
            multiline,
            leftChar,
            leftSource,
            rightChar,
            allowIn,
            allowCall,
            allowUnparenthesizedNew,
            property;

        precedence = option.precedence;
        allowIn = option.allowIn;
        allowCall = option.allowCall;
        type = expr.type || option.type;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, option);
        }

        switch (type) {
        case Syntax.SequenceExpression:
            result = [];
            allowIn |= (Precedence.Sequence < precedence);
            for (i = 0, len = expr.expressions.length; i < len; i += 1) {
                result.push(generateExpression(expr.expressions[i], {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result = parenthesize(result, Precedence.Sequence, precedence);
            break;

        case Syntax.AssignmentExpression:
            allowIn |= (Precedence.Assignment < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.left, {
                        precedence: Precedence.Call,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + expr.operator + space,
                    generateExpression(expr.right, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Assignment,
                precedence
            );
            break;

        case Syntax.ArrowFunctionExpression:
            allowIn |= (Precedence.ArrowFunction < precedence);
            result = parenthesize(generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
            break;

        case Syntax.ConditionalExpression:
            allowIn |= (Precedence.Conditional < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.test, {
                        precedence: Precedence.LogicalOR,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + '?' + space,
                    generateExpression(expr.consequent, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + ':' + space,
                    generateExpression(expr.alternate, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Conditional,
                precedence
            );
            break;

        case Syntax.LogicalExpression:
        case Syntax.BinaryExpression:
            currentPrecedence = BinaryPrecedence[expr.operator];

            allowIn |= (currentPrecedence < precedence);

            fragment = generateExpression(expr.left, {
                precedence: currentPrecedence,
                allowIn: allowIn,
                allowCall: true
            });

            leftSource = fragment.toString();

            if (leftSource.charAt(leftSource.length - 1) === '/' && isIdentifierPart(expr.operator.charAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = generateExpression(expr.right, {
                precedence: currentPrecedence + 1,
                allowIn: allowIn,
                allowCall: true
            });

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace(), fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !allowIn) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, currentPrecedence, precedence);
            }

            break;

        case Syntax.CallExpression:
            result = [generateExpression(expr.callee, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: false
            })];

            result.push('(');
            for (i = 0, len = expr['arguments'].length; i < len; i += 1) {
                result.push(generateExpression(expr['arguments'][i], {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!allowCall) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, Precedence.Call, precedence);
            }
            break;

        case Syntax.NewExpression:
            len = expr['arguments'].length;
            allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;

            result = join(
                'new',
                generateExpression(expr.callee, {
                    precedence: Precedence.New,
                    allowIn: true,
                    allowCall: false,
                    allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
                })
            );

            if (!allowUnparenthesizedNew || parentheses || len > 0) {
                result.push('(');
                for (i = 0; i < len; i += 1) {
                    result.push(generateExpression(expr['arguments'][i], {
                        precedence: Precedence.Assignment,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            result = parenthesize(result, Precedence.New, precedence);
            break;

        case Syntax.MemberExpression:
            result = [generateExpression(expr.object, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: allowCall,
                allowUnparenthesizedNew: false
            })];

            if (expr.computed) {
                result.push('[', generateExpression(expr.property, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: allowCall
                }), ']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNode(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push('.');
                    }
                }
                result.push('.', generateIdentifier(expr.property));
            }

            result = parenthesize(result, Precedence.Member, precedence);
            break;

        case Syntax.UnaryExpression:
            fragment = generateExpression(expr.argument, {
                precedence: Precedence.Unary,
                allowIn: true,
                allowCall: true
            });

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNode(result).toString();
                    leftChar = leftSource.charAt(leftSource.length - 1);
                    rightChar = fragment.toString().charAt(0);

                    if (((leftChar === '+' || leftChar === '-') && leftChar === rightChar) || (isIdentifierPart(leftChar) && isIdentifierPart(rightChar))) {
                        result.push(noEmptySpace(), fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            result = parenthesize(result, Precedence.Unary, precedence);
            break;

        case Syntax.YieldExpression:
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    generateExpression(expr.argument, {
                        precedence: Precedence.Assignment,
                        allowIn: true,
                        allowCall: true
                    })
                );
            }
            break;

        case Syntax.UpdateExpression:
            if (expr.prefix) {
                result = parenthesize(
                    [
                        expr.operator,
                        generateExpression(expr.argument, {
                            precedence: Precedence.Unary,
                            allowIn: true,
                            allowCall: true
                        })
                    ],
                    Precedence.Unary,
                    precedence
                );
            } else {
                result = parenthesize(
                    [
                        generateExpression(expr.argument, {
                            precedence: Precedence.Postfix,
                            allowIn: true,
                            allowCall: true
                        }),
                        expr.operator
                    ],
                    Precedence.Postfix,
                    precedence
                );
            }
            break;

        case Syntax.FunctionExpression:
            result = 'function';

            if (expr.id) {
                result = [result, noEmptySpace(),
                          generateIdentifier(expr.id),
                          generateFunctionBody(expr)];
            } else {
                result = [result + space, generateFunctionBody(expr)];
            }

            break;

        case Syntax.ArrayPattern:
        case Syntax.ArrayExpression:
            if (!expr.elements.length) {
                result = '[]';
                break;
            }
            multiline = expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                for (i = 0, len = expr.elements.length; i < len; i += 1) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === len) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '', generateExpression(expr.elements[i], {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        }));
                    }
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '', ']');
            break;

        case Syntax.Property:
            if (expr.kind === 'get' || expr.kind === 'set') {
                result = [
                    expr.kind, noEmptySpace(),
                    generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    generateFunctionBody(expr.value)
                ];
            } else {
                if (expr.shorthand) {
                    result = generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });
                } else if (expr.method) {
                    result = [];
                    if (expr.value.generator) {
                        result.push('*');
                    }
                    result.push(generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }), generateFunctionBody(expr.value));
                } else {
                    result = [
                        generateExpression(expr.key, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        }),
                        ':' + space,
                        generateExpression(expr.value, {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        })
                    ];
                }
            }
            break;

        case Syntax.ObjectExpression:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = generateExpression(expr.properties[0], {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true,
                    type: Syntax.Property
                });
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNode(fragment).toString())) {
                    result = [ '{', space, fragment, space, '}' ];
                    break;
                }
            }

            withIndent(function (indent) {
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, len = expr.properties.length; i < len; i += 1) {
                        result.push(indent, generateExpression(expr.properties[i], {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true,
                            type: Syntax.Property
                        }));
                        if (i + 1 < len) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push(newline);
            }
            result.push(base, '}');
            break;

        case Syntax.ObjectPattern:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, len = expr.properties.length; i < len; i += 1) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                for (i = 0, len = expr.properties.length; i < len; i += 1) {
                    result.push(multiline ? indent : '', generateExpression(expr.properties[i], {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '', '}');
            break;

        case Syntax.ThisExpression:
            result = 'this';
            break;

        case Syntax.Identifier:
            result = generateIdentifier(expr);
            break;

        case Syntax.Literal:
            if (expr.hasOwnProperty('raw') && parse) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            result = expr.raw;
                            break;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                result = 'null';
                break;
            }

            if (typeof expr.value === 'string') {
                result = escapeString(expr.value);
                break;
            }

            if (typeof expr.value === 'number') {
                result = generateNumber(expr.value);
                break;
            }

            if (typeof expr.value === 'boolean') {
                result = expr.value ? 'true' : 'false';
                break;
            }

            result = generateRegExp(expr.value);
            break;

        case Syntax.ComprehensionExpression:
            result = [
                '[',
                generateExpression(expr.body, {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                })
            ];

            if (expr.blocks) {
                for (i = 0, len = expr.blocks.length; i < len; i += 1) {
                    fragment = generateExpression(expr.blocks[i], {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });
                    result = join(result, fragment);
                }
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = generateExpression(expr.filter, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                });
                if (extra.moz.parenthesizedComprehensionBlock) {
                    result = join(result, [ '(', fragment, ')' ]);
                } else {
                    result = join(result, fragment);
                }
            }
            result.push(']');
            break;

        case Syntax.ComprehensionBlock:
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    generateStatement(expr.left.declarations[0], {
                        allowIn: false
                    })
                ];
            } else {
                fragment = generateExpression(expr.left, {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: true
                });
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, generateExpression(expr.right, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            }));

            if (extra.moz.parenthesizedComprehensionBlock) {
                result = [ 'for' + space + '(', fragment, ')' ];
            } else {
                result = join('for' + space, fragment);
            }
            break;

        default:
            throw new Error('Unknown expression type: ' + expr.type);
        }

        return toSourceNode(result, expr);
    }

    function generateStatement(stmt, option) {
        var i, len, result, node, allowIn, functionBody, directiveContext, fragment, semicolon;

        allowIn = true;
        semicolon = ';';
        functionBody = false;
        directiveContext = false;
        if (option) {
            allowIn = option.allowIn === undefined || option.allowIn;
            if (!semicolons && option.semicolonOptional === true) {
                semicolon = '';
            }
            functionBody = option.functionBody;
            directiveContext = option.directiveContext;
        }

        switch (stmt.type) {
        case Syntax.BlockStatement:
            result = ['{', newline];

            withIndent(function () {
                for (i = 0, len = stmt.body.length; i < len; i += 1) {
                    fragment = addIndent(generateStatement(stmt.body[i], {
                        semicolonOptional: i === len - 1,
                        directiveContext: functionBody
                    }));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });

            result.push(addIndent('}'));
            break;

        case Syntax.BreakStatement:
            if (stmt.label) {
                result = 'break ' + stmt.label.name + semicolon;
            } else {
                result = 'break' + semicolon;
            }
            break;

        case Syntax.ContinueStatement:
            if (stmt.label) {
                result = 'continue ' + stmt.label.name + semicolon;
            } else {
                result = 'continue' + semicolon;
            }
            break;

        case Syntax.DirectiveStatement:
            if (stmt.raw) {
                result = stmt.raw + semicolon;
            } else {
                result = escapeDirective(stmt.directive) + semicolon;
            }
            break;

        case Syntax.DoWhileStatement:
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            result = join('do', maybeBlock(stmt.body));
            result = maybeBlockSuffix(stmt.body, result);
            result = join(result, [
                'while' + space + '(',
                generateExpression(stmt.test, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                }),
                ')' + semicolon
            ]);
            break;

        case Syntax.CatchClause:
            withIndent(function () {
                result = [
                    'catch' + space + '(',
                    generateExpression(stmt.param, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body));
            break;

        case Syntax.DebuggerStatement:
            result = 'debugger' + semicolon;
            break;

        case Syntax.EmptyStatement:
            result = ';';
            break;

        case Syntax.ExpressionStatement:
            result = [generateExpression(stmt.expression, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            })];
            // 12.4 '{', 'function' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNode(result).toString();
            if (fragment.charAt(0) === '{' || (fragment.slice(0, 8) === 'function' && ' ('.indexOf(fragment.charAt(8)) >= 0) || (directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + semicolon];
            } else {
                result.push(semicolon);
            }
            break;

        case Syntax.VariableDeclarator:
            if (stmt.init) {
                result = [
                    generateExpression(stmt.id, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space,
                    '=',
                    space,
                    generateExpression(stmt.init, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ];
            } else {
                result = generateIdentifier(stmt.id);
            }
            break;

        case Syntax.VariableDeclaration:
            result = [stmt.kind];
            // special path for
            // var x = function () {
            // };
            if (stmt.declarations.length === 1 && stmt.declarations[0].init &&
                    stmt.declarations[0].init.type === Syntax.FunctionExpression) {
                result.push(noEmptySpace(), generateStatement(stmt.declarations[0], {
                    allowIn: allowIn
                }));
            } else {
                // VariableDeclarator is typed as Statement,
                // but joined with comma (not LineTerminator).
                // So if comment is attached to target node, we should specialize.
                withIndent(function () {
                    node = stmt.declarations[0];
                    if (extra.comment && node.leadingComments) {
                        result.push('\n', addIndent(generateStatement(node, {
                            allowIn: allowIn
                        })));
                    } else {
                        result.push(noEmptySpace(), generateStatement(node, {
                            allowIn: allowIn
                        }));
                    }

                    for (i = 1, len = stmt.declarations.length; i < len; i += 1) {
                        node = stmt.declarations[i];
                        if (extra.comment && node.leadingComments) {
                            result.push(',' + newline, addIndent(generateStatement(node, {
                                allowIn: allowIn
                            })));
                        } else {
                            result.push(',' + space, generateStatement(node, {
                                allowIn: allowIn
                            }));
                        }
                    }
                });
            }
            result.push(semicolon);
            break;

        case Syntax.ThrowStatement:
            result = [join(
                'throw',
                generateExpression(stmt.argument, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                })
            ), semicolon];
            break;

        case Syntax.TryStatement:
            result = ['try', maybeBlock(stmt.block)];
            result = maybeBlockSuffix(stmt.block, result);
            if (stmt.handlers) {
                // old interface
                for (i = 0, len = stmt.handlers.length; i < len; i += 1) {
                    result = join(result, generateStatement(stmt.handlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                // new interface
                if (stmt.handler) {
                    result = join(result, generateStatement(stmt.handler));
                    if (stmt.finalizer || stmt.guardedHandlers.length > 0) {
                        result = maybeBlockSuffix(stmt.handler.body, result);
                    }
                }

                for (i = 0, len = stmt.guardedHandlers.length; i < len; i += 1) {
                    result = join(result, generateStatement(stmt.guardedHandlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.guardedHandlers[i].body, result);
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', maybeBlock(stmt.finalizer)]);
            }
            break;

        case Syntax.SwitchStatement:
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    generateExpression(stmt.discriminant, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                for (i = 0, len = stmt.cases.length; i < len; i += 1) {
                    fragment = addIndent(generateStatement(stmt.cases[i], {semicolonOptional: i === len - 1}));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            break;

        case Syntax.SwitchCase:
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', generateExpression(stmt.test, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        })),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                len = stmt.consequent.length;
                if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = maybeBlock(stmt.consequent[0]);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== len && !endsWithLineTerminator(toSourceNode(result).toString())) {
                    result.push(newline);
                }

                for (; i < len; i += 1) {
                    fragment = addIndent(generateStatement(stmt.consequent[i], {semicolonOptional: i === len - 1 && semicolon === ''}));
                    result.push(fragment);
                    if (i + 1 !== len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            break;

        case Syntax.IfStatement:
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            if (stmt.alternate) {
                result.push(maybeBlock(stmt.consequent));
                result = maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', generateStatement(stmt.alternate, {semicolonOptional: semicolon === ''})]);
                } else {
                    result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
                }
            } else {
                result.push(maybeBlock(stmt.consequent, semicolon === ''));
            }
            break;

        case Syntax.ForStatement:
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(generateStatement(stmt.init, {allowIn: false}));
                    } else {
                        result.push(generateExpression(stmt.init, {
                            precedence: Precedence.Sequence,
                            allowIn: false,
                            allowCall: true
                        }), ';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space, generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }), ';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space, generateExpression(stmt.update, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }), ')');
                } else {
                    result.push(')');
                }
            });

            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.ForInStatement:
            result = ['for' + space + '('];
            withIndent(function () {
                if (stmt.left.type === Syntax.VariableDeclaration) {
                    withIndent(function () {
                        result.push(stmt.left.kind + noEmptySpace(), generateStatement(stmt.left.declarations[0], {
                            allowIn: false
                        }));
                    });
                } else {
                    result.push(generateExpression(stmt.left, {
                        precedence: Precedence.Call,
                        allowIn: true,
                        allowCall: true
                    }));
                }

                result = join(result, 'in');
                result = [join(
                    result,
                    generateExpression(stmt.right, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    })
                ), ')'];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.LabeledStatement:
            result = [stmt.label.name + ':', maybeBlock(stmt.body, semicolon === '')];
            break;

        case Syntax.Program:
            len = stmt.body.length;
            result = [safeConcatenation && len > 0 ? '\n' : ''];
            for (i = 0; i < len; i += 1) {
                fragment = addIndent(
                    generateStatement(stmt.body[i], {
                        semicolonOptional: !safeConcatenation && i === len - 1,
                        directiveContext: true
                    })
                );
                result.push(fragment);
                if (i + 1 < len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                    result.push(newline);
                }
            }
            break;

        case Syntax.FunctionDeclaration:
            result = [(stmt.generator && !extra.moz.starlessGenerator ? 'function* ' : 'function '),
                      generateIdentifier(stmt.id),
                      generateFunctionBody(stmt)];
            break;

        case Syntax.ReturnStatement:
            if (stmt.argument) {
                result = [join(
                    'return',
                    generateExpression(stmt.argument, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    })
                ), semicolon];
            } else {
                result = ['return' + semicolon];
            }
            break;

        case Syntax.WhileStatement:
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.WithStatement:
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    generateExpression(stmt.object, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        default:
            throw new Error('Unknown statement type: ' + stmt.type);
        }

        // Attach comments

        if (extra.comment) {
            result = addCommentsToStatement(stmt, result);
        }

        fragment = toSourceNode(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = toSourceNode(result).replaceRight(/\s+$/, '');
        }

        return toSourceNode(result, stmt);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        } else {
            SourceNode = SourceNodeMock;
        }

        switch (node.type) {
        case Syntax.BlockStatement:
        case Syntax.BreakStatement:
        case Syntax.CatchClause:
        case Syntax.ContinueStatement:
        case Syntax.DirectiveStatement:
        case Syntax.DoWhileStatement:
        case Syntax.DebuggerStatement:
        case Syntax.EmptyStatement:
        case Syntax.ExpressionStatement:
        case Syntax.ForStatement:
        case Syntax.ForInStatement:
        case Syntax.FunctionDeclaration:
        case Syntax.IfStatement:
        case Syntax.LabeledStatement:
        case Syntax.Program:
        case Syntax.ReturnStatement:
        case Syntax.SwitchStatement:
        case Syntax.SwitchCase:
        case Syntax.ThrowStatement:
        case Syntax.TryStatement:
        case Syntax.VariableDeclaration:
        case Syntax.VariableDeclarator:
        case Syntax.WhileStatement:
        case Syntax.WithStatement:
            result = generateStatement(node);
            break;

        case Syntax.AssignmentExpression:
        case Syntax.ArrayExpression:
        case Syntax.ArrayPattern:
        case Syntax.BinaryExpression:
        case Syntax.CallExpression:
        case Syntax.ConditionalExpression:
        case Syntax.FunctionExpression:
        case Syntax.Identifier:
        case Syntax.Literal:
        case Syntax.LogicalExpression:
        case Syntax.MemberExpression:
        case Syntax.NewExpression:
        case Syntax.ObjectExpression:
        case Syntax.ObjectPattern:
        case Syntax.Property:
        case Syntax.SequenceExpression:
        case Syntax.ThisExpression:
        case Syntax.UnaryExpression:
        case Syntax.UpdateExpression:
        case Syntax.YieldExpression:

            result = generateExpression(node, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            });
            break;

        default:
            throw new Error('Unknown node type: ' + node.type);
        }

        if (!sourceMap) {
            return result.toString();
        }

        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceMapWithCode) {
            return pair;
        }
        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./package.json":44,"estraverse":46,"source-map":31}],31:[function(require,module,exports){
arguments[4][15][0].apply(exports,arguments)
},{"./source-map/source-map-consumer":39,"./source-map/source-map-generator":40,"./source-map/source-node":41,"d:\\Code\\htdocs\\shadejs\\node_modules\\escodegen\\node_modules\\source-map\\lib\\source-map.js":15}],32:[function(require,module,exports){
arguments[4][16][0].apply(exports,arguments)
},{"./util":42,"amdefine":43,"d:\\Code\\htdocs\\shadejs\\node_modules\\escodegen\\node_modules\\source-map\\lib\\source-map\\array-set.js":16}],33:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"./base64":34,"amdefine":43,"d:\\Code\\htdocs\\shadejs\\node_modules\\escodegen\\node_modules\\source-map\\lib\\source-map\\base64-vlq.js":17}],34:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"amdefine":43,"d:\\Code\\htdocs\\shadejs\\node_modules\\escodegen\\node_modules\\source-map\\lib\\source-map\\base64.js":18}],35:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');
  var SourceMapConsumer = require('./source-map-consumer').SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
      smc.__originalMappings = aSourceMap._mappings.toArray().slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var str = aStr;
      var temp = {};
      var mapping;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          base64VLQ.decode(str, temp);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
            // Original source.
            base64VLQ.decode(str, temp);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            base64VLQ.decode(str, temp);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            base64VLQ.decode(str, temp);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              // Original name.
              base64VLQ.decode(str, temp);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle,
                                    this._generatedMappings,
                                    "generatedLine",
                                    "generatedColumn",
                                    util.compareByGeneratedPositions);

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source != null && this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

});

},{"./array-set":32,"./base64-vlq":33,"./binary-search":36,"./source-map-consumer":39,"./util":42,"amdefine":43}],36:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {
  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.LEAST_UPPER_BOUND' or
   *     'binarySearch.GREATEST_LOWER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the element we are
   *     searching for if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    }
    else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  exports.LEAST_UPPER_BOUND = 1;
  exports.GREATEST_LOWER_BOUND = 2;

  /**
   * This is an implementation of binary search which will always try and return
   * the index of next highest value checked if there is no exact hit. This is
   * because mappings between original and generated line/col pairs are single
   * points, and there is an implicit region between each of them, so a miss
   * just means that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'exports.LEAST_UPPER_BOUND' or
   *     'exports.GREATEST_LOWER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the element we are
   *     searching for if the exact element cannot be found. Defaults to
   *     'exports.LEAST_UPPER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    var aBias = aBias || exports.LEAST_UPPER_BOUND;

    if (aHaystack.length === 0) {
      return -1;
    }
    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias)
  };

});

},{"amdefine":43}],37:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var SourceMapConsumer = require('./source-map-consumer').SourceMapConsumer;
  var BasicSourceMapConsumer = require('./basic-source-map-consumer').BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      };
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        }, binarySearch.GREATEST_LOWER_BOUND);
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0)
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[i];

          var source = mapping.source;
          var sourceRoot = section.consumer.sourceRoot;

          if (source != null && sourceRoot != null) {
            source = util.join(sourceRoot, source);
          }

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.column +
              (section.generatedOffset.generatedLine === mapping.generatedLine)
              ? section.generatedOffset.generatedColumn - 1
              : 0,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        };
      };

    this.__generatedMappings.sort(util.compareByGeneratedPositions);
    this.__originalMappings.sort(util.compareByOriginalPositions);
  };

  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

},{"./basic-source-map-consumer":35,"./binary-search":36,"./source-map-consumer":39,"./util":42,"amdefine":43}],38:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./util":42,"amdefine":43,"d:\\Code\\htdocs\\shadejs\\node_modules\\escodegen\\node_modules\\source-map\\lib\\source-map\\mapping-list.js":20}],39:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    // We do late requires because the subclasses require() this file.
    if (sourceMap.sections != null) {
      var indexedSourceMapConsumer = require('./indexed-source-map-consumer');
      return new indexedSourceMapConsumer.IndexedSourceMapConsumer(sourceMap);
    } else {
      var basicSourceMapConsumer = require('./basic-source-map-consumer');
      return new basicSourceMapConsumer.BasicSourceMapConsumer(sourceMap);
    }
  }

  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    var basicSourceMapConsumer = require('./basic-source-map-consumer');
    return basicSourceMapConsumer.BasicSourceMapConsumer
            .fromSourceMap(aSourceMap);
  }

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;


  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._nextCharIsMappingSeparator =
    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
      var c = aStr.charAt(0);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  SourceMapConsumer.LEAST_UPPER_BOUND = 1;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source
   * and line provided. The only argument is an object with the following
   * properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: 0
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line. Since mappings are sorted, this is
        // guaranteed to find all mappings for the line we are interested in.
        while (mapping && mapping.originalLine === needle.originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }

      return mappings;
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./basic-source-map-consumer":35,"./indexed-source-map-consumer":37,"./util":42,"amdefine":43}],40:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();

      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":32,"./base64-vlq":33,"./mapping-list":38,"./util":42,"amdefine":43}],41:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"./source-map-generator":40,"./util":42,"amdefine":43,"d:\\Code\\htdocs\\shadejs\\node_modules\\escodegen\\node_modules\\source-map\\lib\\source-map\\source-node.js":23}],42:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"amdefine":43,"d:\\Code\\htdocs\\shadejs\\node_modules\\escodegen\\node_modules\\source-map\\lib\\source-map\\util.js":24}],43:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require('_process'),"/node_modules\\esgraph\\node_modules\\escodegen\\node_modules\\source-map\\node_modules\\amdefine\\amdefine.js")

},{"_process":50,"path":49}],44:[function(require,module,exports){
module.exports={
  "name": "escodegen",
  "description": "ECMAScript code generator",
  "homepage": "http://github.com/Constellation/escodegen.html",
  "main": "escodegen.js",
  "bin": {
    "esgenerate": "./bin/esgenerate.js",
    "escodegen": "./bin/escodegen.js"
  },
  "version": "0.0.28",
  "engines": {
    "node": ">=0.4.0"
  },
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "url": "http://github.com/Constellation"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/Constellation/escodegen.git"
  },
  "dependencies": {
    "esprima": "~1.0.2",
    "estraverse": "~1.3.0",
    "source-map": ">= 0.1.2"
  },
  "optionalDependencies": {
    "source-map": ">= 0.1.2"
  },
  "devDependencies": {
    "esprima-moz": "*",
    "commonjs-everywhere": "~0.8.0",
    "q": "*",
    "bower": "*",
    "semver": "*",
    "chai": "~1.7.2",
    "grunt-contrib-jshint": "~0.5.0",
    "grunt-cli": "~0.1.9",
    "grunt": "~0.4.1",
    "grunt-mocha-test": "~0.6.2"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/Constellation/escodegen/raw/master/LICENSE.BSD"
    }
  ],
  "scripts": {
    "test": "grunt travis",
    "unit-test": "grunt test",
    "lint": "grunt lint",
    "release": "node tools/release.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js"
  },
  "readme": "\n### Escodegen [![Build Status](https://secure.travis-ci.org/Constellation/escodegen.png)](http://travis-ci.org/Constellation/escodegen) [![Build Status](https://drone.io/github.com/Constellation/escodegen/status.png)](https://drone.io/github.com/Constellation/escodegen/latest)\n\nEscodegen ([escodegen](http://github.com/Constellation/escodegen)) is\n[ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n(also popularly known as [JavaScript](http://en.wikipedia.org/wiki/JavaScript>JavaScript))\ncode generator from [Parser API](https://developer.mozilla.org/en/SpiderMonkey/Parser_API) AST.\nSee [online generator demo](http://constellation.github.com/escodegen/demo/index.html).\n\n\n### Install\n\nEscodegen can be used in a web browser:\n\n    <script src=\"escodegen.browser.js\"></script>\n\nescodegen.browser.js is found in tagged-revision. See Tags on GitHub.\n\nOr in a Node.js application via the package manager:\n\n    npm install escodegen\n\n### Usage\n\nA simple example: the program\n\n    escodegen.generate({\n        type: 'BinaryExpression',\n        operator: '+',\n        left: { type: 'Literal', value: 40 },\n        right: { type: 'Literal', value: 2 }\n    });\n\nproduces the string `'40 + 2'`\n\nSee the [API page](https://github.com/Constellation/escodegen/wiki/API) for\noptions. To run the tests, execute `npm test` in the root directory.\n\n### License\n\n#### Escodegen\n\nCopyright (C) 2012 [Yusuke Suzuki](http://github.com/Constellation)\n (twitter: [@Constellation](http://twitter.com/Constellation)) and other contributors.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#### source-map\n\nSourceNodeMocks has a limited interface of mozilla/source-map SourceNode implementations.\n\nCopyright (c) 2009-2011, Mozilla Foundation and contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the names of the Mozilla Foundation nor the names of project\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Constellation/escodegen/issues"
  },
  "_id": "escodegen@0.0.28",
  "_from": "escodegen@~ 0.0.27"
}

},{}],45:[function(require,module,exports){
/*
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
throwError: true, createLiteral: true, generateStatement: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true,
parseStatement: true, parseSourceElement: true */

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        buffer,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function sliceSource(from, to) {
        return source.slice(from, to);
    }

    if (typeof 'esprima'[0] === 'undefined') {
        sliceSource = function sliceArraySource(from, to) {
            return source.slice(from, to).join('');
        };
    }

    function isDecimalDigit(ch) {
        return '0123456789'.indexOf(ch) >= 0;
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === ' ') || (ch === '\u0009') || (ch === '\u000B') ||
            (ch === '\u000C') || (ch === '\u00A0') ||
            (ch.charCodeAt(0) >= 0x1680 &&
             '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === '\n' || ch === '\r' || ch === '\u2028' || ch === '\u2029');
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === '$') || (ch === '_') || (ch === '\\') ||
            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierStart.test(ch));
    }

    function isIdentifierPart(ch) {
        return (ch === '$') || (ch === '_') || (ch === '\\') ||
            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
            ((ch >= '0') && (ch <= '9')) ||
            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {

        // Future reserved words.
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        }

        return false;
    }

    function isStrictModeReservedWord(id) {
        switch (id) {

        // Strict Mode reserved words.
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        }

        return false;
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        var keyword = false;
        switch (id.length) {
        case 2:
            keyword = (id === 'if') || (id === 'in') || (id === 'do');
            break;
        case 3:
            keyword = (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
            break;
        case 4:
            keyword = (id === 'this') || (id === 'else') || (id === 'case') || (id === 'void') || (id === 'with');
            break;
        case 5:
            keyword = (id === 'while') || (id === 'break') || (id === 'catch') || (id === 'throw');
            break;
        case 6:
            keyword = (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch');
            break;
        case 7:
            keyword = (id === 'default') || (id === 'finally');
            break;
        case 8:
            keyword = (id === 'function') || (id === 'continue') || (id === 'debugger');
            break;
        case 10:
            keyword = (id === 'instanceof');
            break;
        }

        if (keyword) {
            return true;
        }

        switch (id) {
        // Future reserved words.
        // 'const' is specialized as Keyword in V8.
        case 'const':
            return true;

        // For compatiblity to SpiderMonkey and ES.next
        case 'yield':
        case 'let':
            return true;
        }

        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        return isFutureReservedWord(id);
    }

    // 7.4 Comments

    function skipComment() {
        var ch, blockComment, lineComment;

        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source[index];

            if (lineComment) {
                ch = source[index++];
                if (isLineTerminator(ch)) {
                    lineComment = false;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch)) {
                    if (ch === '\r' && source[index + 1] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source[index++];
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    if (ch === '*') {
                        ch = source[index];
                        if (ch === '/') {
                            ++index;
                            blockComment = false;
                        }
                    }
                }
            } else if (ch === '/') {
                ch = source[index + 1];
                if (ch === '/') {
                    index += 2;
                    lineComment = true;
                } else if (ch === '*') {
                    index += 2;
                    blockComment = true;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch ===  '\r' && source[index] === '\n') {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanIdentifier() {
        var ch, start, id, restore;

        ch = source[index];
        if (!isIdentifierStart(ch)) {
            return;
        }

        start = index;
        if (ch === '\\') {
            ++index;
            if (source[index] !== 'u') {
                return;
            }
            ++index;
            restore = index;
            ch = scanHexEscape('u');
            if (ch) {
                if (ch === '\\' || !isIdentifierStart(ch)) {
                    return;
                }
                id = ch;
            } else {
                index = restore;
                id = 'u';
            }
        } else {
            id = source[index++];
        }

        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch)) {
                break;
            }
            if (ch === '\\') {
                ++index;
                if (source[index] !== 'u') {
                    return;
                }
                ++index;
                restore = index;
                ch = scanHexEscape('u');
                if (ch) {
                    if (ch === '\\' || !isIdentifierPart(ch)) {
                        return;
                    }
                    id += ch;
                } else {
                    index = restore;
                    id += 'u';
                }
            } else {
                id += source[index++];
            }
        }

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            return {
                type: Token.Identifier,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (isKeyword(id)) {
            return {
                type: Token.Keyword,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // 7.8.1 Null Literals

        if (id === 'null') {
            return {
                type: Token.NullLiteral,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // 7.8.2 Boolean Literals

        if (id === 'true' || id === 'false') {
            return {
                type: Token.BooleanLiteral,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        return {
            type: Token.Identifier,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        // Check for most common single-character punctuators.

        if (ch1 === ';' || ch1 === '{' || ch1 === '}') {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === ',' || ch1 === '(' || ch1 === ')') {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Dot (.) can also start a floating-point number, hence the need
        // to check the next character.

        ch2 = source[index + 1];
        if (ch1 === '.' && !isDecimalDigit(ch2)) {
            return {
                type: Token.Punctuator,
                value: source[index++],
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Peek more characters.

        ch3 = source[index + 2];
        ch4 = source[index + 3];

        // 4-character punctuator: >>>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            if (ch4 === '=') {
                index += 4;
                return {
                    type: Token.Punctuator,
                    value: '>>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // 3-character punctuators: === !== >>> <<= >>=

        if (ch1 === '=' && ch2 === '=' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '===',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '!' && ch2 === '=' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '!==',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '<<=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // 2-character punctuators: <= >= == != ++ -- << >> && ||
        // += -= *= %= &= |= ^= /=

        if (ch2 === '=') {
            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {
            if ('+-<>&|'.indexOf(ch2) >= 0) {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // The remaining 1-character punctuators.

        if ('[]<>+-*%&|^!~?:=/'.indexOf(ch1) >= 0) {
            return {
                type: Token.Punctuator,
                value: source[index++],
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    }

    // 7.8.3 Numeric Literals

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    number += source[index++];
                    while (index < length) {
                        ch = source[index];
                        if (!isHexDigit(ch)) {
                            break;
                        }
                        number += source[index++];
                    }

                    if (number.length <= 2) {
                        // only 0x
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }

                    if (index < length) {
                        ch = source[index];
                        if (isIdentifierStart(ch)) {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseInt(number, 16),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                } else if (isOctalDigit(ch)) {
                    number += source[index++];
                    while (index < length) {
                        ch = source[index];
                        if (!isOctalDigit(ch)) {
                            break;
                        }
                        number += source[index++];
                    }

                    if (index < length) {
                        ch = source[index];
                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseInt(number, 8),
                        octal: true,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                }

                // decimal number starts with '0' such as '09' is illegal.
                if (isDecimalDigit(ch)) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (index < length) {
                ch = source[index];
                if (!isDecimalDigit(ch)) {
                    break;
                }
                number += source[index++];
            }
        }

        if (ch === '.') {
            number += source[index++];
            while (index < length) {
                ch = source[index];
                if (!isDecimalDigit(ch)) {
                    break;
                }
                number += source[index++];
            }
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }

            ch = source[index];
            if (isDecimalDigit(ch)) {
                number += source[index++];
                while (index < length) {
                    ch = source[index];
                    if (!isDecimalDigit(ch)) {
                        break;
                    }
                    number += source[index++];
                }
            } else {
                ch = 'character ' + ch;
                if (index >= length) {
                    ch = '<end>';
                }
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (index < length) {
            ch = source[index];
            if (isIdentifierStart(ch)) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch)) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'u':
                    case 'x':
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\v';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch)) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanRegExp() {
        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;

        buffer = null;
        skipComment();

        start = index;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        while (index < length) {
            ch = source[index++];
            str += ch;
            if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '\\') {
                    ch = source[index++];
                    // ECMA-262 7.8.5
                    if (isLineTerminator(ch)) {
                        throwError({}, Messages.UnterminatedRegExp);
                    }
                    str += ch;
                } else if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                } else if (isLineTerminator(ch)) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        pattern = str.substr(1, str.length - 2);

        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch)) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        str += '\\u';
                        for (; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                } else {
                    str += '\\';
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }

        return {
            literal: str,
            value: value,
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advance() {
        var ch, token;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [index, index]
            };
        }

        token = scanPunctuator();
        if (typeof token !== 'undefined') {
            return token;
        }

        ch = source[index];

        if (ch === '\'' || ch === '"') {
            return scanStringLiteral();
        }

        if (ch === '.' || isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        token = scanIdentifier();
        if (typeof token !== 'undefined') {
            return token;
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function lex() {
        var token;

        if (buffer) {
            index = buffer.range[1];
            lineNumber = buffer.lineNumber;
            lineStart = buffer.lineStart;
            token = buffer;
            buffer = null;
            return token;
        }

        buffer = null;
        return advance();
    }

    function lookahead() {
        var pos, line, start;

        if (buffer !== null) {
            return buffer;
        }

        pos = index;
        line = lineNumber;
        start = lineStart;
        buffer = advance();
        index = pos;
        lineNumber = line;
        lineStart = start;

        return buffer;
    }

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    return args[index] || '';
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.range[0];
            error.lineNumber = token.lineNumber;
            error.column = token.range[0] - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        var token = lookahead();
        return token.type === Token.Punctuator && token.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        var token = lookahead();
        return token.type === Token.Keyword && token.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var token = lookahead(),
            op = token.value;

        if (token.type !== Token.Punctuator) {
            return false;
        }
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var token, line;

        // Catch the very common case first.
        if (source[index] === ';') {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            return;
        }

        if (match(';')) {
            lex();
            return;
        }

        token = lookahead();
        if (token.type !== Token.EOF && !match('}')) {
            throwUnexpected(token);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [];

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        expect(']');

        return {
            type: Syntax.ArrayExpression,
            elements: elements
        };
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body;

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;

        return {
            type: Syntax.FunctionExpression,
            id: null,
            params: param,
            defaults: [],
            body: body,
            rest: null,
            generator: false,
            expression: false
        };
    }

    function parseObjectPropertyKey() {
        var token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return createLiteral(token);
        }

        return {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    function parseObjectProperty() {
        var token, key, id, param;

        token = lookahead();

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                return {
                    type: Syntax.Property,
                    key: key,
                    value: parsePropertyFunction([]),
                    kind: 'get'
                };
            } else if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead();
                if (token.type !== Token.Identifier) {
                    throwUnexpected(lex());
                }
                param = [ parseVariableIdentifier() ];
                expect(')');
                return {
                    type: Syntax.Property,
                    key: key,
                    value: parsePropertyFunction(param, token),
                    kind: 'set'
                };
            } else {
                expect(':');
                return {
                    type: Syntax.Property,
                    key: id,
                    value: parseAssignmentExpression(),
                    kind: 'init'
                };
            }
        } else if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            return {
                type: Syntax.Property,
                key: key,
                value: parseAssignmentExpression(),
                kind: 'init'
            };
        }
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, kind, map = {}, toString = String;

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;
            if (Object.prototype.hasOwnProperty.call(map, name)) {
                if (map[name] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[name] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[name] |= kind;
            } else {
                map[name] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return {
            type: Syntax.ObjectExpression,
            properties: properties
        };
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var token = lookahead(),
            type = token.type;

        if (type === Token.Identifier) {
            return {
                type: Syntax.Identifier,
                name: lex().value
            };
        }

        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return createLiteral(lex());
        }

        if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                return {
                    type: Syntax.ThisExpression
                };
            }

            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
        }

        if (type === Token.BooleanLiteral) {
            lex();
            token.value = (token.value === 'true');
            return createLiteral(token);
        }

        if (type === Token.NullLiteral) {
            lex();
            token.value = null;
            return createLiteral(token);
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('/') || match('/=')) {
            return createLiteral(scanRegExp());
        }

        return throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var expr;

        expectKeyword('new');

        expr = {
            type: Syntax.NewExpression,
            callee: parseLeftHandSideExpression(),
            'arguments': []
        };

        if (match('(')) {
            expr['arguments'] = parseArguments();
        }

        return expr;
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(')) {
            if (match('(')) {
                expr = {
                    type: Syntax.CallExpression,
                    callee: expr,
                    'arguments': parseArguments()
                };
            } else if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
            }
        }

        return expr;
    }


    function parseLeftHandSideExpression() {
        var expr;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[')) {
            if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr = parseLeftHandSideExpressionAllowCall(), token;

        token = lookahead();
        if (token.type !== Token.Punctuator) {
            return expr;
        }

        if ((match('++') || match('--')) && !peekLineTerminator()) {
            // 11.3.1, 11.3.2
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPostfix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            expr = {
                type: Syntax.UpdateExpression,
                operator: lex().value,
                argument: expr,
                prefix: false
            };
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        token = lookahead();
        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return parsePostfixExpression();
        }

        if (match('++') || match('--')) {
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            expr = {
                type: Syntax.UpdateExpression,
                operator: token.value,
                argument: expr,
                prefix: true
            };
            return expr;
        }

        if (match('+') || match('-') || match('~') || match('!')) {
            expr = {
                type: Syntax.UnaryExpression,
                operator: lex().value,
                argument: parseUnaryExpression()
            };
            return expr;
        }

        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            expr = {
                type: Syntax.UnaryExpression,
                operator: lex().value,
                argument: parseUnaryExpression()
            };
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
            return expr;
        }

        return parsePostfixExpression();
    }

    // 11.5 Multiplicative Operators

    function parseMultiplicativeExpression() {
        var expr = parseUnaryExpression();

        while (match('*') || match('/') || match('%')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseUnaryExpression()
            };
        }

        return expr;
    }

    // 11.6 Additive Operators

    function parseAdditiveExpression() {
        var expr = parseMultiplicativeExpression();

        while (match('+') || match('-')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseMultiplicativeExpression()
            };
        }

        return expr;
    }

    // 11.7 Bitwise Shift Operators

    function parseShiftExpression() {
        var expr = parseAdditiveExpression();

        while (match('<<') || match('>>') || match('>>>')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseAdditiveExpression()
            };
        }

        return expr;
    }
    // 11.8 Relational Operators

    function parseRelationalExpression() {
        var expr, previousAllowIn;

        previousAllowIn = state.allowIn;
        state.allowIn = true;

        expr = parseShiftExpression();

        while (match('<') || match('>') || match('<=') || match('>=') || (previousAllowIn && matchKeyword('in')) || matchKeyword('instanceof')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseShiftExpression()
            };
        }

        state.allowIn = previousAllowIn;
        return expr;
    }

    // 11.9 Equality Operators

    function parseEqualityExpression() {
        var expr = parseRelationalExpression();

        while (match('==') || match('!=') || match('===') || match('!==')) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseRelationalExpression()
            };
        }

        return expr;
    }

    // 11.10 Binary Bitwise Operators

    function parseBitwiseANDExpression() {
        var expr = parseEqualityExpression();

        while (match('&')) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: '&',
                left: expr,
                right: parseEqualityExpression()
            };
        }

        return expr;
    }

    function parseBitwiseXORExpression() {
        var expr = parseBitwiseANDExpression();

        while (match('^')) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: '^',
                left: expr,
                right: parseBitwiseANDExpression()
            };
        }

        return expr;
    }

    function parseBitwiseORExpression() {
        var expr = parseBitwiseXORExpression();

        while (match('|')) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: '|',
                left: expr,
                right: parseBitwiseXORExpression()
            };
        }

        return expr;
    }

    // 11.11 Binary Logical Operators

    function parseLogicalANDExpression() {
        var expr = parseBitwiseORExpression();

        while (match('&&')) {
            lex();
            expr = {
                type: Syntax.LogicalExpression,
                operator: '&&',
                left: expr,
                right: parseBitwiseORExpression()
            };
        }

        return expr;
    }

    function parseLogicalORExpression() {
        var expr = parseLogicalANDExpression();

        while (match('||')) {
            lex();
            expr = {
                type: Syntax.LogicalExpression,
                operator: '||',
                left: expr,
                right: parseLogicalANDExpression()
            };
        }

        return expr;
    }

    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent;

        expr = parseLogicalORExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');

            expr = {
                type: Syntax.ConditionalExpression,
                test: expr,
                consequent: consequent,
                alternate: parseAssignmentExpression()
            };
        }

        return expr;
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var token, expr;

        token = lookahead();
        expr = parseConditionalExpression();

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            expr = {
                type: Syntax.AssignmentExpression,
                operator: lex().value,
                left: expr,
                right: parseAssignmentExpression()
            };
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr = parseAssignmentExpression();

        if (match(',')) {
            expr = {
                type: Syntax.SequenceExpression,
                expressions: [ expr ]
            };

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expr.expressions.push(parseAssignmentExpression());
            }

        }
        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block;

        expect('{');

        block = parseStatementList();

        expect('}');

        return {
            type: Syntax.BlockStatement,
            body: block
        };
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    function parseVariableDeclaration(kind) {
        var id = parseVariableIdentifier(),
            init = null;

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return {
            type: Syntax.VariableDeclarator,
            id: id,
            init: init
        };
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        while (index < length) {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        }

        return list;
    }

    function parseVariableStatement() {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: 'var'
        };
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations;

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: kind
        };
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        expect(';');

        return {
            type: Syntax.EmptyStatement
        };
    }

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var expr = parseExpression();

        consumeSemicolon();

        return {
            type: Syntax.ExpressionStatement,
            expression: expr
        };
    }

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return {
            type: Syntax.IfStatement,
            test: test,
            consequent: consequent,
            alternate: alternate
        };
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return {
            type: Syntax.DoWhileStatement,
            body: body,
            test: test
        };
    }

    function parseWhileStatement() {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return {
            type: Syntax.WhileStatement,
            test: test,
            body: body
        };
    }

    function parseForVariableDeclaration() {
        var token = lex();

        return {
            type: Syntax.VariableDeclaration,
            declarations: parseVariableDeclarationList(),
            kind: token.value
        };
    }

    function parseForStatement() {
        var init, test, update, left, right, body, oldInIteration;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = true;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = true;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwError({}, Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        if (typeof left === 'undefined') {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        }

        return {
            type: Syntax.ForInStatement,
            left: left,
            right: right,
            body: body,
            each: false
        };
    }

    // 12.7 The continue statement

    function parseContinueStatement() {
        var token, label = null;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source[index] === ';') {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return {
                type: Syntax.ContinueStatement,
                label: null
            };
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return {
                type: Syntax.ContinueStatement,
                label: null
            };
        }

        token = lookahead();
        if (token.type === Token.Identifier) {
            label = parseVariableIdentifier();

            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return {
            type: Syntax.ContinueStatement,
            label: label
        };
    }

    // 12.8 The break statement

    function parseBreakStatement() {
        var token, label = null;

        expectKeyword('break');

        // Optimize the most common form: 'break;'.
        if (source[index] === ';') {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return {
                type: Syntax.BreakStatement,
                label: null
            };
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return {
                type: Syntax.BreakStatement,
                label: null
            };
        }

        token = lookahead();
        if (token.type === Token.Identifier) {
            label = parseVariableIdentifier();

            if (!Object.prototype.hasOwnProperty.call(state.labelSet, label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return {
            type: Syntax.BreakStatement,
            label: label
        };
    }

    // 12.9 The return statement

    function parseReturnStatement() {
        var token, argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source[index] === ' ') {
            if (isIdentifierStart(source[index + 1])) {
                argument = parseExpression();
                consumeSemicolon();
                return {
                    type: Syntax.ReturnStatement,
                    argument: argument
                };
            }
        }

        if (peekLineTerminator()) {
            return {
                type: Syntax.ReturnStatement,
                argument: null
            };
        }

        if (!match(';')) {
            token = lookahead();
            if (!match('}') && token.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return {
            type: Syntax.ReturnStatement,
            argument: argument
        };
    }

    // 12.10 The with statement

    function parseWithStatement() {
        var object, body;

        if (strict) {
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return {
            type: Syntax.WithStatement,
            object: object,
            body: body
        };
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test,
            consequent = [],
            statement;

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            if (typeof statement === 'undefined') {
                break;
            }
            consequent.push(statement);
        }

        return {
            type: Syntax.SwitchCase,
            test: test,
            consequent: consequent
        };
    }

    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        if (match('}')) {
            lex();
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant
            };
        }

        cases = [];

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return {
            type: Syntax.SwitchStatement,
            discriminant: discriminant,
            cases: cases
        };
    }

    // 12.13 The throw statement

    function parseThrowStatement() {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return {
            type: Syntax.ThrowStatement,
            argument: argument
        };
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param;

        expectKeyword('catch');

        expect('(');
        if (!match(')')) {
            param = parseExpression();
            // 12.14.1
            if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {
                throwErrorTolerant({}, Messages.StrictCatchVariable);
            }
        }
        expect(')');

        return {
            type: Syntax.CatchClause,
            param: param,
            body: parseBlock()
        };
    }

    function parseTryStatement() {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return {
            type: Syntax.TryStatement,
            block: block,
            guardedHandlers: [],
            handlers: handlers,
            finalizer: finalizer
        };
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement() {
        expectKeyword('debugger');

        consumeSemicolon();

        return {
            type: Syntax.DebuggerStatement
        };
    }

    // 12 Statements

    function parseStatement() {
        var token = lookahead(),
            expr,
            labeledBody;

        if (token.type === Token.EOF) {
            throwUnexpected(token);
        }

        if (token.type === Token.Punctuator) {
            switch (token.value) {
            case ';':
                return parseEmptyStatement();
            case '{':
                return parseBlock();
            case '(':
                return parseExpressionStatement();
            default:
                break;
            }
        }

        if (token.type === Token.Keyword) {
            switch (token.value) {
            case 'break':
                return parseBreakStatement();
            case 'continue':
                return parseContinueStatement();
            case 'debugger':
                return parseDebuggerStatement();
            case 'do':
                return parseDoWhileStatement();
            case 'for':
                return parseForStatement();
            case 'function':
                return parseFunctionDeclaration();
            case 'if':
                return parseIfStatement();
            case 'return':
                return parseReturnStatement();
            case 'switch':
                return parseSwitchStatement();
            case 'throw':
                return parseThrowStatement();
            case 'try':
                return parseTryStatement();
            case 'var':
                return parseVariableStatement();
            case 'while':
                return parseWhileStatement();
            case 'with':
                return parseWithStatement();
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            if (Object.prototype.hasOwnProperty.call(state.labelSet, expr.name)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[expr.name] = true;
            labeledBody = parseStatement();
            delete state.labelSet[expr.name];

            return {
                type: Syntax.LabeledStatement,
                label: expr,
                body: labeledBody
            };
        }

        consumeSemicolon();

        return {
            type: Syntax.ExpressionStatement,
            expression: expr
        };
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;

        expect('{');

        while (index < length) {
            token = lookahead();
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;

        return {
            type: Syntax.BlockStatement,
            body: sourceElements
        };
    }

    function parseFunctionDeclaration() {
        var id, param, params = [], body, token, stricted, firstRestricted, message, previousStrict, paramSet;

        expectKeyword('function');
        token = lookahead();
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead();
                param = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[param.name] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return {
            type: Syntax.FunctionDeclaration,
            id: id,
            params: params,
            defaults: [],
            body: body,
            rest: null,
            generator: false,
            expression: false
        };
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, param, params = [], body, previousStrict, paramSet;

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead();
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        expect('(');

        if (!match(')')) {
            paramSet = {};
            while (index < length) {
                token = lookahead();
                param = parseVariableIdentifier();
                if (strict) {
                    if (isRestrictedWord(token.value)) {
                        stricted = token;
                        message = Messages.StrictParamName;
                    }
                    if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        stricted = token;
                        message = Messages.StrictParamDupe;
                    }
                } else if (!firstRestricted) {
                    if (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } else if (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } else if (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[param.name] = true;
                if (match(')')) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return {
            type: Syntax.FunctionExpression,
            id: id,
            params: params,
            defaults: [],
            body: body,
            rest: null,
            generator: false,
            expression: false
        };
    }

    // 14 Program

    function parseSourceElement() {
        var token = lookahead();

        if (token.type === Token.Keyword) {
            switch (token.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(token.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (token.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead();
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = sliceSource(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var program;
        strict = false;
        program = {
            type: Syntax.Program,
            body: parseSourceElements()
        };
        return program;
    }

    // The following functions are needed only when the option to preserve
    // the comments is active.

    function addComment(type, value, start, end, loc) {
        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (extra.comments.length > 0) {
            if (extra.comments[extra.comments.length - 1].range[1] > start) {
                return;
            }
        }

        extra.comments.push({
            type: type,
            value: value,
            range: [start, end],
            loc: loc
        });
    }

    function scanComment() {
        var comment, ch, loc, start, blockComment, lineComment;

        comment = '';
        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source[index];

            if (lineComment) {
                ch = source[index++];
                if (isLineTerminator(ch)) {
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    lineComment = false;
                    addComment('Line', comment, start, index - 1, loc);
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    comment = '';
                } else if (index >= length) {
                    lineComment = false;
                    comment += ch;
                    loc.end = {
                        line: lineNumber,
                        column: length - lineStart
                    };
                    addComment('Line', comment, start, length, loc);
                } else {
                    comment += ch;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch)) {
                    if (ch === '\r' && source[index + 1] === '\n') {
                        ++index;
                        comment += '\r\n';
                    } else {
                        comment += ch;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source[index++];
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    comment += ch;
                    if (ch === '*') {
                        ch = source[index];
                        if (ch === '/') {
                            comment = comment.substr(0, comment.length - 1);
                            blockComment = false;
                            ++index;
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Block', comment, start, index, loc);
                            comment = '';
                        }
                    }
                }
            } else if (ch === '/') {
                ch = source[index + 1];
                if (ch === '/') {
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart
                        }
                    };
                    start = index;
                    index += 2;
                    lineComment = true;
                    if (index >= length) {
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        lineComment = false;
                        addComment('Line', comment, start, index, loc);
                    }
                } else if (ch === '*') {
                    start = index;
                    index += 2;
                    blockComment = true;
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart - 2
                        }
                    };
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch ===  '\r' && source[index] === '\n') {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function filterCommentLocation() {
        var i, entry, comment, comments = [];

        for (i = 0; i < extra.comments.length; ++i) {
            entry = extra.comments[i];
            comment = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                comment.range = entry.range;
            }
            if (extra.loc) {
                comment.loc = entry.loc;
            }
            comments.push(comment);
        }

        extra.comments = comments;
    }

    function collectToken() {
        var start, loc, token, range, value;

        skipComment();
        start = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = extra.advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            range = [token.range[0], token.range[1]];
            value = sliceSource(token.range[0], token.range[1]);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: range,
                loc: loc
            });
        }

        return token;
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = extra.scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        // Pop the previous token, which is likely '/' or '/='
        if (extra.tokens.length > 0) {
            token = extra.tokens[extra.tokens.length - 1];
            if (token.range[0] === pos && token.type === 'Punctuator') {
                if (token.value === '/' || token.value === '/=') {
                    extra.tokens.pop();
                }
            }
        }

        extra.tokens.push({
            type: 'RegularExpression',
            value: regex.literal,
            range: [pos, index],
            loc: loc
        });

        return regex;
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function createLiteral(token) {
        return {
            type: Syntax.Literal,
            value: token.value
        };
    }

    function createRawLiteral(token) {
        return {
            type: Syntax.Literal,
            value: token.value,
            raw: sliceSource(token.range[0], token.range[1])
        };
    }

    function createLocationMarker() {
        var marker = {};

        marker.range = [index, index];
        marker.loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            },
            end: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        marker.end = function () {
            this.range[1] = index;
            this.loc.end.line = lineNumber;
            this.loc.end.column = index - lineStart;
        };

        marker.applyGroup = function (node) {
            if (extra.range) {
                node.groupRange = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.groupLoc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
            }
        };

        marker.apply = function (node) {
            if (extra.range) {
                node.range = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.loc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
            }
        };

        return marker;
    }

    function trackGroupExpression() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();
        expect('(');

        expr = parseExpression();

        expect(')');

        marker.end();
        marker.applyGroup(expr);

        return expr;
    }

    function trackLeftHandSideExpression() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[')) {
            if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
                marker.end();
                marker.apply(expr);
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function trackLeftHandSideExpressionAllowCall() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(')) {
            if (match('(')) {
                expr = {
                    type: Syntax.CallExpression,
                    callee: expr,
                    'arguments': parseArguments()
                };
                marker.end();
                marker.apply(expr);
            } else if (match('[')) {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: true,
                    object: expr,
                    property: parseComputedMember()
                };
                marker.end();
                marker.apply(expr);
            } else {
                expr = {
                    type: Syntax.MemberExpression,
                    computed: false,
                    object: expr,
                    property: parseNonComputedMember()
                };
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function filterGroup(node) {
        var n, i, entry;

        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};
        for (i in node) {
            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {
                entry = node[i];
                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {
                    n[i] = entry;
                } else {
                    n[i] = filterGroup(entry);
                }
            }
        }
        return n;
    }

    function wrapTrackingFunction(range, loc) {

        return function (parseFunction) {

            function isBinary(node) {
                return node.type === Syntax.LogicalExpression ||
                    node.type === Syntax.BinaryExpression;
            }

            function visit(node) {
                var start, end;

                if (isBinary(node.left)) {
                    visit(node.left);
                }
                if (isBinary(node.right)) {
                    visit(node.right);
                }

                if (range) {
                    if (node.left.groupRange || node.right.groupRange) {
                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];
                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];
                        node.range = [start, end];
                    } else if (typeof node.range === 'undefined') {
                        start = node.left.range[0];
                        end = node.right.range[1];
                        node.range = [start, end];
                    }
                }
                if (loc) {
                    if (node.left.groupLoc || node.right.groupLoc) {
                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;
                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;
                        node.loc = {
                            start: start,
                            end: end
                        };
                    } else if (typeof node.loc === 'undefined') {
                        node.loc = {
                            start: node.left.loc.start,
                            end: node.right.loc.end
                        };
                    }
                }
            }

            return function () {
                var marker, node;

                skipComment();

                marker = createLocationMarker();
                node = parseFunction.apply(null, arguments);
                marker.end();

                if (range && typeof node.range === 'undefined') {
                    marker.apply(node);
                }

                if (loc && typeof node.loc === 'undefined') {
                    marker.apply(node);
                }

                if (isBinary(node)) {
                    visit(node);
                }

                return node;
            };
        };
    }

    function patch() {

        var wrapTracking;

        if (extra.comments) {
            extra.skipComment = skipComment;
            skipComment = scanComment;
        }

        if (extra.raw) {
            extra.createLiteral = createLiteral;
            createLiteral = createRawLiteral;
        }

        if (extra.range || extra.loc) {

            extra.parseGroupExpression = parseGroupExpression;
            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;
            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;
            parseGroupExpression = trackGroupExpression;
            parseLeftHandSideExpression = trackLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;

            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);

            extra.parseAdditiveExpression = parseAdditiveExpression;
            extra.parseAssignmentExpression = parseAssignmentExpression;
            extra.parseBitwiseANDExpression = parseBitwiseANDExpression;
            extra.parseBitwiseORExpression = parseBitwiseORExpression;
            extra.parseBitwiseXORExpression = parseBitwiseXORExpression;
            extra.parseBlock = parseBlock;
            extra.parseFunctionSourceElements = parseFunctionSourceElements;
            extra.parseCatchClause = parseCatchClause;
            extra.parseComputedMember = parseComputedMember;
            extra.parseConditionalExpression = parseConditionalExpression;
            extra.parseConstLetDeclaration = parseConstLetDeclaration;
            extra.parseEqualityExpression = parseEqualityExpression;
            extra.parseExpression = parseExpression;
            extra.parseForVariableDeclaration = parseForVariableDeclaration;
            extra.parseFunctionDeclaration = parseFunctionDeclaration;
            extra.parseFunctionExpression = parseFunctionExpression;
            extra.parseLogicalANDExpression = parseLogicalANDExpression;
            extra.parseLogicalORExpression = parseLogicalORExpression;
            extra.parseMultiplicativeExpression = parseMultiplicativeExpression;
            extra.parseNewExpression = parseNewExpression;
            extra.parseNonComputedProperty = parseNonComputedProperty;
            extra.parseObjectProperty = parseObjectProperty;
            extra.parseObjectPropertyKey = parseObjectPropertyKey;
            extra.parsePostfixExpression = parsePostfixExpression;
            extra.parsePrimaryExpression = parsePrimaryExpression;
            extra.parseProgram = parseProgram;
            extra.parsePropertyFunction = parsePropertyFunction;
            extra.parseRelationalExpression = parseRelationalExpression;
            extra.parseStatement = parseStatement;
            extra.parseShiftExpression = parseShiftExpression;
            extra.parseSwitchCase = parseSwitchCase;
            extra.parseUnaryExpression = parseUnaryExpression;
            extra.parseVariableDeclaration = parseVariableDeclaration;
            extra.parseVariableIdentifier = parseVariableIdentifier;

            parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);
            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);
            parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);
            parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);
            parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);
            parseBlock = wrapTracking(extra.parseBlock);
            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);
            parseCatchClause = wrapTracking(extra.parseCatchClause);
            parseComputedMember = wrapTracking(extra.parseComputedMember);
            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);
            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);
            parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);
            parseExpression = wrapTracking(extra.parseExpression);
            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);
            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);
            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);
            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);
            parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);
            parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);
            parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);
            parseNewExpression = wrapTracking(extra.parseNewExpression);
            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);
            parseObjectProperty = wrapTracking(extra.parseObjectProperty);
            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);
            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);
            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);
            parseProgram = wrapTracking(extra.parseProgram);
            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);
            parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);
            parseStatement = wrapTracking(extra.parseStatement);
            parseShiftExpression = wrapTracking(extra.parseShiftExpression);
            parseSwitchCase = wrapTracking(extra.parseSwitchCase);
            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);
            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);
            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);
        }

        if (typeof extra.tokens !== 'undefined') {
            extra.advance = advance;
            extra.scanRegExp = scanRegExp;

            advance = collectToken;
            scanRegExp = collectRegex;
        }
    }

    function unpatch() {
        if (typeof extra.skipComment === 'function') {
            skipComment = extra.skipComment;
        }

        if (extra.raw) {
            createLiteral = extra.createLiteral;
        }

        if (extra.range || extra.loc) {
            parseAdditiveExpression = extra.parseAdditiveExpression;
            parseAssignmentExpression = extra.parseAssignmentExpression;
            parseBitwiseANDExpression = extra.parseBitwiseANDExpression;
            parseBitwiseORExpression = extra.parseBitwiseORExpression;
            parseBitwiseXORExpression = extra.parseBitwiseXORExpression;
            parseBlock = extra.parseBlock;
            parseFunctionSourceElements = extra.parseFunctionSourceElements;
            parseCatchClause = extra.parseCatchClause;
            parseComputedMember = extra.parseComputedMember;
            parseConditionalExpression = extra.parseConditionalExpression;
            parseConstLetDeclaration = extra.parseConstLetDeclaration;
            parseEqualityExpression = extra.parseEqualityExpression;
            parseExpression = extra.parseExpression;
            parseForVariableDeclaration = extra.parseForVariableDeclaration;
            parseFunctionDeclaration = extra.parseFunctionDeclaration;
            parseFunctionExpression = extra.parseFunctionExpression;
            parseGroupExpression = extra.parseGroupExpression;
            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;
            parseLogicalANDExpression = extra.parseLogicalANDExpression;
            parseLogicalORExpression = extra.parseLogicalORExpression;
            parseMultiplicativeExpression = extra.parseMultiplicativeExpression;
            parseNewExpression = extra.parseNewExpression;
            parseNonComputedProperty = extra.parseNonComputedProperty;
            parseObjectProperty = extra.parseObjectProperty;
            parseObjectPropertyKey = extra.parseObjectPropertyKey;
            parsePrimaryExpression = extra.parsePrimaryExpression;
            parsePostfixExpression = extra.parsePostfixExpression;
            parseProgram = extra.parseProgram;
            parsePropertyFunction = extra.parsePropertyFunction;
            parseRelationalExpression = extra.parseRelationalExpression;
            parseStatement = extra.parseStatement;
            parseShiftExpression = extra.parseShiftExpression;
            parseSwitchCase = extra.parseSwitchCase;
            parseUnaryExpression = extra.parseUnaryExpression;
            parseVariableDeclaration = extra.parseVariableDeclaration;
            parseVariableIdentifier = extra.parseVariableIdentifier;
        }

        if (typeof extra.scanRegExp === 'function') {
            advance = extra.advance;
            scanRegExp = extra.scanRegExp;
        }
    }

    function stringToArray(str) {
        var length = str.length,
            result = [],
            i;
        for (i = 0; i < length; ++i) {
            result[i] = str.charAt(i);
        }
        return result;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        buffer = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.raw = (typeof options.raw === 'boolean') && options.raw;
            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
        }

        if (length > 0) {
            if (typeof source[0] === 'undefined') {
                // Try first to convert to a string. This is good as fast path
                // for old IE which understands string indexing for string
                // literals only and not for string object.
                if (code instanceof String) {
                    source = code.valueOf();
                }

                // Force accessing the characters via an array.
                if (typeof source[0] === 'undefined') {
                    source = stringToArray(code);
                }
            }
        }

        patch();
        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                filterCommentLocation();
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
            if (extra.range || extra.loc) {
                program.body = filterGroup(program.body);
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }

        return program;
    }

    // Sync with package.json.
    exports.version = '1.0.2';

    exports.parse = parse;

    // Deep copy.
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],46:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function (exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP;

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
    };

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = VisitorKeys[nodeType];

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (!isArray(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                        continue;
                    }

                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                            element = new Element(candidate[current2], [key, current2], 'Property', null);
                        } else {
                            element = new Element(candidate[current2], [key, current2], null, null);
                        }
                        worklist.push(element);
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (!isArray(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                    continue;
                }

                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                    if (!candidate[current2]) {
                        continue;
                    }
                    if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                        element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                    } else {
                        element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                    }
                    worklist.push(element);
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.3.2';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],47:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":52}],48:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],49:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":50}],50:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],51:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],52:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":51,"_process":50,"inherits":48}],53:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"./lib":54,"d:\\Code\\htdocs\\shadejs\\node_modules\\analyses\\index.js":1}],54:[function(require,module,exports){

module.exports = walker;

function walker(astNode, functionTable, offset) {
	function stop() { throw stop; }
	var recurse = function (astNode) {
		if (!astNode || typeof astNode !== 'object' || !astNode.type)
			return astNode;
		// range based recursion: only recurse when the astNode is in range
		if (offset !== undefined && astNode.range &&
		    (astNode.range[0] > offset || astNode.range[1] < offset))
			return astNode;
		
		var fn = functionTable[astNode.type] || functionTable.default || checkProps;
		return fn.call(astNode, recurse, stop);
	}
	var ret;
	try {
		ret = recurse(astNode);
	} catch (e) {
		if (e !== stop)
			throw e;
	}
	return ret;
}

function checkProps(recurse) {
	var self = this;
	var mapped = {};
	Object.keys(self).forEach(function (key) {
		var prop = self[key];
		var ret = prop;
		if (Array.isArray(prop))
			ret = prop.map(recurse);
		else
			ret = recurse(prop);
		mapped[key] = ret;
	});
	return mapped;
}

walker.checkProps = checkProps;

},{}],55:[function(require,module,exports){
(function(module){

    // Dependencies
    var Context = require("../base/context.js");
    var common = require("../base/common.js");
    var Base = require("../base/index.js");
    var Annotations = require("./../base/annotation.js");
    var assert = require('assert');
    var walk = require('estraverse');
    var InferenceScope = require("./typeinference/registry/").InferenceScope;
    var System = require("./typeinference/registry/system.js");
    var Shade = require("../interfaces.js");
        var codegen = require("escodegen");


    // Shortcuts
    var Map = common.Map,
        Syntax = common.Syntax,
        FunctionAnnotation = Annotations.FunctionAnnotation,
        ANNO = Annotations.ANNO;

    /**
     *
     * @param {*} program
     * @param {function} analysis
     * @param {*} options
     * @extends {Context}
     * @constructor
     */
    var AnalysisContext = function(program, analysis, options) {
        Context.call(this, program, options);

        assert.equal(program.type, Syntax.Program);

        /**
         * Callback that continues analysis in the same context
         * @see {AnalysisContext.analyze}
         * @type {Function}
         */
        this.analysis = analysis;

        this.root.globalParameters = {};


        var scope = createGlobalScope(program);
        registerSystemInformation(scope, options);
        this.pushScope(scope);

        /**
         * Map of (global) function name to untyped functions that
         * serve as a template for calls that might come with
         * different signatures
         * @type {Map}
         */
        this.functionMap = extractAllFunctions(program, this);


        /**
         * Cache of functions that types has already been derived.
         * Maps from signature to annotated ast
         * @type {Object}
         */
        this.derivedFunctions = {};

        this.constants = null;
    };

    Base.createClass(AnalysisContext, Context, {
        analyse: function() {
            return this.analysis.call(this, this.root, this.options);
        },
        getTypeInfo: function (node) {
            return common.getTypeInfo(node, this.getScope(), this.constants, true);
        },
        /**
         *
         * @param {null|Set}
         */
        setConstants: function(c) {
            this.constants = c;
        },
        callFunction: function (name, args, opt) {
            var signature = this.createSignatureFromNameAndArguments(name, args);
            var info = this.getFunctionInformationBySignature(signature);
            if (info)
                return info;

            return this.createFunctionInformationFor(name, args, opt);
        },
        createSignatureFromNameAndArguments: function (name, args) {
            return args.reduce(function (str, arg) {
                return str + arg.getTypeString()
            }, name);
        },
        getFunctionInformationBySignature: function (signature) {
            if (this.derivedFunctions.hasOwnProperty(signature)) {
                var derivedFunction = this.derivedFunctions[signature];
                //console.log("Reuse", signature);
                return derivedFunction.info;
            }
            return null;
        },
        createFunctionInformationFor: function (name, args, opt) {
            var ast, derived, globalName;
            opt = opt || {};

            if (this.functionMap.has(name)) {
                ast = this.functionMap.get(name);
                globalName = opt.name || this.getSafeUniqueName(name.replace(/\./g, '_'));
                derived = {};
                derived.ast = this.analyseFunction(JSON.parse(JSON.stringify(ast)), args);
                derived.info = derived.ast.extra.returnInfo;
                derived.info.newName = derived.ast.id.name = globalName;
                this.derivedFunctions[this.createSignatureFromNameAndArguments(name, args)] = derived;
                return derived.info;
            }
            throw new Error("Could not resolve function " + name);
        },
        analyseFunction: function(funcDecl, params) {
            var functionScope = new InferenceScope(funcDecl, this.getScope(), {name: funcDecl.id.name });
            var functionAnnotation = new FunctionAnnotation(funcDecl);

            //console.error("analyseFunction:", functionScope.str());

            setParameterTypes(funcDecl.params, params);
            functionScope.declareParameters(funcDecl.params);

            this.pushScope(functionScope);
            funcDecl.body = this.analysis.call(this, funcDecl.body, this.options);

            // Annotate Function Return type from Scope
            functionAnnotation.setReturnInfo(functionScope.getReturnInfo());
            this.popScope();
            return funcDecl;
        },
        getResult: function() {
            // (Re-)add derived function to the program
            addDerivedMethods(this.root, this);
            return this.root;
        },
        declareVariables: function (ast, inDeclaration) {
            var scope = this.getScope(), context = this;
            if (ast.type == Syntax.VariableDeclaration) {
                var declarations = ast.declarations;
                declarations.forEach(function (declaration) {
                    var result = ANNO(declaration);

                    if (declaration.id.type != Syntax.Identifier) {
                        throw new Error("Dynamic variable names are not yet supported");
                    }
                    var variableName = declaration.id.name;
                    scope.declareVariable(variableName, true, result);

                    if (declaration.init) {
                        var init = ANNO(declaration.init);
                        scope.updateTypeInfo(variableName, init, declaration);
                        if (declaration.init.type == Syntax.AssignmentExpression) {
                            context.declareVariables(declaration.init, true);
                        }
                    } else {
                        result.setType(Shade.TYPES.UNDEFINED);
                    }
                })
            } else if (ast.type == Syntax.AssignmentExpression && inDeclaration) {
                var typeInfo = ANNO(ast.right);

                if (ast.left.type != Syntax.Identifier) {
                    throw new Error("Dynamic variable names are not yet supported");
                }
                var variableName = ast.left.name;
                scope.declareVariable(variableName, true, ANNO(ast));
                scope.updateTypeInfo(variableName, typeInfo, ast);
                if (ast.right.type == Syntax.AssignmentExpression) {
                    context.declareVariables(ast.right, true);
                }
            }
            return true;
        },
        injectCall: function(name, entryParams) {

                if (!this.functionMap.has(name))
                    return;

                // First parameter is set as global _env object to be accessible form BRDFs
                // This is a big hack, need better injection mechanism
                var envObject = entryParams[0];
                if (envObject && envObject.extra) {
                    var envAnnotation = new Annotations.Annotation({}, envObject.extra);
                    this.getScope().updateTypeInfo("_env", envAnnotation);
                }

                var overrideName = name.substr(name.indexOf(".")+1);

                this.root.globalParameters[name] = entryParams;
                this.callFunction(name, entryParams.map(function (param) {
                    return ANNO(param);
                }), { name: overrideName});

        }

    });


    /**
     *
     * @param prg
     * @param {AnalysisContext} context
     * @returns {Map}
     */
    function extractAllFunctions(prg, context) {
        var result = new Map();

        result.set("global", prg);

        walk.replace(prg, {
            enter: function (node) {
                if (node.type == Syntax.FunctionDeclaration) {
                    var localName = node.id.name;
                    var parentScope = context.getScope();
                    var anno = new FunctionAnnotation(node);
                    parentScope.declareVariable(localName);
                    parentScope.updateTypeInfo(localName, anno);

                    var newScope = new InferenceScope(node, parentScope, {name: localName });
                    result.set(newScope.str(), node);
                    context.pushScope(newScope);
                }
            },
            leave: function (node) {
                var replace;
                if (node.type == Syntax.FunctionDeclaration) {
                    context.popScope();
                    replace = { type: Syntax.EmptyStatement };
                }
                return replace;
            }
        });
        prg.body = prg.body.filter(function (a) {
            return a.type != Syntax.EmptyStatement;
        });
        return result;
    };


    function addDerivedMethods(program, context) {
        for(var func in context.derivedFunctions) {
            program.body.push(context.derivedFunctions[func].ast);
        }

        walk.traverse(program, {
            enter: function(node) {
                if(node.type == Syntax.CallExpression) {
                    if(node.extra && node.extra.newName) {
                        node.callee.name = node.extra.newName;
                    };
                }
            }
        });
    }

    /**
     *
     * @param {Array.<Object>} params
     * @param {Array.<Object>} types
     */
    function setParameterTypes(params, types) {
        for (var i = 0; i < params.length; i++) {
            var funcParam = ANNO(params[i]);
            if (i < types.length) {
                funcParam.setFromExtra(types[i].getExtra());
                funcParam.setDynamicValue();
            } else {
                funcParam.setType(Shade.TYPES.UNDEFINED);
            }
        }
    }

    function createGlobalScope(ast) {
        var globalScope = new InferenceScope(ast, null, {name: "global"});
        globalScope.registerGlobals();
        return globalScope;
    };

    function registerSystemInformation(scope, opt) {
        var thisInfo = (opt.inject && opt.inject.this) || null;
        scope.declareVariable("this");
        scope.updateTypeInfo("this", System.getThisTypeInfo(thisInfo));
    }

    module.exports = AnalysisContext;


}(module));

},{"../base/common.js":87,"../base/context.js":88,"../base/index.js":90,"../interfaces.js":123,"./../base/annotation.js":85,"./typeinference/registry/":67,"./typeinference/registry/system.js":73,"assert":47,"escodegen":9,"estraverse":46}],56:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var sanitizer = require("./sanitizer/sanitizer.js"),
        resolver =  require("../resolve/resolve.js"),
        staticTransformer = require("./constants/staticTransformer.js"),
        uniformAnalysis = require("./uniformExpressions/uniformAnalysis.js"),
        validator = require("./validator.js"),
        semantics = require("./semantics/semantics.js"),
        AnalysisContext = require("./analysiscontext.js"),
        inference = require("./typeinference/typeinference.js"),
        spaceTransformer = require("../generate/space/transform.js").SpaceTransformer,
        Annotations = require("./../base/annotation.js"),
        codegen = require("escodegen");


    // Shortcuts
    var ANNO = Annotations.ANNO;

    /**
     * This is the main analysis
     * @param {Object} ast
     * @param {Object|null} opt
     * @returns {Object}
     */
    var analyze = function (ast, processingData, opt) {
        opt = opt || {};
        processingData = processingData || {};

        var error;

        try {
            // Resolve BRDF closures
            ast = opt.implementation ? resolver.resolveClosuresPreTypeInference(ast, opt.implementation, processingData, opt) : ast;

            // Sanitize strange expressions into something
            // that is better analysable
            ast = opt.sanitize ? sanitizer.sanitize(ast, opt) : ast;

            //console.log("Analyze", codegen.generate(ast), ast.type, opt.sanitize);
            var context = new AnalysisContext(ast, function(ast, options) {
                    // Calculate types and static values
                    ast = inference.infer(ast, this, options);

                    // Remove/Replace dead code and static expressions
                    ast = staticTransformer.transform(ast, options);

                    ast = opt.extractUniformExpressions ? uniformAnalysis.extract(ast, opt) : ast;
                    //console.log(opt.uniformExpressions);

                    ast = opt.semanticAnalysis ?  semantics(ast, opt) : ast;

                    return ast;

            }, opt);

            context.analyse();
            if (opt.entry) {
                context.injectCall(opt.entry, (opt.inject &&  opt.inject[opt.entry]) || []);
            }
            ast = context.getResult();

            ast = opt.implementation ? resolver.resolveClosuresPostTypeInference(ast, opt.implementation, processingData, opt) : ast;

            // check for remaining code the completeness of annotations
            ast = opt.validate ? validator.validate(ast) : ast;

            if(opt.transformSpaces)
                processingData.spaceInfo = spaceTransformer.transformAast(ast, opt);

        } catch (e) {
            if(opt.throwOnError) {
                throw e;
            }
            error = e;
        }

        return {
            ast: ast,
            error: error
        };

    };

    ns.analyze = analyze;

}(exports));

},{"../generate/space/transform.js":120,"../resolve/resolve.js":126,"./../base/annotation.js":85,"./analysiscontext.js":55,"./constants/staticTransformer.js":58,"./sanitizer/sanitizer.js":60,"./semantics/semantics.js":62,"./typeinference/typeinference.js":79,"./uniformExpressions/uniformAnalysis.js":81,"./validator.js":84,"escodegen":9}],57:[function(require,module,exports){
(function(ns){

    var Syntax = require('estraverse').Syntax,
        ANNO = require("../../base/annotation.js").ANNO,
        Shade = require("../../interfaces.js");


    var UnaryFunctions = {
        "!": function(a) { return !a; },
        "-": function(a) { return -a; },
        "+": function(a) { return +a; },
        "typeof": function(a) { return typeof a; },
        "void": function(a) { return void a; },
        "delete": function(a) { return true; }

    };

    var BinaryFunctions = {
        "+" : function(a,b) { return a + b; },
        "-" : function(a,b) { return a - b; },
        "/" : function(a,b) { return a / b; },
        "*" : function(a,b) { return a * b; },
        "%" : function(a,b) { return a % b; },

        "==" : function(a,b) { return a == b; },
        "!=" : function(a,b) { return a != b; },
        "===" : function(a,b) { return a === b; },
        "!==" : function(a,b) { return a !== b; },
        "<" : function(a,b) { return a < b; },
        "<=" : function(a,b) { return a <= b; },
        ">" : function(a,b) { return a > b; },
        ">=" : function(a,b) { return a >= b; }
    };


    /**
     *
     * @param node
     */
    function getStaticValue(node) {
        if (node.type === Syntax.Literal) {
            var value = node.raw !== undefined ? node.raw : node.value;
            var number = parseFloat(value);
            if (!isNaN(number))
                return number;
            value = node.value;
            switch(value) {
                case "true": return true;
                case "false": return false;
                case "null": return null;
                default: return value;
            }
        }
        if (node.type == Syntax.MemberExpression || node.type == Syntax.CallExpression  || node.type == Syntax.Identifier || node.type == Syntax.NewExpression || node.type == Syntax.LogicalExpression) {
            return ANNO(node).getStaticValue();
        }
        if (node.type === Syntax.UnaryExpression) {
            if (node.operator == "typeof") {
                return ANNO(node).getStaticValue();
            }
            if(UnaryFunctions.hasOwnProperty(node.operator)) {
                return UnaryFunctions[node.operator](getStaticValue(node.argument));
            }
            Shade.throwError(node, "Unknown unary operator: " + node.operator);
        }
        if (node.type === Syntax.BinaryExpression) {
            if(BinaryFunctions.hasOwnProperty(node.operator)) {
                return BinaryFunctions[node.operator](getStaticValue(node.left), getStaticValue(node.right));
            }
            Shade.throwError(node, "Unknown binary operator: " + node.operator);
        }
        Shade.throwError(node, "Evaluating static value for node type: " + node.type);
    };


    function getStaticTruthValue(node) {
        var aNode = ANNO(node);

        // !!undefined == false;
        if (aNode.isNullOrUndefined())
            return false;
        // !!{} == true
        if (aNode.isObject() || this.isFunction())
            return true;
        // In all other cases, it depends on the value,
        // thus we can only evaluate this for static objects
        if (aNode.hasStaticValue()) {
            return !!aNode.getStaticValue();
        }
        return undefined;
    }

    exports.getStaticValue = getStaticValue;
    exports.getStaticTruthValue = getStaticTruthValue;



}(exports));

},{"../../base/annotation.js":85,"../../interfaces.js":123,"estraverse":46}],58:[function(require,module,exports){
(function (ns) {

    var common = require("../../base/common.js"),
        Shade = require("../../interfaces.js"),
        Base = require("../../base/index.js"),
        estraverse = require('estraverse');

    // var codegen = require('escodegen');

    var Syntax = common.Syntax,
        TYPES = Shade.TYPES,
        ANNO = common.ANNO;


    /**
     * Transform AST: Eliminate branches due to static conditions
     * and performs constant folding
     * @param {Object} ast
     * @returns Object
     */
    var transform = ns.transform = function (ast, opt) {
        var transformer = new Transformer(opt);
        return transformer.transform(ast);
    }

    var Transformer = function(opt) {
        opt = opt || {};

        this.foldConstants = opt.foldConstants !== undefined ? opt.foldConstants : true;

        this.controller = new estraverse.Controller();
    };

    Transformer.prototype = {
        transform: function (ast) {
            var that = this;
            return this.controller.replace(ast, {
                enter: function (node, parent) {
                    var typeInfo = ANNO(node);
                    if (!typeInfo.isValid()) {
                        return;
                    }

                    switch (node.type) {
                        case Syntax.IfStatement:
                            return that.handleIfStatement(node);
                        case Syntax.ConditionalExpression:
                            return that.handleConditionalExpression(node);
                        case Syntax.LogicalExpression:
                            return that.handleLogicalExpression(node);
                        case Syntax.AssignmentExpression:
                            return that.handleAssignmentExpression(node);
                        case Syntax.VariableDeclarator:
                            return that.handleVariableDeclarator(node);
                        case Syntax.NewExpression:
                            //case Syntax.CallExpression:
                            return that.handleNewExpression(node);
                        case Syntax.VariableDeclaration:
                            return that.handleVariableDeclaration(node);

                    }

                    if(that.foldConstants && isExpression(node.type, parent.type)) {
                        return that.foldConstantExpression(node);
                    }
                }
            });
        },


        handleIfStatement: function (node) {
            var test = ANNO(node.test);

            if (test.hasStaticValue() || test.canObject()) {
                this.controller.skip();
                var staticValue = test.getStaticTruthValue();
                if (staticValue === true) {
                    return transform(node.consequent);
                }
                if (staticValue === false) {
                    if (node.alternate) {
                        return this.transform(node.alternate);
                    }
                    return {
                        type: Syntax.EmptyStatement
                    }
                }
            }
        },


        handleConditionalExpression: function (node) {
            var test = ANNO(node.test);

            if (test.hasStaticValue() || test.canObject()) {
                this.controller.skip();
                var staticValue = test.getStaticTruthValue();
                if (staticValue === true) {
                    return this.transform(node.consequent);
                } else {
                    return this.transform(node.alternate);
                }
            }
        },

        handleLogicalExpression: function (node) {
            var left = ANNO(node.left);
            var right = ANNO(node.right);
            var leftBool = left.getStaticTruthValue();
            var rightBool = right.getStaticTruthValue();

            if (node.operator === "||") {
                if (leftBool === false) {
                    return node.right;
                }
                if (leftBool === true) {
                    return node.left;
                }
                // Left is dynamic, let's check right
                if (rightBool === false) {
                    return node.left;
                }
            } else if (node.operator === "&&") {
                if (leftBool === false) {
                    return node.left;
                }
                if (leftBool === true) {
                    return node.right;
                }
                // Left is dynamic, let's check right
                if (rightBool === true) {
                    // Now the result type is always the one of the left value
                    return node.left;
                }
                if (rightBool === false) {
                    // Now the result must be false
                    return {
                        type: Syntax.Literal,
                        value: "false",
                        extra: { type: "boolean"}
                    };
                }
            }
        },

        handleAssignmentExpression: function (node) {
            node.right = this.foldConstantExpression(node.right);
            return node;
        },
        handleNewExpression: function (node) {
            var args = node.arguments, newArgs = [];
            args.forEach(function (arg) {
                var typeInfo = ANNO(arg);
                if (isSimpleStatic(typeInfo)) {
                    newArgs.push(generateLiteralFromTypeInfo(typeInfo))
                } else {
                    newArgs.push(arg);
                }
            });
            node.arguments = newArgs;
            return node;
        },

        handleVariableDeclaration: function (node) {
            var declarations = node.declarations, newDeclarations = [], that = this;
            declarations.forEach(function (declaration) {
                var typeInfo = ANNO(declaration);
                if (!typeInfo.isUndefined()) {
                    newDeclarations.push(declaration);
                }
            });
            node.declarations = newDeclarations;
            return node;
        },
        handleVariableDeclarator: function (node) {
            if (node.init) {
                node.init = this.foldConstantExpression(node.init);
                return node;
            }
        },
        foldConstantExpression: function (node) {
            var anno = ANNO(node);
            if (this.foldConstants) {
                if (isSimpleStatic(anno)) {
                    return generateLiteralFromTypeInfo(anno);
                } else if (isStaticObject(anno)) {
                    return generateConstructorFromTypeInfo(anno);
                }
            }
            return node;
        }


    };

    function isSimpleStatic(typeInfo) {
        return typeInfo.hasStaticValue() && !(typeInfo.isObject() || typeInfo.isNullOrUndefined());
    }

     function isStaticObject(typeInfo) {
        return typeInfo.hasStaticValue() && typeInfo.isVector();
    }

    var c_expressions = [Syntax.BinaryExpression, Syntax.UnaryExpression, Syntax.MemberExpression];
    var c_parentLiteralExpressions = [Syntax.BinaryExpression, Syntax.ReturnStatement, Syntax.CallExpression];


    function isExpression(type, parentType) {
        if(type === Syntax.Identifier) {
            return c_parentLiteralExpressions.indexOf(parentType) !== -1;
        }
        return c_expressions.indexOf(type) !== -1;
    };


    function generateConstructorFromTypeInfo(typeInfo) {
        var value = typeInfo.getStaticValue(), size, name, arguments = [];
        switch(typeInfo.getKind()) {
            case Shade.OBJECT_KINDS.FLOAT2: size = 2; name = "Vec2"; break;
            case Shade.OBJECT_KINDS.FLOAT3: size = 3; name = "Vec3"; break;
            case Shade.OBJECT_KINDS.FLOAT4: size = 4; name = "Vec4"; break;
            default:
                throw new Error("Internal error in static transformation. Unknown kind: " + typeInfo.getKind());
        }

        var same = true;
        for(var i = 0; (i < size-1) && same; ++i) {
            same = same && value[i] == value[i+1];
        }

        size = same ? 1 : size;

        for(i = 0; i < size; ++i) {
            arguments.push(generateFloatLiteralFromValue(value[i]));
        }


        var result = {
            type: Syntax.NewExpression,
            callee: {
                type: Syntax.Identifier,
                name: name
            },
            arguments: arguments
        }
        ANNO(result).copy(typeInfo);
        return result;
    }

    function generateFloatLiteralFromValue(value) {
        var needsSign = value < 0;

        var literal = { type: Syntax.Literal, value: needsSign ? -value : value };
        ANNO(literal).setType(Shade.TYPES.NUMBER);

        if (!needsSign)
            return literal;

        var expression = {
                type: Syntax.UnaryExpression,
                operator: "-",
                argument: literal
        }
        ANNO(expression).setType(Shade.TYPES.NUMBER);
        return expression;
    }

    function generateLiteralFromTypeInfo(typeInfo) {
        var value = typeInfo.getStaticValue();
        var isNegative = value < 0;

        var result = {
            type: Syntax.Literal,
            value: isNegative ? -value : value,
            extra: {}
        }
        Base.extend(result.extra, typeInfo.getExtra());

        if(isNegative) {
            result.extra.staticValue = -value;
            result = {
                type: Syntax.UnaryExpression,
                operator: "-",
                argument: result,
                extra: {}
            }
            Base.extend(result.extra, typeInfo.getExtra());
        }
        return result;
    }









}(exports));

},{"../../base/common.js":87,"../../base/index.js":90,"../../interfaces.js":123,"estraverse":46}],59:[function(require,module,exports){
(function (ns) {

    var walk = require('estraverse'),
        Scope = require("./../base/scope.js"),
        resolver = require("../resolve/resolve.js"),
        Syntax = walk.Syntax;

    var derivedSystemParameters = {
        normalizedCoords: ["coords"],
        height: ["coords"],
        width: ["coords"]
    };


    /**
     *
     * @param {{shaderParameters: Array, systemParameters: Array}} result
     * @param {{shaderParameters: Array, systemParameters: Array}} other
     */
    function merge(result, other) {
        var i, param;
        for (var container in result) {
            for(i = 0; i < other[container].length; i++) {
                param = other[container][i];
                if (result[container].indexOf(param) == -1) {
                    result[container].push(param);
                }
            }
        }
    }

    function addSystemParameter(parameterName, container, parameterMap) {
        // Is parameter already in container?
        if (container.indexOf(parameterName) != -1)
            return;

        if (parameterMap && parameterMap.hasOwnProperty(parameterName)) {
            var requiredParameters = parameterMap[parameterName];
            requiredParameters.forEach(function (param) {
                addSystemParameter(param, container, parameterMap);
            });
            return;
        }
        container.push(parameterName);
    }

    /**
     * @param {string} functionName Global name of the function to analyze
     * @param {*} program AST of the program
     * @param {number} environmentObjectPosition
     * @param {object=} analyzedCalls
     * @returns {{shaderParameters: Array, systemParameters: Array}}
     */
    var findParametersInFunction = function (functionName, program, environmentObjectPosition, analyzedCalls) {
        var context = new Scope(program, null, {name: "global"});
        var contextStack = [context];

        var result = { shaderParameters: [], systemParameters: [] };
        analyzedCalls = analyzedCalls || {};
        // console.log("Looking for: ", functionName, environmentObjectPosition);

        var activeParam = null;

        var controller = new walk.Controller();
        controller.traverse(program, {
            enter: function (node) {
                var type = node.type,
                    context, retVal = null;
                switch (type) {
                    case Syntax.FunctionDeclaration:
                        var parentContext = contextStack[contextStack.length - 1];
                        parentContext.declareVariable(node.id.name, false);
                        context = new Scope(node, parentContext, {name: node.id.name });
                        contextStack.push(context);
                        if (context.str() == functionName) {
                            if (environmentObjectPosition != -1 && node.params.length > environmentObjectPosition) {
                                activeParam = node.params[environmentObjectPosition].name;
                            }
                        } else {
                            controller.skip();
                        }
                        break;
                    case Syntax.CallExpression:
                        var pos = node.arguments.reduce(function (prev, curr, index) {
                            if (curr.name && curr.name == activeParam)
                                return index;
                            return prev;
                        }, -1);
                        context = contextStack[contextStack.length - 1];
                        var id = context.getVariableIdentifier(node.callee.name);
                        if (id && !analyzedCalls[id]) {
                            analyzedCalls[id] = true;
                            merge(result, findParametersInFunction(id, program, pos, analyzedCalls));
                        }
                        break;
                    default:
                }
            },
            leave: function (node) {
                var type = node.type;
                switch (type) {
                    case Syntax.FunctionDeclaration:
                        contextStack.pop();
                        activeParam = null;
                        break;
                    case Syntax.MemberExpression:
                        var parameterName = node.property.name;
                        // In a specific parameter of the current method
                        if (activeParam && node.object.name == activeParam) {
                            addSystemParameter(parameterName, result.shaderParameters);
                        } // In 'this' is a system parameter
                        else if (node.object.type == Syntax.ThisExpression) {
                            addSystemParameter(parameterName, result.systemParameters, derivedSystemParameters);
                        } // In global variable '_env'
                        else if (node.object.name == "_env") {
                            addSystemParameter(parameterName, result.shaderParameters);
                        }
                        break;
                }
            }
        });

        return result;
    };

    /**
     * @param {object!} program
     * @param {object?} opt
     * @returns {{shaderParameters: Array, systemParameters: Array}}
     */
    ns.extractParameters = function (program, opt) {
        opt = opt || {};
        var functionName = opt.context || "global.shade";
        var parameterPosition = opt.param || 0;

        if(opt.implementation) {
            program = resolver.resolveClosuresPreTypeInference(program, opt.implementation, opt);
        }
        return findParametersInFunction(functionName, program, parameterPosition);
    };


}(exports));

},{"../resolve/resolve.js":126,"./../base/scope.js":91,"estraverse":46}],60:[function(require,module,exports){
(function (ns) {

    var walk = require('estraverse'),
        assert = require("assert"),
        Base = require("../../base/index.js"),
        common = require("./../../base/common.js"),
        Shade = require("../../interfaces.js"),
        StatementSplitTraverser = require("./statement-split-traverser");

    var Syntax = walk.Syntax;
    var VisitorOption = walk.VisitorOption;


    var DeclarationSimplifier = function (opt) {
        this.declarationStack = [];
    };
    Base.extend(DeclarationSimplifier.prototype, {

        execute: function (root) {
            walk.replace(root, {
                enter: this.enterNode.bind(this),
                leave: this.exitNode.bind(this)
            });
            return root;
        },

        enterNode: function (node, parent) {
            switch(node.type){
                case Syntax.FunctionExpression:
                case Syntax.FunctionDeclaration:
                case Syntax.Program:
                    this.declarationStack.push([]);
                    break;
                case Syntax.VariableDeclarator:
                    this.addDeclaredIdentifier(node.id.name);
                    break;
            }
        },

        exitNode: function (node, parent) {
            switch(node.type){
                case Syntax.FunctionExpression:
                case Syntax.FunctionDeclaration:
                case Syntax.Program:
                    return this.addTopDeclaration(node, parent);
                    break;
                case Syntax.VariableDeclaration:
                    return this.removeMidCodeDeclaration(node, parent);
            }
        },

        removeMidCodeDeclaration: function(node, parent){
            var newNode;
            var isForInit = (parent.type == Syntax.ForStatement && parent.init == node);
            if(isForInit){
                newNode = {
                    type: Syntax.SequenceExpression,
                    expressions: [],
                    loc: node.loc
                }
            }
            else{
                newNode = {
                    type: Syntax.BlockStatement,
                    body: [],
                    loc: node.loc
                }
            }

            var declarations = node.declarations;
            for(var i = 0; i < declarations.length; ++i){
                var declaration = declarations[i];
                if(declaration.init){
                    var expression = {
                        type: Syntax.AssignmentExpression,
                        operator: "=",
                        left: declaration.id,
                        right: declaration.init,
                        loc: declaration.loc
                    };
                    if(isForInit)
                        newNode.expressions.push(expression);
                    else{
                        var statement = {
                            type: Syntax.ExpressionStatement,
                            expression: expression,
                            loc: declaration.loc
                        }
                        newNode.body.push(statement);
                    }
                }
            }
            if(isForInit && newNode.expressions.length == 1){
                return newNode.expressions[0];
            }
            return newNode;
        },

        addTopDeclaration: function(node, parent){
            var declarations = this.declarationStack.pop();
            if(declarations.length > 0){
                var declarationStatement = {
                    type: Syntax.VariableDeclaration,
                    declarations: [],
                    kind: "var"
                };
                for(var i = 0; i < declarations.length; ++i){
                    declarationStatement.declarations[i] = {
                        type: Syntax.VariableDeclarator,
                        id: { type: Syntax.Identifier, name: declarations[i] },
                        init: null
                    }
                }
                if(node.type == Syntax.Program)
                    node.body.unshift(declarationStatement);
                else if(node.body.body)
                    node.body.body.unshift(declarationStatement);
            }
            return node;
        },

        addDeclaredIdentifier: function(name){
            var topStack = this.declarationStack[this.declarationStack.length - 1];
            if(topStack.indexOf(name) == -1)
                topStack.push(name);
        }
    });
    var StatementSimplifier = function (opt) {
        StatementSplitTraverser.call(this, opt);
        this.skipExtraction.forInitUpdate = true;

        this.statementIdentifierInfo = {};
    };

    Base.createClass(StatementSimplifier, StatementSplitTraverser, {
        onGatherSplitInfo: function(){
            this.statementIdentifierInfo = {};
        },
        statementSplitEnter: function(node, parent){
            switch(node.type){
                case Syntax.FunctionExpression:
                    return VisitorOption.Skip;
                case Syntax.Identifier:
                    return this.identifierEnter(node, parent);
                case Syntax.AssignmentExpression:
                case Syntax.UpdateExpression:
                    return this.assignmentEnter(node, parent);
            }
        },

        statementSplitExit: function (node, parent) {
            switch(node.type){
                case Syntax.AssignmentExpression:
                case Syntax.UpdateExpression:
                    return this.assignmentExit(node, parent);
                    break;
            }
        },

        identifierEnter: function(node, parent){
            if(parent.type == Syntax.MemberExpression)
                return;
            if(parent.type == Syntax.AssignmentExpression && parent.left == node)
                return;
            var name = node.name;
            if(!this.statementIdentifierInfo[name])
                this.statementIdentifierInfo[name] = { reads: [], lastWrite: null };
            this.statementIdentifierInfo[name].reads.push(node);
        },

        assignmentEnter: function(node, parent){
            if(parent.type == Syntax.ExpressionStatement)
                return;
            if((node.left || node.argument).type != Syntax.Identifier)
                throw Shade.throwError(node, "We only support nested assignments for simple identifiers, not objects or arrays.");

            if(node.type == Syntax.UpdateExpression){
                var usePrevValue = !node.prefix;
                node = { type: Syntax.AssignmentExpression,
                        operator: "=",
                        left: {type: Syntax.Identifier, name: node.argument.name, loc: node.argument.loc},
                        right: { type: Syntax.BinaryExpression,
                                 operator: node.operator == "++" ? "+" : "-",
                                 left:  {type: Syntax.Identifier, name: node.argument.name , loc: node.argument.loc},
                                 right: {type: Syntax.Literal, value: 1}
                        },
                        loc: node.loc,
                        _usePrevValue: usePrevValue
                };

            }
            else if(node.type == Syntax.AssignmentExpression && node.operator != "="){
                var binaryOperator = node.operator.substr(0, node.operator.length-1);
                node.operator = "=";
                node.right = { type: Syntax.BinaryExpression,
                               operator: binaryOperator,
                               left: {type: Syntax.Identifier, name: node.left.name, loc: node.right.loc },
                               right: node.right,
                               loc: node.right.loc};
            }
            var name = node.left.name;
            var entry = this.statementIdentifierInfo[name];
            if(entry && entry.reads.length > 0)
                node._preIdentifierWriter = entry.lastWrite;
            return node;
        },

        assignmentExit: function(node, parent){
            if(parent.type == Syntax.ExpressionStatement)
                return;

            var readOldValue = node._usePrevValue;
            delete node._usePrevValue;

            var oldName = node.left.name;
            if(!this.statementIdentifierInfo[oldName]){
                this.statementIdentifierInfo[oldName] = { reads: [], lastWrite: null };
            }

            var entry = this.statementIdentifierInfo[oldName];

            var readReplace = {
                type: Syntax.Identifier,
                name: oldName,
                loc: node.loc
            };
            if(readOldValue || (node._preIdentifierWriter !== undefined && node._preIdentifierWriter == entry.lastWrite)){
                var newName = this.getFreeName();
                if(!entry.lastWrite){
                    var copyAssignment = {
                        type: Syntax.AssignmentExpression,
                        left: { type: Syntax.Identifier, name: newName },
                        right: {type: Syntax.Identifier, name: oldName},
                        operator: "="
                    };
                    this.assignmentsToBePrepended.unshift(copyAssignment);
                }else{
                    entry.lastWrite.left.name = newName;
                }
                for(var i = 0; i < entry.reads.length; ++i){
                    entry.reads[i].name = newName;
                }
            }
            entry.reads = [];
            delete node._preIdentifierWriter;
            entry.lastWrite = node;

            if(readOldValue)
                readReplace.name = newName;
            else
                this.statementIdentifierInfo[oldName].reads.push(readReplace);


            this.assignmentsToBePrepended.push(node);
            return readReplace;
        }
    });


    ns.sanitize = function (ast, opt) {
        var declarationSimplifier = new DeclarationSimplifier(opt);
        var statementSimplifier = new StatementSimplifier(opt);
        ast = declarationSimplifier.execute(ast);
        ast = statementSimplifier.execute(ast);
        return ast;
    };


}(exports));

},{"../../base/index.js":90,"../../interfaces.js":123,"./../../base/common.js":87,"./statement-split-traverser":61,"assert":47,"estraverse":46}],61:[function(require,module,exports){
(function (ns) {

    var walk = require('estraverse'),
        assert = require("assert"),
        Base = require("../../base/index.js"),
        common = require("./../../base/common.js"),
        Shade = require("../../interfaces.js"),
        TypeInfo = require("../../base/typeinfo.js").TypeInfo,
        ANNO = require("../../base/annotation.js").ANNO,
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS;

    var Syntax = walk.Syntax;

    var StatementSplitTraverser = function (opt) {
        opt = opt || {};

        /**
         * The root of the program AST
         * @type {*}
         */
        this.scopes = [];
        this.preContinueStatements = [];
        this.currentStatementTmpUsed = [];
        this.assignmentsToBePrepended = [];

        this.skipExtraction = {
            forInitUpdate: false
        }
    };

    Base.extend(StatementSplitTraverser.prototype, {

        execute: function (root) {
            walk.replace(root, {
                enter: this.enterNode.bind(this),
                leave: this.exitNode.bind(this)
            });
            return root;
        },


        gatherStatmentSplitInfo: function(node){
            this.currentStatementTmpUsed = [];
            this.assignmentsToBePrepended = [];
            this.onGatherSplitInfo();
            return walk.replace(node, {
                enter: this.statementSplitEnter.bind(this),
                leave: this.statementSplitExit.bind(this)
            });
        },
        statementSplitEnter: function(nodeParent){
            // Implemented by subclass
        },
        statementSplitExit: function(nodeParent){
            // Implemented by subclass
        },
        onGatherSplitInfo: function(){
            // Implemented by subclass
        },

        isRedundant: function(node){
            var result = true;
            walk.traverse(node, {
                enter: function(node){
                    switch(node.type){
                        case Syntax.AssignmentExpression:
                        case Syntax.UpdateExpression:
                        case Syntax.FunctionExpression:
                        case Syntax.FunctionDeclaration:
                        case Syntax.CallExpression:
                            result = false;
                            this.break();
                    }
                }
            });
            return result;
        },

        pushScope: function(){
            var newScope = {
                declared: [],
                tmpDeclared: [],
                tmpDeclaredTypes: []
            };
            this.scopes.push(newScope);
            return newScope;
        },
        popScope: function(){
            return this.scopes.pop();
        },
        getScope: function(){
            return this.scopes[this.scopes.length - 1];
        },
        addPreContinueStatements: function(statements){
            var last = this.preContinueStatements[this.preContinueStatements.length - 1];
            last.push.apply(last, statements);
        },
        getPreContinueStatements: function(){
            return this.preContinueStatements[this.preContinueStatements.length - 1];
        },

        enterNode: function (node, parent) {
            switch(node.type){
                case Syntax.FunctionExpression:
                case Syntax.FunctionDeclaration:
                case Syntax.Program:
                    var newScope= this.pushScope();
                    if(node.params){
                        for(var i = 0; i < node.params.length; ++i){
                            newScope.declared.push(node.params[i].name);
                        }
                    }
                    break;
                case Syntax.VariableDeclarator:
                    this.addDeclaredIdentifier(node.id.name);
                    break;
                case Syntax.ContinueStatement:
                    return this.extendContinueStatement(node);
                case Syntax.ExpressionStatement:
                    return this.performStatementSplit(node, [{pre: true}]);
                case Syntax.IfStatement:
                    return this.performStatementSplit(node, [{prop: "test", pre: true}]);
                case Syntax.ReturnStatement:
                    return this.performStatementSplit(node, [{prop: "argument", pre: true}]);
                case Syntax.WhileStatement:
                    return this.performStatementSplit(node, [{prop: "test", pre: true, post: true}], "body");
                case Syntax.ForStatement:
                    var extractions = [];

                    if(!this.skipExtraction.forInitUpdate)
                        extractions.push({prop: "init", pre: true, extract: true});

                    extractions.push({prop: "test", pre: true, post: true});

                    if(!this.skipExtraction.forInitUpdate)
                        extractions.push({prop: "update", post: true, extract: true});

                    return this.performStatementSplit(node, extractions, "body");
                case Syntax.DoWhileStatement:
                    return this.performStatementSplit(node, [{prop: "test", post: true}], "body");
            }
        },

        exitNode: function (node, parent) {
            switch(node.type){
                case Syntax.FunctionExpression:
                case Syntax.FunctionDeclaration:
                    return this.addTmpDeclaration(node);
                case Syntax.Program:
                    this.removeRedundantBlocks(node, "body");
                    return this.addTmpDeclaration(node);
                case Syntax.BlockStatement:
                    return this.removeRedundantBlocks(node, "body");
                case Syntax.SwitchCase:
                    return this.removeRedundantBlocks(node, "consequent");
                case Syntax.ContinueStatement:
                    delete node._extended;
                    break;
                case Syntax.WhileStatement:
                case Syntax.ForStatement:
                case Syntax.DoWhileStatement:
                    if(node._preContinueStacked){
                        delete node._preContinueStacked;
                        this.preContinueStatements.pop();
                    }
                    break;
            }
        },


        addDeclaredIdentifier: function(name){
            var declared = this.getScope().declared;
            if(declared.indexOf(name) == -1)
                declared.push(name);
        },

        isNameDeclared: function(name, untyped){
            var i = this.scopes.length;
            while(i--){
                if(this.scopes[i].declared.indexOf(name) != -1)
                    return true;
            }
            if(untyped && this.getScope().tmpDeclared.indexOf(name) != -1)
                return true;
            return false;
        },

        getFreeName: function(type, kind){
            var resultIdx = 0;
            var untyped = (type === undefined);
            var result, prefix = this._getTypedPrefix(type, kind);
            do{
                result = prefix + resultIdx++;
            }while(this.isNameDeclared(result, untyped) || this.currentStatementTmpUsed.indexOf(result) != -1);
            this.currentStatementTmpUsed.push(result);
            var scope = this.getScope();
            if(scope.tmpDeclared.indexOf(result) == -1){
                scope.tmpDeclared.push(result);
                scope.tmpDeclaredTypes.push({type: type, kind: kind});
            }
            return result;
        },

        getStatementTmpUsedCount: function(){
            return this.currentStatementTmpUsed.length;
        },
        reduceStatementTmpUsed: function(newCount){
            this.currentStatementTmpUsed.length = newCount;
        },

        removeStatementTmpUsedAfter: function(name){
            var idx = this.currentStatementTmpUsed.indexOf(name);
            if(idx == -1) return;
            idx++;
            var removeCount = this.currentStatementTmpUsed.length - idx;
            this.currentStatementTmpUsed.splice(idx, removeCount );
        },


        _getTypedPrefix: function(type, kind){
            if(type === undefined)
                return "_tmp";
            switch(type){
                case Types.BOOLEAN: return "_boolTmp";
                case Types.NUMBER: return "_numTmp";
                case Types.INT: return "_intTmp";
                case Types.STRING: return "_stringTmp";
                case Types.OBJECT: switch(kind){
                    case Kinds.FLOAT2: return "_vec2Tmp";
                    case Kinds.FLOAT3: return "_vec3Tmp";
                    case Kinds.FLOAT4: return "_vec4Tmp";
                    case Kinds.MATRIX3: return "_mat3Tmp";
                    case Kinds.MATRIX4: return "_mat4Tmp";
                }
            }
        },

        performStatementSplit: function(node, subProperties, bodyProperty){
            if(bodyProperty && !node._preContinueStacked){
                this.preContinueStatements.push([]);
                node._preContinueStacked = true;
            }

            var originalNode = node, returnNode = node;
            var i = subProperties.length;
            while(i--){
                var property = subProperties[i].prop;
                var target = originalNode;
                if(property) target = originalNode[property];
                if(property && subProperties[i].extract){
                    this.onGatherSplitInfo();
                    this.currentStatementTmpUsed = [];
                    this.assignmentsToBePrepended = target ? [target] : [];
                    originalNode[property] = null;
                }
                else{
                    target = this.gatherStatmentSplitInfo(target);
                    if(property)
                        originalNode[property] = target;
                    else
                        returnNode = target;
                }
                if(this.assignmentsToBePrepended.length > 0){
                    if(subProperties[i].pre){
                        returnNode = this.getSplittedStatementBlock(this.assignmentsToBePrepended, returnNode);
                    }
                    if(subProperties[i].post){
                        var body = originalNode[bodyProperty];
                        var statements = this.getSplittedStatementBlock(this.assignmentsToBePrepended);
                        if(body && body.type == Syntax.BlockStatement){

                            body.body.push(statements);
                        }
                        else{
                            if(body) statements.body.unshift(body);
                            originalNode[bodyProperty] = statements;
                        }
                        this.addPreContinueStatements(this.assignmentsToBePrepended);
                    }
                }
            }
            return returnNode;
        },

        extendContinueStatement: function(node){
            if(node._extended)
                return;
            node._extended = true;
            var statements = this.getPreContinueStatements();
            if(statements.length == 0 )
                return node;
            return this.getSplittedStatementBlock(statements,node);
        },


        getSplittedStatementBlock: function(statements, node){
            var result = {
                type: Syntax.BlockStatement,
                body: [],
                loc: node && node.loc
            };
            for(var i = 0; i < statements.length; ++i){
                var assignment = Base.deepExtend({}, statements[i]);
                result.body.push({
                   type: Syntax.ExpressionStatement,
                   expression: assignment,
                   loc: assignment.loc
                });
            }
            if(node && (node.type != Syntax.ExpressionStatement || !this.isRedundant(node))){
                result.body.push(node);
            }
            return result;
        },



        removeRedundantBlocks: function(node, propertyName){
            var list = node[propertyName];
            var i = list.length;
            while(i--){
                if(list[i].type == Syntax.BlockStatement){
                    var args = [i, 1];
                    args.push.apply(args, list[i].body);
                    list.splice.apply(list, args);
                }
            }
            return node;
        },

        addTmpDeclaration: function(node){
            var tmpDeclared = this.getScope().tmpDeclared,
                tmpDeclaredTypes = this.getScope().tmpDeclaredTypes;
            if(tmpDeclared.length == 0)
                return;
            var list;
            if(node.type == Syntax.Program)
                list = node.body;
            else
                list = node.body.body;
            var declaration = null;
            if(list[0].type == Syntax.VariableDeclaration)
                declaration = list[0];
            else{
                declaration = {
                    type: Syntax.VariableDeclaration,
                    declarations: [],
                    kind: "var"
                };
                list.unshift(declaration);
            }
            for(var i = 0; i < tmpDeclared.length; ++i){
                var declarator = {
                    type : Syntax.VariableDeclarator,
                    id: { type: Syntax.Identifier, name: tmpDeclared[i] },
                    init: null
                };
                if(tmpDeclaredTypes[i].type !== undefined){
                    ANNO(declarator).setType(tmpDeclaredTypes[i].type, tmpDeclaredTypes[i].kind);
                }
                declaration.declarations.push(declarator);
            }


            this.popScope();
        }
    });

    module.exports = StatementSplitTraverser;

}(module));

},{"../../base/annotation.js":85,"../../base/index.js":90,"../../base/typeinfo.js":92,"../../interfaces.js":123,"./../../base/common.js":87,"assert":47,"estraverse":46}],62:[function(require,module,exports){
(function (module) {

    // dependencies
    var walker = require('walkes');
    var worklist = require('analyses');
    var common = require("../../base/common.js");
    var codegen = require('escodegen');
    var Tools = require("./../settools.js");
    var esgraph = require('esgraph');


    // shortcuts
    var Syntax = common.Syntax;
    var Set = worklist.Set;
    var ANNO = common.ANNO;

    // defines

    /**
     * Possible semantics
     * @enum
     * @type {{COLOR: string, NORMAL: string, UNKNOWN: string}}
     */
    var Semantic = {
        COLOR: 'color',
        NORMAL: 'normal',
        UNKNOWN: 'unknown'
    };


    /**
     * @param cfg
     * @param {FlowNode} start
     * @returns {Map}
     */
    function compute(body, start) {

        var cfg = esgraph(body, { omitExceptions: true });

        var result = worklist(cfg, transferFunction, {
            direction: 'backward',
            start: new Set(),
            merge: worklist.merge(mergeSemantics)
        });
        //Tools.printMap(result, cfg);
        return body;
    }

    /**
     * @param {Set} input
     * @this {FlowNode}
     * @returns {Set} output with respect to input
     */
    function transferFunction(input) {
        if (this.type || !this.astNode) // Start and end node do not influence the result
            return input;

        // Local
        var kill = this.kill = this.kill || Tools.findVariableAssignments(this.astNode);
        var generatedDependencies = this.generate = this.generate || generateSemanticDependencies(this.astNode, kill);
        var generatedSemantics = this.generatedSemantics = this.generatedSemantics || generateNewSemantics(this.astNode);
        //generate && console.log(this.label, generate);

        // Depends on input
        var dependencies = null;
        if (generatedDependencies && generatedDependencies.deps.size) {
            var entry = input.filter(function (elem) {
                return elem.name == generatedDependencies.def;
            });
            if (entry.length) {
                dependencies = new Set();
                generatedDependencies.deps.forEach(function (dep) {
                    var obj = { name: dep, type: entry[0].type };
                    dependencies.add(obj)
                });
            }
        }

        var killed = new Set();
        kill.forEach(function (toKill) {
            killed = new Set(input.filter(function (elem) {
                return elem.name == toKill;
            }));
        });
        return mergeSemantics(Set.minus(input, killed), mergeSemantics(dependencies, generatedSemantics));
    }

    /**
     * Special merge function that merges entries with same names
     * to a new entry with top element Semantic.UNKNOWN
     * @param {Set} a
     * @param {Set} b
     * @returns {Set}
     */
    function mergeSemantics(a, b) {

        var mergeEntry = function(a, b) {
            return { name: a.name, type: a.type != b.type ? Semantic.UNKNOWN : a.type };
        };

        if (!a && b)
            return new Set(b);
        var s = new Set(a);
        if (b)
            b.forEach(
                function (elem) {
                    var name = elem.name;
                    var resultA = a.filter(function (other) {
                        return other.name == name
                    });

                    // Not in A, just add it
                    if (!resultA.length) {
                        s.add(elem);
                    } else {
                        // In A, and type is different: mergeType
                        if (resultA[0].type !== elem.type) {
                            s.add(mergeEntry(elem, resultA[0]));
                            s.delete(resultA[0]);
                        }
                    }
                }
            );
        return s;
    }


    function generateSemanticDependencies(ast, defs) {

        var defCount = defs.size;
        if (defCount == 0)
            return null;
        if (defCount > 1)
            throw new Error("Code not sanitized, found multiple definitions in one statement");

        return { def: defs.values()[0], deps: evaluateSemanticDependencies(ast) };
    }

    function evaluateSemanticDependencies(ast) {
        var result = new Set();
        if (!ast && !ast.type) {
            return result;
        }

        walker(ast, {
            AssignmentExpression: function (recurse) {
                recurse(this.right);
            },
            VariableDeclarator: function (recurse) {
                recurse(this.init);
            },
            Identifier: function () {
                result.add(this.name);
            },
            NewExpression: function () {
            },
            MemberExpression: function () {
                if (this.object.type == Syntax.Identifier && this.property.type == Syntax.Identifier) {
                    result.add(this.object.name + "." + this.property.name);
                }
            },
            CallExpression: function () {
                if (this.callee.type == Syntax.MemberExpression) {
                    var callee = this.callee;
                    if (MemberHandlers.hasOwnProperty(callee.object.name)) {
                        var propertyHandler = MemberHandlers[callee.object.name];
                        if (propertyHandler.hasOwnProperty(callee.property.name)) {
                            var handler = propertyHandler[callee.property.name];
                            result = handler(this.arguments, result);
                            return;
                        }
                    } else {
                        // Call on env
                        // TODO: This is not safe. Perform on annotated AST
                        if (Vec3Handler.hasOwnProperty(callee.property.name)) {
                            handler = Vec3Handler[callee.property.name];
                            result = handler(callee, this.arguments, result);
                            return;
                        }
                    }
                    console.log("Unhandled: ", codegen.generate(this))
                }

            }
        });
        return result;
    }

    function getName(node) {
        switch (node.type) {
            case Syntax.Identifier:
                return node.name;
            case Syntax.MemberExpression:
                return node.object.name + "." + node.property.name;
            default:
                console.error("No name for", codegen.generate(node));
                return "?"
        }
    }

    // TODO: Support more functions
    var MathHandlers = {
        mix: function (args, result) {
            result = Set.union(result, evaluateSemanticDependencies(args[0]));
            result = Set.union(result, evaluateSemanticDependencies(args[1]));
            return result;
        }
    };

    var Vec3Handler = {
        normalize: function (callee, args, result) {
            result.add(getName(callee.object));
            return result;
        },
        mul: function (callee, args, result) {
            result.add(getName(callee.object));
            result = Set.union(result, evaluateSemanticDependencies(args[0]));
            return result;
        }
    };


    var MemberHandlers = {
        "Math": MathHandlers
    };


    function generateNewSemantics(astNode) {
        var result = new Set();

        walker(astNode, {
            CallExpression: function (recurse) {
                if (this.callee.type == Syntax.MemberExpression && isBRDFCall(this.callee.object)) {
                    var name = this.callee.property.name;
                    //noinspection FallthroughInSwitchStatementJS
                    switch (name) {
                        case "diffuse":
                        case "phong":
                            declare(Semantic.COLOR, this.arguments[0], result);
                            declare(Semantic.NORMAL, this.arguments[1], result);
                            break;
                    }
                    recurse(this.callee);
                } else {
                    recurse(this.callee);
                    recurse(this.arguments);

                }
            }
        });
        return result;
    }

    function isBRDFCall(ast) {
        if (!ast) {
            return false;
        }
        if (ast.type == Syntax.NewExpression) {
            return ast.callee.type == Syntax.Identifier && ast.callee.name === "Shade";
        }
        if (ast.type == Syntax.CallExpression && ast.callee.type == Syntax.MemberExpression) {
            return isBRDFCall(ast.callee.object);
        }
        return false;
    }

    function declare(semantic, astNode, variables) {
        walker(astNode, {
            Identifier: function () {
                ANNO(this).setSemantic(semantic);
                addMerged(variables, {
                    name: this.name,
                    type: semantic
                });
            },
            MemberExpression: function () {
                if (this.object.type == Syntax.Identifier && this.property.type == Syntax.Identifier) {
                    ANNO(this).setSemantic(semantic);
                    addMerged(variables, {
                        name: getName(this),
                        type: semantic
                    });
                }
            }
        });
    }

    function addMerged(target, elem) {
        var sameName = target.filter(function (other) {
            return other.name == elem.name;
        });
        if (!sameName.length) {
            target.add(elem);
        } else {
            if (sameName[0].type !== elem.type) {
                target.add({name: elem.name, type: Semantic.UNKNOWN});
                target.delete(sameName[0]);
            }
        }
    }

    compute.Semantic = Semantic;
    module.exports = compute;

}(module));

},{"../../base/common.js":87,"./../settools.js":63,"analyses":1,"escodegen":9,"esgraph":27,"walkes":53}],63:[function(require,module,exports){

var Set = require('analyses').Set;
var walk = require('estraverse');
var codegen = require('escodegen');

var Syntax = walk.Syntax;

var Tools = {

    getSetLabels: function (s) {
        if (!s)
            return "Set: null";

        if (!s.size)
            return "Set: {}";

        return "Set: {" + s.values().map(function (n) {
            return n.label;
        }).join(", ") + "}";
    },

    printMap: function (map, cfg, cb) {
        cb = cb || JSON.stringify;
        for (var node in cfg[2]) {
            var n = cfg[2][node];
            if (n.label || n.type || !n.astNode)
                console.log(n.label || n.type, cb(map.get(n)));
            else
                console.log(codegen.generate(n.astNode), cb(map.get(n)));
        }
    },

    findVariableAssignments: function (ast, ignoreUninitalizedDeclarations) {
        var definitions = new Set();
        walk.traverse(ast, {
            leave: function (node, parent) {
                switch (node.type) {
                    case Syntax.AssignmentExpression:
                        if (node.left.type == Syntax.Identifier) {
                            definitions.add(node.left.name);
                        }
                        break;
                    case Syntax.VariableDeclarator:
                        if (node.id.type == Syntax.Identifier && (!ignoreUninitalizedDeclarations || node.init)) {
                            definitions.add(node.id.name);
                        }
                        break;
                    case Syntax.UpdateExpression:
                        if (node.argument.type == Syntax.Identifier) {
                            definitions.add(node.argument.name);
                        }
                        break;
                }
            }
        })
        return definitions;
    }

}

module.exports = Tools;



},{"analyses":1,"escodegen":9,"estraverse":46}],64:[function(require,module,exports){
(function (module) {

    // dependencies
    var walker = require('walkes');
    var worklist = require('analyses');
    var common = require("../base/common.js");
    var esgraph = require('esgraph');
    var codegen = require('escodegen');
    var Tools = require("./settools.js");
    var Shade = require("./../interfaces.js"),
        SpaceType = Shade.SpaceType,
        VectorType = Shade.VectorType,
        SpaceVectorType = Shade.SpaceVectorType;


    // shortcuts
    var Syntax = common.Syntax;
    var Set = worklist.Set,
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS;

    // defines


    var c_resultPointOk = true, c_resultNormalOk = true,
        c_customFunctionPropagations = null, c_debug = false;

    function analyze(functionAast, customFunctionPropagations) {
        var cfg = esgraph(functionAast.body, { omitExceptions: true });
        c_resultPointOk = true; c_resultNormalOk = true;
        c_customFunctionPropagations = customFunctionPropagations || {};
        var output = worklist(cfg, transferSpaceInfo, {
            direction: 'backward',
            start: null,
            merge: worklist.merge(mergeSpaceInfo)
        });
        var startNodeResult = output.get(cfg[0]);
        var result = {};
        var tranferEntry = {
            transferPointOk: c_resultPointOk,
            transferNormalOk: c_resultNormalOk,
            transferArgs: []
        };
        var transferSpaces = {};
        startNodeResult.forEach(function(elem) {
            var split = elem.split(";"), name = split[0], space = split[1]*1;
            if(Shade.getSpaceFromSpaceVector(space) == SpaceType.RESULT){
                transferSpaces[name] = true;
                return;
            }
            if(!result[name]) result[name] = [];
            result[name].push(space);
        });
        for(var i = 0; i < functionAast.params.length; ++i){
            var name = functionAast.params[i].name;
            tranferEntry.transferArgs.push( transferSpaces[name]);
        }
        c_customFunctionPropagations[functionAast.id.name] = tranferEntry;
        return result;
    }


    function setSpaceInfo(ast, key, value){
        if(!ast.spaceInfo)
            ast.spaceInfo = {};
        ast.spaceInfo[key] = value;
    }
    function setSpaceInfoSpaces(ast, key, spaces){
        var values = spaces && spaces.filter(function(space){ return Shade.getSpaceFromSpaceVector(space) != SpaceType.RESULT });
        setSpaceInfo(ast, key, values);
    }

    /**
     * @param {Set} input
     * @this {FlowNode}
     * @returns {Set} output with respect to input
     */
    function transferSpaceInfo(input) {
        if (this.type || !this.astNode) // Start and end node do not influence the result
            return input;

        // Local
        var kill = this.kill = this.kill || Tools.findVariableAssignments(this.astNode, true);
        var generatedDependencies = this.generate = this.generate || generateSpaceDependencies(this.astNode, kill);
        //generate && console.log(this.label, generate);

        // Depends on input
        var depSpaceInfo = new Set(), finalSpaces = null, spaceTypes = null;
        setSpaceInfo(this.astNode, "transferSpaces", null);
        setSpaceInfo(this.astNode, "hasSpaceOverrides", generatedDependencies.dependencies.spaceOverrides.length > 0);
        if(generatedDependencies.def){
            var def = generatedDependencies.def;
            setSpaceInfo(this.astNode, "def", def);
            spaceTypes = getSpaceVectorTypesFromInfo(input, def);
        }
        else{
            spaceTypes = new Set([SpaceVectorType.OBJECT])
            if(this.astNode.type == Syntax.ReturnStatement){
                spaceTypes.add(SpaceVectorType.RESULT_NORMAL);
                spaceTypes.add(SpaceVectorType.RESULT_POINT);
            }
        }
        setSpaceInfoSpaces(this.astNode, "transferSpaces", spaceTypes);
        finalSpaces = createSpaceInfoFromDependencies(depSpaceInfo, generatedDependencies.dependencies, spaceTypes);
        setSpaceInfoSpaces(this.astNode, "finalSpaces", (finalSpaces && finalSpaces.size > 0) ? finalSpaces : null);

        input = new Set(input.filter(function (elem) {
            return !kill.has(elem.split(";")[0]);
        }));
        return mergeSpaceInfo(input, depSpaceInfo);
    }

    function getSpaceVectorTypesFromInfo(spaceInfo, identifier){
        var set = new Set(spaceInfo.filter(function(elem){return elem.split(";")[0] == identifier}).map(function(elem){ return elem.split(";")[1]*1}));
        if(set.size == 0)
            set.add(SpaceVectorType.OBJECT);
        return set;
    }
    function isSpaceTypeValid(spaceType, dependencies){
        var type = Shade.getVectorFromSpaceVector(spaceType);
        return type == VectorType.NONE || (type == VectorType.NORMAL && !dependencies.normalSpaceViolation)
           || (type == VectorType.POINT && !dependencies.pointSpaceViolation);
    }

    function createSpaceInfoFromDependencies(depSpaceInfo, dependencies, spaces){
        var finalSpaces = new Set();
        dependencies.toObjectSet.forEach(function(name){
            depSpaceInfo.add(  name + ";" + SpaceVectorType.OBJECT);
        })
        spaces.forEach(function(spaceVector){
            var space = Shade.getSpaceFromSpaceVector(spaceVector);
            var isValid = isSpaceTypeValid(spaceVector, dependencies);

            if(space != SpaceType.OBJECT && dependencies.hasDirectVec3SpaceOverride()){
                if(space == SpaceType.RESULT)
                    isValid = false;
                else
                    throw new Error("Detection of repeated space conversion. Not supported!");
            }

            finalSpaces.add(spaceVector);

            if(!isValid && space == SpaceType.RESULT){
                if(Shade.getVectorFromSpaceVector(spaceVector) == VectorType.NORMAL)
                    c_resultNormalOk = false;
                else
                    c_resultPointOk = false;
            }
            spaceVector = isValid ?  spaceVector : SpaceVectorType.OBJECT;

            dependencies.propagateSet.forEach(function(name){
                depSpaceInfo.add( name + ";"  + spaceVector );
            });
        });
        var overrides = dependencies.spaceOverrides;
        for(var i = 0; i < overrides.length; ++i){
            createSpaceInfoFromDependencies(depSpaceInfo, overrides[i].dependencies, new Set( [overrides[i].space] ));
        }
        return finalSpaces;
    }


    /**
     * Special merge function that merges entries with same names
     * to a new entry with top element Semantic.UNKNOWN
     * @param {Set} a
     * @param {Set} b
     * @returns {Set}
     */
    function mergeSpaceInfo(a, b) {
        var s = a ? new Set(a) : new Set();
        if (b)
            b.forEach(
                function (elem) {
                    s.add(elem);
                }
            );
        return s;
    }

    function SpaceDependencies(){
        this.normalSpaceViolation = false;
        this.pointSpaceViolation = false;
        this.propagateSet = new Set();
        this.toObjectSet = new Set();
        this.spaceOverrides = [];
    }

    SpaceDependencies.prototype.addSpaceOverride = function(space, fromObjectSpace, dependencies){
        this.spaceOverrides.push({ space: space, fromObjectSpace: fromObjectSpace, dependencies: dependencies})
    }
    SpaceDependencies.prototype.hasDirectVec3SpaceOverride = function(){
        var i = this.spaceOverrides.length;
        while(i--){
            if(!this.spaceOverrides[i].fromObjectSpace)
                return true;
        }
        return false;
    }


    function generateSpaceDependencies(ast, defs) {
        var result = {def: null, dependencies: new SpaceDependencies()};
        if (!ast && !ast.type)
            return result;
        var defCount = defs.size;
        if (defCount > 1)
            throw new Error("Code not sanitized, found multiple definitions in one statement");
        if(defCount == 1)
            result.def = defs.values()[0];
        // TODO: Properly determine FLOAT3 statements
        var isFloat3Statement = (ast.extra && ast.extra.kind == Kinds.FLOAT3);

        if(isFloat3Statement){
            gatherSpaceDependencies(ast, result.dependencies);
            setSpaceInfo(ast, "propagateSet", result.dependencies.propagateSet.values());
            setSpaceInfo(ast, "normalSpaceViolation", result.dependencies.normalSpaceViolation);
            setSpaceInfo(ast, "pointSpaceViolation", result.dependencies.pointSpaceViolation);
        }
        else
            gatherObjectDependencies(ast, result.dependencies);

        return result;
    }

    function getSpaceConversion(callAst){
        var callee = callAst.callee;
        if(callee.type == Syntax.MemberExpression && callee.object.type == Syntax.Identifier
            && callee.object.name == "Space"){
            var spaceType = 0;
            switch(callee.property.name){
                case "transformPoint": spaceType = VectorType.POINT; break;
                case "transformDirection": spaceType = VectorType.NORMAL; break;
            }
            spaceType = spaceType << 3;
            if(spaceType){
                var firstArg = callAst.arguments[0];

                if(firstArg.type != Syntax.MemberExpression || firstArg.object.type != Syntax.Identifier
                    || firstArg.object.name != "Space" || firstArg.property.type != Syntax.Identifier)
                    throw new Error("The first argument of '" + callee.property + "' must be a Space enum value.");
                switch(firstArg.property.name){
                    case "VIEW" : spaceType += SpaceType.VIEW; break;
                    case "WORLD": spaceType += SpaceType.WORLD; break;
                }
                return spaceType;
            }
        }
        return null;
    }

    function handleSpaceOverride(callAst, result, fromObjectSpace){
        var space = getSpaceConversion(callAst);
        if(space){
            var subResult = new SpaceDependencies();
            gatherSpaceDependencies(callAst.arguments[1], subResult);
            result.addSpaceOverride(space, fromObjectSpace, subResult);
            setSpaceInfo(callAst, "spaceOverride", space);
            setSpaceInfo(callAst, "propagateSet", subResult.propagateSet.values());
            setSpaceInfo(callAst, "normalSpaceViolation", subResult.normalSpaceViolation);
            setSpaceInfo(callAst, "pointSpaceViolation", subResult.pointSpaceViolation);
            return true;
        }
        return false;
    }

    function gatherObjectDependencies(ast, result){
        walker(ast, {
            VariableDeclaration: function(){},
            Identifier: function(){
                if(this.extra.kind == Kinds.FLOAT3){
                    result.toObjectSet.add(this.name);
                }

            },
            MemberExpression: function (recurse) {
                if(this.extra.kind == Kinds.FLOAT3){
                    if (this.object.type == Syntax.Identifier && this.property.type == Syntax.Identifier) {
                        if(this.object.extra.global)
                            result.propagateSet.add("env." + this.property.name);
                        else if(this.object.name !== "uexp") { // FIXME
                            throw new Error("Member Access of non 'env' object in space equation - not supported: " + codegen.generate(this));
                        }
                    }
                }
                else{
                    recurse(this.object);
                    recurse(this.property);
                }
            },
            CallExpression: function (recurse) {
                if(handleSpaceOverride(this, result, true))
                    return;
                recurse(this.callee);
                this.arguments.map(recurse);
            }
        });
    }

    function gatherSpaceDependencies(ast, result) {
        walker(ast, {
            VariableDeclaration: function(){},
            AssignmentExpression: function (recurse) {
                recurse(this.right);
            },
            Identifier: function () {
                if(this.extra.kind == Kinds.FLOAT3){
                    result.propagateSet.add(this.name);
                    setSpaceInfo(this, "propagate", true);
                }
             },
            NewExpression: function (recurse) {
                if(this.callee == "Vec3"){
                    handleVec3Args(this.arguments, recurse, result, false);
                }
            },
            MemberExpression: function (recurse) {
                if(this.extra.kind == Kinds.FLOAT3){
                    if (this.object.type == Syntax.Identifier && this.property.type == Syntax.Identifier) {
                        if(this.object.extra.global)
                            result.propagateSet.add("env." + this.property.name);
                        else if(this.object.name !== "uexp") { // FIXME
                            throw new Error("Member Access of non 'env' object in space equation - not supported.")
                        }
                        setSpaceInfo(this, "propagate", true);
                    }
                }
                else{
                    recurse(this.object);
                    recurse(this.property);
                }
            },
            CallExpression: function (recurse) {
                if(handleSpaceOverride(this, result, false))
                    return;
                if (this.callee.type == Syntax.MemberExpression) {
                    result.pointSpaceViolation = true;
                    var callObject = this.callee.object;
                    var objectKind = callObject.extra.kind,
                        method = this.callee.property.name,
                        args = this.arguments;
                    if(PropagationRules[objectKind] && PropagationRules[objectKind][method]){
                        PropagationRules[objectKind][method](callObject, args, recurse, result);
                        return;
                    }
                    c_debug && console.log("Unhandled: ", codegen.generate(this))
                }else if(this.callee.type == Syntax.Identifier){
                    var id = this.callee.name;
                    var customEntry = c_customFunctionPropagations && c_customFunctionPropagations[id];
                    if(customEntry){
                        if(!customEntry.transferPointOk) result.pointSpaceViolation = true;
                        if(!customEntry.transferNormalOk) result.normalSpaceViolation = true;
                        var i = customEntry.transferArgs.length;
                        while(i--){
                            if(customEntry.transferArgs[i])
                                recurse(this.arguments[i]);
                            else
                                gatherObjectDependencies(this.arguments[i], result);
                        }
                        return;
                    }
                }
                result.pointSpaceViolation = true;
                result.normalSpaceViolation = true;
                gatherObjectDependencies(this, result);
                //this.arguments.forEach(function(arg){ gatherObjectDependencies(arg, result)});
            }
        });
    }

    function handleScaleOperator(callObject, args, recurse, result){
        handleVec3Args(args, recurse, result, true);
        recurse(callObject);
    }
    function handleAddSubOperation(callObject, args, recurse, result){
        handleVec3Args(args, recurse, result, false);
        recurse(callObject);
    }

    function handleVec3Args(args, recurse, result, scaling){
        if(!scaling && args.length == 0){
            result.normalSpaceViolation = true;
            return;
        }
        if(args.length > 1){
            result.normalSpaceViolation = true;
            return;
        }
        if(args.length == 1){
            if(args[0].extra.kind == Kinds.FLOAT3){
                recurse(args[0]);
            }
            else if(scaling && typeIsScalar(args[0].extra.type)){
                gatherObjectDependencies(args[0], result);
            }
            else{
                result.normalSpaceViolation = true;
            }
        }
    }

    function typeIsScalar(type){
        return type == Types.NUMBER || type == Types.INT;
    }


    var PropagationRules = {
        "float3" : {
            "add" : handleAddSubOperation,
            "sub" : handleAddSubOperation,
            "cross" : handleAddSubOperation,
            "mul" : handleScaleOperator,
            "div" : handleScaleOperator,
            "normalize" : handleScaleOperator
        }
    }
    module.exports = {
        analyze: analyze
    };

}(module));

},{"../base/common.js":87,"./../interfaces.js":123,"./settools.js":63,"analyses":1,"escodegen":9,"esgraph":27,"walkes":53}],65:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var common = require("../../base/common.js"),
        Shade = require("../../interfaces.js"),
        evaluator = require("../constants/evaluator.js"),
        estraverse = require('estraverse'),
        ErrorHandler = require("../../base/errors.js");

    var codegen = require('escodegen');

    // Shortcuts
    var Syntax = common.Syntax,
        TYPES = Shade.TYPES,
        ANNO = common.ANNO,
        generateErrorInformation = ErrorHandler.generateErrorInformation,
        ERROR_TYPES = ErrorHandler.ERROR_TYPES;

    var debug = false;



    var handlers = {

        ArrayExpression: function (node, parent, context) {
            var result = ANNO(node), elements = context.getTypeInfo(node.elements), elementType = ANNO({});

            result.setType(TYPES.ARRAY);
            elements.forEach(function (element, index) {
                if (!index) {
                    elementType.copy(element);
                } else {
                    if (!elementType.setCommonType(elementType, element)) {
                        result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "shade.js does not support inhomogenous arrays: [", elements.map(function (e) {
                            return e.getTypeString()
                        }).join(", "), "]"));
                    }
                }
            });
        },

        /**
         * @param node
         */
        Literal: function (node) {
            var value = node.raw !== undefined ? node.raw : node.value,
                result = ANNO(node);

            var number = parseFloat(value);
            if (!isNaN(number)) {
                if (value.toString().indexOf(".") == -1) {
                    result.setType(TYPES.INT);
                }
                else {
                    result.setType(TYPES.NUMBER);
                }
            } else if (value === 'true' || value === 'false') {
                result.setType(TYPES.BOOLEAN);
            } else if (value === 'null') {
                result.setType(TYPES.NULL);
            } else {
                result.setType(TYPES.STRING);
            }
            if (!result.isNull()) {
                result.setStaticValue(evaluator.getStaticValue(node));
            }
        },

        /**
         * ExpressionStatement: Just copy the result from the actual expression
         */
        ExpressionStatement: function (node) {
            var result = ANNO(node),
                expression = ANNO(node.expression);
            result.copy(expression);
        },


        /**
         * ReturnStatement: If return has an argument, copy the TypeInfo
         * form the argument, otherwise it's undefined. Inform the scope on
         * the return type of this return branch.
         */
        ReturnStatement: function (node, parent, context) {
            var result = ANNO(node),
                argument = context.getTypeInfo(node.argument);

            if (argument) {
                result.copy(argument);
            } else {
                result.setType(TYPES.UNDEFINED);
            }
            context.getScope().updateReturnInfo(result);
        },

        /**
         * NewExpression: Find the type of the Callee from
         * the scope and evaluate based on annotated parameters
         */
        NewExpression: function(node, parent, context) {
            var result = ANNO(node), staticValue;

            // Be on the safe side, assume result is static independently of former annotations
            result.setDynamicValue();

            var scope = context.getScope();
            var entry = scope.getBindingByName(node.callee.name);
            if (entry && entry.hasConstructor()) {
                var constructor = entry.getConstructor();
                var args = context.getTypeInfo(node.arguments);
                try {
                    var extra = constructor.evaluate(result, args, scope);
                    result.setFromExtra(extra);
                } catch (e) {
                    result.setInvalid(e);
                    return;
                }
                if (constructor.computeStaticValue) {
                    try {
                        staticValue = constructor.computeStaticValue(result, context.getTypeInfo(node.arguments), scope);
                        if (staticValue !== undefined) {
                            result.setStaticValue(staticValue);
                        }
                    } catch (e) {
                        result.setDynamicValue();
                    }
                }
            }
            else {
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.REFERENCE_ERROR, node.callee.name, "is not defined"));
            }
        },


        /**
         * UnaryExpression
         */
        UnaryExpression: function (node, parent, context) {
            var result = ANNO(node),
                argument = context.getTypeInfo(node.argument),
                operator = node.operator;

            //noinspection FallthroughInSwitchStatementJS
            switch (operator) {
                case "!":
                    result.setType(TYPES.BOOLEAN);
                    if (argument.canObject()) {
                        result.setStaticValue(false); // !obj == false
                        return;
                    }
                    break;
                case "+":
                case "-":
                    if (argument.canInt()) {
                        result.setType(TYPES.INT);
                    } else if (argument.canNumber()) {
                        result.setType(TYPES.NUMBER);
                    } else {
                        result.setInvalid(generateErrorInformation(node, ERROR_TYPES.NAN_ERROR));
                    }
                    break;
                case "typeof":
                    result.setType(TYPES.STRING);
                    if(argument.isValid())
                        result.setStaticValue(argument.getJavaScriptTypeString());
                    return;

                case "~":
                case "void":
                case "delete":
                default:
                    result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, operator, "is not supported."));
            }
            if (argument.hasStaticValue()) {
                result.setStaticValue(evaluator.getStaticValue(node));
            } else {
                result.setDynamicValue();
            }
        },

        /**
         * 'Undefined' is an identifier. Variables, names of functions and
         * member properties are handled within parent expressions
         */
        Identifier: function (node) {
            if (node.name === "undefined") {
                ANNO(node).setType(TYPES.UNDEFINED);
            }
        },

        /**
         * BinaryExpression
         */
        BinaryExpression: function (node, parent, context) {
            //console.log(node.left, node.right);
            var left = context.getTypeInfo(node.left),
                right = context.getTypeInfo(node.right),
                result = ANNO(node),
                operator = node.operator,
                value;

            if(!(left.isValid() && right.isValid())) {
                result.setInvalid();
                return;
            }

            //noinspection FallthroughInSwitchStatementJS
            switch (operator) {
                case "+":
                case "-":
                case "*":
                case "/":
                case "%":
                    // int 'op' int => int
                    // int / int => number
                    if (left.canInt() && right.canInt()) {
                        if (operator == "/")
                            result.setType(TYPES.NUMBER);
                        else
                            result.setType(TYPES.INT);
                    }
                    // int 'op' number => number
                    else if (left.canInt() && right.isNumber() || right.canInt() && left.isNumber()) {
                        result.setType(TYPES.NUMBER);
                    }
                    // number 'op' number => number
                    else if (left.isNumber() && right.isNumber()) {
                        result.setType(TYPES.NUMBER);
                        // int 'op' null => int
                    }
                    else if (left.isInt() && right.isNull() || right.isInt() && left.isNull()) {
                        result.setType(TYPES.INT);
                    }
                    // number 'op' null => number
                    else if ((left.isNumber() && right.isNull()) || (right.isNumber() && left.isNull())) {
                        result.setType(TYPES.NUMBER);
                    }
                    else {
                        // NaN

                       var message = "";
                       // Special handling for undefined, as this is the main reason for this error
                       if(left.isNullOrUndefined()) {
                            message = codegen.generate(node.left) + " is undefined";
                       } else if (right.isNullOrUndefined()) {
                            message = codegen.generate(node.right) + " is undefined";
                       }
                        result.setInvalid(generateErrorInformation(node, ERROR_TYPES.NAN_ERROR, message));
                    }
                    break;
                case "===":
                case "!==":
                    result.setType(TYPES.BOOLEAN);
                    if (left.isUndefined() || right.isUndefined()) {
                        value = left.isUndefined() && right.isUndefined();
                        result.setStaticValue(operator == "===" ? value : !value);
                        return;
                    }
                    break;
                case "==": // comparison
                case "!=":
                case ">":
                case "<":
                case ">=":
                case "<=":
                    result.setType(TYPES.BOOLEAN);
                    if (left.isUndefined() || right.isUndefined()) {
                        value = left.isUndefined() && right.isUndefined();
                        result.setStaticValue(operator == "!=" ? !value : value);
                        return;
                    }
                    break;
                default:
                    result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, operator, "is not supported."));
                    return;
            }
             if (left.hasStaticValue() && right.hasStaticValue()) {
                //console.log(left.getStaticValue(), operator, right.getStaticValue());
                result.setStaticValue(evaluator.getStaticValue(node));
            } else {
                result.setDynamicValue();
            }
        },

        UpdateExpression: function(node, parent, context) {
            var argument = context.getTypeInfo(node.argument),
                result = ANNO(node);
            if(argument.canNumber()) {
                result.copy(argument);
                if(node.prefix && argument.hasStaticValue()) {
                    if(node.operator == "++") {
                        result.setStaticValue(argument.getStaticValue()+1)
                    } else if(node.operator == "--") {
                        result.setStaticValue(argument.getStaticValue()-1)
                    } else {
                        throw new Error("Operator not supported: " + node.operator);
                    }
                }
            } else {
                // e.g. var a = {}; a++;
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.NAN_ERROR));
            }
        },

        AssignmentExpression: function (node, parent, context) {
            var right = context.getTypeInfo(node.right),
                result = ANNO(node);

            result.copy(right);
            result.setDynamicValue();
            result.clearUniformDependencies();

            // Check, if a assigned variable still has the same type as
            // before and update type of uninitialized variables.
            if (node.left.type == Syntax.Identifier && !context.inDeclaration() && right.isValid()) {
                var name = node.left.name;
                var scope = context.getScope();
                scope.updateTypeInfo(name, right, node);
            }
        },


        MemberExpression: function (node, parent, context) {
            var resultType = context.getTypeInfo(node),
                objectAnnotation = context.getTypeInfo(node.object),
                propertyAnnotation = ANNO(node.property),
                scope = context.getScope();

            if(!objectAnnotation.isValid()) {
                resultType.setInvalid();
                return;
            }

            //console.log("Member", node.object.name, node.property.name, node.computed);
            if (node.computed) {
                if (objectAnnotation.isArray()) {
                    // Property is computed, thus it could be a variable
                    var propertyType =  context.getTypeInfo(node.property);
                    if (!propertyType.canNumber()) {
                        Shade.throwError(node, "Expected 'int' or 'number' type for array accessor");
                    }
                    var elementInfo = objectAnnotation.getArrayElementType();
                    resultType.setType(elementInfo.type, elementInfo.kind);
                    return;
                }
                else {
                    resultType.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "no array access to object yet"));
                    return;
                    //Shade.throwError(node, "TypeError: Cannot access member via computed value from object '" + objectAnnotation.getTypeString());
                }
            }
            var propertyName = node.property.name;

            var objectOfInterest = common.getObjectReferenceFromNode(node.object, scope);

            objectOfInterest || Shade.throwError(node,"ReferenceError: " + node.object.name + " is not defined. Context: " + scope.str());

            if (!objectOfInterest.isValid() || objectOfInterest.getType() == TYPES.UNDEFINED) {  // e.g. var a = undefined; a.unknown;
                resultType.setInvalid(generateErrorInformation(node, ERROR_TYPES.TYPE_ERROR, "Cannot read property '" + propertyName + "' of undefined"));
                return;
            }
            if (objectOfInterest.getType() != TYPES.OBJECT) { // e.g. var a = 5; a.unknown;
                resultType.setType(TYPES.UNDEFINED);
                return;
            }

            var objectInfo = scope.getObjectInfoFor(objectOfInterest);
            if(!objectInfo) {
                resultType.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Internal: Incomplete registration for object:", objectOfInterest.getTypeString(), ",", JSON.stringify(node.object)));
                return;
            }

            objectAnnotation.copy(objectOfInterest);
            if (!objectInfo.hasOwnProperty(propertyName)) {
                resultType.setType(TYPES.UNDEFINED);
                propertyAnnotation.setType(TYPES.UNDEFINED);
                return;
            }

            var propertyTypeInfo = objectInfo[propertyName];
            propertyAnnotation.setFromExtra(propertyTypeInfo);
            resultType.copy(propertyAnnotation);
        },

        CallExpression: function (node, parent, context) {
            var result = ANNO(node),
                scope = context.getScope(),
                args = context.getTypeInfo(node.arguments),
                extra, staticValue;

            if (!args.every(function (arg) {return arg.isValid() })) {
                result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Not all arguments types of call expression could be evaluated"));
                return;
            }
            // Be on the safe side, assume result is static independently of former annotations
            result.setDynamicValue();

            // Call on an object, e.g. Math.cos()
            if (node.callee.type == Syntax.MemberExpression) {

                var memberExpression = context.getTypeInfo(node.callee);
                if(!memberExpression.isValid()) {
                    result.setInvalid();
                    return;
                }

                var object = node.callee.object,
                    propertyName = node.callee.property.name;

                var objectReference = context.getTypeInfo(object);
                if(!objectReference)  {
                    Shade.throwError(node, "Internal: No object info for: " + object);
                }
                var objectInfo = scope.getObjectInfoFor(objectReference);
                if(!objectInfo) { // Every object needs an info, otherwise we did something wrong
                    Shade.throwError(node, "Internal Error: No object registered for: " + objectReference.getTypeString() + JSON.stringify(node.object));
                }

                if (!memberExpression.isFunction()) { // e.g. Math.PI()
                    if (objectInfo.hasOwnProperty(propertyName)) {
                      result.setInvalid(generateErrorInformation(node, ERROR_TYPES.TYPE_ERROR, "Property '" + propertyName + "' of object #<"+ objectReference.getTypeString() +"> is not a function"));
                    } else {
                      result.setInvalid(generateErrorInformation(node, ERROR_TYPES.TYPE_ERROR, (object.type == Syntax.ThisExpression ? "'this'" : objectReference.getTypeString())+ " has no method '"+ propertyName + "'"));
                    }
                    return;
                }


                if (!objectInfo.hasOwnProperty(propertyName)) {
                    result.setType(TYPES.UNDEFINED);
                    return;
                }
                var propertyHandler = objectInfo[propertyName];

                if (typeof propertyHandler.evaluate != "function") {
                    Shade.throwError(node, "Internal: no handler registered for '" + propertyName + "'");
                }
                // Evaluate type of call

                try {
                    extra = propertyHandler.evaluate(result, args, scope, objectReference, context);
                    result.setFromExtra(extra);
                } catch (e) {
                    result.setInvalid(generateErrorInformation(node, e.message));
                    return;
                }

                // If we have a type, evaluate static value
                if (typeof propertyHandler.computeStaticValue != "function") {
                    debug && console.warn("No static evaluation exists for function", codegen.generate(node));
                    return;
                }
                staticValue = propertyHandler.computeStaticValue(result, args, scope, objectReference, context);
                if (staticValue !== undefined) {
                    result.setStaticValue(staticValue);
                }
                return;

            }  else if (node.callee.type == Syntax.Identifier) {
                var functionName = node.callee.name;
                var func = scope.getBindingByName(functionName);
                if (!func) {
                    result.setInvalid(generateErrorInformation(node, ERROR_TYPES.REFERENCE_ERROR, functionName,  "is not defined"));
                    return;
                }
                if(!func.isFunction()) {
                    result.setInvalid(generateErrorInformation(node, ERROR_TYPES.TYPE_ERROR, func.getTypeString(), "is not a function"));
                    return;
                }
                try {
                    extra = context.callFunction(scope.getVariableIdentifier(functionName), args);
                    extra && result.setFromExtra(extra);
                } catch(e) {
                    result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Failure in function call: ", e.message));
                }
                return;
            }
            result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Internal:", "Unhandled CallExpression", node.callee.type));
        },

        VariableDeclarator: function (node, parent, context) {
            var init = node.init ? context.getTypeInfo(node.init) : null,
                result = ANNO(node);
            if(init) {
                ANNO(node.init).copy(init);
                result.copy(init);
            }
        },

        VariableDeclaration: function (node, parent, context) {
            context.setInDeclaration(false);
        },

        LogicalExpression: function (node, parent, context) {
            var left = context.getTypeInfo(node.left),
                right = context.getTypeInfo(node.right),
                result = ANNO(node);


            // static: true || false, dynamic: undefined
            var leftBool = left.getStaticTruthValue(),
                rightBool = right.getStaticTruthValue(),
                operator = node.operator;

            if (operator === "||") {
                if (leftBool === false) {
                    result.copy(right);
                    return;
                }
                if (leftBool === true) {
                    result.copy(left);
                    return;
                }
                // Left is dynamic, let's check right
                if (rightBool === false) {
                    // Now the result type is always the one of the left value
                    result.copy(left);
                    return;
                }
            } else if (operator === "&&") {
                if (leftBool === false) {
                    // T(x) == false => x && y == x
                    result.copy(left);
                    return;
                }
                if (leftBool === true) {
                    result.copy(right);
                    return;
                }
                // Left is dynamic, let's check right
                if (rightBool === true) {
                    // Now the result type is always the one of the left value
                    result.copy(left);
                    return;
                }
                if (rightBool === false) {
                    // Now the result must be false
                    result.setType(TYPES.BOOLEAN);
                    result.setStaticValue(false);
                    return;
                }
            }

            // If we can cast both sides to a common type, it's fine
            if(result.setCommonType(left, right)) {
                return;
            }
            result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Can't evaluate polymorphic logical expression"));
        },

        ConditionalExpression: function (node, parent, context) {
            var consequent = context.getTypeInfo(node.consequent),
                alternate = context.getTypeInfo(node.alternate),
                test = context.getTypeInfo(node.test),
                result = ANNO(node);

            var testResult = test.getStaticTruthValue();
            if(testResult === true) {
                result.copy(consequent);
            } else if (testResult === false) {
                result.copy(alternate);
            } else {
                if (result.setCommonType(consequent, alternate)) {
                    result.setDynamicValue();
                } else {
                    result.setInvalid(generateErrorInformation(node, ERROR_TYPES.SHADEJS_ERROR, "Can't evaluate polymorphic conditional expression"))
                }
            }

        }

    };

    ns.annotateRight  = function(context, ast, propagatedConstants) {

        if(!ast)
            throw Error("No node to analyze");

        var controller = new estraverse.Controller();

        context.setConstants(propagatedConstants || null);

        controller.traverse(ast, {
            enter: function(node) {
                if(node.type == Syntax.VariableDeclaration) {
                    context.setInDeclaration(true);
                }
            },
            leave: function(node, parent) {
                if (handlers.hasOwnProperty(node.type)) {
                    return handlers[node.type].call(this, node, parent, context);
                }
                return null;
            }
        });

        context.setConstants(null);

    }
}(exports));

},{"../../base/common.js":87,"../../base/errors.js":89,"../../interfaces.js":123,"../constants/evaluator.js":57,"escodegen":9,"estraverse":46}],66:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        Tools = require("./tools.js");

    var ColorClosureInstance = {
        mul: {
            type: TYPES.FUNCTION,
            evaluate: function() {
                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        },
        add: {
            type: TYPES.FUNCTION,
            evaluate: function() {
                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        }
    };

    Tools.extend(ns, {
        id: "ColorClosure",
        kind: KINDS.COLOR_CLOSURE,
        object: {
            constructor: null,
            static: null
        },
        instance: ColorClosureInstance
    });


}(exports));

},{"../../../interfaces.js":123,"./tools.js":75}],67:[function(require,module,exports){
(function (ns) {

    var Scope = require("../../../base/scope.js"),
        Base = require("../../../base/index.js");


    var objects = {
        Shade : require("./shade.js"),
        Space : require("./space.js"),
        Math : require("./math.js"),
        Vec2 : require("./vec2.js"),
        Vec3 : require("./vec3.js"),
        Color: require("./vec3.js"),
        Vec4 : require("./vec4.js"),
        Mat3 : require("./mat3.js"),
        Mat4 : require("./mat4.js"),
        Texture : require("./texture.js"),
        ColorClosure: require("./colorclosure.js")
    };

    var Registry = {
        name: "TypeInference",
        getByName: function(name) {
            var result = objects[name];
            return result || null;
        },
        getInstanceForKind: function(kind) {
            for(var obj in objects) {
                if (objects[obj].kind == kind) {
                    return objects[obj].instance;
                }
            }
            return null;
        }
    };


    /**
     * @constructor
     * @extends {Scope}
     */
    var InferenceScope = function(node, parentScope, opt) {
        opt = opt || {};
        Base.extend(opt, { registry: Registry });
        Scope.call(this, node, parentScope, opt);
    }

    Base.createClass(InferenceScope, Scope, {

        registerGlobals: function() {
            this.registerObject("Math", objects.Math);
            this.registerObject("Color",  objects.Color);
            this.registerObject("Vec2", objects.Vec2);
            this.registerObject("Vec3", objects.Vec3);
            this.registerObject("Vec4", objects.Vec4);
            this.registerObject("Texture", objects.Texture);
            this.registerObject("Shade", objects.Shade);
            this.registerObject("Space", objects.Space);
            this.registerObject("Mat3", objects.Mat3);
            this.registerObject("Mat4", objects.Mat4);
            this.declareVariable("_env");
        }

    });

    exports.InferenceScope = InferenceScope;

}(exports));

},{"../../../base/index.js":90,"../../../base/scope.js":91,"./colorclosure.js":66,"./mat3.js":68,"./mat4.js":69,"./math.js":70,"./shade.js":71,"./space.js":72,"./texture.js":74,"./vec2.js":76,"./vec3.js":77,"./vec4.js":78}],68:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        Tools = require("./tools.js");

    var Matrix3Constructor =  {
        type: TYPES.OBJECT,
        kind: KINDS.MATRIX3,
        /**
         * @param {Annotation} result
         * @param {Array.<Annotation>} args
         * @param {Context} ctx
         */
        evaluate: Tools.Mat.matConstructorEvaluate.bind(null, "Mat3")
    };

    var Matrix3StaticObject = {
    };

    var Matrix3Instance = {
        col: {
            type: TYPES.FUNCTION,
            evaluate: Tools.Mat.colEvaluate.bind(null, "Mat3")
        }
    };
    Tools.Mat.attachMatMethods(Matrix3Instance, "Mat3", ['add', 'sub', 'mul', 'div']);
    Tools.Vec.attachVecMethods(Matrix3Instance, "Mat3", 3, 3, ['mulVec']);


    Tools.extend(ns, {
        id: "Mat3",
        kind: KINDS.MATRIX3,
        object: {
            constructor: Matrix3Constructor,
            static: Matrix3StaticObject
        },
        instance: Matrix3Instance
    });


}(exports));

},{"../../../interfaces.js":123,"./tools.js":75}],69:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        Tools = require("./tools.js");

    var Matrix4Constructor =  {
        type: TYPES.OBJECT,
        kind: KINDS.MATRIX4,
        /**
         * @param {Annotation} result
         * @param {Array.<Annotation>} args
         * @param {Context} ctx
         */
        evaluate: Tools.Mat.matConstructorEvaluate.bind(null, "Mat4")
    };

    var Matrix4StaticObject = {
    };

    var Matrix4Instance = {
        col: {
            type: TYPES.FUNCTION,
            evaluate: Tools.Mat.colEvaluate.bind(null, "Mat4")
        }
    };
    Tools.Mat.attachMatMethods(Matrix4Instance, "Mat4", ['add', 'sub', 'mul', 'div']);
    Tools.Vec.attachVecMethods(Matrix4Instance, "Mat4", 4, 4, ['mulVec']);


    Tools.extend(ns, {
        id: "Mat4",
        kind: KINDS.MATRIX4,
        object: {
            constructor: Matrix4Constructor,
            static: Matrix4StaticObject
        },
        instance: Matrix4Instance
    });


}(exports));

},{"../../../interfaces.js":123,"./tools.js":75}],70:[function(require,module,exports){
(function (ns) {

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        Base = require("../../../base/index.js"),
        Tools = require("./tools.js");


    var notStatic = function() {};

    var evaluateStatic = function(name) {
        return function (result, args) {
            if (Tools.allArgumentsAreStatic(args)) {
                var callArgs = args.map(function (a) {
                    return a.getStaticValue();
                });
                return Math[name].apply(null, callArgs);
            }
        }
    }

    var evaluateMethod = function (name, paramCount, returnType) {
        /**
         * @param {Annotation} result
         * @param {Array.<Annotation>} args
         * @param {Context} ctx
         */
        return function (result, args, ctx) {
            if (paramCount != -1) { // Arbitrary number of arguments
                if (!args || args.length != paramCount) {
                    throw new Error("Invalid number of parameters for Math." + name + ", expected " + paramCount);
                }
            }

            args.forEach(function (param, index) {
                if (!(param.canNumber() || param.isVector()))
                    throw new Error("Parameter " + index + " has invalid type for Math." + name + ", expected 'number', but got " + param.getType());
            });
            var typeInfo = {
                type: returnType || args[0].isVector() ? TYPES.OBJECT : TYPES.NUMBER
            }
            args[0].isVector() && (typeInfo.kind = args[0].getKind());

            return typeInfo;
        }
    }

    var MathObject = {
        random: {
            type: TYPES.FUNCTION,
            evaluate: function (node, args) {
                if (args.length)
                    throw new Error("Math.random has no parameters.");
                return {
                    type: TYPES.NUMBER
                }
            },
            computeStaticValue: notStatic
        },
        abs: {
            type: TYPES.FUNCTION,
            evaluate: function (result, args) {
                Tools.checkParamCount(result.node, "Math.abs", [1], args.length);
                var typeInfo = {};
                if(args[0].canNumber()) {
                    typeInfo.type = args[0].getType();
                }
                else if (args[0].isVector()) {
                    typeInfo.type = args[0].getType();
                    typeInfo.kind = args[0].getKind();
                }
                else {
                    Shade.throwError(result.node, "InvalidType for Math.abs");
                }
                // TODO: Static value
                return typeInfo;
            },
            computeStaticValue: evaluateStatic("abs")
        },


        // Non-standard methods
        clamp: {
            type: TYPES.FUNCTION,
            evaluate: function (result, args) {
                Tools.checkParamCount(result.node, "Math.clamp", [3], args.length);

                if(args[1].canNumber() && args[2].canNumber()){
                    var typeInfo = {};
                    if(args[0].canNumber()) {
                        typeInfo.type = TYPES.NUMBER;
                    }
                    else if (args[0].isVector()) {
                        typeInfo.type = args[0].getType();
                        typeInfo.kind = args[0].getKind();
                    }
                    return typeInfo;
                }
                Shade.throwError(result.node, "Math.clamp not supported with argument types: " + args.map(function (arg) {
                    return arg.getTypeString();
                }).join(", "));
            },
            computeStaticValue: evaluateStatic("clamp")

        },
        smoothstep: {
            type: TYPES.FUNCTION,
            evaluate: function (result, args, ctx) {
                Tools.checkParamCount(result.node, "Math.smoothstep", [3], args.length);

                if (args.every(function (e) { return e.canNumber(); })) {
                    return { type: TYPES.NUMBER };
                }
                if (args.every(function (e) {
                    return e.isVector();
                })) {
                    if (!(args[0].equals(args[1]) && args[1].equals(args[2]))) {
                        Shade.throwError(result.node, "Math.smoothstep: All arguments have to have the same type: " + args.map(function (arg) {
                            return arg.getTypeString();
                        }).join(", "));
                    };
                    return  {
                        type: TYPES.OBJECT,
                        kind: args[0].getKind()
                    }

                };
                Shade.throwError(result.node, "Math.smoothstep not supported with argument types: " + args.map(function (arg) {
                    return arg.getTypeString();
                }).join(", "));
            },
            computeStaticValue: evaluateStatic("smoothstep")
        },
        step: {
            type: TYPES.FUNCTION,
            evaluate: function (result, args, ctx) {
                Tools.checkParamCount(result.node, "Shade.step", [2], args.length);

                if (Tools.allArgumentsCanNumber(args)) {
                    return { type: TYPES.NUMBER }
                }
                Shade.throwError(result.node, "Shade.step not supported with argument types: " + args.map(function (arg) {
                    return arg.getTypeString();
                }).join(", "));
            },
            computeStaticValue: evaluateStatic("step")
        },
        fract: {
            type: TYPES.FUNCTION,
            evaluate: Tools.Vec.anyVecArgumentEvaluate.bind(null, "fract"),
            computeStaticValue: evaluateStatic("fract")
        },
        mix: {
            type: TYPES.FUNCTION,
            evaluate: function (result, args, ctx) {
                Tools.checkParamCount(result.node, "Math.mix", [3], args.length);

                var cnt = Tools.Vec.checkAnyVecArgument(result.node, "Math.mix", args[0]);

                var typeInfo = {};
                Base.extend(typeInfo, Tools.Vec.getType(cnt));

                if (!args[1].equals(args[0]))
                    Shade.throwError(result.node, "Math.mix types of first two arguments do no match: got " + args[0].getTypeString() +
                        " and " + args[1].getTypeString());
                if (!args[2].canNumber())
                    Shade.throwError(result.node, "Math.mix third argument is not a number.");

                return typeInfo;
            },
            computeStaticValue: evaluateStatic("mix")
        },
        saturate: {
            type: TYPES.FUNCTION,
            evaluate: function (result, args, ctx) {
                Tools.checkParamCount(result.node, "Shade.saturate", [1], args.length);

                var typeInfo = {
                    type: TYPES.NUMBER
                }
                var arg = args[0];
                if (!arg.canNumber()) {
                    Shade.throwError(result.node, "Math.saturate not supported with argument type: " + arg.getTypeString());
                }
                return typeInfo;
            },
            computeStaticValue: evaluateStatic("saturate")
        }
    };

    var MathConstants = ["E", "PI", "LN2", "LOG2E", "LOG10E", "PI", "SQRT1_2", "SQRT2"];
    var OneParameterNumberMethods = ["acos", "asin", "atan", "cos", "exp", "log", "round", "sin", "sqrt", "tan", "ceil", "floor"];
    var OneParameterIntMethods = [];
    var TwoParameterNumberMethods = ["atan2", "pow"];
    var ArbitraryParameterNumberMethods = ["max", "min"];

    MathConstants.forEach(function (constant) {
        MathObject[constant] = { type: TYPES.NUMBER, staticValue: Math[constant] };
    });

    OneParameterNumberMethods.forEach(function (method) {
        MathObject[method] = { type: TYPES.FUNCTION, evaluate: evaluateMethod(method, 1), computeStaticValue: evaluateStatic(method) };
    });

    TwoParameterNumberMethods.forEach(function (method) {
        MathObject[method] = { type: TYPES.FUNCTION, evaluate: evaluateMethod(method, 2), computeStaticValue: evaluateStatic(method)  };
    });

    OneParameterIntMethods.forEach(function (method) {
        MathObject[method] = { type: TYPES.FUNCTION, evaluate: evaluateMethod(method, 1, TYPES.INT), computeStaticValue: evaluateStatic(method)  };
    });

    ArbitraryParameterNumberMethods.forEach(function (method) {
        MathObject[method] = { type: TYPES.FUNCTION, evaluate: evaluateMethod(method, -1), computeStaticValue: evaluateStatic(method)  };
    });

    Base.extend(ns, {
        id: "Math",
        object: {
            constructor: null,
            static: MathObject,
            staticValue: Math
        },
        instance: MathObject
    });


}(exports));

},{"../../../base/index.js":90,"../../../interfaces.js":123,"./tools.js":75}],71:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        Base = require("../../../base/index.js"),
        Tools = require("./tools.js");

    var ShadeConstructor =  {
        type: TYPES.OBJECT,
        kind: KINDS.COLOR_CLOSURE,
        /**
         * @param {Annotation} result
         * @param {Array.<Annotation>} args
         * @param {Context} ctx
         */
        evaluate: function(result, args, context, objectReference, root) {
            if (args.length > 0)
                throw new Error("Shade.emission expects no parameters.");
            return {
                type: TYPES.OBJECT,
                kind: KINDS.COLOR_CLOSURE
            };
        }
    };

    var checkArgumentIsColor = function(node, args, position, name) {
        if(!args[position] || !args[position].canColor())
            Shade.throwError(node, "Argument "+ position + " of Shade." + name + " must evaluate to a color, found " + (args[position] ? args[position].getTypeString() : "undefined"));
    };

    var checkArgumentIsNormal = function(node, args, position, name) {
        if(!args[position] || !args[position].canNormal())
            Shade.throwError(node, "Argument "+ position + " of Shade." + name + " must evaluate to a normal, found " + (args[position] ? args[position].getTypeString() : "undefined"));
    };

    var ShadeObject = {
        emission: {
            type: TYPES.FUNCTION,
            evaluate: function(result, args, context, objectReference, root) {
                if (args.length > 0)
                    throw new Error("Shade.emission expects no parameters.");
                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        },
        diffuse: {
            type: TYPES.FUNCTION,
            name: "diffuse",
            evaluate: function(result, args, context, objectReference, root) {
                checkArgumentIsColor(result.node, args, 0, this.name);
                checkArgumentIsNormal(result.node, args, 1, this.name);

                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        },
        phong: {
            type: TYPES.FUNCTION,
            name: "phong",
            evaluate: function(result, args, ctx) {
                // TODO: Check arguments based on interface description
                checkArgumentIsColor(result.node, args, 0, this.name);
                checkArgumentIsNormal(result.node, args, 1, this.name);

                if (args.length > 2) {
                    var shininess = args[2];
                    if(!shininess.canNumber()) {
                        throw new Error("Third argument (shininess) of Shade.phong must evaluate to a number. Found: " + shininess.str());
                    }
                }

                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        },
        cookTorrance: {
            type: TYPES.FUNCTION,
            name: "cookTorrance",
            evaluate: function(result, args, ctx) {
                // TODO: Check arguments based on interface description
                checkArgumentIsColor(result.node, args, 0, this.name);
                checkArgumentIsNormal(result.node, args, 1, this.name);

                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        },
        ward: {
            type: TYPES.FUNCTION,
            name: "ward",
            evaluate: function(result, args, ctx) {
                // TODO: Check arguments based on interface description
                checkArgumentIsColor(result.node, args, 0, this.name);
                checkArgumentIsNormal(result.node, args, 1, this.name);
                checkArgumentIsNormal(result.node, args, 2, this.name);

                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        },
        reflect: {
            type: TYPES.FUNCTION,
            name: "reflect",
            evaluate: function(result, args, ctx) {
                // TODO: Check arguments based on interface description
                checkArgumentIsNormal(result.node, args, 0, this.name);

                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        },
        refract: {
            type: TYPES.FUNCTION,
            name: "refract",
            evaluate: function(result, args, ctx) {
                // TODO: Check arguments based on interface description
                checkArgumentIsNormal(result.node, args, 0, this.name);

                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        },
        scatter: {
            type: TYPES.FUNCTION,
            name: "scatter",
            evaluate: function(result, args, ctx) {
                // TODO: Check arguments based on interface description
                checkArgumentIsColor(result.node, args, 0, this.name);
                checkArgumentIsNormal(result.node, args, 1, this.name);

                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.COLOR_CLOSURE
                };
            }
        }

    };

    Base.extend(ns, {
        id: "Shade",
        kind: KINDS.COLOR_CLOSURE,
        object: {
            constructor: ShadeConstructor,
            static: null
        },
        instance: ShadeObject

    });

}(exports));

},{"../../../base/index.js":90,"../../../interfaces.js":123,"./tools.js":75}],72:[function(require,module,exports){
(function (ns) {

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;
        Base = require("../../../base/index.js"),
        Tools = require("./tools.js");


    var SpaceObject = {
        transformDirection: {
            type: TYPES.FUNCTION,
            evaluate: function (result, args, context, objectReference, root) {
                if (args.length != 2)
                    throw new Error("transformDirection expects 2 parameters.");
                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.FLOAT3
                };
            }
        },
        transformPoint: {
            type: TYPES.FUNCTION,
            evaluate: function (result, args, context, objectReference, root) {
                if (args.length != 2)
                    throw new Error("transformPoint expects 2 parameters.");
                return {
                    type: TYPES.OBJECT,
                    kind: KINDS.FLOAT3
                };
            }
        },
        VIEW: { type: TYPES.NUMBER},
        WORLD: { type: TYPES.NUMBER}
    };

    Base.extend(ns, {
        id: "Space",
        object: {
            constructor: null,
            static: SpaceObject,
            staticValue: Math
        },
        instance: SpaceObject
    });


}(exports));

},{"../../../base/index.js":90,"../../../interfaces.js":123,"./tools.js":75}],73:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js"),
        Base = require("../../../base/index.js"),
        Annotations = require("../../../base/annotation.js"),
        Tools = require("./tools.js");

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        ANNO = Annotations.ANNO;


    /**
     * Derived parameters: These exist in the system for convenience,
     * but can be derived from other system parameters
     */
    var DerivedCanvasProperties = {
        normalizedCoords: {
            type: TYPES.OBJECT,
            kind: KINDS.FLOAT3,
            derived: true
        },
        height: {
            type: TYPES.INT,
            derived: true
        },
        width: {
            type: TYPES.INT,
            derived: true
        }

    };

    function allowNumberOrVector(name) {
        return function(result, args) {
           Tools.checkParamCount(result.node, name, [1], args.length);
                var arg = args[0];
                if (arg.canNumber()) {
                    return {
                        type: arg.getType()
                    }
                }
                if (arg.isVector()) {
                    return {
                        type: TYPES.OBJECT,
                        kind: arg.getKind()
                    }
                }
                Shade.throwError(result.node, "IllegalArgumentError: first argument of this." + name + " is of type: " + arg.getTypeString());
        }
    }


    var OptionalMethods = {
        fwidth: {
            type: TYPES.FUNCTION,
            evaluate: allowNumberOrVector("fwidth")
        },
        dx: {
            type: TYPES.FUNCTION,
            evaluate: allowNumberOrVector("dx")
        },
        dy: {
            type: TYPES.FUNCTION,
            evaluate: allowNumberOrVector("dy")
        }
    };

    ns.getThisTypeInfo = function(systemInfo) {
        systemInfo = systemInfo || { type: TYPES.OBJECT, kind: KINDS.ANY, info: {}};
        var thisAnnotation = ANNO({}, systemInfo);
        // Add those parameters that can be calculated from system inputs
        var objectInfo = thisAnnotation.getNodeInfo();
        if (!objectInfo) {
            objectInfo = {};
            thisAnnotation.setNodeInfo(objectInfo);
        }

        if(objectInfo.hasOwnProperty("coords")) {
            Base.extend(objectInfo, DerivedCanvasProperties);
        }
        for(var entry in OptionalMethods) {
            if(objectInfo.hasOwnProperty(entry)) {
                Base.extend(objectInfo[entry], OptionalMethods[entry])
            }
        }

        return thisAnnotation;
    }



}(exports));

},{"../../../base/annotation.js":85,"../../../base/index.js":90,"../../../interfaces.js":123,"./tools.js":75}],74:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        Tools = require("./tools.js");

    var TextureConstructor =  {
        type: TYPES.OBJECT,
        kind: KINDS.TEXTURE,
        /**
         * @param {Annotation} result
         * @param {Array.<Annotation>} args
         * @param {Context} ctx
         */
        evaluate: function(result, args, ctx) {
            Shade.throwError(result.node, "Construction of Textures is not supported." );
        }
    };

    var TextureStaticObject = {
    };

    var TextureInstance = {
        width: {
            type: TYPES.INT
        },
        height: {
            type: TYPES.INT
        }
    };

    Tools.Vec.attachVecMethods(TextureInstance, "Texture", 4, 2, ['sample2D']);

    Tools.extend(ns, {
        id: "Texture",
        kind: KINDS.TEXTURE,
        object: {
            constructor: TextureConstructor,
            static: TextureStaticObject
        },
        instance: TextureInstance
    });


}(exports));

},{"../../../interfaces.js":123,"./tools.js":75}],75:[function(require,module,exports){
(function(ns){
    var Base = require("../../../base/index.js");
    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        VecBase = require("../../../base/vec.js");

    var allArgumentsAreStatic = function (args) {
        return args.every(function (arg) {
            return arg.hasStaticValue()
        });
    }

    ns.allArgumentsCanNumber = function(args) {
        return args.every(function (arg) {
            return arg.canNumber();
        });
    }

    ns.checkParamCount = function(node, name, allowed, is) {
        if (allowed.indexOf(is) == -1) {
            Shade.throwError(node, "Invalid number of parameters for " + name + ", expected " + allowed.join(" or ") + ", found: " + is);
        }
    }

    ns.singleAccessor = function (name, obj, validArgCounts, staticValueFunction) {
        return {
            type: TYPES.FUNCTION,
            evaluate: function (result, args, ctx, callObject) {
                ns.checkParamCount(result.node, name, validArgCounts, args.length);
                var typeInfo =  args.length ? obj : { type: TYPES.NUMBER };

                if (staticValueFunction && callObject.hasStaticValue() && args.every(function(a) {return a.hasStaticValue(); })) {
                    typeInfo.staticValue = staticValueFunction(callObject.getStaticValue(), args);
                }
                return typeInfo;
            }
        }
    };

    ns.extend = Base.extend;

    var Vec = {
        TYPES: {
            1: { type: TYPES.NUMBER },
            2: { type: TYPES.OBJECT, kind: KINDS.FLOAT2 },
            3: { type: TYPES.OBJECT, kind: KINDS.FLOAT3 },
            4: { type: TYPES.OBJECT, kind: KINDS.FLOAT4 }
        },
        getType: function(destVector){
            return Vec.TYPES[destVector];
        },
        getStaticValue: function(methodName, result, args, ctx, callObject){
            if(callObject.hasStaticValue() && allArgumentsAreStatic(args)){
                var object = callObject.getStaticValue();
                var callArgs = args.map(function(a) {return a.getStaticValue(); });
                var method = object[methodName];
                if(method)
                    return method.apply(object, callArgs);
            }
        },
        checkAnyVecArgument: function(astNode, methodName, arg){
            var cnt;

            if(arg.canNumber()) cnt = 1;
            else if(arg.isOfKind(KINDS.FLOAT2)) cnt = 2;
            else if(arg.isOfKind(KINDS.FLOAT3)) cnt = 3;
            else if(arg.isOfKind(KINDS.FLOAT4)) cnt = 4;
            else Shade.throwError(astNode, "Invalid parameter for " + methodName + ", type '" +
                    arg.getTypeString() + "' is not supported");
            return cnt;
        },
        checkVecArguments: function(methodName, vecSize, withEmpty, argStart, result, args){
            withEmpty = (withEmpty || vecSize == 0);
            var allowed = [];
            for(var i = withEmpty ? 0 : 1; i <= vecSize; ++i) allowed.push(i + argStart);
            ns.checkParamCount(result.node, methodName, allowed, args.length);

            if(withEmpty && args.length - argStart == 0)
                return;

            if(args.length - argStart== 1 && args[0].canNumber())
                return;

            var idx = 0;
            for(var i = argStart; idx < vecSize && i < args.length; ++i){
                var arg= args[i], cnt;
                if(arg.canNumber()) cnt = 1;
                else if(arg.isOfKind(KINDS.FLOAT2)) cnt = 2;
                else if(arg.isOfKind(KINDS.FLOAT3)) cnt = 3;
                else if(arg.isOfKind(KINDS.FLOAT4)) cnt = 4;
                else if(arg.isOfKind(KINDS.MATRIX3)) cnt = 9;
                else if(arg.isOfKind(KINDS.MATRIX4)) cnt = 16;
                else Shade.throwError(result.node, "Invalid parameter for " + methodName + ", type '" + arg.getTypeString() + "' is not supported");
                idx += cnt;
            }

            if(idx < vecSize)
                Shade.throwError(result.node, "Invalid parameters for " + methodName + ", expected " + vecSize + " scalar values, got " + idx);
            else if(i < args.length){
                Shade.throwError(result.node, "Invalid parameters for " + methodName + ", too many parameters");
            }
        },

        vecEvaluate: function(objectName, methodName, destVecSize, srcVecSize, result, args, ctx, callObject){
            Vec.checkVecArguments(objectName + "." + methodName, srcVecSize, false, 0, result, args);

            var typeInfo = {};
            Base.extend(typeInfo, Vec.getType(destVecSize));

            return typeInfo;
        },
        anyVecArgumentEvaluate: function(methodName, result, args, ctx, callObject){
            ns.checkParamCount(result.node, methodName, [1], args.length);
            var arg = args[0];

            var typeInfo = {};
            var cnt = Vec.checkAnyVecArgument(result.node, methodName, arg);
            Base.extend(typeInfo, Vec.getType(cnt));

            return typeInfo;
        },

        optionalZeroEvaluate: function(objectName, methodName, destVecSize, zeroDestVecSize, srcVecSize, result, args, ctx, callObject) {
            var qualifiedName = objectName + "." + methodName;
            var typeInfo = {};

            if(args.length == 0){
                Base.extend(typeInfo, Vec.getType(zeroDestVecSize));
            }
            else{
                Vec.checkVecArguments(qualifiedName, srcVecSize, true, 0, result, args);
                Base.extend(typeInfo, Vec.getType(destVecSize));
            }

            return typeInfo;
        },

        swizzleEvaluate: function(objectName, vecSize, swizzle, withSetter, result, args, ctx, callObject) {
            if(withSetter){
                return Vec.optionalZeroEvaluate(objectName, swizzle, vecSize, swizzle.length, swizzle.length,
                    result, args, ctx, callObject);
            }
            else{
                return Vec.vecEvaluate(objectName, swizzle, swizzle.length, 0, result, args, ctx, callObject);
            }
        },
        swizzleOperatorEvaluate: function(objectName, vecSize, swizzle, operator, result, args, ctx, callObject) {
            return Vec.vecEvaluate(objectName, swizzle + operator, vecSize, swizzle.length, result, args, ctx, callObject);
        },
        getSwizzleEvaluate: function(objectName, vecSize, swizzle, withSetter){
            return  {
                type: TYPES.FUNCTION,
                evaluate: Vec.swizzleEvaluate.bind(null, objectName, vecSize, swizzle, withSetter),
                computeStaticValue: Vec.getStaticValue.bind(null, swizzle)
            }
        },
        getSwizzleOperatorEvaluate: function(objectName, vecSize, swizzle, operator){
            return  {
                type: TYPES.FUNCTION,
                evaluate: Vec.swizzleOperatorEvaluate.bind(null, objectName, vecSize, swizzle, operator),
                computeStaticValue: Vec.getStaticValue.bind(null, swizzle + operator)
            }
        },
        attachSwizzles: function (instance, objectName, vecCount){
            for(var s = 0; s < VecBase.swizzleSets.length; ++s){
                for(var count = 1; count <= 4; ++count){
                    var max = Math.pow(vecCount, count);
                     for(var i = 0; i < max; ++i){
                        var val = i;
                        var key = "";

                        var indices = [], withSetter = (count <= vecCount);
                        for(var  j = 0; j < count; ++j){
                            var idx = val % vecCount;
                            val = Math.floor(val / vecCount);
                            key+= VecBase.swizzleSets[s][idx];
                            if(indices[idx])
                                withSetter = false;
                            else
                                indices[idx] = true;
                        }
                        instance[key] = Vec.getSwizzleEvaluate(objectName, vecCount, key, withSetter);
                        if(withSetter){
                            for(var operator in VecBase.swizzleOperators){
                                instance[key + operator] = Vec.getSwizzleOperatorEvaluate(objectName, vecCount, key, operator);
                            }
                        }
                    }
                }
            }
        },
        attachVecMethods: function(instance, objectName, destVecSize, srcVecSize, methodNames){
            for(var i = 0; i < methodNames.length; ++i){
                    var methodName = methodNames[i];
                    instance[methodName] = {
                        type: TYPES.FUNCTION,
                        evaluate: Vec.vecEvaluate.bind(null, objectName, methodName, destVecSize, srcVecSize)
                    }
            }
        },

        getStaticValueFromConstructor: function(objectName, args){
            var argArray = [];
            var isStatic = true;
            args.forEach(function (param) {
                isStatic = isStatic && param.hasStaticValue();
                if (isStatic)
                    argArray.push(param.getStaticValue());
            });

            if (isStatic) {
                var v = new Shade[objectName]();
                Shade[objectName].apply(v, argArray);
                return v;
            }
            return undefined;
        },

        constructorEvaluate: function(objectName, vecSize, result, args, ctx) {
            Vec.checkVecArguments(objectName, vecSize, true, 0, result, args);
            return Vec.getType(vecSize);
        },
        constructorComputeStaticValue: function(objectName, result, args, ctx) {
            return Vec.getStaticValueFromConstructor(objectName, args);
        }

    };

    var Mat = {
        TYPES: {
            "Mat3": { type: { type: TYPES.OBJECT, kind: KINDS.MATRIX3 }, cols: 3, rows: 3 },
            "Mat4": { type: { type: TYPES.OBJECT, kind: KINDS.MATRIX4 }, cols: 4, rows: 4 }
        },
        getType: function(matName){
            return Mat.TYPES[matName].type;
        },
        getVecSize: function(matName){
            return Mat.TYPES[matName].cols * Mat.TYPES[matName].rows;
        },
        checkMatArguments: function(methodName, matName, withEmpty, result, args){
            if(args.length == 1 && (args[0].isOfKind(KINDS.MATRIX3) || args[0].isOfKind(KINDS.MATRIX4)))
                return;

            for(var i = 0; i < args.length; ++i){
                if(args[i].isOfKind(KINDS.MATRIX3) || args[i].isOfKind(KINDS.MATRIX4))
                    Shade.throwError(result.node, "Invalid parameter for " + methodName + ": Constructing Matrix from Matrix can only take one argument");
            }
            Vec.checkVecArguments(methodName, Mat.getVecSize(matName), withEmpty, 0, result, args);
        },

        matEvaluate: function(matName, methodName, result, args, ctx, callObject){
            Mat.checkMatArguments(matName + "." + methodName, matName, false, result, args);

            var typeInfo = {};
            Base.extend(typeInfo, Mat.getType(matName));

            return typeInfo;
        },

        matConstructorEvaluate: function(matName, result, args, ctx){
            Mat.checkMatArguments(matName, matName, true, result, args);
            return Vec.getConstructorTypeInfo(matName, Mat.getVecSize(matName), Mat.getType(matName), result, args);
        },

        attachMatMethods: function(instance, matName, methodNames){
            for(var i = 0; i < methodNames.length; ++i){
                var methodName = methodNames[i];
                instance[methodName] = {
                    type: TYPES.FUNCTION,
                    evaluate: Mat.matEvaluate.bind(null, matName, methodName)
                }
            }
        },
        colEvaluate: function(matName, result, args, ctx, callObject) {
            var qualifiedName = matName + ".col";
            var typeInfo = {};

            var cols = Mat.TYPES[matName].cols, rows = Mat.TYPES[matName].rows;

            if(args.length > 1){
                Vec.checkVecArguments(qualifiedName, rows, true, 1, result, args);
                Base.extend(typeInfo, Mat.getType(matName));
            }
            else{
                ns.checkParamCount(result.node, qualifiedName, [1], args.length);
                Base.extend(typeInfo, Vec.getType(rows));
            }
            if(!args[0].canNumber()){
                Shade.throwError(result.node, "Invalid parameter for " + qualifiedName + ", first parameter must be a number.");
            }

            // TODO: Vec.getStaticValue(typeInfo, "col", args, callObject);

            return typeInfo;
        }

    }

    ns.Vec = Vec;
    ns.Mat = Mat;
    ns.allArgumentsAreStatic = allArgumentsAreStatic;


}(exports));

},{"../../../base/index.js":90,"../../../base/vec.js":93,"../../../interfaces.js":123}],76:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        Tools = require("./tools.js");

    var Vector2Constructor =  {
        type: TYPES.OBJECT,
        kind: KINDS.FLOAT2,
        /**
         * @param {Annotation} result
         * @param {Array.<Annotation>} args
         * @param {Context} ctx
         */
        evaluate: Tools.Vec.constructorEvaluate.bind(null, "Vec2", 2),
        computeStaticValue: Tools.Vec.constructorComputeStaticValue.bind(null, "Vec2")
    };

    var Vector2StaticObject = {
    };

    var Vector2Instance = {
        length: {
            type: TYPES.FUNCTION,
            evaluate: Tools.Vec.optionalZeroEvaluate.bind(null,"Vec2", "length", 2, 1, 1)
        }
    };
    Tools.Vec.attachSwizzles(Vector2Instance, "Vec2", 2);
    Tools.Vec.attachVecMethods(Vector2Instance, "Vec2", 2, 2, ['add', 'sub', 'mul', 'div', 'mod', 'reflect']);
    Tools.Vec.attachVecMethods(Vector2Instance, "Vec2", 1, 2, ['dot']);
    Tools.Vec.attachVecMethods(Vector2Instance, "Vec2", 2, 0, ['normalize', 'flip']);


    Tools.extend(ns, {
        id: "Vec2",
        kind: KINDS.FLOAT2,
        object: {
            constructor: Vector2Constructor,
            static: Vector2StaticObject
        },
        instance: Vector2Instance
    });


}(exports));

},{"../../../interfaces.js":123,"./tools.js":75}],77:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        Tools = require("./tools.js");

    var Vector3Constructor =  {
        type: TYPES.OBJECT,
        kind: KINDS.FLOAT3,
        /**
         * @param {Annotation} result
         * @param {Array.<Annotation>} args
         * @param {Context} ctx
         */
        evaluate: Tools.Vec.constructorEvaluate.bind(null, "Vec3", 3),
        computeStaticValue: Tools.Vec.constructorComputeStaticValue.bind(null, "Vec3")

    };

    var Vector3StaticObject = {
    };

    var Vector3Instance = {
        length: {
            type: TYPES.FUNCTION,
            evaluate: Tools.Vec.optionalZeroEvaluate.bind(null,"Vec3", "length", 3, 1, 1)
        }
    };
    Tools.Vec.attachSwizzles(Vector3Instance, "Vec3", 3);
    Tools.Vec.attachVecMethods(Vector3Instance, "Vec3", 3, 3, ['add', 'sub', 'mul', 'div', 'mod', 'reflect', "cross"]);
    Tools.Vec.attachVecMethods(Vector3Instance, "Vec3", 1, 3, ['dot']);
    Tools.Vec.attachVecMethods(Vector3Instance, "Vec3", 3, 0, ['normalize', 'flip']);

    Vector3Instance["refract"] = {
        type: TYPES.FUNCTION,
        evaluate: function (result, args, ctx) {
            if (args.length < 2)
                Shade.throwError(result.node, "Not enough parameters for refract.");

            var eta = args.pop();
            if (!eta || !eta.canNumber())
                Shade.throwError(result.node, "Invalid parameter for refract, expected a number got " + eta.getTypeString());

            Tools.Vec.checkVecArguments(Vector3Instance + "." + "refract", 3, false, 0, result, args);

            var typeInfo = {
                type: TYPES.OBJECT,
                kind: KINDS.FLOAT3
            };

            return typeInfo;
        }
    };

    Tools.extend(ns, {
        id: "Vec3",
        kind: KINDS.FLOAT3,
        object: {
            constructor: Vector3Constructor,
            static: Vector3StaticObject
        },
        instance: Vector3Instance
    });


}(exports));

},{"../../../interfaces.js":123,"./tools.js":75}],78:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js"),
        TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS,
        Tools = require("./tools.js");

    var Vector4Constructor =  {
        type: TYPES.OBJECT,
        kind: KINDS.FLOAT4,
        /**
         * @param {Annotation} result
         * @param {Array.<Annotation>} args
         * @param {Context} ctx
         */
        evaluate: Tools.Vec.constructorEvaluate.bind(null, "Vec4", 4),
        computeStaticValue: Tools.Vec.constructorComputeStaticValue.bind(null, "Vec4")
    };

    var Vector4StaticObject = {
    };

    var Vector4Instance = {
        length: {
            type: TYPES.FUNCTION,
            evaluate: Tools.Vec.optionalZeroEvaluate.bind(null,"Vec4", "length", 4, 1, 1)
        }
    };
    Tools.Vec.attachSwizzles(Vector4Instance, "Vec4", 4);
    Tools.Vec.attachVecMethods(Vector4Instance, "Vec4", 4, 4, ['add', 'sub', 'mul', 'div', 'mod', 'reflect']);
    Tools.Vec.attachVecMethods(Vector4Instance, "Vec4", 1, 4, ['dot']);
    Tools.Vec.attachVecMethods(Vector4Instance, "Vec4", 4, 0, ['normalize', 'flip']);


    Tools.extend(ns, {
        id: "Vec4",
        kind: KINDS.FLOAT4,
        object: {
            constructor: Vector4Constructor,
            static: Vector4StaticObject
        },
        instance: Vector4Instance
    });


}(exports));

},{"../../../interfaces.js":123,"./tools.js":75}],79:[function(require,module,exports){
(function (ns) {

    // dependencies
    var assert = require('assert');
    var esgraph = require('esgraph');
    var worklist = require('analyses');
    var common = require("../../base/common.js");
    var Context = require("../../base/context.js");
    var Base = require("../../base/index.js");
    var codegen = require('escodegen');
    var annotateRight = require("./infer_expression.js").annotateRight;
    var InferenceScope = require("./registry/").InferenceScope;
    var System = require("./registry/system.js");
    var Annotations = require("./../../base/annotation.js");
    var walk = require('estraverse');
    var Tools = require("../settools.js");
    var Shade = require("../../interfaces.js");
    var walkes = require('walkes');
    var validator = require('../validator');
    var TypeInfo = require("../../base/typeinfo.js").TypeInfo;

    // shortcuts
    var Syntax = common.Syntax;
    var Map = common.Map;
    var Set = worklist.Set;
    var FunctionAnnotation = Annotations.FunctionAnnotation;
    var ANNO = Annotations.ANNO;








    function findConstantsFor(ast, names, constantVariables) {
        var result = new Set(), annotation, name, formerValue;
        constantVariables = constantVariables ? constantVariables.values() : [];

        walkes(ast, {
            AssignmentExpression: function(recurse) {


                if (this.left.type != Syntax.Identifier) {
                    Shade.throwError(ast, "Can't find constant for computed left expression");
                }
                name = this.left.name;
                if(names.has(name)) {
                    annotation = ANNO(this.right);
                    if(annotation.hasStaticValue()) {
                        switch(this.operator) {
                            case "=":
                                result.add({ name: name, constant: TypeInfo.copyStaticValue(annotation)});
                                break;
                            case "-=":
                            case "+=":
                            case "*=":
                            case "/=":
                                formerValue = constantVariables.filter(function(v){ return v.name == name; });
                                if(formerValue.length) {
                                    var c = formerValue[0].constant, v;
                                    switch(this.operator) {
                                        case "+=":
                                            v = c + TypeInfo.copyStaticValue(annotation);
                                            break;
                                        case "-=":
                                            v = c - TypeInfo.copyStaticValue(annotation);
                                            break;
                                        case "*=":
                                            v = c * TypeInfo.copyStaticValue(annotation);
                                            break;
                                        case "/=":
                                            v = c / TypeInfo.copyStaticValue(annotation);
                                            break;
                                    }
                                    result.add({ name: name, constant: v});
                                }
                                break;
                            default:
                                assert(!this.operator);
                        }

                    }
                }
                recurse(this.right);
            },

            VariableDeclarator: function(recurse) {
                name = this.id.name;
                if (this.init && names.has(name)) {
                    annotation = ANNO(this.init);
                    if(annotation.hasStaticValue()) {
                        result.add({ name: name, constant: TypeInfo.copyStaticValue(annotation)});
                    }
                }
                recurse(this.init);
            },

            UpdateExpression: function(recurse) {
                if(this.argument.type == Syntax.Identifier) {
                    name = this.argument.name;
                    annotation = ANNO(this);
                    if(annotation.hasStaticValue()) {
                        var value = TypeInfo.copyStaticValue(annotation);
                        if (!this.prefix) {
                            value = this.operator == "--" ? --value : ++value;
                        }
                        result.add({ name: name, constant: value});
                    }
                }
            }
        });

        return result;
    }



    /**
     *
     * @param ast
     * @param {AnalysisContext} context
     * @param {*} opt
     * @constructor
     */
    var TypeInference = function (ast, context, opt) {
        opt = opt || {};

        this.context = context;

        this.propagateConstants = opt.propagateConstants || false;
    };

    Base.extend(TypeInference.prototype, {

        /**
         * @param {*} ast
         * @param {*} opt
         * @returns {*}
         */
        inferBody: function (ast, opt) {
             var cfg = esgraph(ast, { omitExceptions: true }),
                 context = this.context,
                 propagateConstants = this.propagateConstants;

        //console.log("infer body", cfg)

        var result = worklist(cfg,
            /**
             * @param {Set} input
             * @this {FlowNode}
             * @returns {*}
             */
                function (input) {

                if (!this.astNode || this.type) // Start and end node do not influence the result
                    return input;

                //console.log("Analyze", codegen.generate(this.astNode), this.astNode.type);

                // Local
                if(propagateConstants) {
                    this.kill = this.kill || Tools.findVariableAssignments(this.astNode, true);
                }

                annotateRight(context, this.astNode, propagateConstants ? input : null );

                this.decl = this.decl || context.declareVariables(this.astNode);

                //context.computeConstants(this.astNode, input);

                if(!propagateConstants) {
                    return input;
                }



                var filteredInput = null, generate = null;
                if (this.kill.size) {
                    // Only if there's an assignment, we need to generate
                    generate = findConstantsFor(this.astNode, this.kill, propagateConstants ? input : null);
                    var that = this;
                    filteredInput = new Set(input.filter(function (elem) {
                            return !that.kill.some(function(tokill) { return elem.name == tokill });
                    }));
                }

                var result = Set.union(filteredInput || input, generate);
//                console.log("input:", input);
//                console.log("kill:", this.kill);
//                console.log("generate:", generate);
//                console.log("filteredInput:", filteredInput);
//                console.log("result:", result);
                return result;
            }
            , {
                direction: 'forward',
                merge: worklist.merge(function(a,b) {
                    if (!a && !b)
                        return null;
                    //console.log("Merge", a && a.values(), b && b.values())
                    var result = Set.intersect(a, b);
                    //console.log("Result", result && result.values())
                    return result;
                })
            });
        //Tools.printMap(result, cfg);
        return ast;
        }

    });




    /**
     *
     * @param ast
     * @param {AnalysisContext} context
     * @param opt
     * @returns {*}
     */
    var inferProgram = function (ast, context, opt) {
        opt = opt || {};
        //var globalScope = createGlobalScope(ast);
        //registerSystemInformation(globalScope, opt);

        var typeInference = new TypeInference(ast, context, opt);
        var result = typeInference.inferBody(ast, opt);


        return result;
    };

    ns.infer = inferProgram;

}(exports));

},{"../../base/common.js":87,"../../base/context.js":88,"../../base/index.js":90,"../../base/typeinfo.js":92,"../../interfaces.js":123,"../settools.js":63,"../validator":84,"./../../base/annotation.js":85,"./infer_expression.js":65,"./registry/":67,"./registry/system.js":73,"analyses":1,"assert":47,"escodegen":9,"esgraph":27,"estraverse":46,"walkes":53}],80:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var traverse = require('estraverse'),
        common = require("./../../base/common.js"),
        Shade = require("../../interfaces.js"),
        codegen = require('escodegen'),
        Set = require('analyses').Set,
        Tools = require('../../base/asttools.js');


    // Shortcuts
    var Syntax = traverse.Syntax, ANNO = common.ANNO;

    function toMap(uniformSet) {
        var result = {};
        uniformSet && uniformSet.forEach(function(entry) {
            result[entry.name] = {
                dependencies: entry.dependencies,
                costs: entry.costs
            };
        });
        return result;
    }

    var allowedMemberCalls = ["Math", "Shade"];

    ns.generateUniformExpressions = function (ast, input) {

        var uniformVariables = toMap(input);

        traverse.traverse(ast, {
            leave: function (node, parent) {
                var result = ANNO(node);
                result.clearUniformDependencies();

                switch (node.type) {

                    // New uniforms can come via the env object
                    case Syntax.MemberExpression:
                        var propertyAnnotation = ANNO(node.property);
                        if (propertyAnnotation.getSource() == Shade.SOURCES.UNIFORM) {
                            result.setUniformDependencies(node.property.name);
                            result.setUniformCosts(0);
                        }
                        break;

                    case Syntax.Identifier:
                        // Not a variable
                        if(!Tools.isVariableReference(node, parent))
                            return;

                        // Not a variable on the right side
                        if(parent.type == Syntax.AssignmentExpression && parent.left == node)
                            return;

                        if(uniformVariables.hasOwnProperty(node.name)) {
                            var propagatedUniform = uniformVariables[node.name];
                            result.setUniformDependencies(propagatedUniform.dependencies);
                            result.setUniformCosts(propagatedUniform.costs);
                        }

                        break;
                    case Syntax.BinaryExpression:
                         var left = ANNO(node.left),
                             right = ANNO(node.right);

                        if (left.canUniformExpression() && right.canUniformExpression()) {
                            result.setUniformDependencies(left.getUniformDependencies(), right.getUniformDependencies());
                            result.setUniformCosts(left.getUniformCosts() + right.getUniformCosts() + 2);
                        }
                        break;
                    case Syntax.UnaryExpression:
                        var argument = ANNO(node.argument);

                        if(argument.isUniformExpression()) {
                            result.setUniformDependencies(argument.getUniformDependencies());
                            result.setUniformCosts(argument.getUniformCosts() + 1);
                        }
                        break;
                    case Syntax.CallExpression:
                        if(node.callee.type == Syntax.MemberExpression) {
                            var object = node.callee.object;
                            var args = node.arguments.map(function(arg) { return ANNO(arg);});

                            if(object.name && ~allowedMemberCalls.indexOf(object.name)) {
                                var dependencies = mergeUniformDependencies(args);
                                if(dependencies) {
                                    result.setUniformDependencies(dependencies);
                                    var costs = args.reduce(function(prev, next) { return prev + next.getUniformCosts(); }, 1);
                                    result.setUniformCosts(costs)
                                }
                            } else {
                                // TODO: CleanCode: Merge with above as soon as all differences are clear
                                var objectAnno = ANNO(object);
                                if(objectAnno.isUniformExpression()) {
                                    var dependencies = mergeUniformDependencies(args);
                                    if (dependencies || args.length == 0) {
                                        result.setUniformDependencies(dependencies, objectAnno.getUniformDependencies());
                                        var costs = args.reduce(function(prev, next) { return prev + next.getUniformCosts(); }, 1);
                                        result.setUniformCosts(costs)
                                    }
                                }  else {
                                    // console.log("No exp:", Shade.toJavaScript(node))
                                }
                            }
                        }
                        break;
                    case Syntax.NewExpression:
                        if(node.callee.type == Syntax.Identifier) {
                            var args = node.arguments.map(function(arg) { return ANNO(arg);});
                            var dependencies = mergeUniformDependencies(args);
                            if(dependencies) {
                                result.setUniformDependencies(dependencies);
                                var costs = args.reduce(function(prev, next) { return prev + next.getUniformCosts(); }, 1);
                                result.setUniformCosts(costs);
                            }
                        }
                        break;

                }
            }
        });

        var result = new Set();
        switch (ast.type) {
            case Syntax.AssignmentExpression:
                var right = ANNO(ast.right);
                if (right.isUniformExpression()) {
                    result.add({ name: ast.left.name, dependencies: right.getUniformDependencies(), costs: right.getUniformCosts() });
                }
                break;
            case Syntax.VariableDeclaration:
                ast.declarations.forEach(function (declaration) {
                    if (declaration.init) {
                        var init = ANNO(declaration.init);
                        if (init.isUniformExpression()) {
                            result.add({ name: declaration.id.name, dependencies: init.getUniformDependencies(), costs: init.getUniformCosts() });
                        }
                    }
                });
                break;
        }
        return result;
    }
    
    
    function atLeastOneArgumentIsUniform(args) {
        var allUniformOrStatic = true,
            oneUniform = false;

        for(var i = 0; i < args.length && allUniformOrStatic; i++) {
            var thisUniform = args[i].isUniformExpression();
            allUniformOrStatic = allUniformOrStatic && (thisUniform || args[i].hasStaticValue());
            oneUniform = oneUniform || thisUniform;
        }
        return allUniformOrStatic && oneUniform;
    };

    function mergeUniformDependencies(args) {
        var uniformDependencies = null;

        if(atLeastOneArgumentIsUniform(args)) {
            uniformDependencies = []
            for(var i = 0; i< args.length;i++) {
                if (args[i].isUniformExpression())        {
                    uniformDependencies = uniformDependencies.concat(args[i].getUniformDependencies());
                }
            }
        }
        return uniformDependencies;
    };

}(exports));

},{"../../base/asttools.js":86,"../../interfaces.js":123,"./../../base/common.js":87,"analyses":1,"escodegen":9,"estraverse":46}],81:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var common = require("../../base/common.js");
    var esgraph = require('esgraph');
    var worklist = require('analyses');
    var evaluator = require('./evaluator.js');
    var transformer = require('./uniformTransformer.js');
    var Tools = require("../settools.js");
    var assert = require("assert");

    // Shortcuts
    var Set = worklist.Set,
        Syntax = common.Syntax;

    /**
     * @param root
     * @param opt
     * @constructor
     */
    function UniformAnalysis(root, opt) {
        this.root = root;
        this.opt = opt || {};
    }


    UniformAnalysis.prototype = {
        analyzeBody: function (body) {
            var cfg = esgraph(body, { omitExceptions: true });


            var result = worklist(cfg,
            /**
             * @param {Set} input
             * @this {FlowNode}
             * @returns {*}
             */
                function (input) {

                if (!this.astNode || this.type) // Start and end node do not influence the result
                    return input;

                var generate = evaluator.generateUniformExpressions(this.astNode, input);
                this.kill = this.kill || Tools.findVariableAssignments(this.astNode, true);

                var filteredInput = input;
                if (this.kill.size) {
                    var that = this;
                    filteredInput = new Set(input.filter(function (elem) {
                            return !that.kill.some(function(tokill) { return elem.name == tokill });
                    }));
                }

                var result = Set.union(filteredInput, generate);

//                console.log("input:", input);
//                console.log("kill:", this.kill);
//                console.log("generate:", generate);
//                console.log("filteredInput:", filteredInput);
//                //console.log("result:", result);
                return result;
                }, {
                direction: 'forward',
                merge: worklist.merge(function(a,b) {
                    if (!a && !b)
                        return null;
                    return Set.intersect(a, b);
                })
            });
            //Tools.printMap(result, cfg);

        },

        transform: function () {
            var result = transformer.transform(this.root, this.opt);
            return result;
        }
    };


    ns.extract = function (ast, opt) {

        assert(ast.type == Syntax.Program || ast.type == Syntax.BlockStatement);

        var analysis = new UniformAnalysis(ast, opt);

        // Propagate and analyze
        analysis.analyzeBody(ast.type == Syntax.Program ? ast.body : ast);

        // Transform
        return analysis.transform();
    };


}(exports));

},{"../../base/common.js":87,"../settools.js":63,"./evaluator.js":80,"./uniformTransformer.js":83,"analyses":1,"assert":47,"esgraph":27}],82:[function(require,module,exports){
(function (ns) {

    var walk = require('estraverse');
    var Syntax = walk.Syntax;
    var ANNO = require("../../base/annotation.js").ANNO;

    var interfaces = require("../../interfaces.js");
    var TYPES = interfaces.TYPES,
        KINDS = interfaces.OBJECT_KINDS;

    function getConstructor(kind){
        switch(kind){
            case KINDS.FLOAT2: return "Shade.Vec2"; break;
            case KINDS.FLOAT3: return "Shade.Vec3"; break;
            case KINDS.FLOAT4: return "Shade.Vec4"; break;
            case KINDS.MATRIX3: return "Shade.Mat3"; break;
            case KINDS.MATRIX4: return "Shade.Mat4"; break;
            default: throw "Unsupported object kind in uniform expression argument: " + kind;
        }
    }


    function isMathCall(node) {
        return (node.callee.type === Syntax.MemberExpression && node.callee.object.type === Syntax.Identifier && node.callee.object.name === "Math");
    }

    function isVecMathCall(node) {
        if(!isMathCall(node))
            return false;
        var firstArgument = ANNO(node.arguments[0]);
        return firstArgument.isVector();
    }

    var leaveVisitor = function (node, parent, variables, controller) {
        if (node.type == Syntax.MemberExpression) {
            var object = ANNO(node.object);
            if (node.object.type == Syntax.Identifier && object.isUniformExpression()) {
                if(variables.hasOwnProperty(node.object.name)) {
                //console.log("Found: " + node.object.name, variables[node.object.name]);
                    node.object = variables[node.object.name].code;
                }
            }
            if (object.isGlobal() && node.property.type == Syntax.Identifier) {
                var property = ANNO(node.property);

                if(property.isObject()){
                    // Is the accessed parameter is a vector or matrix , we have to
                    // wrap the typed array in the respective constructor
                    var constructor = getConstructor(property.getKind());
                    return {
                        type: Syntax.NewExpression,
                        callee: { type: Syntax.Identifier, name: constructor},
                        arguments:  [node]
                    }
                }
                else if((parent == node) || parent.type != Syntax.MemberExpression){
                    // Is the accessed parameter is a scalar value, we have to
                    // access the first entry of the input array
                    return {
                        type: Syntax.MemberExpression,
                        computed: true,
                        object: node,
                        property: {
                            type: Syntax.Literal,
                            value: 0
                        }
                    }
                }
            }
        }

        if (node.type == Syntax.CallExpression) {
            if (isVecMathCall(node)) {
                node.callee.object.name = "Math";
            }
        }


        if (node.type == Syntax.Identifier) {
            if (~[Syntax.MemberExpression, Syntax.FunctionDeclaration, Syntax.VariableDeclarator].indexOf(parent.type))
                return;

            if (parent.type == Syntax.NewExpression && parent.callee == node)
                return;

            // Not a variable on the right side
            if (parent.type == Syntax.AssignmentExpression && parent.left == node)
                return;

            if(variables.hasOwnProperty(node.name)) {
                //console.log("Found: " + node.name, this[node.name]);
                var code = variables[node.name].code;
                return code;
            }
        }

        if (node.type == Syntax.NewExpression) {
            if (node.callee.type == Syntax.Identifier) {
                var name = node.callee.name;
                switch(name) {
                    case "Vec2":
                    case "Vec3":
                    case "Vec4":
                        node.callee.name = "Shade." + name;
                        break;

                }
            }
        }

        if (node.type == Syntax.ReturnStatement) {
            var anno = ANNO(node.argument);
            if(anno.isObject()){
                node.argument = { type: Syntax.CallExpression,
                    callee: {
                        type: Syntax.MemberExpression,
                        object: node.argument,
                        property: {type: Syntax.Identifier,
                            name: "_toFloatArray"
                        }
                    },
                    arguments: []
                };
                return node;
            }
        }
        }

    ns.transformUniformSetter = function (ast, variables) {
        return walk.replace(ast, { leave: function(node, parent) {
            return leaveVisitor(node, parent, variables, this);
        }});
    };


}(exports));

},{"../../base/annotation.js":85,"../../interfaces.js":123,"estraverse":46}],83:[function(require,module,exports){
(function(ns){

    // Dependencies
    var traverse = require('estraverse'),
        common = require("./../../base/common.js"),
        codegen = require('escodegen'),
        setterGenerator = require('./uniformSetterTransformation.js');

    // Shortcuts
    var ANNO = common.ANNO,
        Syntax = traverse.Syntax;

    var UniformTransformer = function(opt){
        opt = opt || {};

        var counter = opt.uniformCounter || 1;
        this.getCounter = function() {
            return counter++;
        };
        this.uniformExpressions = {};
        this.activeUniformVariables = {};
    };

    UniformTransformer.prototype = {
        transform: function(ast) {
            var that = this;
            return traverse.replace(ast, {
                enter: function(node) {
                    var anno = ANNO(node);
                    if(anno.isUniformExpression() && shouldGenerateUniformExpression(node, anno)) {
                        return that.generateUniformExpression(node);
                    }
                    if (node.type == Syntax.AssignmentExpression || (node.type == Syntax.VariableDeclarator && node.init)) {
                        var right = ANNO(node.right || node.init);
                        var leftNode = node.left || node.id;
                        if (right.isUniformExpression() && leftNode.type == Syntax.Identifier) {
                            that.activeUniformVariables[leftNode.name] = {
                                code: setterGenerator.transformUniformSetter(node.right || node.init, that.activeUniformVariables),
                                dependencies: right.getUniformDependencies()
                            }
                        }
                    }
                }
            });
        },
        getUniformExpression: function(uexp) {
            for(var name in this.uniformExpressions) {
                var other = this.uniformExpressions[name];
                if(uexp.code == other.code && equalDependencies(uexp.dependencies, other.dependencies))
                    return name;
            }
            return "";
        },
        generateUniformExpression: function(node) {
            var anno = ANNO(node);
            var uexp = {
                code: codegen.generate(setterGenerator.transformUniformSetter(node, this.activeUniformVariables)),
                dependencies: anno.getUniformDependencies()

            };

            var name = this.getUniformExpression(uexp);
            if(!name) {
                name = "u" + this.getCounter();
                this.uniformExpressions[name] = uexp;
            }
            var result = {
                type: Syntax.MemberExpression,
                object: {
                    type: Syntax.Identifier,
                    name: "uexp"
                },
                property: {
                    type: Syntax.Identifier,
                    name: name
                }
            }

            ANNO(result).copy(anno);
            return result;
        }
    };

    function equalDependencies(a, b) {
        if(a.length != b.length)
            return false;
        a.forEach(function(elem) {
            if(b.indexOf(elem) == -1)
                return false;
        });
        return true;
    }

    function shouldGenerateUniformExpression(node, anno) {
        var costs = anno.getUniformCosts();
        return costs > 0;
    };

    var transform = ns.transform = function (ast, opt) {
        var transformer = new UniformTransformer(opt);
        var result = transformer.transform(ast);
        opt.uniformExpressions = transformer.uniformExpressions;
        return result;
    };

}(exports));

},{"./../../base/common.js":87,"./uniformSetterTransformation.js":82,"escodegen":9,"estraverse":46}],84:[function(require,module,exports){
(function (ns) {

    var common = require("./../base/common.js"),
        Shade = require("../interfaces.js"),
        estraverse = require('estraverse');

    // var codegen = require('escodegen');

    var Syntax = common.Syntax,
        TYPES = Shade.TYPES,
        ANNO = common.ANNO;

    var leaveNode = function(node) {
        var annotation = ANNO(node), right;

        if(!annotation.isValid()) {
            var errorInfo = annotation.getError();
            var error = new Error(errorInfo.message);
            error.loc = errorInfo.loc;
            throw error;
        }

        if(node.type == Syntax.VariableDeclarator) {
            if(node.init) {
                right = ANNO(node.init);
                annotation.copy(right);
            }

            if (annotation.getType() == TYPES.ANY || annotation.isNullOrUndefined()) {
                Shade.throwError(node, "No type could be calculated for ")
            }
        }
        if(node.type == Syntax.AssignmentExpression) {
            right = ANNO(node.right);
            annotation.copy(right);
            annotation.clearUniformDependencies();

            if (annotation.getType() == TYPES.ANY || annotation.isNullOrUndefined()) {
                Shade.throwError(node, "No type could be calculated for ")
            }
        } else if(node.type == Syntax.ExpressionStatement) {
            var exp = ANNO(node.expression);
            annotation.copy(exp);
        }


    };

    /**
     * Validates AST: Tests if the non-eliminated nodes
     * are all valid and have type information
     * @param {Object} ast
     * @returns Object
     */
    var validate = ns.validate = function (ast) {
        return estraverse.replace(ast, {
            leave: leaveNode
        });
    }


}(exports));

},{"../interfaces.js":123,"./../base/common.js":87,"estraverse":46}],85:[function(require,module,exports){
(function(ns){

    var Shade = require("../interfaces.js"),
        Syntax = require('estraverse').Syntax,
        Base = require("./index.js"),
        TypeInfo = require("./typeinfo.js").TypeInfo;

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;


    /**
     * @param {object} node
     * @param {object} extra
     * @extends TypeInfo
     * @constructor
     */
    var Annotation = function (node, extra) {
        TypeInfo.call(this, node, extra);
    };

    Base.createClass(Annotation, TypeInfo, {

        setCall : function(call) {
            var extra = this.getExtra();
            extra.evaluate = call;
        },
        getCall : function() {
            return this.getExtra().evaluate;
        },
        clearCall: function() {
            var extra = this.getExtra();
            delete extra.evaluate;
        }

    });


    /**
     * @param {object} node
     * @param {object} extra
     * @extends Annotation
     * @constructor
     */
    var FunctionAnnotation = function (node, extra) {
        Annotation.call(this, node, extra);
        this.setType(TYPES.FUNCTION);
    };

    Base.createClass(FunctionAnnotation, Annotation, {
        getReturnInfo: function() {
            return this.getExtra().returnInfo;
        },
        setReturnInfo: function(info) {
            this.getExtra().returnInfo = info;
        },
        isUsed: function() {
            return !!this.getExtra().used;
        },
        setUsed: function(v) {
            this.getExtra().used = v;
        }
    });

    ns.Annotation = Annotation;
    ns.FunctionAnnotation = FunctionAnnotation;
    ns.ANNO = function(object, extra){return new Annotation(object, extra)};

}(exports));

},{"../interfaces.js":123,"./index.js":90,"./typeinfo.js":92,"estraverse":46}],86:[function(require,module,exports){
(function (ns) {

    var Syntax = require("./common.js").Syntax;


    var isVariableName = function (node, parent) {
        return node.type == Syntax.Identifier && !((parent.type == Syntax.MemberExpression && parent.property == node) || parent.type == Syntax.FunctionDeclaration || (parent.type == Syntax.NewExpression && parent.callee == node) ||  (parent.type == Syntax.CallExpression && parent.callee == node));
    };

    var isVariableReference = function (node, parent) {
        return isVariableName(node, parent) && parent.type != Syntax.VariableDeclarator;
    };

    ns.isVariableReference = isVariableReference;
    ns.isVariableName = isVariableName;

}(exports));

},{"./common.js":87}],87:[function(require,module,exports){
(function (ns) {

    var ANNO = require("../base/annotation.js").ANNO,
        estraverse = require('estraverse'),
        ErrorHandler = require("./errors.js");


    var Syntax = estraverse.Syntax;

    /**
     *
     * @param {object|Array.<object>} node
     * @param scope
     * @returns {TypeInfo|Array.<TypeInfo>}
     */
    ns.createTypeInfo = function (node, scope) {
        if(Array.isArray(node)) {
            return node.map(function (arg) {
                return scope.createTypeInfo(arg);
            });
        }
        var result = ANNO(node);
        if (node.type == Syntax.Identifier || node.type == Syntax.ThisExpression) {
            var name = node.type == Syntax.Identifier ? node.name : 'this';
            var binding = scope.getBindingByName(name);
            if (binding) {
                result.copy(binding);
                return binding;
            }
        }
        return result;
    };

    /**
     *
     * @param {object|Array.<object>} node
     * @param scope
     * @param {Array?} constants Additional array of constants
     * @param {boolean} check
     * @returns {TypeInfo|Array.<TypeInfo>}
     */
    ns.getTypeInfo = function getTypeInfo(node, scope, constants, check) {
        if(!node)
            return null;

        check = check == undefined ? false : check;

        if(Array.isArray(node)) {
            return node.map(function (arg) {
                return getTypeInfo(arg, scope, constants, check);
            });
        }
        var binding;
        if (node.type == Syntax.Identifier) {
            var name = node.name;

            if(name == 'undefined')
                return ANNO(node);

            binding = scope.getBindingByName(name);
            if(binding == undefined && check) {
                ANNO(node).setInvalid(ErrorHandler.generateErrorInformation(node, ErrorHandler.ERROR_TYPES.REFERENCE_ERROR, name, "is not defined"));
                return ANNO(node);
            }
            if(binding) {
                var result = ANNO(node, binding.getExtra());
                // A variable is dynamic per default. Only if it's listed in constant
                // we can assume a static value
                result.setDynamicValue();
                binding.setDynamicValue();
                if (constants && !binding.isNullOrUndefined()) {
                    var propagatedConstant = constants.filter(function (constant) {
                        return constant.name == name;
                    });

                    if (propagatedConstant.length) {
                        binding.setStaticValue(propagatedConstant[0].constant);
                        result.setStaticValue(propagatedConstant[0].constant);
                    }
                }
                return binding;

            }
        } else if (node.type == Syntax.ThisExpression) {
            binding = scope.getBindingByName('this');
        }
        return binding || ANNO(node);
    };



    ns.Syntax = Syntax;
    ns.VisitorOption = estraverse.VisitorOption;
    ns.Map = require('es6-map-shim').Map;

    ns.ANNO = ANNO;
    ns.getObjectReferenceFromNode = ns.getTypeInfo;


}(exports));

},{"../base/annotation.js":85,"./errors.js":89,"es6-map-shim":8,"estraverse":46}],88:[function(require,module,exports){
(function (module) {

    var Context = function (root, opt) {

        this.options = opt || {};

        /**
         * The root of the program to analyze
         * @type {*}
         */
        this.root = root;

        /**
         * To identify the main method of the shader
         * @type {*|string}
         */
        this.mainFunction = opt.mainFunction || "global.shade";


        /**
         * @type {Array.<Scope>}
         */
        this.scopeStack = opt.scope ? [opt.scope] : [  ];

        /**
         * Reserved keywords
         * @type {Array.<string>}
         */
        this.blockedNames = opt.blockedNames || [];

        /**
         * Used names
         * @type {Array.<string>}
         */
        this.usedNames = [];


        this.declaration = false;
    };

    Context.prototype = {
        getScope: function () {
            return this.scopeStack[this.scopeStack.length - 1];
        },
        pushScope: function (scope) {
            return this.scopeStack.push(scope);
        },
        popScope: function () {
            return this.scopeStack.pop();
        },
        inMainFunction: function() {
            return this.getScope().str() == this.mainFunction;
        },
        setInDeclaration: function(inDeclaration) {
            this.declaration = inDeclaration;
        },
        inDeclaration : function () {
            return this.declaration;
        },
        getSafeName: function(baseName) {
            var index = 0, searchName = baseName;
            while (this.blockedNames.indexOf(searchName) != -1) {
                searchName = baseName + index++;
            }
            return searchName;
        },
        getSafeUniqueName: function(baseName) {
            var index = 1, searchName = baseName;
            while (!(this.usedNames.indexOf(searchName) == -1 && this.blockedNames.indexOf(searchName) == -1)) {
                searchName = baseName + index++;
            }
            this.usedNames.push(searchName);
            return searchName;
        }

    };


    module.exports = Context;

}(module));

},{}],89:[function(require,module,exports){
(function(){

    // Dependencies
    var codegen = require('escodegen');

    var ErrorHandler = {};

        /**
     * @param node
     * @param {string} type
     * @param {...*} message
     * @returns {{message: string, loc: *}}
     */
    ErrorHandler.generateErrorInformation = function(node, type, message) {
        var args = Array.prototype.slice.call(arguments).splice(2),
            loc = node.loc,
            codeInfo = "";

        codeInfo += codegen.generate(node);
        if (loc && loc.start.line) {
            codeInfo += " (Line " + loc.start.line + ")";
        }
        message = args.length ? args.join(" ") + ": " : "";
        return { message: type + ": " + message + codeInfo, loc: loc};
    };

    ErrorHandler.ERROR_TYPES = {
        TYPE_ERROR: "TypeError",
        REFERENCE_ERROR: "ReferenceError",
        NAN_ERROR: "NotANumberError",
        SHADEJS_ERROR: "ShadeJSError"
    };

    module.exports = ErrorHandler;

}(module));

},{"escodegen":9}],90:[function(require,module,exports){
(function(ns){

    ns.extend = function(a, b) {
        for ( var prop in b) {
            var g = b.__lookupGetter__(prop), s = b.__lookupSetter__(prop);
            if (g||s) {
                if (g) {
                    a.__defineGetter__(prop, g);
                }
                if (s) {
                    a.__defineSetter__(prop, s);
                }
            } else {
                if (b[prop] === undefined) {
                    delete a[prop];
                } else if (prop !== "constructor" || a !== window) {
                    a[prop] = b[prop];
                }
            }
        }
        return a;
    };



    ns.deepExtend = function(destination, source) {
        for (var property in source) {
            var srcValue = source[property];
            var dstValue = destination[property];
            var copy;
            if (Array.isArray(srcValue)) {
                copy = dstValue || [];
                ns.deepExtend(copy, srcValue);
            } else if (typeof srcValue === "object" && srcValue !== null) {
                copy = dstValue || {};
                ns.deepExtend(copy, srcValue);
            } else {
                copy = srcValue;
            }
            destination[property] = copy;
        }
        return destination;
    };

    ns.shallowExtend = function(destination, source) {
        for (var property in source) {
            destination[property] = source[property];
        }
        return destination;
    };

    /**
     *
     * @param {Object} ctor Constructor
     * @param {Object} parent Parent class
     * @param {Object=} methods Methods to add to the class
     * @return {Object!}
     */
    ns.createClass = function(ctor, parent, methods) {
        methods = methods || {};
        if (parent) {
            /** @constructor */
            var F = function() {
            };
            F.prototype = parent.prototype;
            ctor.prototype = new F();
            ctor.prototype.constructor = ctor;
            ctor.superclass = parent.prototype;
        }
        for ( var m in methods) {
            ctor.prototype[m] = methods[m];
        }
        return ctor;
    };


}(exports))

},{}],91:[function(require,module,exports){
(function(ns){

    var Base = require("./index.js"),
        Shade = require("../interfaces.js"),
        TYPES = Shade.TYPES,
        Annotation = require("./annotation.js").Annotation,
        TypeInfo = require("./typeinfo.js").TypeInfo,
        Syntax = require('estraverse').Syntax,
        ErrorHandler = require("./errors.js");


    /**
     *
     * @param binding
     * @extends TypeInfo
     * @constructor
     */
    var Binding = function(binding, registry) {
        TypeInfo.call(this, binding);
        if(this.node.ref) {
            if (!registry[this.node.ref])
                throw Error("No object has been registered for: " + this.node.ref);
            this.globalObject = registry[this.node.ref].object;
            if (this.globalObject) {
                this.setType(TYPES.OBJECT);
            }
        }
    };


    Base.createClass(Binding, TypeInfo, {
        hasConstructor: function() {
            return !!this.getConstructor();
        },
        getConstructor: function() {
            return this.globalObject && this.globalObject.constructor;
        },
        isInitialized: function() {
            return this.node.initialized;
        },
        setInitialized: function(v) {
            this.node.initialized = v;
        },
        hasStaticValue: function() {
            return this.globalObject ? true : TypeInfo.prototype.hasStaticValue.call(this);
        },
        getStaticValue : function() {
            if (!this.hasStaticValue()) {
                throw new Error("Node has no static value: " + this.node);
            }
           return this.globalObject ? this.globalObject.staticValue : TypeInfo.prototype.getStaticValue.call(this);
        },
        isGlobal: function() {
            return this.node.info && this.node.info._global || TypeInfo.prototype.isGlobal.call(this);
        },
        getType: function() {
            return this.globalObject? TYPES.OBJECT : TypeInfo.prototype.getType.call(this);
        },
        getStaticProperties: function() {
            if (this.globalObject)
                return this.globalObject.static;
            return null;
        },
        getInfoForSignature: function(signature) {
            var extra = this.getExtra();
            if(!extra.signatures)
                return null;
            return extra.signatures[signature];
        },
        setInfoForSignature: function(signature, info) {
            var extra = this.getExtra();
            if(!extra.signatures)
                extra.signatures = {};
            return extra.signatures[signature] = info;
        }


    })


    /**
     * @param {Scope|null} parent
     * @param opt
     * @constructor
     */
    var Scope = function(node, parent, opt) {
        opt = opt || {};

        /** @type (Scope|null) */
        this.parent = parent || opt.parent || null;
        this.registry = opt.registry || (parent ? parent.registery : {});

        this.scope = node.scope = node.scope || {};

        /** @type {Object.<string, {initialized: boolean, annotation: Annotation}>} */
        this.scope.bindings = this.scope.bindings || {};
        if(opt.bindings) {
            Base.extend(this.scope.bindings, opt.bindings);
        }

        this.scope.name = opt.name || node.name || "<anonymous>";

    };

    Base.extend(Scope.prototype, {
        setRegistry: function(registry) {
            this.registry = registry;
        },
        getName: function() {
            return this.scope.name;
        },
        getRootContext: function() {
            if (this.parent)
                return this.parent.getRootContext();
            return this;
        },

        getBindings: function() {
            return this.scope.bindings;
        },

        updateReturnInfo: function(annotation) {
            this.scope.returnInfo = annotation.getExtra();
        },
        getReturnInfo: function() {
            return this.scope.returnInfo || { type: TYPES.UNDEFINED };
        },

        /**
         * @param {string} name
         * @returns {*}
         */
        getBindingByName: function(name) {
            var bindings = this.getBindings();
            var binding = bindings[name];
            if(binding !== undefined)
                return new Binding(binding, this.registry);
            if (this.parent)
                return this.parent.getBindingByName(name);
            return undefined;
        },

        /**
         * @param {string} name
         * @returns {Scope|null}
         */
        getContextForName: function(name) {
            var bindings = this.getBindings();
            if(bindings[name] !== undefined)
                return this;
            if (this.parent)
                return this.parent.getContextForName(name);
            return null;
        },

        getVariableIdentifier: function(name) {
            var scope = this.getContextForName(name);
            if(!scope)
                return null;
            return scope.str() + "." + name;
        },

        declareVariable: function(name, fail, position) {
            var bindings = this.getBindings();
            fail = (fail == undefined) ? true : fail;
            if (bindings[name]) {
                if (fail) {
                    throw new Error(name + " was already declared in this scope.")
                } else {
                    return false;
                }
            }

            var init = {
                initialized : false,
                initPosition: position,
                extra: {
                    type: TYPES.UNDEFINED
                }
            };
            bindings[name] = init;
            return true;
        },

        /**
         *
         * @param {string} name
         * @param {TypeInfo} typeInfo
         */
        updateTypeInfo: function (name, typeInfo, node) {
            var v = this.getBindingByName(name);
            if (!v) {
                if(node) {
                    typeInfo.setInvalid(ErrorHandler.generateErrorInformation(node, ErrorHandler.ERROR_TYPES.REFERENCE_ERROR, name, "is not defined"));
                    return;
                }
                throw new Error("Reference error: " + name + " is not defined.")
            }
            if (v.isInitialized() && v.getType() !== typeInfo.getType()) {
                 if(node) {
                    typeInfo.setInvalid(ErrorHandler.generateErrorInformation(node, ErrorHandler.ERROR_TYPES.SHADEJS_ERROR, name, "may not change it's type"));
                    return;
                }
                throw new Error("Variable may not change it's type: " + name);
            }
            if (!v.isInitialized()) {
                // Annotate the declaration, if one is given
                if(v.node.initPosition)
                    v.node.initPosition.copy(typeInfo);
            }

            v.copy(typeInfo);
            v.setDynamicValue();
            v.setInitialized(!typeInfo.isUndefined());
        },

        registerObject: function(name, obj) {
            this.registry[obj.id] = obj;
            var bindings = this.getBindings();
            bindings[name] = {
                extra: {
                    type: TYPES.OBJECT
                },
                ref: obj.id
            };
        },

        declareParameters: function(params) {
            var bindings = this.getBindings();
            for(var i = 0; i < params.length; i++) {
                var parameter = params[i];
                var annotation = new Annotation(parameter);

                var node = { extra: { type: TYPES.UNDEFINED }};
                var binding = new TypeInfo(node);
                binding.copy(annotation);
                bindings[parameter.name] = node;
            }
        },

        str: function() {
            var ctx = this;
            var names = [];
            while(ctx) {
                names.unshift(ctx.getName());
                ctx = ctx.parent;
            }
            return names.join(".");
        },

        getAllBindings: function() {
            var result = Object.keys(this.getBindings());
            if (this.parent) {
                var parentBindings = this.parent.getAllBindings();
                for(var i = 0; i < parentBindings.length; i++) {
                    if (result.indexOf(parentBindings[i]) !== -1) {
                        result.push(parentBindings[i]);
                    }
                }
            }
            return result;
        },

        /**
         *
         * @param node
         * @returns {TypeInfo}
         */
        createTypeInfo: function (node) {
            var result = new Annotation(node);
            if (node.type == Syntax.Identifier) {
                var name = node.name;
                var binding = this.getBindingByName(name);
                if (binding) {
                    result.copy(binding);
                    return binding;
                }
            }
            return result;
        },

        getObjectInfoFor: function(obj) {
            if (!obj.isObject())
                return null;

            // There are three ways to get the properties of an object

            // 1. Object is static and has registered it's properties via reference
            var staticProperties = obj.getStaticProperties();
            if (staticProperties)
                return staticProperties;

            // 1: Object is generic (any), then it carries it's information itself
            if (obj.isOfKind(Shade.OBJECT_KINDS.ANY)) {
                return obj.getNodeInfo();
            }


            // 3. Last chance: The object is an instance of a registered type,
            // then we get the information from it's kind
            return this.registry && this.registry.getInstanceForKind(obj.getKind()) || null;
        }

    });


    ns.exports = Scope;




}(module));

},{"../interfaces.js":123,"./annotation.js":85,"./errors.js":89,"./index.js":90,"./typeinfo.js":92,"estraverse":46}],92:[function(require,module,exports){
(function(ns){

    var Shade = require("../interfaces.js"),
        Syntax = require('estraverse').Syntax,
        Base = require("./index.js"),
        Set = require('analyses').Set;

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;


    /**
     * @param {*} node Carrier object for the type info, only node.extra gets polluted
     * @param {Object?} extra
     * @constructor
     */
    var TypeInfo = function (node, extra) {
        this.node = node;
        this.node.extra = this.node.extra || {};
        if (extra) {
            Base.shallowExtend(this.node.extra, extra);
        }
    }

    TypeInfo.createForContext = function(node, ctx) {
        var result = new TypeInfo(node);
        if (result.getType() !== TYPES.ANY) {
            return result;
        }

        if (node.type == Syntax.Identifier) {
            var name = node.name;
            var variable = ctx.getBindingByName(name);
            if (variable) {
                result.copy(variable);
            }
        }
        return result;
    }

       /**
     * @param {TypeInfo} typeInfo
     * @param {Object?} value
     */
    TypeInfo.copyStaticValue = function(typeInfo, value) {
        value = value || typeInfo.getStaticValue();
        // We don't have to copy primitive types
        if(!typeInfo.isObject())
            return value;
        switch(typeInfo.getKind()) {
            case KINDS.FLOAT2: return new Shade.Vec2(value);
            case KINDS.FLOAT3: return new Shade.Vec3(value);
            case KINDS.FLOAT4: return new Shade.Vec4(value);
            case KINDS.MATRIX3: return new Shade.Mat3(value);
            case KINDS.MATRIX4: return new Shade.Mat4(value);
            default: throw new Error("Can't copy static value of kind: " + typeInfo.getKind());
        }
    }

    TypeInfo.prototype = {
        getExtra: function () {
            return this.node.extra;
        },
        getType: function () {
            var extra = this.getExtra();
            if (extra.type != undefined)
                return extra.type;
            return TYPES.ANY;
        },

        setKind: function (kind) {
            var extra = this.getExtra();
            extra.kind = kind;
        },

        getKind: function () {
            if (!this.isObject())
                return null;
            return this.getExtra().kind || KINDS.ANY;
        },

        getUserData: function () {
            var extra = this.getExtra();
            if(!extra.userData) extra.userData = {};
            return extra.userData;
        },

        getArrayElementType: function () {
            if(!this.isArray())
                throw new Error("Called getArrayElementType on " + this.getType());
            return this.getExtra().elements;
        },

        isOfKind: function(kind) {
            if (!this.isObject()) {
                return false;
            }
            return this.getKind() == kind;
        },

        /**
         * @param {string} type
         * @param {string?} kind
         */
        setType: function (type, kind) {
            var extra = this.getExtra();
            extra.type = type;
            if (kind)
                this.setKind(kind);
            if(this.isValid())
                this.clearError();
        },

        setInvalid: function(message) {
            this.setType(TYPES.INVALID);
            if(message)
                this.setError(message);
        },

        isOfType: function (type) {
            return this.getType() == type;
        },

        equals: function (other) {
            return this.getType() == other.getType() && this.getKind() == other.getKind();
        },

        isInt: function () {
            return this.isOfType(TYPES.INT);
        },
        isNumber: function () {
            return this.isOfType(TYPES.NUMBER);
        },
        isValid: function () {
            return !this.isOfType(TYPES.INVALID);
        },
        isNullOrUndefined: function () {
            return this.isNull() || this.isUndefined();
        },
        isNull: function () {
            return this.isOfType(TYPES.NULL);
        },
        isUndefined: function () {
            return this.isOfType(TYPES.UNDEFINED);
        },
        isBool: function () {
            return this.isOfType(TYPES.BOOLEAN);
        },
        isString: function () {
            return this.isOfType(TYPES.STRING);
        },
        isArray: function () {
            return this.isOfType(TYPES.ARRAY);
        },
        isFunction: function () {
            return this.isOfType(TYPES.FUNCTION);
        },
        isObject: function () {
            return this.isOfType(TYPES.OBJECT);
        },
        isVector: function () {
            return this.isObject() && this.isOfKind(KINDS.FLOAT2) || this.isOfKind(KINDS.FLOAT3) || this.isOfKind(KINDS.FLOAT4);
        },
        isGlobal: function() {
            return !!this.getExtra().global;
        },
        setGlobal: function (global) {
            var extra = this.getExtra();
            extra.global = global;
        },
        isOutput: function(){
            return !!this.getExtra().output;
        },
        setOutput: function (output) {
            var extra = this.getExtra();
            extra.output = output;
        },
        canNumber: function () {
            return this.isNumber() || this.isInt() || this.isBool();
        },
        canInt: function () {
            return this.isInt() || this.isBool();
        },
        canObject: function () {
            return this.isObject() || this.isArray() || this.isFunction();
        },
        setCommonType: function(a,b) {
            if(a.equals(b)) {
                this.copy(a);
                return true;
            }
            if(a.canNumber() && b.canNumber()) {
                this.setType(TYPES.NUMBER)
                return true;
            }
            return false;
        },
        hasStaticValue : function() {
            var extra = this.getExtra();
            if (this.isNullOrUndefined())
                return true;
            return extra.hasOwnProperty("staticValue");
        },
        setStaticValue : function(v) {
            var extra = this.getExtra();
            if (this.isNullOrUndefined())
                throw new Error("Null and undefined have predefined values.");
            extra.staticValue = v;
        },
        canUniformExpression: function() {
            return this.hasStaticValue() || this.isUniformExpression();
        },

        isUniformExpression: function() {
            var extra = this.getExtra();
            return extra.hasOwnProperty("uniformDependencies")
        },
        setUniformDependencies: function() {
            var extra = this.getExtra();
            var dependencies = new Set();
            var args = Array.prototype.slice.call(arguments);
            args.forEach(function(arg) {
               if(Array.isArray(arg))
                   dependencies = Set.union(dependencies, arg);
                else
                   dependencies.add(arg);
            });
            extra.uniformDependencies = dependencies.values();
        },
        getUniformDependencies: function() {
            var extra = this.getExtra();
            return extra.uniformDependencies || [];
        },
        getUniformCosts: function() {
            var extra = this.getExtra();
            return extra.uniformCosts | 0;
        },
        setUniformCosts: function(costs) {
            var extra = this.getExtra();
            extra.uniformCosts = costs;
        },
        clearUniformDependencies: function() {
            var extra = this.getExtra();
            delete extra.uniformDependencies;
        },
        getStaticValue : function() {
            if (!this.hasStaticValue()) {
                throw new Error("Node has no static value: " + this.node);
            }
            if (this.isNull())
                return null;
            if (this.isUndefined())
                return undefined;
            return this.getExtra().staticValue;
        },
        setDynamicValue : function() {
            delete this.getExtra().staticValue;
        },
        setCall : function(call) {
            var extra = this.getExtra();
            extra.evaluate = call;
        },
        getCall : function() {
            return this.getExtra().evaluate;
        },
        clearCall: function() {
            var extra = this.getExtra();
            delete extra.evaluate;
        },
        copy: function(other) {
            this.setFromExtra(other.getExtra());
        },
        str: function() {
            var extra = this.getExtra();
            return JSON.stringify(extra, null, 1);
        },
        canNormal: function() {
            return this.isObject() && (this.isOfKind(KINDS.NORMAL) || this.isOfKind(KINDS.FLOAT3));
        },
        canColor: function() {
            return this.isObject() && (this.isOfKind(KINDS.FLOAT4) || this.isOfKind(KINDS.FLOAT3));
        },
        hasError : function() {
            return this.getError() != null;
        },
        getError : function() {
            var extra = this.getExtra();
            return extra.error;
        },
        setError : function(err) {
            var extra = this.getExtra();
            extra.error = err;
        },
        clearError : function() {
            var extra = this.getExtra();
            extra.error = null;
        },
        setFromExtra: function(extra){
            Base.shallowExtend(this.node.extra, extra);
            // Set static object extra: This might be an object
            if (extra.staticValue != undefined) {
                this.setStaticValue(TypeInfo.copyStaticValue(this, extra.staticValue));
            }
        },
        getNodeInfo: function() {
            if (this.isObject())
                return this.getExtra().info;
        },
        setNodeInfo: function(info) {
            if (!this.isObject())
                throw new Error("Only objects may have a node info");
            this.getExtra().info = info;
        },
        getTypeString: function() {
            if (this.isObject()) {
                return this.isOfKind(KINDS.ANY) ? "Object" : ("Object #<" + this.getKind() + ">");
            }
            return this.getType();
        },
        /**
         * Get the internal type as JavaScript type
         * @returns {string}
         */
        getJavaScriptTypeString: function() {
            //noinspection FallthroughInSwitchStatementJS
            switch (this.getType()) {
                case TYPES.INT:
                case TYPES.FLOAT:
                case TYPES.NUMBER:
                    return "number";
                case TYPES.OBJECT:
                case TYPES.ARRAY:
                    return "object";
                case TYPES.STRING:
                    return "string";
                case TYPES.UNDEFINED:
                    return "undefined";
                default:
                    // TODO: For debug we use this now, should throw an exception
                    return "?" + this.getType();
            }
        },
        setSource: function(source) {
            var extra = this.getExtra();
            extra.source = source;
        },
        getSource: function() {
            return this.getExtra().source;
        },
        getStaticProperties: function() {
            // Only bound object have static properties (Math, Shade etc)
            return null;
        },
        isDerived: function() {
            return this.getExtra().derived == true;
        },
        getStaticTruthValue: function() {
            // !!undefined == false;
            if (this.isNullOrUndefined())
                return false;
            // !!{} == true
            if (this.canObject())
                return true;
            // In all other cases, it depends on the value,
            // thus we can only evaluate this for static objects
            if (this.hasStaticValue()) {
                return !!this.getStaticValue();
            }
            return undefined;
        },
        setSemantic: function(sem) {
            this.getExtra().semantic = sem;
        },
        getSemantic: function(sem) {
            return this.getExtra().semantic;
        }

    }




    ns.TypeInfo = TypeInfo;

}(exports));

},{"../interfaces.js":123,"./index.js":90,"analyses":1,"estraverse":46}],93:[function(require,module,exports){
(function(ns){

    ns.swizzleToIndex = function(swizzleKey){
        switch(swizzleKey){
            case 'x':case 'r' :case 's': return 0;
            case 'y':case 'g' :case 't': return 1;
            case 'z':case 'b' :case 'p': return 2;
            case 'w':case 'a' :case 'q': return 3;
        }
        throw new Error("Unknown swizzle key: '" + swizzleKey + "'");
    };
    ns.indexToSwizzle = function(index){
        switch(index){
            case 0: return 'x';
            case 1: return 'y';
            case 2: return 'z';
            case 3: return 'w';
        }
        throw new Error("Unknown swizzle index: '" + index + "'");
    };
    ns.swizzleSets = [
        ['x', 'y', 'z', 'w'],
        ['r', 'g', 'b', 'a'],
        ['s', 't', 'p', 'q']
    ];
    ns.swizzleOperators = {
        'Add' : '+',
        'Sub' : '-',
        'Mul' : '*',
        'Div' : '/'
    }


}(exports))

},{}],94:[function(require,module,exports){
(function(ns){

    var OneParameterNumberMethods = ["acos", "asin", "atan", "cos", "exp", "log", "round", "sin", "sqrt", "tan", "ceil", "floor"];

    function oneParameterFunction(name) {

        var func = Math[name];

        return function(vec) {
            var length = vec.length,
                result = new Float32Array(length);
            while(length--) {
                result[length] = func(vec[length]);
            }
            return result;
        }
    }

    var VecMath = {
        mix : function(x,y,a) {
            var length = x.length,
                result = new Float32Array(length),
                oneMinusA;

            if (Array.isArray(a) && a.length >= length) {
                while(length--) {
                    var a = a[length];
                    result[length] = x[length] * (1 - a) + y[length] * a;
                }
            } else {
                oneMinusA = 1 - a;
                while(length--) {
                    result[length] = x[length] * oneMinusA + y[length] * a;
                }
            }
            return result;

        },
        step : function(edge, x) {
            var length = edge.length,
                result = new Float32Array(length);

            while(length--) {
                var e = edge[length];
                var x0 = x[length];
                result[length] = (x0 <= e) ? 0 : 1;
            }
            return result;
        },
        smoothstep : function(edge0, edge1, x) {
            var length = edge0.length,
                result = new Float32Array(length);

            while(length--) {
                var e0 = edge0[length];
                var e1 = edge1[length];
                var x0 = x[length];
                var t = Math.clamp((x0 - e0) / (e1 - e0), 0.0, 1.0);
                result[length] = t * t * (3.0 - 2.0 * t);
            }
            return result;
        }
    };

    OneParameterNumberMethods.forEach(function(name) {
        VecMath[name] = oneParameterFunction(name);
    });

    ns.VecMath = VecMath;


}(exports));

},{}],95:[function(require,module,exports){
(function (ns) {

    ns.extend = function(dest){
        var vec2 = dest.vec2;
        var vec3 = dest.vec3;
        var vec4 = dest.vec4;
        var mat2 = dest.mat2;
        var mat3 = dest.mat3;
        var mat4 = dest.mat4;

        vec2.setLength = function(dest, a, b){
            var length = vec2.length(a);
            if(!length) return;
            vec2.scale(dest, a, b / length);
        };
        vec3.setLength = function(dest, a, b){
            var length = vec3.length(a);
            if(!length) return;
            vec3.scale(dest, a, b / length);
        };
        vec4.setLength = function(dest, a, b){
            var length = vec4.length(a);
            if(!length) return;
            vec4.scale(dest, a, b / length);
        };


        vec2.copyArray = function(dest, array, i){
            var off = 2*i;
            vec2.set(dest, array[off], array[off+1]);
        };
        vec3.copyArray = function(dest, array, i){
            var off = 3*i;
            vec3.set(dest, array[off], array[off+1], array[off+2]);
        };
        vec4.copyArray = function(dest, array, i){
            var off = 4*i;
            vec4.set(dest, array[off], array[off+1], array[off+2], array[off+3]);
        };
        mat3.copyArray = function(dest, array, i){
            var j = 9;
            var off = j*i;
            while(j--){
                dest[j] = array[off+j];
            }
        };
        mat4.copyArray = function(dest, array, i){
            var j = 16;
            var off = j*i;
            while(j--){
                dest[j] = array[off+j];
            }
        };
        vec2.pasteArray = function(dest, i, value){
            var off = 2*i;
            dest[off] = value[0];
            dest[off+1] = value[1];
        };
        vec3.pasteArray = function(dest, i, value){
            var off = 3*i;
            dest[off] = value[0];
            dest[off+1] = value[1];
            dest[off+2] = value[2];
        };
        vec4.pasteArray = function(dest, i, value){
            var off = 3*i;
            dest[off] = value[0];
            dest[off+1] = value[1];
            dest[off+2] = value[2];
            dest[off+3] = value[3];
        };
        mat3.pasteArray = function(dest, i, value){
            var j = 9;
            var off = j*i;
            while(j--){
                dest[off+j] = value[j];
            }
        };
        mat4.pasteArray = function(dest, i, value){
            var j = 16;
            var off = j*i;
            while(j--){
                dest[off+j] = value[j];
            }
        };
    };

}(exports));

},{}],96:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.2.1
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function(_global) {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = typeof(window) !== 'undefined' ? window : _global;
    }
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

if(!GLMAT_ARRAY_TYPE) {
    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
}

if(!GLMAT_RANDOM) {
    var GLMAT_RANDOM = Math.random;
}

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

if(typeof(exports) !== 'undefined') {
    exports.glMatrix = glMatrix;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new GLMAT_ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new GLMAT_ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = GLMAT_RANDOM() * 2.0 * Math.PI;
    var z = (GLMAT_RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/*
* Rotate a 3D vector around the x-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/*
* Rotate a 3D vector around the y-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/*
* Rotate a 3D vector around the z-axis
* @param {vec3} out The receiving vec3
* @param {vec3} a The vec3 point to rotate
* @param {vec3} b The origin of the rotation
* @param {Number} c The angle of rotation
* @returns {vec3} out
*/
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = GLMAT_RANDOM();
    out[1] = GLMAT_RANDOM();
    out[2] = GLMAT_RANDOM();
    out[3] = GLMAT_RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;


/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

if(typeof(exports) !== 'undefined') {
    exports.mat2d = mat2d;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new GLMAT_ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new GLMAT_ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[7]-m[5])*fRoot;
        out[1] = (m[2]-m[6])*fRoot;
        out[2] = (m[3]-m[1])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;













  })(shim.exports);
})(this);

},{}],97:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var common = require("../../base/common.js");
    var Shade = require("../../interfaces.js");

    // Shortcuts
    var Syntax = common.Syntax;

    function generateFloat(value) {
        if (isNaN(value))
            throw Error("Internal: Expression generated NaN!");
        var result = '' + value;
        if (result.indexOf(".") == -1 && result.indexOf("e") == -1) {
            result += ".0";
        }
        return result;
    }

    /**
     *
     * @param controller
     * @param {object?} options
     * @constructor
     */
    var ExpressionHandler = function (controller, options) {
        this.controller = controller;
        this.controller.generateFloat = this.controller.generateFloat || generateFloat;
        this.options = options || {};
    };

    ExpressionHandler.prototype = {
        binary: function (node) {
            var result = this.expression(node);
            //noinspection FallthroughInSwitchStatementJS
            switch (node.type) {
                case Syntax.BinaryExpression:
                case Syntax.LogicalExpression:
                case Syntax.AssignmentExpression:
                case Syntax.ConditionalExpression:
                    result = "( " + result + " )";
                    break;
            }
            return result;
        },
        arguments: function (container) {
            var result = "(";
            container.forEach(function (arg, index) {
                result += this.expression(arg);
                if (index < container.length - 1) {
                    result += ", ";
                }
            }, this);
            return result + ")";
        },
        literal: function (extra, alternative) {
            var extra = extra || {},
                value = extra.staticValue !== undefined ? extra.staticValue : alternative;

            if (extra.type == Shade.TYPES.NUMBER)
                return this.controller.generateFloat(value); else
                return value;
        },
        expression: function (node) {
            if (!node) return "";

            var result = "";

            //noinspection FallthroughInSwitchStatementJS
            switch (node.type) {
                case Syntax.NewExpression:
                    result = this.controller.type(node.extra, { constructor: true });
                    result += this.arguments(node.arguments);
                    break;

                case Syntax.Literal:
                    result = this.literal(node.extra, node.value);
                    break;

                case Syntax.Identifier:
                    result = node.name;
                    break;

                case Syntax.AssignmentExpression:
                case Syntax.BinaryExpression:
                case Syntax.LogicalExpression:
                    result += this.binary(node.left);
                    result += " " + node.operator + " ";
                    result += this.binary(node.right);
                    break;
                case Syntax.UnaryExpression:
                    result = node.operator;
                    result += this.binary(node.argument);
                    break;

                case Syntax.CallExpression:
                    result = this.expression(node.callee);
                    result += this.arguments(node.arguments);
                    break;

                case Syntax.MemberExpression:
                    result = this.binary(node.object);
                    result += node.computed ? "[" : ".";
                    result += this.expression(node.property);
                    node.computed && (result += "]");
                    break;

                case Syntax.ConditionalExpression:
                    result = this.expression(node.test);
                    result += " ? ";
                    result += this.expression(node.consequent);
                    result += " : ";
                    result += this.expression(node.alternate);
                    break;

                case Syntax.UpdateExpression:
                    result = "";
                    if (node.isPrefix) {
                        result += node.operator;
                    }
                    result += this.expression(node.argument);
                    if (!node.isPrefix) {
                        result += node.operator;
                    }
                    break;
                case Syntax.ExpressionStatement:
                    result = this.expression(node.expression);
                    break;
                default:
                    result = "<unhandled: " + node.type + ">"
            }
            return result;
        },
        statement: function (node) {
            var result = "unhandled statement";
            switch (node.type) {
                case Syntax.ReturnStatement:
                    var hasArguments = node.argument;
                    result = "return" + (hasArguments ? (" " + this.expression(node.argument)) : "") + ";";
                    break;
            }
            return result;
        }
    };

    // Exports
    ns.ExpressionHandler = ExpressionHandler;


}(exports));

},{"../../base/common.js":87,"../../interfaces.js":123}],98:[function(require,module,exports){
(function (ns) {

    var Base = require("../../base/index.js"),
        codegen = require("escodegen");

    var Simplifier = require("../simple-statement/simple-statement.js");
    var Transformer = require("./transform.js").GLMatrixTransformer;


    var GLMatrixCompiler = function () {

    };

    Base.extend(GLMatrixCompiler.prototype, {

        compile: function (aast, opt) {
            opt = opt || {};

            aast = Simplifier.simplifyStatements(aast, opt);

            aast = new Transformer().transform(aast);

            var code = codegen.generate(aast, opt);

            return code;
        }

    });


    ns.GLMatrixCompiler = GLMatrixCompiler;

}(exports));

},{"../../base/index.js":90,"../simple-statement/simple-statement.js":116,"./transform.js":99,"escodegen":9}],99:[function(require,module,exports){
(function (ns) {

    var Base = require("../../base/index.js"),
        common = require("../../base/common.js"),
        Shade = require("./../../interfaces.js"),
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS,
        analyses = require('analyses'),
        Tools = require('../tools.js'),
        assert = require('assert');


    var walk = require('estraverse');
    var Syntax = walk.Syntax;
    var ANNO = common.ANNO;
    var Map = common.Map;
    var Set = analyses.Set;


    /**
     * Transforms the JS AST to an AST representation convenient
     * for code generation
     * @constructor
     */
    var GLMatrixTransformer = function () {

    };

    Base.extend(GLMatrixTransformer.prototype, {

        transform: function (aast) {

            return this.replace(aast);
        },
        /**
         *
         * @param {Object!} ast
         * @returns {*}
         */
        replace: function(aast) {
            var controller = new walk.Controller();

            return controller.replace(aast, {

                enter: function (node, parent) {

                },

                leave: function(node, parent) {
                    switch(node.type) {
                        case Syntax.VariableDeclarator:
                            return leaveVariableDeclarator(node, parent);
                        case Syntax.CallExpression:
                            return leaveCallExpression(node, parent);
                        case Syntax.AssignmentExpression:
                            return leaveAssignmentExpression(node);
                        case Syntax.FunctionDeclaration:
                        case Syntax.FunctionDeclaration:
                            return leaveFunction(node, parent);
                    }
                }
            });
        }
    });

    function leaveFunction(node, parent){
        var declarators = [];
        addMathLinkDeclaration(declarators, "vec2");
        addMathLinkDeclaration(declarators, "vec3");
        addMathLinkDeclaration(declarators, "vec4");
        addMathLinkDeclaration(declarators, "mat3");
        addMathLinkDeclaration(declarators, "mat4");
        var declaration = {
            type: Syntax.VariableDeclaration, kind: "var",
            declarations: declarators
        };
        node.body.body.unshift(declaration);
        return node;
    }

    function addMathLinkDeclaration(dest, name){
        dest.push({ type: Syntax.VariableDeclarator,
            id: {type: Syntax.Identifier, name: name},
            init: {
                type: Syntax.MemberExpression, computed: false,
                object: { type: Syntax.MemberExpression, computed: false,
                        object: { type: Syntax.Identifier, name: "Shade"},
                        property: { type: Syntax.Identifier, name: "Math"}},
                property: {type: Syntax.Identifier, name: name}
            }
        });
    }

    function leaveVariableDeclarator(node, parent){
        var nodeAnno = ANNO(node);

        var glObject = getGlMatrixObject(nodeAnno.getKind());
        if(glObject){
            node.init = getCallExpression(glObject, "create", []);
            return node;
        }
    }

    function leaveCallExpression(node, parent){
        if(node.callee.type != Syntax.MemberExpression)
            return;
        var nodeAnno = ANNO(node);
        var objectAnno = ANNO(node.callee.object);
        var methodName = node.callee.property.name;

        var glObject = getGlMatrixObject(objectAnno.getKind());
        if(nodeAnno.getType() != Types.OBJECT && glObject){
            var componentIndex = getComponentIndex(methodName);
            var result;
            if(componentIndex !== undefined){
                result = getArrayAccessAst(node.callee.object, componentIndex);
            }
            else{
                var glMethodName = getScalarGlMethodName(glObject, methodName);
                var arguments = [node.callee.object];
                arguments.push.apply(arguments, node.arguments);
                result = getCallExpression(glObject, glMethodName, arguments);
            }
            ANNO(result).copy(ANNO(node));
            return result;
        }
    }
    function getComponentIndex(methodName){
        switch(methodName){
            case "x": return 0;
            case "y": return 1;
            case "z": return 2;
            case "w": return 3;
        }
        return undefined;
    }

    function leaveAssignmentExpression(node, parent){
        var destAnno = ANNO(node);
        if(destAnno.getType() != Types.OBJECT) return;

        if(node.right.type == Syntax.NewExpression){
            return leaveAssignmentNew(node, parent);
        }
        else if(node.right.type == Syntax.CallExpression
                && node.right.callee.type == Syntax.MemberExpression &&
                getGlMatrixObject(ANNO(node.right.callee.object).getKind())){
            return leaveAssignmentCall(node, parent);
        }
        else{
            return leaveAssignmentCopy(node, parent);
        }

    }

    function leaveAssignmentNew(node, parent){
        var destAnno = ANNO(node);
        var glObject = getGlMatrixObject(destAnno.getKind());

        var arguments = [node.left];

        var nodeArgs = node.right.arguments;
        for(var i = 0; i < nodeArgs.length; ++i){
            pushArgComponents(arguments, nodeArgs[i]);
        }
        if(arguments.length == 1){
            arguments.push({
                type: Syntax.Literal,
                value: 0,
                raw: "0"
            });
        }
        var expectedArgLength = 1 + getComponents(destAnno);


        while(arguments.length < expectedArgLength){
            arguments.push(Base.deepExtend({},arguments[arguments.length-1]));
        }

        var result = getCallExpression(glObject, "set", arguments);
        ANNO(result).copy(ANNO(node));
        return result;
    }

    function leaveAssignmentCall(node, parent){
        var objectAnno = ANNO(node.right.callee.object);
        var glObject = getGlMatrixObject(objectAnno.getKind());
        var methodName = node.right.callee.property.name;

        return getObjectGlMethodCall(objectAnno.getKind(), methodName, node.left, node.right.callee.object, node.right.arguments);
    }

    function leaveAssignmentCopy(node, parent){
        var destAnno = ANNO(node);
        var glObject = getGlMatrixObject(destAnno.getKind());
        var arguments = [];

        if(isArrayAccess(node.left)){
            arguments.push(node.left.object);
            arguments.push(node.left.property);
            arguments.push(node.right);
            return getCallExpression(glObject, "pasteArray", arguments);
        }
        else{
            arguments.push(node.left);
            if(isArrayAccess(node.right)){
                arguments.push(node.right.object);
                arguments.push(node.right.property);
                return getCallExpression(glObject, "copyArray", arguments);
            }
            else{
                arguments.push(node.right);
                return getCallExpression(glObject, "copy", arguments);
            }
        }

    }


    function isArrayAccess(node){
        return node.type == Syntax.MemberExpression && ANNO(node.object).isArray();
    }


    function pushArgComponents(dest, arg){
        var components = getComponents(ANNO(arg));
        if(components == 1){
            dest.push(arg);
            return;
        }
        for(var i = 0; i < components; ++i){
            dest.push(getArrayAccessAst(arg, i));
        }
    }



    function getComponents(anno){
        var type = anno.getType(), kind = anno.getKind();
        if(type == Types.NUMBER || type == Types.INT)
            return 1;
        switch(kind){
            case Kinds.FLOAT2: return 2;
            case Kinds.FLOAT3: return 3;
            case Kinds.FLOAT4: return 4;
            case Kinds.MATRIX3: return 9;
            case Kinds.MATRIX4: return 16;
        }
    }

    function getGlMatrixObject(kind){
        switch(kind){
            case Kinds.FLOAT2: return "vec2";
            case Kinds.FLOAT3: return "vec3";
            case Kinds.FLOAT4: return "vec4";
            case Kinds.MATRIX3: return "mat3";
            case Kinds.MATRIX4: return "mat4";
        }
        return null;
    }

    function getMemberExpression(objectName, propertyName ){
        return {type: Syntax.MemberExpression, object: {type: Syntax.Identifier, name: objectName},
                    property: {type: Syntax.Identifier, name: propertyName}
                }
    }
    function getCallExpression(objectName, propertyName, arguments ){
        return { type: Syntax.CallExpression,
            callee: getMemberExpression(objectName, propertyName),
            arguments: arguments
        };
    }

    function getArrayAccessAst(object, index){
        return {type: Syntax.MemberExpression, object: object, computed: true,
             property: {type: Syntax.Literal, value: index, raw: index}};
    }



    function getScalarGlMethodName(glObject, methodName){
        switch(methodName){
            case "dot": return "dot";
            case "length" : return "length";
        }
        throw new Error("Unknown glMatrix method with scalar output: '" + methodName + "'");
    }

    function getObjectGlMethodCall(objectKind, methodName, destObj, srcObj, arguments){
        var actualKind = objectKind, method, srcAfterArgs = false;
        switch(methodName){
            case "add": method = "add"; break;
            case "sub": method = "sub"; break;
            case "mul": method = "mul"; break;
            case "div": method = "div"; break;
            case "max": method = "max"; break;
            case "min" : method = "min"; break;
            case "length": method = "setLength"; break;
            case "normalize" : method = "normalize"; break;
            case "mulVec" : switch(objectKind){
                    case Kinds.MATRIX3: actualKind= Kinds.FLOAT3; method = "transformMat3"; break;
                    case Kinds.MATRIX4: actualKind= Kinds.FLOAT4; method = "transformMat4"; break;
                }
                srcAfterArgs = true;
            break;
            default:
                throw new Error("Unknown glMatrix method with object output: '" + methodName + "'");
        }
        var args = [destObj];
        if(!srcAfterArgs) args.push(srcObj);
        args.push.apply(args, arguments);
        if(srcAfterArgs) args.push(srcObj);
        var glObject = getGlMatrixObject(actualKind);
        return getCallExpression(glObject, method, args);
    }

    // Exports
    ns.GLMatrixTransformer = GLMatrixTransformer;


}(exports));

},{"../../base/common.js":87,"../../base/index.js":90,"../tools.js":121,"./../../interfaces.js":123,"analyses":1,"assert":47,"estraverse":46}],100:[function(require,module,exports){
(function (ns) {

    var Base = require("../../base/index.js");

    var Transformer = require("./transform.js").GLASTTransformer;
    var generate = require("./glsl-generate.js").generate;

    var GLSLCompiler = function () {

    };

    Base.extend(GLSLCompiler.prototype, {

        compileFragmentShader: function (aast, opt) {
            opt = opt || {};

            var transformer = new Transformer(aast, "global.shade", false, opt);

            //console.log(JSON.stringify(aast, 0, " "));

            var transformed = transformer.transform(aast);

            //console.log(JSON.stringify(aast, 0, " "));

            opt.headers = transformed.headers;
            var code = generate(transformed.program, false, opt);

            return {source: code, uniformSetter: transformed.uniformSetter};
        },
        compileVertexShader: function (aast, opt) {
            opt = opt || {};

            var transformer = new Transformer(aast, "global.main", true, opt);

            //console.log(JSON.stringify(aast, 0, " "));

            var transformed = transformer.transform(aast);

            //console.log(JSON.stringify(aast, 0, " "));

            opt.headers = transformed.headers;
            var code = generate(transformed.program, true, opt);

            return {source: code, uniformSetter: transformed.uniformSetter};
        }

    });


    ns.GLSLCompiler = GLSLCompiler;

}(exports));

},{"../../base/index.js":90,"./glsl-generate.js":101,"./transform.js":113}],101:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var FunctionAnnotation = require("./../../base/annotation.js").FunctionAnnotation;
    var Shade = require("./../../interfaces.js");
    var walk = require('estraverse');
    var ExpressionHandler = require('../base/expression-handler.js').ExpressionHandler,
        Syntax = walk.Syntax,
        VisitorOption = walk.VisitorOption,
        ANNO = require("../../base/annotation.js").ANNO;


    // Shortcuts
    var Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS,
        Sources = Shade.SOURCES;

    var InternalFunctions = {
        "MatCol" : function(name, details){
            var matType = details.matType,
                colType = details.colType;
            return [matType + " " + name + "(" + matType + " mat, int idx, " + colType + " value){",
                  "  " + matType + " result = " + matType + "(mat);",
                  "  result[idx] = value;",
                  "  return result;",
                  "}"];
        }
    }

    var GLSL = {
        Storage: {
            CONST: "const",
            UNIFORM: "uniform",
            VARYING: "varying",
            ATTRIBUTE: "attribute"
        }
    }

    var handler = new ExpressionHandler( {
        type: toGLSLType
    });


    /**
     * @param {object} opt
     */
    var getHeader = function (opt) {
        if (opt.omitHeader == true)
            return [];
        var header = [
            "// Generated by shade.js"
        ];
        if (opt.headers)
            header = header.concat(opt.headers)
        var floatPrecision = opt.floatPrecision || "highp";
        header.push("precision " + floatPrecision + " float;");
        header.push("");
        return header;
    }

    function toGLSLType(info, options) {
        if(!info) return "?";
        options = options || {};

        switch (info.type) {
            case Types.OBJECT:
                switch (info.kind) {
                    case Kinds.FLOAT4:
                        return "vec4";
                    case Kinds.FLOAT3:
                        return "vec3";
                    case Kinds.FLOAT2:
                        return "vec2";
                    case Kinds.TEXTURE:
                        return "sampler2D";
                    case Kinds.MATRIX3:
                        return "mat3";
                    case Kinds.MATRIX4:
                        return "mat4";
                    case Kinds.COLOR_CLOSURE:
                        return "vec4";
                    default:
                        return "<undefined>";
                }
            case Types.ARRAY:
                return toGLSLType(info.elements, options);

            case Types.UNDEFINED:
                if (options.allowUndefined)
                    return "void";
                throw new Error("Could not determine type");
            case Types.NUMBER:
                return "float";
            case Types.BOOLEAN:
                return "bool";
            case Types.INT:
                return "int";
            default:
                //throw new Error("toGLSLType: Unhandled type: " + info.type);
                return info.type;

        }
    }

    var toGLSLStorage = function(info, vertexShader) {
        if (!info.source)
            return null;
        if (info.source == Sources.VERTEX){
            if(vertexShader && !info.output)
                return GLSL.Storage.ATTRIBUTE;
            else
                return GLSL.Storage.VARYING;
        }
         if (info.source == Sources.UNIFORM)
            return GLSL.Storage.UNIFORM;
        if (info.source == Sources.CONSTANT)
            return GLSL.Storage.CONST;
        throw new Error("toGLSLSource: Unhandled type: " + info.source);
    }

    function filterUndefined(arr) {
        return arr.filter(function(n) { return n.extra.type != Types.UNDEFINED; });
    }

    function createLineStack() {
        var arr = [];
        arr.push.apply(arr, arguments);
        var indent = "";
        arr.appendLine = function(line){
            line ? this.push(indent + line) : this.push("");
        };
        arr.changeIndention = function(add){
            while(add > 0){
                indent += "    "; add--;
            }
            if(add < 0){
                indent = indent.substr(0, indent.length + add*4);
            }
        };
        arr.append = function(str){
            this[this.length-1] = this[this.length-1] + str;
        };
        return arr;
    };


    /*Base.extend(LineStack.prototype, {

    });*/

    var generate = function (ast, vertexshader, opt) {

        opt = opt || {};

        var lines = createLineStack();

        traverse(ast, lines, vertexshader, opt);

        return lines.join("\n");
    }

    function appendInternalFunctions(lines, internalFunctions){
        if(!internalFunctions) return;
        for(var key in internalFunctions){
            var entry = internalFunctions[key];
            if(InternalFunctions[entry.type]){
                var linesToAdd = InternalFunctions[entry.type](entry.name, entry.details);
                lines.push.apply(lines, linesToAdd);
            }
            else{
                throw Error("Internal: InlineFunction of type '" + entry.type + "' not available!");
            }
        }
    }

    function traverse(ast, lines, vertexShader, opt) {
        var insideMain = false;


        walk.traverse(ast, {
                enter: function (node) {
                    try {
                        var type = node.type;
                        switch (type) {

                            case Syntax.Program:
                                getHeader(opt).forEach(function (e) {
                                    lines.push(e)
                                });
                                appendInternalFunctions(lines, ANNO(ast).getUserData().internalFunctions);
                                addForwardDeclarations(lines, node);
                                break;


                            case Syntax.FunctionDeclaration:
                                opt.newLines && lines.appendLine();
                                if(node.id.name == "main")
                                    insideMain = true;

                                lines.appendLine(generateFunctionSignature(node) + " {");
                                lines.changeIndention(1);
                                return;


                            case Syntax.ReturnStatement:
                                lines.appendLine(handler.statement(node));
                                return;

                            case Syntax.VariableDeclarator :
                                // console.log("Meep!");
                                var decl = handleVariableDeclaration(node, insideMain, vertexShader, opt);
                                lines.appendLine(decl);
                                return;

                            case Syntax.AssignmentExpression:
                            case Syntax.ExpressionStatement:
                                lines.appendLine(handler.expression(node) + ";")
                                return VisitorOption.Skip;;

                            case Syntax.IfStatement:
                                lines.appendLine("if(" + handler.expression(node.test, opt) + ") {");

                                lines.changeIndention(1);
                                traverse(node.consequent, lines, opt);
                                lines.changeIndention(-1);

                                if (node.alternate) {
                                    lines.appendLine("} else {");
                                    lines.changeIndention(1);
                                    traverse(node.alternate, lines, opt);
                                    lines.changeIndention(-1);
                                }
                                lines.appendLine("}");
                                return VisitorOption.Skip;

                            case Syntax.ForStatement:
                                lines.appendLine("for (" + handleInlineDeclaration(node.init, opt) + "; " + handler.expression(node.test, opt) +"; " + handler.expression(node.update, opt) + ") {");
                                lines.changeIndention(1);
                                traverse(node.body, lines, opt);
                                lines.changeIndention(-1);
                                lines.appendLine("}");
                                return VisitorOption.Skip;

                            case Syntax.ContinueStatement:
                                lines.appendLine("continue;");
                                return;
                            case Syntax.BreakStatement:
                                lines.appendLine("break;");
                                return;


                            default:
                            //console.log("Unhandled: " + type);

                        }
                    } catch (e) {
                        throw e;//console.error(e);
                        //Shade.throwError(node, e.message);
                    }
                },
                leave: function (node) {
                    var type = node.type;
                    switch (type) {
                        case Syntax.Program:
                            break;
                        case Syntax.FunctionDeclaration:
                            lines.changeIndention(-1);
                            lines.appendLine("}");
                            break;
                    }
                }
            }
        );
    }

    function addForwardDeclarations(lines, node) {
        var first = true;
        walk.traverse(node, {
            enter: function(node) {
                if(node.type == Syntax.FunctionDeclaration) {
                    if(node.id.name == "main") {
                        return;
                    }
                    if (first) {
                        first = false;
                        lines.appendLine("// Forward declarations");
                    }
                    lines.appendLine(generateFunctionSignature(node)+";");
                }
            }
        });
        if(!first) {
            lines.appendLine("");
        }
    }

    function generateFunctionSignature(node) {
        var func = new FunctionAnnotation(node);
        var methodStart = [toGLSLType(func.getReturnInfo(), { allowUndefined: true })];
        methodStart.push(node.id.name, '(');
        if (!(node.params && node.params.length)) {
            methodStart.push("void");
        } else {
            var methodArgs = [];
            node.params.forEach(function (param) {
                methodArgs.push(toGLSLType(param.extra) + " " + param.name);
            })
            methodStart.push(methodArgs.join(", "));
        }
        methodStart.push(")");
        return methodStart.join(" ");
    }

    function getStaticValue(extra) {
        if (!extra || extra.staticValue === undefined) return "";
        return extra.staticValue;
    };

    function handleVariableDeclaration(node, writeStorageQualifier, vertexShader, opt) {
        var storageQualifier = !writeStorageQualifier ? toGLSLStorage(node.extra, vertexShader) : null;
        var result = storageQualifier ? storageQualifier + " " : "";
        result += toGLSLType(node.extra) + " " + node.id.name;
        if (node.extra.elements) {
            result += "[" + (node.extra.staticSize ? node.extra.staticSize : "0") + "]";
        }
        if (node.init) result += " = " + handler.expression(node.init);
        if (!node.init && storageQualifier == GLSL.Storage.CONST) {
            result += " = " + getStaticValue(node.extra);
        }
        return result + ";";
    }


    function handleInlineDeclaration(node, opt) {
        if(!node)
            return "";
        if (node.type == Syntax.VariableDeclaration) {
            var result = node.declarations.reduce(function (declString, declaration) {
                var decl = toGLSLType(declaration.extra) + " " + declaration.id.name;
                if (declaration.init) {
                    decl += " = " + handler.expression(declaration.init);
                }
                return declString + decl;
            }, "");
            return result;
        }

        // GLSL allows only declaration in init, but since this is a new scope, it should be fine
        if (node.type == Syntax.AssignmentExpression) {
            return toGLSLType(node.extra) + " " + handler.expression(node.left) + " = " + handler.expression(node.right);
        }
        Shade.throwError(node, "Internal error in GLSL::handleInlineDeclaration, found " + node.type);
    }





    exports.generate = generate;


}(exports));

},{"../../base/annotation.js":85,"../base/expression-handler.js":97,"./../../base/annotation.js":85,"./../../interfaces.js":123,"estraverse":46}],102:[function(require,module,exports){
(function(ns) {

    var Scope = require("../../../base/scope.js"),
        Context = require("../../../base/context.js"),
        Base = require("../../../base/index.js"),
        Shade = require("../../../interfaces.js"),
        TypeInfo = require("../../../base/typeinfo.js").TypeInfo,
        common = require("../../../base/common.js");


    var Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS;

    var objects = {
        Shade : require("./shade.js"),
        Space : require("./space.js"),
        Math : require("./math.js"),
        System : require("./system.js"),
        Vec2 : require("./vec2.js"),
        Vec3 : require("./vec3.js"),
        Color: require("./vec3.js"),
        Vec4 : require("./vec4.js"),
        Mat3 : require("./mat3.js"),
        Mat4 : require("./mat4.js"),
        Texture : require("./texture.js")
    };

    var Registry = {
        name: "GLSLTransformRegistry",
        getByName: function(name) {
            var result = objects[name];
            return result || null;
        },
        getInstanceForKind: function(kind) {
            for(var obj in objects) {
                //noinspection JSUnfilteredForInLoop
                if (objects[obj].kind == kind) {
                    //noinspection JSUnfilteredForInLoop
                    return objects[obj].instance;
                }
            }
            return null;
        }
    };


    /**
     * @param root
     * @param {string} entry
     * @param opt
     * @extends {Context}
     * @constructor
     */
    var GLTransformContext = function(root, entry, vertexShader, opt) {
        opt.mainFunction = entry;
        Context.call(this, root, opt);
        this.usedParameters = {
            shader: {},
            system: {},
            uexp: {}
        };

        this.uniformExpressions = opt.uniformExpressions || {};

        this.vertexShader = vertexShader;
        this.systemParameters = {};
        this.blockedNames = [];
        this.topDeclarations = [];
        this.internalFunctions = {};
        this.idNameMap = {};
        this.headers = []; // Collection of header lines to define

        this.globalParameters = root.globalParameters && root.globalParameters[entry] && root.globalParameters[entry][0] ? root.globalParameters[entry][0].extra.info : {};


    };

    Base.createClass(GLTransformContext, Context, {
        createScope: function(node, parent, name) {
            return new GLTransformScope(node, parent, {name: name});
        },
        getTypeInfo: function(node) {
            return common.getTypeInfo(node, this.getScope());
        },
        addHeader: function(headerStr) {
            if (this.headers.indexOf(headerStr) == -1) {
                this.headers.push(headerStr);
            }
        }
    });

    /**
     * @constructor
     * @extends {Scope}
     */
    var GLTransformScope = function(node, parentScope, opt) {
        Scope.call(this, node, parentScope, opt);
        this.setRegistry(Registry);
    };

    Base.createClass(GLTransformScope, Scope, {

        registerGlobals: function() {
            this.registerObject("Math", objects.Math);
            this.registerObject("Color",  objects.Color);
            this.registerObject("Vec2", objects.Vec2);
            this.registerObject("Vec3", objects.Vec3);
            this.registerObject("Vec4", objects.Vec4);
            this.registerObject("Texture", objects.Texture);
            this.registerObject("Shade", objects.Shade);
            this.registerObject("Mat3", objects.Mat3);
            this.registerObject("Mat4", objects.Mat4);
            this.registerObject("Space", objects.Space);

            this.declareVariable("gl_FragCoord", false);
            this.updateTypeInfo("gl_FragCoord", new TypeInfo({
                extra: {
                    type: Types.OBJECT,
                    kind: Kinds.FLOAT3
                }
            }));
        }
    });



    ns.GLTransformScope = GLTransformScope;
    ns.GLTransformContext = GLTransformContext;

}(exports));

},{"../../../base/common.js":87,"../../../base/context.js":88,"../../../base/index.js":90,"../../../base/scope.js":91,"../../../base/typeinfo.js":92,"../../../interfaces.js":123,"./mat3.js":103,"./mat4.js":104,"./math.js":105,"./shade.js":106,"./space.js":107,"./system.js":108,"./texture.js":109,"./vec2.js":110,"./vec3.js":111,"./vec4.js":112}],103:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");
    var ANNO = require("../../../base/annotation.js").ANNO;

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;

    var Mat3Instance = {
        col: {
            callExp: Tools.Mat.generateColCall.bind(null, "Mat3")
        }
    }
    Tools.Mat.attachOperators(Mat3Instance, "Mat3", {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/'
    });
    Tools.Vec.attachOperators(Mat3Instance, 3, {
        mulVec: '*'
    });


    Tools.extend(ns, {
        id: "Mat3",
        kind: KINDS.MATRIX3,
        object: {
            constructor: Tools.Vec.generateConstructor,
            static: {}
        },
        instance: Mat3Instance
    });

}(exports));

},{"../../../base/annotation.js":85,"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],104:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");
    var ANNO = require("../../../base/annotation.js").ANNO;

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;

    var Mat4Instance = {
        col: {
            callExp: Tools.Mat.generateColCall.bind(null, "Mat4")
        }
    }
    Tools.Mat.attachOperators(Mat4Instance, "Mat4", {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/'
    });
    Tools.Vec.attachOperators(Mat4Instance, 4, {
        mulVec: '*'
    });


    Tools.extend(ns, {
        id: "Mat4",
        kind: KINDS.MATRIX4,
        object: {
            constructor: Tools.Vec.generateConstructor,
            static: {}
        },
        instance: Mat4Instance
    });

}(exports));

},{"../../../base/annotation.js":85,"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],105:[function(require,module,exports){
(function(ns){

   var Shade = require("../../../interfaces.js");
   var Syntax = require('estraverse').Syntax;
   var Tools = require("../../tools.js");

    var MathConstants = ["E", "PI", "LN2", "LOG2E", "LOG10E", "PI", "SQRT1_2", "SQRT2"];


    var handleIntVersion = function(node) {
        node.extra.type = Shade.TYPES.NUMBER;
        node.callee = Tools.removeMemberFromExpression(node.callee);
        return node;
    };

    var handleMathCall = function(opt) {
        opt = opt ||{};
        return function(node, args) {
            if (node.type !== Syntax.CallExpression) {
                Shade.throwError(node, "Internal Error in Math object");
            }
            // Cast all arguments of the math function to float, as they are
            // not defined for other types (int, bool)
            // Don't replace the arguments array, it's already cached by the traversal
            for(var i = 0; i < args.length; i++) {
                if (args[i].isInt())
                    node.arguments[i] = Tools.castToFloat(node.arguments[i]);
            }
            node.callee = Tools.removeMemberFromExpression(node.callee);
            if (opt.name) {
                node.callee.name = opt.name;
            }
            if (opt.arguments) {
                for (var idx = 0; idx < opt.arguments.length; ++idx)
                    if (typeof opt.arguments[idx] !== "undefined")
                        node.arguments[idx] = opt.arguments[idx];
            }
            return node;
        }
    };

    var MathEntry  = {
        abs: { callExp: handleMathCall() },
        acos: { callExp: handleMathCall() },
        asin: { callExp: handleMathCall() },
        atan: { callExp: handleMathCall() },
        atan2: { callExp: handleMathCall({ name: "atan" }) },
        ceil: { callExp: handleIntVersion },
        cos:  { callExp: handleMathCall() },
        exp: { callExp: handleMathCall() },
        floor: { callExp: handleMathCall() },
        // imul: { callExp: handleMathCall },
        log: { callExp: handleMathCall() },
        max: { callExp: handleMathCall() },
        min: { callExp: handleMathCall() },
        pow: { callExp: handleMathCall() },
        // random: function random() { [native code] }
        round: { callExp: handleMathCall() }, // Since GLSL 1.3, what does WebGL use?
        sin:  { callExp: handleMathCall() },
        sqrt: { callExp: handleMathCall() },
        tan: { callExp: handleMathCall() },

        // Non-standard methods
        clamp: { callExp: handleMathCall() },
        saturate: { callExp: handleMathCall({ name: "clamp", arguments: [
            undefined,
            {
                type: Syntax.Literal,
                value: 0.0,
                extra: {
                    type: Shade.TYPES.NUMBER,
                    staticValue: 0.0
                }
            },
            {
                type: Syntax.Literal,
                value: 1.0,
                extra: {
                    type: Shade.TYPES.NUMBER,
                    staticValue: 1.0
                }
            }
        ] }) },
        smoothstep: { callExp: handleMathCall() },
        step: { callExp: handleMathCall() },
        fract: { callExp: handleMathCall() },
        mix: { callExp: handleMathCall() }
    };

    MathConstants.forEach(function (constant) {
        MathEntry[constant] = {
            property: function () {
                return  { type: Syntax.Literal, value: Math[constant], extra: { type: Shade.TYPES.NUMBER } };
            }
        }
    });

    Tools.extend(ns, {
        id: "Math",
        object: {
            constructor: null,
            static: MathEntry
        },
        instance: MathEntry
    });

}(exports));

},{"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],106:[function(require,module,exports){
(function (ns) {

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");

    var ShadeInstance = {
        diffuse: {
            callExp: function(node) {
                return {
                    type: Syntax.BinaryExpression,
                    operator: "+",
                    left: {
                        type: Syntax.CallExpression,
                        callee: node.callee.property,
                        arguments: node.arguments
                    },
                    right: node.callee,
                    extra: {
                        type: Shade.TYPES.OBJECT,
                        kind: Shade.OBJECT_KINDS.COLOR_CLOSURE
                    }
                }
            }
        },
        phong: {

        }

    }

    Tools.extend(ns, {
        id: "Shade",
        kind: Shade.OBJECT_KINDS.COLOR_CLOSURE,
        object: {
            constructor: Tools.Vec.generateConstructor,
            static: {}
        },
        instance: ShadeInstance
    });

}(exports));

},{"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],107:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");


    function getSpaceTransform(spaceArg, normal){
        if( spaceArg.type != Syntax.MemberExpression ||
            spaceArg.object.type != Syntax.Identifier ||
            spaceArg.object.name != "Space" ||
            spaceArg.property.type != Syntax.Identifier)
            Shade.throwError(spaceArg, "We only support Space enums for the first argument of transformDirection and transformPoint");

        switch(spaceArg.property.name){
            case "VIEW": return normal ? "modelViewMatrixN" : "modelViewMatrix";
            case "WORLD": return normal ? "modelMatrixN" : "modelMatrix";
            default: Shade.throwError(spaceArg, "Unknown Space Type: '" + spaceArg.property.name + "'");
        }
    }

    var ANNO = require("../../../base/annotation.js").ANNO;
    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;
    var SpaceEntry  = {
        transformDirection: { callExp: function(callExpression, parent, context, state){
            var transform = getSpaceTransform(callExpression.arguments[0], true);
            var result = {  type: Syntax.BinaryExpression, operator: "*",
                            left: { type: Syntax.Identifier, name: transform},
                            right: callExpression.arguments[1]
            };

            ANNO(result).setType(TYPES.OBJECT, KINDS.FLOAT3);
            ANNO(result.left).setType(TYPES.OBJECT, KINDS.MATRIX3);
            ANNO(result.right).setType(TYPES.OBJECT, KINDS.FLOAT3);

            var systemName = Tools.getNameForSystem(transform);
            state.usedParameters.system[systemName] = state.systemParameters[transform];

            return result;
        } },
        transformPoint: { callExp: function(callExpression, parent, context, state){
            var transform = getSpaceTransform(callExpression.arguments[0], false);
            var result = {  type: Syntax.MemberExpression,
                            object: {  type: Syntax.BinaryExpression, operator: "*",
                                left: { type: Syntax.Identifier, name: transform},
                                right: {type: Syntax.CallExpression,
                                   callee: {type: Syntax.Identifier, name: "vec4"},
                                   arguments: [
                                        callExpression.arguments[1],
                                        { type: Syntax.Literal, value: 1, raw: 1}
                                   ]
                                }
                            },
                            property: { type: Syntax.Identifier, name: "xyz" }
                          };
            ANNO(result).setType(TYPES.OBJECT, KINDS.FLOAT3);
            ANNO(result.object).setType(TYPES.OBJECT, KINDS.FLOAT4);
            ANNO(result.object.left).setType(TYPES.OBJECT, KINDS.MATRIX4);
            ANNO(result.object.right).setType(TYPES.OBJECT, KINDS.FLOAT4);
            ANNO(result.object.right.arguments[1]).setType(TYPES.NUMBER);


            var systemName = Tools.getNameForSystem(transform);
            state.usedParameters.system[systemName] = state.systemParameters[transform];

            return result;
        } },
        VIEW: {
            property: function (memberExpression) {
                return memberExpression;
            }},
        WORLD: {
            property: function (memberExpression) {
                return  memberExpression;
            }}
    };

    Tools.extend(ns, {
        id: "Space",
        object: {
            constructor: null,
            static: SpaceEntry
        },
        instance: SpaceEntry
    });

}(exports));

},{"../../../base/annotation.js":85,"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],108:[function(require,module,exports){
(function (ns) {

    // Dependencies
    var Shade = require("../../../interfaces.js");
    var Tools = require("../../tools.js");
    var Syntax = require('estraverse').Syntax;

    // Shortcuts
    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;


    var SystemDefines = {};
    SystemDefines.CANVAS_DIMENSIONS = "coords";
    SystemDefines.DERIVATE_EXTENSION = "#extension GL_OES_standard_derivatives : enable";

    var CoordsType =  {
        type: Shade.TYPES.OBJECT,
        kind: Shade.OBJECT_KINDS.FLOAT3,
        source: Shade.SOURCES.UNIFORM
    };


    var DerivedParameters = {
        coords: {
            property: function (node) {
                node.property.name = "gl_FragCoord";
                return node.property;
            }
        },
        normalizedCoords: {
            property: function (node, parent, context, state) {
                var parameterName = Tools.getNameForSystem(SystemDefines.CANVAS_DIMENSIONS);
                var canvasDimensions = state.systemParameters[SystemDefines.CANVAS_DIMENSIONS];
                if(!canvasDimensions)
                   Shade.throwError(node, "Internal Error: No canavas dimensions defined" );

                state.usedParameters.system[parameterName] = canvasDimensions;

                return {
                    type: Syntax.NewExpression,
                    callee: {
                        type: Syntax.Identifier,
                        name: "Vec3"
                    },
                    arguments: [
                        {
                            type: Syntax.BinaryExpression,
                            left: {
                                type: Syntax.MemberExpression,
                                object: {
                                    type: Syntax.Identifier,
                                    name: "gl_FragCoord"
                                },
                                property: {
                                    type: Syntax.Identifier,
                                    name: "xyz"
                                }
                            },
                            right: {
                                type: Syntax.Identifier,
                                name: Tools.getNameForSystem(SystemDefines.CANVAS_DIMENSIONS)
                            },
                            operator: "/",
                            extra: {
                                type: Shade.TYPES.OBJECT,
                                kind: Shade.OBJECT_KINDS.FLOAT3
                            }
                        }
                    ],
                    extra: {
                        type: Shade.TYPES.OBJECT,
                        kind: Shade.OBJECT_KINDS.FLOAT3
                    }
                }
            }
        },
        height: {
            property: function (node, parent, context, state) {
                var parameterName = Tools.getNameForSystem(SystemDefines.CANVAS_DIMENSIONS);
                state.usedParameters.system[parameterName] = state.systemParameters[SystemDefines.CANVAS_DIMENSIONS];

                node.property.name = parameterName + ".y";
                return node.property;
            }
        },
        width: {
            property: function (node, parent, context, state) {
                var parameterName = Tools.getNameForSystem(SystemDefines.CANVAS_DIMENSIONS);
                state.usedParameters.system[parameterName] = state.systemParameters[SystemDefines.CANVAS_DIMENSIONS];

                node.property.name = parameterName + ".x";
                return node.property;
            }
        },
        fwidth: {
            property: function (node, parent, context, state) {
                state.addHeader(SystemDefines.DERIVATE_EXTENSION);
                return Tools.removeMemberFromExpression(node);
            }
        },
        dx: {
            property: function (node, parent, context, state) {
                state.addHeader(SystemDefines.DERIVATE_EXTENSION);
                var result = Tools.removeMemberFromExpression(node);
                result.name = "dFdx";
                return result;
            }
        },
        dy: {
            property: function (node, parent, context, state) {
                state.addHeader(SystemDefines.DERIVATE_EXTENSION);
                var s = Tools.removeMemberFromExpression(node);
                var result = Tools.removeMemberFromExpression(node);
                result.name = "dFdy";
                return result;
            }
        }

    };

    Tools.extend(ns, {
        id: "System",
        object: {
            constructor: null,
            static: DerivedParameters
        },
        instance: null,
        derivedParameters: DerivedParameters
    });
}(exports));

},{"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],109:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");
    var ANNO = require("../../../base/annotation.js").ANNO;

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;

    var TextureInstance = {
        sample2D: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'texture2D', 2)
        },
        width: {
            property: function (node, parent, context, state) {
                var parameterName = node.object.name;
                node.property.name = parameterName + "_width";
                state.usedParameters.shader[parameterName + "_width"] = {
                    type: Shade.TYPES.INT,
                    kind: Shade.OBJECT_KINDS.INT,
                    source: Shade.SOURCES.UNIFORM
                };
                return node.property;
            }
        },
        height: {
            property: function (node, parent, context, state) {
                var parameterName = node.object.name;
                node.property.name = parameterName + "_height";
                state.usedParameters.shader[parameterName + "_height"] = {
                    type: Shade.TYPES.INT,
                    kind: Shade.OBJECT_KINDS.INT,
                    source: Shade.SOURCES.UNIFORM
                };
                return node.property;
            }
        }
    }

    Tools.extend(ns, {
        id: "Texture",
        kind: KINDS.TEXTURE,
        object: {
            constructor: null,
            static: {}
        },
        instance: TextureInstance
    });

}(exports));

},{"../../../base/annotation.js":85,"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],110:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");
    var ANNO = require("../../../base/annotation.js").ANNO;

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;

    var Vec2Instance = {
        normalize: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'normalize', 0)
        },
        flip: {
            callExp: Tools.Vec.createFunctionCall.bind(null, '-', 0)
        },
        dot: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'dot', 2)
        },
        reflect: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'reflect', 2)
        },
        length: {
            callExp: Tools.Vec.generateLengthCall
        }
    }
    Tools.Vec.attachSwizzles(Vec2Instance, 2, Tools.Vec.createSwizzle, Tools.Vec.createSwizzleOperator);
    Tools.Vec.attachOperators(Vec2Instance, 2, {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%'
    })


    Tools.extend(ns, {
        id: "Vec2",
        kind: KINDS.FLOAT2,
        object: {
            constructor: Tools.Vec.generateConstructor,
            static: {}
        },
        instance: Vec2Instance
    });

}(exports));

},{"../../../base/annotation.js":85,"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],111:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");
    var ANNO = require("../../../base/annotation.js").ANNO;

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;

    var Vec3Instance = {
        normalize: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'normalize', 0)
        },
        flip: {
            callExp: Tools.Vec.createFunctionCall.bind(null, '-', 0)
        },
        dot: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'dot', 3)
        },
        reflect: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'reflect', 3)
        },
        refract: {
            callExp: function (node, args, parent) {
                var eta = node.arguments.pop();
                var result = Tools.Vec.createFunctionCall("refract", 3, node, args, parent);
                ANNO(eta).setType(TYPES.NUMBER);
                result.arguments.push(eta);
                return result;
            }
        },
        length: {
            callExp: Tools.Vec.generateLengthCall
        },
        cross: {
            callExp: Tools.Vec.createFunctionCall.bind(null, "cross", 3)
        }
    }
    Tools.Vec.attachSwizzles(Vec3Instance, 3, Tools.Vec.createSwizzle, Tools.Vec.createSwizzleOperator);
    Tools.Vec.attachOperators(Vec3Instance, 3, {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%'
    })


    Tools.extend(ns, {
        id: "Vec3",
        kind: KINDS.FLOAT3,
        object: {
            constructor: Tools.Vec.generateConstructor,
            static: {}
        },
        instance: Vec3Instance
    });

}(exports));

},{"../../../base/annotation.js":85,"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],112:[function(require,module,exports){
(function(ns){

    var Shade = require("../../../interfaces.js");
    var Syntax = require('estraverse').Syntax;
    var Tools = require("../../tools.js");
    var ANNO = require("../../../base/annotation.js").ANNO;

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;

    var Vec4Instance = {
        normalize: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'normalize', 0)
        },
        flip: {
            callExp: Tools.Vec.createFunctionCall.bind(null, '-', 0)
        },
        dot: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'dot', 4)
        },
        reflect: {
            callExp: Tools.Vec.createFunctionCall.bind(null, 'reflect', 4)
        },
        length: {
            callExp: Tools.Vec.generateLengthCall
        }
    }
    Tools.Vec.attachSwizzles(Vec4Instance, 4, Tools.Vec.createSwizzle, Tools.Vec.createSwizzleOperator);
    Tools.Vec.attachOperators(Vec4Instance, 4, {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%'
    })


    Tools.extend(ns, {
        id: "Vec4",
        kind: KINDS.FLOAT4,
        object: {
            constructor: Tools.Vec.generateConstructor,
            static: {}
        },
        instance: Vec4Instance
    });

}(exports));

},{"../../../base/annotation.js":85,"../../../interfaces.js":123,"../../tools.js":121,"estraverse":46}],113:[function(require,module,exports){
(function (ns) {

    var Base = require("../../base/index.js"),
        common = require("../../base/common.js"),
        FunctionAnnotation = require("../../base/annotation.js").FunctionAnnotation,
        Shade = require("./../../interfaces.js"),
        Types = Shade.TYPES,
        analyses = require('analyses'),
        Tools = require('../tools.js'),
        System = require('./registry/system.js'),
        assert = require('assert');


    var Context = require("./registry/").GLTransformContext;


    var walk = require('estraverse');
    var Syntax = walk.Syntax;
    var ANNO = common.ANNO;
    var Map = common.Map;
    var Set = analyses.Set;


    /**
     * Transforms the JS AST to an AST representation convenient
     * for code generation
     * @constructor
     */
    var GLASTTransformer = function (root, mainId, vertexShader, opt) {
        this.context = new Context(root, mainId, vertexShader, opt);
    };

    function createUniformDependencyMap(uniformExpressions) {
        var name, uexpSet, dependencies, dependency, dl, dependencyMap = new Map();
        for (name in uniformExpressions) {
            dependencies = uniformExpressions[name].dependencies;
            dl = dependencies.length;
            while (dl--) {
                dependency = dependencies[dl];
                if (dependencyMap.has(dependency)) {
                    uexpSet = dependencyMap.get(dependency);
                } else {
                    uexpSet = new Set();
                    dependencyMap.set(dependency, uexpSet);
                }
                uexpSet.add(name);
            }
        }
        return dependencyMap;
    }

    Base.extend(GLASTTransformer.prototype, {
        /**
         *
         * @param {GLTransformScope} scope
         */
        registerThisObject: function (scope) {
            var thisObject = scope.getBindingByName("this");
            if (thisObject && thisObject.isObject()) {
                var properties = thisObject.getNodeInfo();
                for (var name in properties) {
                    var prop = ANNO({}, properties[name]);
                    if (!prop.isDerived())
                        this.context.blockedNames.push(Tools.getNameForSystem(name));
                }
                for (var property in System.derivedParameters) {
                    if(properties.hasOwnProperty(property)) {
                        Base.deepExtend(properties[property], System.derivedParameters[property]);
                    }
                }
                Base.extend(this.context.systemParameters, properties);
            }
        },


        createUniformSetterFunction: function (parameters) {
            // Reverse uniform expression dependencies
            var c_dependencyMap = createUniformDependencyMap(parameters.uexp);

            return function (envNames, sysNames, inputCollection, cb) {
                var i, base, override, srcName, destName, ul, uniformList;
                if (envNames && inputCollection.envBase) {
                    i = envNames.length;
                    base = inputCollection.envBase;
                    override = inputCollection.envOverride;
                    while (i--) {
                        srcName = envNames[i];
                        if(c_dependencyMap.has(srcName)) {
                            uniformList = c_dependencyMap.get(srcName).values();
                            ul = uniformList.length;
                            while(ul--) {
                                var expName = uniformList[ul];
                                var expression = parameters.uexp[expName];
                                var value = expression.setter.call(Shade, inputCollection.envBase);
                                cb(expName, value);
                            }
                        }
                        destName = Tools.getNameForGlobal(envNames[i]);
                        if (!parameters.shader[destName])
                            continue;
                        cb(destName, override && override[srcName] !== undefined ? override[srcName] : base[srcName]);
                        if (parameters.shader[destName].kind === Shade.OBJECT_KINDS.TEXTURE) {
                            cb(destName + "_width", override && override[srcName] !== undefined ? override[srcName].width : base[srcName] && base[srcName][0].width || 0);
                            cb(destName + "_height", override && override[srcName] !== undefined ? override[srcName].height : base[srcName] && base[srcName][0].height || 0)
                        }
                    }
                }
                if (sysNames && inputCollection.sysBase) {
                    i = sysNames.length;
                    base = inputCollection.sysBase;
                    while (i--) {
                        srcName = sysNames[i];
                        destName = Tools.getNameForSystem(sysNames[i]);
                        cb(destName, base[srcName]);
                    }
                }
            }

        },

        transform: function () {
            var context = this.context,
                program = context.root,
                scope = context.createScope(this.context.root, null, "global"),
                name, declaration;

            scope.registerGlobals();
            context.pushScope(scope);

            this.registerThisObject(scope);

            // TODO: We should also block systemParameters here. We can block all system names, even if not used.
            for(name in context.globalParameters){
                context.blockedNames.push( Tools.getNameForGlobal(name) );
            }

            this.replace(program);

            var usedParameters = context.usedParameters;
            for (var container in usedParameters) {
                for (name in usedParameters[container]) {
                    declaration = createTopDeclaration(name, usedParameters[container][name]);
                    declaration && program.body.unshift(declaration);
                }
            }

            var uniformSetter = this.createUniformSetterFunction(usedParameters);

            var userData = ANNO(program).getUserData();
            userData.internalFunctions = context.internalFunctions;

            return { program: program, uniformSetter: uniformSetter, headers: context.headers};
        },
        /**
         *
         * @param {Object!} ast
         * @returns {*}
         */
        replace: function(ast) {
            var controller = new walk.Controller(),
                context = this.context,
                that = this;

            ast = controller.replace(ast, {

                enter: function (node, parent) {

                    switch (node.type) {
                        case Syntax.Identifier:
                            return enterIdentifier(node, parent, context);
                        case Syntax.IfStatement:
                            return enterIfStatement(node);
                        case Syntax.FunctionDeclaration:
                            return enterFunctionDeclaration(node, context);
                    }
                },

                leave: function(node, parent) {
                    switch(node.type) {
                        case Syntax.MemberExpression:
                            return leaveMemberExpression(node, parent, context);
                        case Syntax.NewExpression:
                            return leaveNewExpression(node, context);
                        case Syntax.LogicalExpression:
                            return leaveLogicalExpression(node);
                        case Syntax.CallExpression:
                            return leaveCallExpression(node, parent, context);
                        case Syntax.UnaryExpression:
                            return leaveUnaryExpression(node);
                        case Syntax.FunctionDeclaration:
                            return leaveFunctionDeclaration(node, context);
                        case Syntax.ReturnStatement:
                            return leaveReturnStatement(node, context);
                        case Syntax.BinaryExpression:
                            return handleBinaryExpression(node, parent, context);

                    }
                }
            });
            return ast;
        }
    });

    /**
     * @param {string} name
     * @param {object} typeInfo
     * @returns {*}
     */
    var createTopDeclaration = function(name, typeInfo){
        var propertyLiteral =  { type: Syntax.Identifier, name: name};
        var propertyAnnotation =  ANNO(propertyLiteral);
        propertyAnnotation.setFromExtra(typeInfo);

        if (propertyAnnotation.isNullOrUndefined() || propertyAnnotation.isDerived() || propertyAnnotation.isFunction())
            return;

        if( propertyAnnotation.isOfType(Types.ARRAY) && typeInfo.staticSize == 0)
            return;

        var decl = {
            type: Syntax.VariableDeclaration,
            declarations: [
                {
                    type: Syntax.VariableDeclarator,
                    id: propertyLiteral,
                    init: null
                }
            ],
            kind: "var"
        };
        var declAnnotation =  ANNO(decl.declarations[0]);
        declAnnotation.copy(propertyAnnotation);
        return decl;
    };

    var enterIdentifier = function(node, parent, state){
        var blockedNames = state.blockedNames;
        var idNameMap = state.idNameMap;

        if(parent.type == Syntax.MemberExpression)
            return node;
        var name = node.name;
        if(idNameMap[name]) {
            node.name = idNameMap[name];
            return node;
        }
        var newName = Tools.generateFreeName(name, blockedNames);
        idNameMap[name] = newName;
        node.name = newName;
        return node;
    };


    /**
     * Transform a !number expression into an binary expression, number == 0
     * @param node
     * @returns {*}
     */
    var leaveUnaryExpression = function(node) {
        if(node.operator == "!") {
            var argument = ANNO(node.argument);
            //noinspection FallthroughInSwitchStatementJS
            switch(argument.getType()) {
                case Types.INT:
                case Types.NUMBER:
                    return {
                        type: Syntax.BinaryExpression,
                        operator: "==",
                        left: node.argument,
                        right: {
                            type: Syntax.Literal,
                            value: 0,
                            extra: {
                                type: argument.getType()
                            }
                        }
                    };
                    break;
            }
        }
    };

    /**
     * A return in the main functions sets gl_FragColor or discard if the
     * main method returns without argument
     * @param node
     * @param {GLTransformContext} context
     * @returns {*}
     */
    var leaveReturnStatement = function(node, context) {
        var scope = context.getScope(), fragColors;

        if(!context.inMainFunction())
            return;

        if (node.argument) {
            var argument = ANNO(node.argument);
            if (argument.isArray()) {
               context.addHeader("#extension GL_EXT_draw_buffers : require");
               fragColors = {type: Syntax.BlockStatement, body: []};
               node.argument.elements.forEach(function(element, index) {
                    fragColors.body.push(createGLFragColor(Tools.castToVec4(element, scope), index, context));
               });
            } else {
                fragColors = createGLFragColor(Tools.castToVec4(node.argument, scope), undefined, context);
            }
            return {
                type: Syntax.BlockStatement,
                body: [ fragColors, { type: Syntax.ReturnStatement } ]
            };

        } else {
            return {
                type: Syntax.ExpressionStatement,
                expression : {
                    type: Syntax.Identifier,
                    name: "discard"
                }
            }
        }
    };

    /**
     * Transform the main function into a GLSL conform main function
     * with signature 'void main(void)'
     * @param node
     */
    var leaveMainFunction = function(node) {
        var anno = new FunctionAnnotation(node);
        anno.setReturnInfo({ type: Types.UNDEFINED });

        // Main has no parameters
        node.params = [];
        // Rename to 'main'
        node.id.name = "main";
        //console.log(node);
    };

    function createGLFragColor(result, index, context) {
        var name;
        if(context.vertexShader){
            name = "gl_Position";
        }
        else if(index !== undefined){
            name = "gl_FragData[" + index + "]";
        }
        else{
            name = "gl_FragColor";
        }

        return {
            type: Syntax.AssignmentExpression,
            operator: "=",
            left: {
                type: Syntax.Identifier,
                name: name
            },
            right: result
        };
    }

    function getNameOfNode(node) {
        switch (node.type) {
            case Syntax.Identifier:
                return node.name;
            case Syntax.MemberExpression:
                return getNameOfNode(node.object) + "." + getNameOfNode(node.property);
            case Syntax.NewExpression:
                return getNameOfNode(node.callee);
            default:
                return "unknown(" + node.type + ")";
        }
    }

    /**
     *
     * @param {object} node
     * @param {object} parent
     * @param {GLTransformContext} context
     * @returns {*}
     */
    var leaveCallExpression = function (node, parent, context) {
        var scope = context.getScope();

        /** Filter out undefined arguments, we do the same for the declaration */
        node.arguments = node.arguments.filter(function(a) { return !ANNO(a).isUndefined()});

        // Is this a call on an object?
        if (node.callee.type == Syntax.MemberExpression) {
            var calleeReference = common.getTypeInfo(node.callee, scope);
            if(!(calleeReference && calleeReference.isFunction()))
                Shade.throwError(node, "Something went wrong in type inference, " + node.callee.object.name);

            var object = node.callee.object,
                propertyName = node.callee.property.name;

            var objectReference = common.getTypeInfo(object, scope);
            if(!objectReference)  {
                Shade.throwError(node, "Internal: No type info for: " + object);
            }

            var objectInfo = scope.getObjectInfoFor(objectReference);
            if(!objectInfo) { // Every object needs an info, otherwise we did something wrong
                Shade.throwError(node, "Internal Error: No object registered for: " + objectReference.getTypeString() + ", " + getNameOfNode(node.callee.object)+", "+node.callee.object.type);
            }
            if (objectInfo.hasOwnProperty(propertyName)) {
                var propertyHandler = objectInfo[propertyName];
                if (typeof propertyHandler.callExp == "function") {
                    var args = common.createTypeInfo(node.arguments, scope);
                    return propertyHandler.callExp(node, args, parent, context);
                }
            }
        }
    };

    var leaveNewExpression = function(newExpression, context){
        var scope = context.getScope();
        var entry = scope.getBindingByName(newExpression.callee.name);
        //console.error(entry);
        if (entry && entry.hasConstructor()) {
            var constructor = entry.getConstructor();
            return constructor(newExpression);
        }
       else {
            throw new Error("ReferenceError: " + newExpression.callee.name + " is not defined");
        }
    };


    /**
     *
     * @param {object} node
     * @param {object} parent
     * @param {GLTransformContext} context
     * @returns {*}
     */
    var leaveMemberExpression = function (node, parent, context) {
        var propertyName = node.property.name,
            scope = context.getScope(),
            parameterName,
            propertyLiteral;

        if (node.computed) {
            return handleComputedMemberExpression(node, parent, context);
        }

        if(ANNO(node).isUniformExpression()) {
            var uexp = handleUniformExpression(node, context);
            if(uexp)
                return uexp;
        }

        var objectReference = common.getTypeInfo(node.object, scope);

        if (!objectReference || !objectReference.isObject()) {
            Shade.throwError(node, "Internal Error: Object of Member expression is no object.");
        }


        var objectInfo = scope.getObjectInfoFor(objectReference);
        if(!objectInfo) {// Every object needs an info, otherwise we did something wrong
            Shade.throwError(node, "Internal Error: No object registered for: " + objectReference.getTypeString() + JSON.stringify(node.object));
        }
        if (!objectInfo.hasOwnProperty(propertyName))
            Shade.throwError(node, "Internal Error: Object of type " + objectReference.getTypeString() + " has no property '" + propertyName +"'");

        var propertyHandler = objectInfo[propertyName];
        if (typeof propertyHandler.property == "function") {
            return propertyHandler.property(node, parent, scope, context);
        }

        var usedParameters = context.usedParameters;
        if(objectReference.isGlobal()) {
            parameterName = Tools.getNameForGlobal(propertyName);
            if(!usedParameters.shader.hasOwnProperty(parameterName)) {
                usedParameters.shader[parameterName] = context.globalParameters[propertyName];
            }

            propertyLiteral =  { type: Syntax.Identifier, name: parameterName};
            ANNO(propertyLiteral).copy(ANNO(node));
            return propertyLiteral;
        }
        if (node.object.type == Syntax.ThisExpression) {
            parameterName = Tools.getNameForSystem(propertyName);
            if(!usedParameters.system.hasOwnProperty(parameterName)) {
                usedParameters.system[parameterName] = context.systemParameters[propertyName];
            }

            propertyLiteral =  { type: Syntax.Identifier, name: parameterName};
            ANNO(propertyLiteral).copy(ANNO(node));
            return propertyLiteral;
        }

    };

    /**
     * @param {object} node
     * @param {object} parent
     * @param {GLASTTransformer} context
     */
    var handleComputedMemberExpression = function(node, parent, context) {
        var objectReference = context.getTypeInfo(node.object);
        if (!objectReference.isArray()) {
            Shade.throwError(node, "In shade.js, [] access is only allowed on arrays.");
        }
        var propertyType =  context.getTypeInfo(node.property);
        if(!propertyType.canInt()){
            node.property = {
                type: Syntax.CallExpression,
                callee: {type: "Identifier", name: "int"},
                arguments: [ node.property]
            }
            ANNO(node.property).setType(Types.INT);
        }
        return node;
    };


    /**
     * @param {object} node
     * @param {object} parent
     * @param {GLASTTransformer} context
     */
    var handleBinaryExpression = function (node, parent, context) {
        // In GL, we can't mix up floats, ints and bool for binary expressions
        var left = context.getTypeInfo(node.left),
            right = context.getTypeInfo(node.right);

        if (left.isNumber() && right.isInt()) {
            node.right = Tools.castToFloat(node.right);
        }
        else if (right.isNumber() && left.isInt()) {
            node.left = Tools.castToFloat(node.left);
        }

        if (node.operator == "%") {
            return Tools.binaryExpression2FunctionCall(node, "mod");
        }
        return node;
    };

    /*function castToInt(ast, force) {
        var exp = ANNO(ast);

        if (!exp.isInt() || force) {   // Cast
            return {
                type: Syntax.CallExpression,
                callee: {
                    type: Syntax.Identifier,
                    name: "int"
                },
                arguments: [ast]
            };
        }
        return ast;
    };*/

    /**
     * @param {Object} node
     * @param {GLTransformContext} context
     * @returns {*}
     */
    var enterFunctionDeclaration = function(node, context) {
        var scope = context.createScope(node, context.getScope(), node.id.name);
        context.pushScope(scope);

        var newParameterList = [];
        // Remove parameters of type undefined (these are not used anyway)
        node.params.forEach(function(a) {
            // Don't declare undefined parameters
            if(!ANNO(a).isUndefined()){
                newParameterList.push(a);
            } else {
                var binding = scope.getBindingByName(a.name);
                if(!binding.isUndefined()) {
                    addDeclaration(a.name, binding, node.body);
                }
            }
        });
        node.params = newParameterList;
        return node;
    };

    /**
     * @param {Object} node
     * @param {GLTransformContext} context
     * @returns {*}
     */
    var leaveFunctionDeclaration = function(node, context) {
        var wasMain = context.inMainFunction();
        context.popScope();
        if (wasMain)
            return leaveMainFunction(node);
    };


    var enterIfStatement = function (node) {
        var test = ANNO(node.test);

       assert(!test.hasStaticValue(), "Static value in IfStatement test");
       assert(!test.isObject(), "Object in IfStatement test");

       //noinspection FallthroughInSwitchStatementJS
        switch(test.getType()) {
           // Transform 'if(number)' into 'if(number != 0)'
           case Types.INT:
           case Types.NUMBER:
               node.test = {
                   type: Syntax.BinaryExpression,
                   operator: "!=",
                   left: node.test,
                   right: {
                       type: Syntax.Literal,
                       value: 0,
                       extra: {
                           type: test.getType()
                       }
                   }
               };
               break;
       }
    };

    /**
     * Need to transform truth expressions in real boolean expression, because something like if(0) is
     * not allowed in GLSL
     *
     * @param node
     * @returns {*}
     */
    var leaveLogicalExpression = function(node) {
        var left = ANNO(node.left);
        var right = ANNO(node.right);

        if (left.isBool() && right.isBool()) {
            // Everything is okay, no need to modify anything
            return;
        }

        // Now we have to implement the JS boolean semantic for GLSL
        if (left.canNumber()) {
            var test =  node.left;
            return {
                type: Syntax.ConditionalExpression,
                test: {
                    type: Syntax.BinaryExpression,
                    operator: "==",
                    left: test,
                    right: {
                        type: Syntax.Literal,
                        value: left.isNumber() ? 0.0 : left.isInt() ? 0 : "false",
                        extra: {
                            type : left.getType(),
                            staticValue: left.isNumber() ? 0.0 : left.isInt() ? 0 : "false"
                        }
                    },
                    extra: { type: Types.BOOLEAN }
                },
                consequent: node.right,
                alternate: test
            };
        }
    };


    function handleUniformExpression(node, context) {
            var exp = ANNO(node),
                extra;

            if (exp.isUniformExpression() && !(exp.getSource() == Shade.SOURCES.UNIFORM)) {
                var uniformName = node.property.name;

                if (context.usedParameters.uexp.hasOwnProperty(uniformName)) { // Reuse
                    extra = context.usedParameters.uexp[uniformName];
                    return {
                        type: Syntax.Identifier,
                        name: uniformName,
                        extra: extra
                    }
                }

                // Generate new uniform expression
                extra = {};

                if(!context.uniformExpressions.hasOwnProperty(uniformName)) {
                    throw new Error("Internal: No information about uniform expression available: " + Shade.toJavaScript(node));
                }
                extra.setter = generateUniformSetter(exp, context.uniformExpressions[uniformName]);

                //console.log(uniformName, extra.setter);

                extra.type = exp.getType();
                if (exp.isObject()) {
                    extra.kind = exp.getKind();
                }
                extra.source = Shade.SOURCES.UNIFORM;
                extra.dependencies = exp.getUniformDependencies();

                context.usedParameters.uexp[uniformName] = extra;

                return {
                    type: Syntax.Identifier,
                    name: uniformName,
                    extra: extra
                }
            }
        }

    function generateUniformSetter(uniformAnno, expressionInfo) {
        var code = expressionInfo.code;
        if(uniformAnno.isObject())
            code = "(" + expressionInfo.code + ")._toFloatArray()";
        var source = "return " + code + ";";
        return new Function("env", source);
    }

    function addDeclaration(name, typeInfo, target) {
        var targetContainer, declaration;
        switch (target.type) {
            case Syntax.BlockStatement:
                targetContainer = target.body;
                break;
            default:
                throw new Error("Internal: addDeclaration to " + target.type);
        }
        if (targetContainer.length && targetContainer[0].type == Syntax.VariableDeclaration) {
           declaration = targetContainer[0];
           //console.log(declaration.declarations.push(declaration.declarations[0]));
        } else {
            declaration = {
                type: Syntax.VariableDeclaration,
                kind: "var",
                declarations: []
            }
            targetContainer.unshift(declaration);
        }
        var declarator = {
            type: Syntax.VariableDeclarator,
            id: {
                type: Syntax.Identifier,
                name: name
            },
            init: null
        };
        ANNO(declarator).copy(typeInfo);
        declaration.declarations.push(declarator);
    }


    // Exports
    ns.GLASTTransformer = GLASTTransformer;


}(exports));

},{"../../base/annotation.js":85,"../../base/common.js":87,"../../base/index.js":90,"../tools.js":121,"./../../interfaces.js":123,"./registry/":102,"./registry/system.js":108,"analyses":1,"assert":47,"estraverse":46}],114:[function(require,module,exports){
(function (ns) {

    var common = require("../../base/common.js"),
        parser = require('esprima'),
        Shade = require("./../../interfaces.js"),
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS,
        analyzer = require("../../analyze/analyze.js");
    var walk = require('estraverse');
    var Syntax = walk.Syntax;

    var Template = require("./light-pass-template").LightPassTemplate;
    var ArgStorageType = require("../../resolve/xml3d-glsl-deferred/color-closure-signature.js").ArgStorageType;

    var PRE_TEXTURE_FETCHES = 2,
        POSITION_IS_IN_ARGS = true,
        TEXCOORD_NAME = "texcoord",
        DEFERRED_TEX_PREFIX = "deferred",
        DEFERRED_VALUE_PREFIX = "deferred";

    function getInputArgDeclaration(colorClosureSignature){
        var declarations = [];
        var defaultArgCount = POSITION_IS_IN_ARGS ? 3 : 2;
        for(var i = 0; i < colorClosureSignature.args.length - defaultArgCount; ++i){
            declarations.push({ type: Syntax.VariableDeclarator,
            id: {type: Syntax.Identifier, name: "cc" + colorClosureSignature.id + "Arg" + i},
            init: null});
        }
        return {
            type: Syntax.VariableDeclaration,
            kind: "var",
            declarations: declarations
        };
    }

    function createTexMethodAccess(texId, method){
        return {type: Syntax.CallExpression,
            callee: { type: Syntax.MemberExpression,
                object: {type: Syntax.Identifier, name: DEFERRED_VALUE_PREFIX + texId },
                property: {type: Syntax.Identifier, name: method}},
            arguments: []};
    }

    var FetchResolver = {};
    FetchResolver[ArgStorageType.FLOAT] = function(arg){
        var functionName;
        switch(arg.componentIdx){
            case 0: functionName = "x"; break;
            case 1: functionName = "y"; break;
            case 2: functionName = "z"; break;
            case 3: functionName = "w"; break;
        }
        return createTexMethodAccess(arg.texIdx, functionName);
    }
    FetchResolver[ArgStorageType.FLOAT2] = function(arg){
        var functionName;
        switch(arg.componentIdx){
            case 0: functionName = "xy"; break;
            case 1: functionName = "yz"; break;
            case 2: functionName = "zw"; break;
        }
        return createTexMethodAccess(arg.texIdx, functionName);
    }
    FetchResolver[ArgStorageType.FLOAT3] = function(arg){
        var functionName;
        switch(arg.componentIdx){
            case 0: functionName = "xyz"; break;
            case 1: functionName = "yzw"; break;
        }
        return createTexMethodAccess(arg.texIdx, functionName);
    }
    FetchResolver[ArgStorageType.FLOAT4] = function(arg){
        return createTexMethodAccess(arg.texIdx, "xyzw");
    }

    function addTextureSamples(statements, colorClosureSignature){
        for(var i = PRE_TEXTURE_FETCHES; i < colorClosureSignature.textureCount; ++i){
            statements.push(
            {type: Syntax.ExpressionStatement,
                expression: {type: Syntax.AssignmentExpression, operator: "=",
                    left: { type: Syntax.Identifier, name: DEFERRED_VALUE_PREFIX + i },
                    right: { type: Syntax.CallExpression,
                        callee: {type: Syntax.MemberExpression,
                            object: {type: Syntax.MemberExpression,
                                object: {type: Syntax.Identifier, name: "env"},
                                property: {type: Syntax.Identifier, name: DEFERRED_TEX_PREFIX + i }},
                            property: {type: Syntax.Identifier, name: "sample2D"}},
                        arguments: [{ type: Syntax.Identifier, name: TEXCOORD_NAME }]
                    }
                }
            });
        }
    }
    function addArgumentFetching(statements, colorClosureSignature){
        var id = colorClosureSignature.id;
        var defaultArgCount = POSITION_IS_IN_ARGS ? 3 : 2;
        var args = colorClosureSignature.args;
        for(var i = defaultArgCount; i < args.length; ++i){
            var arg = args[i];
            if(!FetchResolver[arg.storeType])
                throw new Error("StoreType '" + arg.storeType + "' not supported in light pass shader");
            var valueFetchAst = FetchResolver[arg.storeType](arg);
            statements.push({type: Syntax.ExpressionStatement,
                expression: {type: Syntax.AssignmentExpression, operator: "=",
                    left: {type: Syntax.Identifier, name: "cc" + id + "Arg" + (i - defaultArgCount)},
                    right: valueFetchAst
                    }});
        }
    }

    function getColorClosureArgs(id, ccEntry){
        var defaultArgCount = POSITION_IS_IN_ARGS ? 3 : 2;
        var args = [], argIndices = ccEntry.argIndices;
        for(var i = 0; i < argIndices.length; ++i){
            args.push({type: Syntax.Identifier, name: "cc" + id + "Arg" + (argIndices[i] - defaultArgCount)});
        }
        return args;
    }

    function getReturnStatement(colorClosureSignature){

        var returnArgument = { type: Syntax.NewExpression,
            callee: {type: Syntax.Identifier, name: "Shade"},
            arguments: []};
        var ccList = colorClosureSignature.colorClosures;
        for(var i = 0; i < ccList.length; ++i){
            var args = getColorClosureArgs(colorClosureSignature.id, ccList[i]);
            returnArgument = {  type: Syntax.CallExpression,
                                callee: {type: Syntax.MemberExpression,
                                    object: returnArgument,
                                    property: {type: Syntax.Identifier, name: ccList[i].name}},
                                arguments: args};
        }

        return {type: Syntax.ReturnStatement,
            argument: returnArgument};
    }


    function getIfStatement(colorClosureSignature){
        var statements = [];
        statements.push(getInputArgDeclaration(colorClosureSignature));
        addTextureSamples(statements, colorClosureSignature);
        addArgumentFetching(statements, colorClosureSignature);
        statements.push(getReturnStatement(colorClosureSignature));

        return  { type: Syntax.IfStatement,
                    test: {type: Syntax.BinaryExpression, operator: "==",
                        left: {type: Syntax.Identifier, name: "ccId"},
                        right: {type: Syntax.Literal, value: colorClosureSignature.id }
                    },
                    consequent: { type: Syntax.BlockStatement,
                        body: statements},
                    alternate: null
                };
    }

    ns.generateLightPassAst = function(colorClosureSignatures){
        var lightPassAst;
        try{
            lightPassAst = parser.parse(Template.toString(), { raw: true });
        }
        catch(e){
            console.error("Error in parsing of lightPass template", e);
            return null;
        }
        var functionBlock = lightPassAst.body[0].body;
        //functionBlock.body.push(getInputArgDeclaration(colorClosureSignatures));

        var resolvedIfStatements = [];
        for(var i = 0; i < colorClosureSignatures.length; ++i){
            if(resolvedIfStatements.indexOf(colorClosureSignatures[i].id) == -1){
                resolvedIfStatements.push(colorClosureSignatures[i].id);
                functionBlock.body.push(getIfStatement(colorClosureSignatures[i]));
            }
        }

        return lightPassAst;
    }


    ns.generateLightPassAast = function(colorClosureSignatures, inject){
        var ast = ns.generateLightPassAst(colorClosureSignatures);
        if(!ast) return null;

        var opt = {};
        opt.entry = "global.shade";
        opt.validate = true;
        opt.throwOnError = true;
        opt.implementation = "xml3d-glsl-forward";
        opt.inject = inject;
        opt.lightLoopNoSpaceTransform = true;
        opt.lightLoopPositionArg = {type: Syntax.Identifier, name: "position"};
        opt.lightLoopAmbientArg = {type: Syntax.Identifier, name: "ambientIntensity"};
        var resultAast = analyzer.analyze(ast, {}, opt).ast;
        return resultAast;
    }

}(exports));

},{"../../analyze/analyze.js":56,"../../base/common.js":87,"../../resolve/xml3d-glsl-deferred/color-closure-signature.js":127,"./../../interfaces.js":123,"./light-pass-template":115,"esprima":45,"estraverse":46}],115:[function(require,module,exports){
(function (ns) {

    ns.LightPassTemplate = function shade(env){
        var texcoord = this.normalizedCoords.xy();
        var deferred0 = env.deferred0.sample2D(texcoord),
            deferred1 = env.deferred1.sample2D(texcoord),
            deferred2, deferred3, deferred4, deferred5, deferred6, deferred7;
        var ccId = deferred0.x();
        var position = deferred0.yzw();
        var ambientIntensity = deferred1.x();
    };

}(exports));

},{}],116:[function(require,module,exports){
(function (ns) {

    var walk = require('estraverse'),
        assert = require("assert"),
        Base = require("../../base/index.js"),
        common = require("./../../base/common.js"),
        Shade = require("../../interfaces.js"),
        TypeInfo = require("../../base/typeinfo.js").TypeInfo,
        StatementSplitTraverser = require("../../analyze/sanitizer/statement-split-traverser"),
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS,
        ANNO = require("../../base/annotation.js").ANNO;

    var Syntax = walk.Syntax;
    var VisitorOption = walk.VisitorOption;

    var FunctionArgWriteDuplicator = function(opt) {
        this.scopeStack = [];
    };
    Base.extend(FunctionArgWriteDuplicator.prototype, {

        execute: function(root) {
            walk.replace(root, {
                enter: this.enterNode.bind(this),
                leave: this.exitNode.bind(this)
            });
            return root;
        },

        enterNode: function(node, parent) {
            switch(node.type) {
                case Syntax.FunctionExpression:
                case Syntax.FunctionDeclaration:
                    this.pushScope(node);
                    this.findArgAssignments(node.body);
                    break;
                case Syntax.Program:
                    this.pushScope(node);
                    break;
                case Syntax.VariableDeclarator:
                    this.addDeclaredIdentifier(node.id.name);
                    break;
            }
        },

        exitNode: function(node, parent) {
            switch(node.type) {
                case Syntax.Identifier:
                    return this.resolveIdentifier(node, parent);
                case Syntax.FunctionExpression:
                case Syntax.FunctionDeclaration:
                case Syntax.Program:
                    return this.resolveScope(node, parent);
                    break;
            }
        },

        pushScope: function(node) {
            var scope = { declared: [], args: {}};

            var params = node.params;
            if(params) {
                for(var i = 0; i < params.length; ++i) {
                    scope.args[params[i].name] = {name: params[i].name, replace: null, extra: Base.deepExtend({}, params[i].extra)};
                    scope.declared.push(params[i].name);
                }
            }
            this.scopeStack.push(scope);
        },
        resolveScope: function(node, parent) {
            var scope = this.scopeStack.pop();
            var toBeDeclared = [];
            for(var key in scope.args) {
                if(scope.args[key].replace) toBeDeclared.push(scope.args[key]);
            }
            this.addTopDeclaration(node, toBeDeclared);
            return node;
        },
        getScope: function() {
            return this.scopeStack[this.scopeStack.length - 1];
        },

        findArgAssignments: function(node) {
            walk.traverse(node, {
                enter: this.assignmentSearchEnter.bind(this)
            });
        },
        assignmentSearchEnter: function(node, parent) {
            switch(node.type) {
                case Syntax.Program:
                case Syntax.FunctionDeclaration:
                case Syntax.FunctionExpression:
                    return VisitorOption.Skip;
            }
            if(node.type != Syntax.AssignmentExpression) return;
            if(node.left.type != Syntax.Identifier) return;
            if(ANNO(node).getType() != Types.OBJECT)
                return VisitorOption.Skip;
            var scope = this.getScope();
            var varName = node.left.name;
            if(scope.args[varName]) {
                if(!scope.args[varName].replace) {
                    var newVarName = this.getFreeVarName("_dest_" + varName);
                    this.addDeclaredIdentifier(newVarName);
                    scope.args[varName].replace = newVarName;
                }
            }
            return VisitorOption.Skip;
        },

        resolveIdentifier: function(node, parent) {
            if(parent.type == Syntax.FunctionDeclaration || parent.type == Syntax.FunctionExpression) return;
            var scope = this.getScope();
            var arg = scope.args[node.name];
            if(arg && arg.replace)
                node.name = arg.replace;
            return node;
        },
        getFreeVarName: function(varName) {
            var result = varName, i = 0;
            while(this.isVarDeclared(result)) {
                i++;
                result = varName + i;
            }
            return result;
        },
        isVarDeclared: function(varName) {
            var i = this.scopeStack.length;
            while(i--) {
                if(this.scopeStack[i].declared.indexOf(varName) != -1) return true;
            }
            return false;
        },

        addTopDeclaration: function(node, declarations) {
            if(declarations.length > 0) {
                var declarators = [];
                var assignments = [];
                for(var i = 0; i < declarations.length; ++i) {
                    var declaration = {
                        type: Syntax.VariableDeclarator,
                        id: { type: Syntax.Identifier, name: declarations[i].replace },
                        extra: declarations[i].extra,
                        init: null
                    }
                    var assignment = {
                        type: Syntax.ExpressionStatement,
                        expression: { type: Syntax.AssignmentExpression,
                            operator: "=",
                            left: { type: Syntax.Identifier, name: declarations[i].replace},
                            right: { type: Syntax.Identifier, name: declarations[i].name}
                        }
                    };
                    var annoDeclaration = ANNO(declaration);
                    ANNO(assignment.expression).copy(annoDeclaration);
                    ANNO(assignment.expression.left).copy(annoDeclaration);
                    ANNO(assignment.expression.right).copy(annoDeclaration);
                    declarators.push(declaration);
                    assignments.push(assignment);
                }

                var dest;
                if(node.type == Syntax.Program)
                    dest = node.body;
                else if(node.body.body)
                    dest = node.body.body;

                if(dest.length == 0 || dest[0].type != Syntax.VariableDeclaration) {
                    dest.unshift({
                        type: Syntax.VariableDeclaration,
                        declarations: declarators,
                        kind: "var"
                    });
                }
                else
                    dest[0].declarations.push.apply(dest[0].declarations, declarators);

                var nonDeclarationIndex = 0;
                while(nonDeclarationIndex < dest.length && dest[nonDeclarationIndex].type == Syntax.VariableDeclaration) {
                    nonDeclarationIndex++;
                }
                assignments.unshift(nonDeclarationIndex, 0);
                dest.splice.apply(dest, assignments);
            }
            return node;
        },

        addDeclaredIdentifier: function(name) {
            var topScope = this.getScope();
            if(topScope.declared.indexOf(name) == -1)
                topScope.declared.push(name);
        }
    });


    var SingleAssignmentSplitter = function() {
        StatementSplitTraverser.call(this);

    }

    Base.createClass(SingleAssignmentSplitter, StatementSplitTraverser, {


        statementSplitEnter: function(node, parent) {
            switch(node.type) {
                case Syntax.FunctionExpression:
                    return VisitorOption.Skip;
                case Syntax.CallExpression:
                case Syntax.NewExpression:
                case Syntax.MemberExpression:
                    node._usedIndex = this.getStatementTmpUsedCount();
                    return;
            }
        },

        statementSplitExit: function(node, parent) {
            switch(node.type) {
                case Syntax.CallExpression:
                case Syntax.NewExpression:
                    return this.callExit(node, parent);
                case Syntax.MemberExpression:
                    return this.memberExit(node, parent)
            }
        },

        memberExit: function(node, parent) {
            var nodeAnno = ANNO(node);
            var type = nodeAnno.getType(), kind = nodeAnno.getKind();

            var usedIndex = node._usedIndex;
            delete node._usedIndex;

            if(parent.type == Syntax.AssignmentExpression && parent.left == node)
                return;

            if(isParentNonArrayAssignment(parent))
                return;

            // Extract array access:
            if(node.computed && ANNO(node.object).getType() == Types.ARRAY && this.isObjectResult(type, kind)) {
                this.reduceStatementTmpUsed(usedIndex);

                var identifierNode = this.addAssignment(type, kind, node);
                return identifierNode;
            }


        },

        callExit: function(node, parent) {

            var nodeAnno = ANNO(node);
            var type = nodeAnno.getType(), kind = nodeAnno.getKind();

            var usedIndex = node._usedIndex;
            delete node._usedIndex;

            if(node.type == Syntax.CallExpression) {
                var argumentInfo = this.getObjectArgsInfo(node);
                if(argumentInfo) {
                    if(argumentInfo.extractArgs) {
                        var argType = argumentInfo.type;
                        var argKind = argumentInfo.kind;

                        var newNode = {type: Syntax.NewExpression,
                            callee: {type: Syntax.Identifier, name: getCalleeName(argKind)},
                            arguments: argumentInfo.args
                        };
                        ANNO(newNode).setType(argType, argKind);
                        var tmpArgIdentifier = this.addAssignment(argType, argKind, newNode);
                        node.arguments.splice(argumentInfo.argIndex, argumentInfo.args.length, tmpArgIdentifier);
                    }
                    if(argumentInfo.swizzle) {
                        node = this.convertToSwizzle(node.callee.object, node.arguments, argumentInfo);
                    }
                }
            }
            if(!this.isObjectResult(type, kind))
                return node;

            if(isParentNonArrayAssignment(parent))
                return node;


            this.reduceStatementTmpUsed(usedIndex);

            var identifierNode = this.addAssignment(type, kind, node);
            return identifierNode;
        },

        convertToSwizzle: function(object, arguments, swizzleInfo) {
            if(arguments.length == 0)
                return createSwizzleRead(object, swizzleInfo);
            else
                return createSwizzleWrite(object, arguments[0], swizzleInfo);
        },

        addAssignment: function(type, kind, right) {
            var tmpName = this.getFreeName(type, kind);

            var assignment = {
                type: Syntax.AssignmentExpression,
                operator: "=",
                left: {type: Syntax.Identifier, name: tmpName},
                right: right
            };
            ANNO(assignment).copy(ANNO(right));
            ANNO(assignment.left).copy(ANNO(right));
            this.assignmentsToBePrepended.push(assignment);

            var identifierNode = {type: Syntax.Identifier, name: tmpName};
            ANNO(identifierNode).copy(ANNO(right));
            return identifierNode;
        },

        isObjectResult: function(type, kind) {
            return type == Types.OBJECT;
        },
        getObjectArgsInfo: function(node) {
            var result = {
                type: null,
                kind: null,
                argIndex: 0,
                args: null,
                extractArgs: false,
                swizzle: null,
                swizzleOperator: null
            }
            if(!getNodeArgumentTypeAndIndex(node, result))
                return false;
            return result;

        }
    });

    function getCalleeName(kind) {
        switch(kind) {
            case Kinds.FLOAT2:
                return "Vec2";
            case Kinds.FLOAT3:
                return "Vec3";
            case Kinds.FLOAT4:
                return "Vec4";
            case Kinds.MATRIX3:
                return "Mat3";
            case Kinds.MATRIX4:
                return "Mat4";
        }
        throw new Error("Unknown Kind '" + kind + "', no callee available.");
    };


    function createSwizzleRead(object, swizzleInfo) {
        var swizzles = swizzleInfo.swizzle;
        if(swizzles.length == 1) {
            return createComponentCall(object, swizzles);
        }
        var result = { type: Syntax.NewExpression,
            callee: {type: Syntax.Identifier, name: "Vec" + swizzles.length},
            arguments: []};
        ANNO(result).setType(Types.OBJECT, getObjectKindByComponentCount(swizzles.length));
        for(var i = 0; i < swizzles.length; ++i) {
            var component = swizzles[i];
            result.arguments.push(createComponentCall(object, component));
        }
        return result;
    }

    function createSwizzleWrite(object, argObj, swizzleInfo) {
        var objectKind = ANNO(object).getKind();
        var result = { type: Syntax.NewExpression,
            callee: {type: Syntax.Identifier, name: getCalleeName(objectKind) },
            arguments: []};
        ANNO(result).copy(ANNO(object));
        var components = getObjectComponentCount(objectKind);
        var swizzles = swizzleInfo.swizzle;
        var componentMap = [];
        for(var i = 0; i < swizzles.length; ++i) {
            componentMap[getComponentIndex(swizzles[i])] = i;
        }
        for(var i = 0; i < components; ++i) {
            var argument;
            if(componentMap[i] == undefined) {
                argument = createComponentCall(object, getComponentName(i));
            }
            else {
                argument = swizzles.length == 1 ? argObj : createComponentCall(argObj, getComponentName(componentMap[i]));
                if(swizzleInfo.swizzleOperator) {
                    argument = { type: Syntax.BinaryExpression,
                        operator: swizzleInfo.swizzleOperator,
                        left: createComponentCall(object, getComponentName(i)),
                        right: argument};
                    ANNO(argument).copy(ANNO(argument.left));
                }
            }
            result.arguments.push(argument);
        }
        return result;
    }

    function getComponentIndex(swizzleComponent) {
        switch(swizzleComponent) {
            case "x":
            case "r" :
            case "s":
                return 0;
            case "y":
            case "g" :
            case "t":
                return 1;
            case "z":
            case "b" :
            case "p":
                return 2;
            case "w":
            case "a" :
            case "q":
                return 3;
        }
        throw new Error("Unknown Swizzle Component '" + swizzleComponent + "'");
    }

    function getComponentName(componentIndex) {
        switch(componentIndex) {
            case 0:
                return "x";
            case 1:
                return "y";
            case 2:
                return "z";
            case 3:
                return "w";
        }
    }

    function createComponentCall(object, component) {
        component = getComponentName(getComponentIndex(component));
        var result = {type: Syntax.CallExpression,
            callee: { type: Syntax.MemberExpression, object: object,
                property: {type: Syntax.Identifier, name: component }},
            arguments: []
        };
        ANNO(result).setType(Types.NUMBER);
        ANNO(result.callee).setType(Types.FUNCTION);
        return result;
    }

    function isParentNonArrayAssignment(node) {
        if(node.type != Syntax.AssignmentExpression)
            return false;

        if(node.left.type == Syntax.MemberExpression && ANNO(node.left.object).isArray())
            return false;

        return true;
    }

    function getNodeArgumentTypeAndIndex(node, result) {
        if(node.callee.type != Syntax.MemberExpression)
            return false;
        var objectKind = ANNO(node.callee.object).getKind();
        if(objectKind == Kinds.ANY)
            return false;
        var objComponentCnt = getObjectComponentCount(objectKind);
        var requiredComponents = getArgTypeandIndex(objComponentCnt, node.callee.property.name, result);
        if(!requiredComponents)
            return false;
        var index = result.argIndex;
        var providedComponents = 0;
        var args = [];
        while(index < node.arguments.length && providedComponents < requiredComponents) {
            var arg = node.arguments[index];
            args.push(arg);
            providedComponents += getObjectComponentCount(ANNO(arg).getKind());
            index++;
        }
        result.extractArgs = true;
        if(providedComponents == 0)
            result.extractArgs = false;
        if(providedComponents == requiredComponents && args.length == 1)
            result.extractArgs = false;
        result.args = args;
        return result;
    }

    function getObjectComponentCount(objectKind) {
        switch(objectKind) {
            case Kinds.FLOAT2:
                return 2;
            case Kinds.FLOAT3:
                return 3;
            case Kinds.FLOAT4:
                return 4;
            case Kinds.MATRIX3:
                return 9;
            case Kinds.MATRIX4:
                return 16;
            default:
                return 1; // must be number
        }
    }

    function getObjectKindByComponentCount(componentCount) {
        switch(componentCount) {
            case 2:
                return Kinds.FLOAT2;
            case 3:
                return Kinds.FLOAT3;
            case 4:
                return Kinds.FLOAT4;
            case 9:
                return Kinds.MATRIX3;
            case 16:
                return Kinds.MATRIX4;
        }
        throw new Error("Unknown Object Count '" + componentCount + "', no kind available.");
    }

    function getArgTypeandIndex(objComponentCnt, methodName, result) {
        var inputComponentCnt = 0, offsetIndex = 0;
        switch(methodName) {
            case 'add':
            case 'sub':
            case 'mul':
            case 'div':
            case 'mod':
            case 'reflect':
            case 'cross':
            case 'dot' :
                inputComponentCnt = objComponentCnt;
                break;
            case 'length' :
                inputComponentCnt = 1;
                break;
            case 'normalize' :
            case 'flip' :
                inputComponentCnt = 0;
                break;
            case 'mulVec':
                inputComponentCnt = (objComponentCnt == 16 ? 4 : 3);
                break;
            case 'col':
                inputComponentCnt = (objComponentCnt == 16 ? 4 : 3);
                offsetIndex = 1;
                break;
            default:
                var swizzleMatches = methodName.match(/^([xyzwrgbastpq]{1,4})(Add|Sub|Mul|Div)?$/);
                if(swizzleMatches) {
                    inputComponentCnt = swizzleMatches[1].length;
                    result.swizzle = swizzleMatches[1];
                    switch(swizzleMatches[2]) {
                        case "Add":
                            result.swizzleOperator = "+";
                            break;
                        case "Sub":
                            result.swizzleOperator = "-";
                            break;
                        case "Mul":
                            result.swizzleOperator = "*";
                            break;
                        case "Div":
                            result.swizzleOperator = "/";
                            break;
                    }
                }
        }
        if(!result.swizzle && inputComponentCnt <= 1) return 0;
        if(inputComponentCnt > 1){
            result.type = Types.OBJECT;
            result.kind = getObjectKindByComponentCount(inputComponentCnt);
        }
        else{
            result.type = Types.NUMBER;
        }
        result.argIndex = offsetIndex;
        return inputComponentCnt;
    }

    ns.simplifyStatements = function (aast, opt) {
        var funcArgWriteDuplicator = new FunctionArgWriteDuplicator(opt);
        aast = funcArgWriteDuplicator.execute(aast);

        var singleAssignmentSplitter = new SingleAssignmentSplitter(opt);
        aast = singleAssignmentSplitter.execute(aast);
        return aast;
    };

}(exports));

},{"../../analyze/sanitizer/statement-split-traverser":61,"../../base/annotation.js":85,"../../base/index.js":90,"../../base/typeinfo.js":92,"../../interfaces.js":123,"./../../base/common.js":87,"assert":47,"estraverse":46}],117:[function(require,module,exports){
(function (ns) {

    var walk = require('estraverse'),
        assert = require("assert"),
        Base = require("../../base/index.js"),
        common = require("./../../base/common.js"),
        Shade = require("../../interfaces.js"),
        TypeInfo = require("../../base/typeinfo.js").TypeInfo,
        StatementSplitTraverser = require("../../analyze/sanitizer/statement-split-traverser"),
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS,
        ANNO = require("../../base/annotation.js").ANNO;

    var Syntax = walk.Syntax;
    var VisitorOption = walk.VisitorOption;

    var SNIPPET_CONVERTER_MODE = {
        JS_ITERATE: 1,
        JS_NO_ITERATE: 2,
        GLSL_VS: 3
    };

    var SnippetConnector = function(){

    }

    Base.extend(SnippetConnector.prototype, {
        execute: function(snippetList, mode){
            var context = {
                iterateIdentifier: null,
                envName: null,
                blockedNames: [],
                transferInputNameMap: {},
                outputNameMap: [],
                directInputNameMap: [],
                mode: mode,
                declareNames: []
            }
            
            gatherOutputNames(snippetList, context);
            context.iterateIdentifier = getFreeName("i", context);
            if(context.mode == SNIPPET_CONVERTER_MODE.GLSL_VS){
                context.envName = getFreeName("env", context);
            }
            var ast = connectSnippets(snippetList, context);
            ast = getProgram(ast, context);
            var result = {
                ast: ast,
                argTypes: null
            };
            addArgTypes(result, context);
            return result;
        }
    });

    function gatherOutputNames(snippetList, context){
        var i = snippetList.entries.length;
        while(i--){
            var entry = snippetList.entries[i];
            var j = entry.outputInfo.length;
            while(j--){
                var outputInfo = entry.outputInfo[j];
                if(outputInfo.isFinal()){
                    var name = getFreeName(outputInfo.name, context);
                    context.transferInputNameMap[i + "_" + j] = {
                        name: name,
                        finalOutput: true
                    };
                    context.outputNameMap[outputInfo.finalOutputIndex] = {
                        name: name,
                        type: outputInfo.type
                    };
                }
            }
        }
    }

    function connectSnippets(snippetList, context){
        var ast = { type: Syntax.BlockStatement, body: []};
        for(var i = 0; i < snippetList.entries.length; ++i){
            var entry = snippetList.entries[i];
            var snippedContext = {
                outputMap: createOutputMap(entry, i, context),
                inputMap: createInputMap(entry, context),
                temporaryMap: {}
            };
            addSnippedAst(ast.body, entry, snippedContext, context );
        }
        return ast;
    }

    function getProgram(ast, context){
        var params = [];
        if(context.mode == SNIPPET_CONVERTER_MODE.GLSL_VS){
            params.push({type: Syntax.Identifier, name: context.envName})
        }
        else{
            for(var i = 0; i < context.outputNameMap.length; ++i){
                var name = context.outputNameMap[i].name;
                params.push({type: Syntax.Identifier, name: name});
            }
            for(var i = 0; i < context.directInputNameMap.length; ++i){
                var name = context.directInputNameMap[i].name;
                params.push({type: Syntax.Identifier, name: name});
            }
        }
        var body = ast;
        if(context.mode == SNIPPET_CONVERTER_MODE.JS_ITERATE){
            var iterMax = getFreeName("maxIter", context);
            params.push({type: Syntax.Identifier, name: iterMax});
            body = { type: Syntax.BlockStatement,
                body: [
                    {type: Syntax.VariableDeclaration, "kind": "var", declarations: [
                        {type: Syntax.VariableDeclarator,
                            id: {type: Syntax.Identifier, name: context.iterateIdentifier},
                            init: {type: Syntax.Identifier, name: iterMax}
                        }
                    ]},
                    {type: Syntax.WhileStatement,
                        test: {type: Syntax.UpdateExpression, operator: "--",
                            argument: {type: Syntax.Identifier, name: context.iterateIdentifier}},
                        body: ast
                    }
                ]
            };
        }
        addBodyDeclarations(body, context);
        return { type: Syntax.Program, body: [{
            type: Syntax.FunctionDeclaration,
            id: {type: Syntax.Identifier, name: "main"},
            params: params,
            defaults: [],
            body: body
        }]};
    }
    function addArgTypes(result, context){
        var argTypes = [];
        if(context.mode == SNIPPET_CONVERTER_MODE.GLSL_VS){

            var attribs = {};
            var outputIndices = {},
                inputIndices = {};

            for(var i = 0; i < context.outputNameMap.length; ++i){
                var entry = context.outputNameMap[i];
                var type = Base.deepExtend({}, entry.type);
                type.source = "vertex";
                type.output = true;
                attribs[entry.name] = type;
                outputIndices[entry.name] = i;
            }
            for(var i = 0; i < context.directInputNameMap.length; ++i){
                var entry = context.directInputNameMap[i];
                if(!entry) continue;
                var type = Base.deepExtend({}, entry.type);
                type.source = entry.iterate ? "vertex" : "uniform";
                attribs[entry.name] = type;
                inputIndices[entry.name] = i;
            }
            var env = { "extra" : {"type": "object", "kind": "any", "global": true, "info": attribs }};
            argTypes.push(env);
            result.outputIndices = outputIndices;
            result.inputIndices = inputIndices;
        }
        else{
            for(var i = 0; i < context.outputNameMap.length; ++i){
                argTypes.push({extra: {type: "array", elements: Base.deepExtend({}, context.outputNameMap[i].type) }});
            }
            for(var i = 0; i < context.directInputNameMap.length; ++i){
                var type = Base.deepExtend({}, context.directInputNameMap[i].type);
                if(!context.directInputNameMap[i].arrayAccess)
                    type = {type: "array", elements: type };
                argTypes.push({extra: type });
            }
            argTypes.push({ extra: {type: "int"}});
        }

        result.argTypes = argTypes;
    }

    function addBodyDeclarations(body, context){
        if(context.declareNames.length == 0)
            return;
        var decl = {type: Syntax.VariableDeclaration, "kind": "var",
            declarations: []};
        for(var i = 0; i < context.declareNames.length; ++i){
            var name = context.declareNames[i];
            decl.declarations.push({type: Syntax.VariableDeclarator,
                    id: {type: Syntax.Identifier, name: name},
                    init: null});
        }
        body.body.unshift(decl);
    }

    function addSnippedAst(dest, entry, snippedContext, context){
        var astBody = walk.replace(entry.ast.body, {
            leave: function(node, parent){
                switch(node.type){
                    case Syntax.Identifier : return handleIdentifierExit(node, parent, snippedContext, context);
                    case Syntax.VariableDeclarator: return handleDeclaratorExit(node, parent, snippedContext, context);
                    case Syntax.BlockStatement: return handleBlockExit(node, parent, snippedContext, context);
                    case Syntax.ReturnStatement: return handleReturnExit(node, parent, snippedContext, context);
                }
            }
        });
        dest.push.apply(dest, astBody.body);
    }


    function handleIdentifierExit(node, parent, snippedContext, context){
        if(parent.type == Syntax.Property && parent.key == node)
            return;
        if(parent.type == Syntax.VariableDeclarator)
            return;
        if(snippedContext.temporaryMap[node.name]){
            return snippedContext.temporaryMap[node.name];
        }
        if(snippedContext.inputMap[node.name]){
            return snippedContext.inputMap[node.name];
        }
    }
    function handleDeclaratorExit(node, parent, snippedContext, context){
        var name = node.id.name;
        var tmpName = getFreeName(name, context);
        context.declareNames.push(tmpName);
        snippedContext.temporaryMap[name] = { type: Syntax.Identifier, name: tmpName};
    }
    function handleBlockExit(node, parent, snippedContext, context){
        var i = node.body.length;
        while(i--){
            if(node.body[i].type == Syntax.VariableDeclaration){
                node.body.splice(i,1);
            }
        }
        return node;
    }
    function handleReturnExit(node, parent, snippedContext, context){
        if(node.argument.type != Syntax.ObjectExpression){
            var outputName;
            for(outputName in snippedContext.outputMap) break;
            return createResultAssignment(outputName, node.argument, snippedContext);
        }
        else{
            var result = { type: Syntax.BlockStatement, body: [] };
            var properties = node.argument.properties;
            var addReturn = null;
            for(var i = 0; i < properties.length; ++i){
                var prop = properties[i];
                var outputName = prop.key.name || prop.key.value;
                if(outputName == "_glPosition"){
                    if(context.mode == SNIPPET_CONVERTER_MODE.GLSL_VS){
                        addReturn = prop.value;
                    }
                }
                else{
                    result.body.push(createResultAssignment(outputName, prop.value, snippedContext));
                }
            }
            if(addReturn){
                result.body.push({
                    type: Syntax.ReturnStatement,
                    argument: addReturn
                })
            }
            return result;
        }
    }

    function createResultAssignment(name, value, snippedContext){
        return {
            type: Syntax.ExpressionStatement, expression: {
                type: Syntax.AssignmentExpression, operator: "=",
                left: Base.deepExtend({}, snippedContext.outputMap[name]),
                right: value
            }
        };
    }


    function createInputMap(entry, context){
        var result = {};
        var inputInfo = entry.inputInfo,
            params = entry.ast.params;
        for(var i = 0; i < inputInfo.length; ++i){
            var info = inputInfo[i];
            var paramName = params[i].name;
            result[paramName] = getInputAst(paramName, info, context);
        }
        return result;
    }

    function getInputAst(name, info, context){
        var actualName, pureTransfer = false;
        if(info.isTransferInput()){
            var entry = context.transferInputNameMap[info.getTransferInputKey()];
            actualName = entry.name;
            pureTransfer = !entry.finalOutput;
        }
        else{
            var index = info.directInputIndex;
            if(!context.directInputNameMap[index]){
                var type = info.type;
                if(info.arrayAccess){
                    type = {type: "array", elements: type, staticSize: info.arraySize };
                }
                context.directInputNameMap[index] = {
                    name: getFreeName(name, context),
                    type: type,
                    iterate: info.iterate,
                    arrayAccess: info.arrayAccess
                };
            }
            actualName = context.directInputNameMap[index].name;
        }
        var ast = {type: Syntax.Identifier, name: actualName};
        if(!pureTransfer){
            ast = getParamAccessAst(ast, info.arrayAccess, info.iterate, context);
        }

        return ast
    }

    function createOutputMap(entry, operatorIndex, context){
        var result = {};
        var outputInfo = entry.outputInfo;
        for(var i = 0; i < outputInfo.length; ++i){
            var info = outputInfo[i];
            var paramName = outputInfo[i].name;
            result[paramName] = getOutputAst(paramName, info, operatorIndex, i, context);
        }
        return result;
    }

    function getOutputAst(name, info, operatorIndex, outputIndex, context){
        var actualName, final;
        if(info.isFinal()){
            final = true;
            actualName = context.outputNameMap[info.finalOutputIndex].name;
        }else{
            actualName = getFreeName(name, context);
            context.transferInputNameMap[operatorIndex + "_" + outputIndex] = {
                name: actualName,
                finalOutput: false
            };
            context.declareNames.push(actualName);
        }
        var ast = {type: Syntax.Identifier, name: actualName};
        if(final){
            ast = getParamAccessAst(ast, false, true, context);
        }
        return ast
    }

    function getParamAccessAst(ast, arrayAccess, iterate, context){
        if(context.mode == SNIPPET_CONVERTER_MODE.JS_ITERATE && !arrayAccess){
            return { type: Syntax.MemberExpression, computed: true,
                    object: ast, property: ( iterate ?
                        {type: Syntax.Identifier, name: context.iterateIdentifier} :
                        {type: Syntax.Literal, value: 0, raw: "0"})
                  };
        }
        else if(context.mode == SNIPPET_CONVERTER_MODE.GLSL_VS){
            return { type: Syntax.MemberExpression,
                    object: {type: Syntax.Identifier, name: context.envName},
                    property: ast
            };
        }
    }

    function getFreeName(name, context){
        var test = name, i = 1;
        while(context.blockedNames.indexOf(test) != -1){
            test = name + "_" + (++i);
        }
        context.blockedNames.push(test);
        return test;
    }

    ns.connectSnippets = function (snippedList, opt) {
        var funcArgWriteDuplicator = new SnippetConnector();
        return funcArgWriteDuplicator.execute(snippedList, opt.mode || SNIPPET_CONVERTER_MODE.JS_ITERATE);
    };
    ns.MODE = SNIPPET_CONVERTER_MODE

}(exports));

},{"../../analyze/sanitizer/statement-split-traverser":61,"../../base/annotation.js":85,"../../base/index.js":90,"../../base/typeinfo.js":92,"../../interfaces.js":123,"./../../base/common.js":87,"assert":47,"estraverse":46}],118:[function(require,module,exports){
(function (ns) {

    var walk = require('estraverse'),
        assert = require("assert"),
        Base = require("../../base/index.js"),
        common = require("./../../base/common.js");

    var SnippetList = function(){
        this.entries = [];
    }

    Base.extend(SnippetList.prototype, {
        addEntry: function(entry){
            this.entries.push(entry);
        }
    });

    var SnippetEntry = function(ast){
        this.inputInfo = [];
        this.outputInfo = [];
        this.ast = ast || null;
    }
 
    
    Base.extend(SnippetEntry.prototype, {
        setAst: function(ast){
            this.ast = ast;
        },
        addVertexInput: function(type, directInputIndex){
            var input = new SnippetInput(type, true, false);
            input.setDirectInput(directInputIndex);
            this.inputInfo.push(input);
        },
        addUniformInput: function(type, directInputIndex){
            var input = new SnippetInput(type, false, false);
            input.setDirectInput(directInputIndex);
            this.inputInfo.push(input);
        },
        addUniformArray: function(type, directInputIndex, arraySize){
            var input = new SnippetInput(type, false, true);
            input.setDirectInput(directInputIndex, arraySize);
            this.inputInfo.push(input);
        },
        addTransferInput: function(type, transferOperatorIndex, transferOutputIndex){
            var input = new SnippetInput(type, true, false);
            input.setTransferInput(transferOperatorIndex, transferOutputIndex);
            this.inputInfo.push(input);
        },
        addLostOutput: function(type, name){
            var output = new SnippetOutput(type, name);
            this.outputInfo.push(output);
        },
        addFinalOutput: function(type, name, index){
            var output = new SnippetOutput(type, name);
            output.setFinalOutputIndex(index);
            this.outputInfo.push(output);
        }
    });


    var SnippetInput = function(type, iterate, arrayAccess){
        this.type = type;
        this.iterate = iterate;
        this.arrayAccess = arrayAccess;
        this.transferOperatorIndex = undefined;
        this.transferOutputIndex = undefined;
        this.directInputIndex = undefined;
        this.arraySize = undefined;
    }

    Base.extend(SnippetInput.prototype, {
        setDirectInput: function(directInputIndex, arraySize){
            this.transferOperatorIndex = this.transferOutputIndex = undefined;
            this.directInputIndex = directInputIndex;
            this.arraySize = arraySize;
        },
        setTransferInput: function(transferOperatorIndex, transferOutputIndex){
            this.transferOperatorIndex = transferOperatorIndex;
            this.transferOutputIndex = transferOutputIndex;
            this.directInputIndex = undefined;
        },
        isTransferInput: function(){
            return this.transferOperatorIndex !== undefined;
        },
        getTransferInputKey: function(){
            return this.transferOperatorIndex + "_" + this.transferOutputIndex;
        }
    });

    var SnippetOutput = function(type, name) {
        this.type = type;
        this.name = name;
        this.finalOutputIndex = undefined;
    }

    Base.extend(SnippetOutput.prototype, {
        setFinalOutputIndex: function(index){
            this.finalOutputIndex = index;
        },
        isFinal: function(){
            return this.finalOutputIndex !== undefined;
        }
    });

    ns.SnippetList = SnippetList;
    ns.SnippetEntry = SnippetEntry;

}(exports));

},{"../../base/index.js":90,"./../../base/common.js":87,"assert":47,"estraverse":46}],119:[function(require,module,exports){
(function (ns) {

    var common = require("../../base/common.js"),
        Shade = require("./../../interfaces.js"),
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS,
        SpaceType = Shade.SpaceType,
        VectorType = Shade.VectorType;
    var walk = require('estraverse');
    var Syntax = walk.Syntax;
    var ANNO = common.ANNO;


    ns.getSpaceTransformCall = function(ast, space){
        var callExpression = {
            type: Syntax.CallExpression,
            callee: this.getSpaceConvertFunction(space),
            arguments: [ this.getSpaceConvertArg(space), ast ]
        };
        return callExpression;
    };

    ns.getSpaceConvertFunction = function(space){
        var vectorType = Shade.getVectorFromSpaceVector(space);
        var functionName;
        switch(vectorType){
            case VectorType.POINT: functionName = "transformPoint"; break;
            case VectorType.NORMAL: functionName = "transformDirection"; break;
        }
        var result = {
            type: Syntax.MemberExpression,
            object: {type: Syntax.Identifier, name: "Space"},
            property: { type: Syntax.Identifier, name: functionName }
        };
        ANNO(result).setType(Types.FUNCTION);
        ANNO(result.object).setType(Types.OBJECT, Kinds.ANY);
        return result;
    }

    ns.getSpaceConvertArg = function(space){
        var spaceType = Shade.getSpaceFromSpaceVector(space);
        var spaceName;
        switch(spaceType){
            case SpaceType.VIEW: spaceName = "VIEW"; break;
            case SpaceType.WORLD: spaceName = "WORLD"; break;
        }
        return {
            type: Syntax.MemberExpression,
            object: { type: Syntax.Identifier, name: "Space"  },
            property: { type: Syntax.Identifier, name: spaceName }
        };
    };


}(exports));

},{"../../base/common.js":87,"./../../interfaces.js":123,"estraverse":46}],120:[function(require,module,exports){
(function (ns) {

    var Base = require("../../base/index.js"),
        common = require("../../base/common.js"),
        FunctionAnnotation = require("../../base/annotation.js").FunctionAnnotation,
        TypeInfo = require("../../base/typeinfo.js").TypeInfo,
        Shade = require("./../../interfaces.js"),
        esgraph = require('esgraph'),
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS;
    var spaceAnalyzer = require("../../analyze/space_analyzer.js"),
        SpaceVectorType = Shade.SpaceVectorType,
        SpaceType = Shade.SpaceType,
        VectorType = Shade.VectorType;
    var SpaceTransformTools = require("./space-transform-tools.js");



    var walk = require('estraverse');
    var Syntax = walk.Syntax;
    var ANNO = common.ANNO;


    /**
     * Transforms the JS AST to an AST representation convenient
     * for code generation
     * @constructor
     */
    var SpaceTransformer = function (mainId) {
        this.mainId = mainId;
    };

    function spaceInfo(ast){
        return ast.spaceInfo || {};
    }

    Base.extend(SpaceTransformer.prototype, {
        transformAast: function (aast, opt) {
            opt = opt || {};
            this.root = aast;
            this.functionSpaceInfo = {};
            this.functionTranfserInfo = {};
            this.globalIdentifiers = this.getGlobalIdentifiers(aast);
            this.envSpaces = {};

            this.transformFunctions(aast);
            this.updateGlobalObject(aast, this.envSpaces);
            return this.envSpaces;
        },
        /**
         *
         * @param {Object!} ast
         * @param {Object!} state
         * @returns {*}
         */
        transformFunctions: function(aast) {
            var self = this;
            aast = walk.replace(aast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    switch (node.type) {
                        case Syntax.FunctionDeclaration:
                            self.replaceFunctionInvocations(node.body);
                            self.extractSpaceTransforms(node);
                            this.skip();
                            break;
                    }
                }
            });
            return aast;
        },
        replaceFunctionInvocations: function(functionBodyAast){
            var self = this;
            walk.replace(functionBodyAast, {
                enter: function (node, parent) {
                    if(node.type == Syntax.CallExpression){
                        if(node.callee.type == Syntax.Identifier && self.functionSpaceInfo[node.callee.name]){
                            var paramTransitions = self.functionSpaceInfo[node.callee.name];
                            var oldArgs = node.arguments, newArgs = [];
                            for(var i = 0; i < paramTransitions.length; ++i){
                                var paramT = paramTransitions[i];
                                if(!paramT.space)
                                    oldArgs[paramT.idx] !== undefined && newArgs.push(oldArgs[paramT.idx]);
                                else{
                                    newArgs.push(SpaceTransformTools.getSpaceTransformCall(oldArgs[paramT.idx], paramT.space));
                                }
                            }
                            node.arguments = newArgs;
                        }
                    }
                }
            });
        },

        extractSpaceTransforms: function(functionAast){
            var self = this;
            this.usedIdentifiers = this.getUsedIdentifiers(functionAast);

            var analyzeResult = spaceAnalyzer.analyze(functionAast, this.functionTranfserInfo);
            var nameMap = {}, addDeclarations = [];
            this.extractEnvSpaces(analyzeResult, nameMap);
            this.initFunctionHeader(functionAast, analyzeResult, nameMap, addDeclarations);

            functionAast.body = walk.replace(functionAast.body, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    if(node.type == Syntax.ExpressionStatement){
                        var newStatement = self.duplicateSpaceStatement(node, nameMap, addDeclarations);
                        if(newStatement){
                            this.skip();
                            return newStatement;
                        }
                    }
                    else if(spaceInfo(node).hasSpaceOverrides){
                        self.resolveSpaceUsage(node, SpaceVectorType.OBJECT, nameMap);
                        this.skip();
                    }
                }
            });
            this.addDeclarations(functionAast, addDeclarations);
            this.cleanUpDeclarations(functionAast);
        },

        extractEnvSpaces: function(analyzeResult, nameMap){
            for(var name in analyzeResult){
                if(name.indexOf("env.") == 0){
                    var property = name.substr(4);
                    var j = analyzeResult[name].length;
                    while(j--){
                        var space = analyzeResult[name][j];
                        var spaceName = this.getSpaceName(name, space);
                        if(!this.envSpaces[property]) this.envSpaces[property] = [];
                        if( !this.envSpaces[property].some(function(e){return e.space == space}))
                            this.envSpaces[property].push({ name: spaceName.split(".")[1], space: space } );
                        if(!nameMap[name]) nameMap[name] = {};
                        nameMap[name][space] = this.getSpaceName(name, space);
                    }
                }
            }
        },

        initFunctionHeader: function(functionAast, analyzeResult, nameMap, addDeclarations){
            var newParams = [];
            var paramTransitions = [];
            for(var i = 0; i < functionAast.params.length; ++i){
                var param = functionAast.params[i], paramName = param.name;
                if(analyzeResult[paramName]){
                    var j = analyzeResult[paramName].length, hasObjectSpace = false;
                    while(j--){
                        var space = analyzeResult[paramName][j];
                        if(space != SpaceVectorType.OBJECT){
                            if(!nameMap[paramName]) nameMap[paramName] = {};
                            nameMap[paramName][space] = this.getSpaceName(paramName, space);
                            var newParam = {
                                type: Syntax.Identifier,
                                name: nameMap[paramName][space]
                            };
                            ANNO(newParam).copy(ANNO(param));
                            newParams.push(newParam);
                            paramTransitions.push({idx: i, space: space});
                        }
                        else{
                            hasObjectSpace = true;
                            newParams.push(param);
                            paramTransitions.push({idx: i});
                        }
                    }
                    if(!hasObjectSpace){
                        addDeclarations.push(paramName);
                    }
                }
                else{
                    newParams.push(param);
                    paramTransitions.push({idx: i});
                }
            }
            functionAast.params = newParams;
            this.functionSpaceInfo[functionAast.id.name] = paramTransitions;
        },

        duplicateSpaceStatement: function(statementAast, nameMap, addedDeclarations){
            var duplicatedStatements = [];
            var child = statementAast.expression;
            var sInfo = spaceInfo(child);

            var newSpaceNameEntries = {};
            if(!sInfo.finalSpaces){
                nameMap[sInfo.def] = newSpaceNameEntries;
                return;
            }

            sInfo.finalSpaces.forEach(function(space){
                var expressionCopy = JSON.parse(JSON.stringify(child));
                if(space != SpaceVectorType.OBJECT && !this.isSpacePropagrationPossible(sInfo, space)){
                    this.resolveSpaceUsage(expressionCopy, SpaceVectorType.OBJECT, nameMap);
                    expressionCopy.right = SpaceTransformTools.getSpaceTransformCall(expressionCopy.right, space);
                }
                else{
                    this.resolveSpaceUsage(expressionCopy, space, nameMap);
                }
                duplicatedStatements.push({ type: Syntax.ExpressionStatement, expression: expressionCopy });
                if(space != SpaceVectorType.OBJECT){
                    var spaceName = this.getSpaceName(sInfo.def, space);
                    if(addedDeclarations.indexOf(spaceName) == -1)
                        addedDeclarations.push(spaceName);
                    newSpaceNameEntries[space] = spaceName;
                    expressionCopy.left.name = spaceName;
                }

            }.bind(this));
            nameMap[sInfo.def] = newSpaceNameEntries;

            if(duplicatedStatements.length == 0)
                return;
            if(duplicatedStatements.length == 1)
                return duplicatedStatements[0];

            var blockStatement = {
                type: Syntax.BlockStatement,
                body: duplicatedStatements
            };
            return blockStatement

        },

        addDeclarations: function(functionAast, addDeclarations){
            var i = functionAast.params.length;
            while(i--) {
                var idx = addDeclarations.indexOf(functionAast.params[i].name);
                if(idx != -1)
                    addDeclarations.splice(idx, 1);
            }
            if(addDeclarations.length > 0){
                var declarations = { type: Syntax.VariableDeclaration, kind: "var", declarations: []};
                var i = addDeclarations.length;
                while(i--){
                    var name = addDeclarations[i];
                    var decl = {type: Syntax.VariableDeclarator, id: {type: Syntax.Identifier, name: name}, init: null};
                    ANNO(decl).setType(Types.OBJECT, Kinds.FLOAT3);
                    declarations.declarations.push(decl);
                }
                functionAast.body.body.unshift(declarations);
            }
        },

        isSpacePropagrationPossible: function(sInfo, targetSpace){
            if(sInfo.propagateSet.length == 0) // We need to have at least one dependency. Otherwise we can't propagate the space
                return false;
            var vectorType = Shade.getVectorFromSpaceVector(targetSpace)
            if(vectorType == VectorType.NORMAL && sInfo.normalSpaceViolation)
                return false;
            if(vectorType == VectorType.POINT && sInfo.pointSpaceViolation)
                return false;

            return true;
        },

        resolveSpaceUsage: function(aast, targetSpace, nameMap){
            var self = this;
            aast = walk.replace(aast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    switch (node.type) {
                        case Syntax.Identifier:
                            if(targetSpace != SpaceVectorType.OBJECT && spaceInfo(node).propagate){
                                node.name = nameMap[node.name][targetSpace];
                            }
                            break;
                        case Syntax.MemberExpression:
                            if(targetSpace != SpaceVectorType.OBJECT && spaceInfo(node).propagate){
                                var nameKey = "env." + node.property.name;
                                var name = nameMap[nameKey][targetSpace],
                                    token = name.split(".");
                                node.property.name = token[1];
                            }
                            break;
                        case Syntax.CallExpression:
                            var sInfo = spaceInfo(node);
                            if(sInfo.spaceOverride &&
                                self.isSpacePropagrationPossible(sInfo, sInfo.spaceOverride))
                            {
                                var result = self.resolveSpaceUsage(node.arguments[1], sInfo.spaceOverride, nameMap);
                                this.skip();
                                return result;
                            }
                    }
                }
            });
            return aast;
        },

        getSpaceName: function(name, space){
            if(space == SpaceVectorType.OBJECT)
                return name;

            var checkGlobal = false;
            if(name.indexOf("env.") == 0){
                checkGlobal = true;
                name = name.substr(4);
            }
            switch(space){
                case SpaceVectorType.VIEW_POINT : name += "_vps"; break;
                case SpaceVectorType.WORLD_POINT : name += "_wps"; break;
                case SpaceVectorType.VIEW_NORMAL : name += "_vns"; break;
                case SpaceVectorType.WORLD_NORMAL : name += "_wns"; break;
            }
            var result = name;
            var i = 2;
            while( (checkGlobal ? this.globalIdentifiers : this.usedIdentifiers ).indexOf(result) != -1){
                result = name + i++;
            }
            if(checkGlobal)
                result = "env." + result;
            return result;
        },

        getUsedIdentifiers : function(functionAast){
            var result = [];
            walk.traverse(functionAast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    if(node.type == Syntax.Identifier){
                        if( parent.type == Syntax.MemberExpression && parent.property == node)
                            return;
                        if(result.indexOf(node.name) == -1)
                            result.push(node.name);
                    }
                }
            });
            return result;
        },
        getGlobalIdentifiers : function(programAast){
            var result = [];
            walk.traverse(programAast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    if(node.type == Syntax.MemberExpression && node.object.extra.global){
                        if(result.indexOf(node.property.name) == -1)
                            result.push(node.property.name);
                    }
                }
            });
            return result;
        },
        cleanUpDeclarations: function(functionAast){
            var declarators = [];
            var body = functionAast.body.body;
            var i = body.length;
            while(i--){
                if(body[i].type == Syntax.VariableDeclaration){
                    declarators.push.apply(declarators, body[i].declarations);
                    body.splice(i,1);
                }
            }
            var usedIdentifiers = this.getUsedIdentifiers(functionAast.body);
            var declaration = { type: Syntax.VariableDeclaration, kind: "var", declarations: []};
            i = declarators.length;
            while(i--){
                if(usedIdentifiers.indexOf(declarators[i].id.name) != -1){
                    declaration.declarations.push(declarators[i]);
                }
            }
            if(declaration.declarations.length > 0)
                body.unshift(declaration);
        },

        updateGlobalObject: function(aast, envSpaces){
            if(!aast.globalParameters)
                return;
            var globalObject;
            for(var funcName in aast.globalParameters){
                var args = aast.globalParameters[funcName];
                var i = args.length;
                while(i--){
                    if(args[i].extra.global)
                        globalObject = args[i].extra;
                }
            }
            if(!globalObject)
                return;
            var newInfo = {};
            for(var propName in globalObject.info){
                var data = globalObject.info[propName];
                if(!envSpaces[propName]){
                    newInfo[propName] = data;
                    continue;
                }
                var entryList = envSpaces[propName];
                for(var i = 0; i < entryList.length; ++i){
                    var copyData = Base.deepExtend({}, data);
                    newInfo[entryList[i].name]= copyData;
                }
            }
            globalObject.info = newInfo;
            walk.traverse(aast, {
                enter: function (node, parent) {
                    //console.log("Enter:", node.type);
                    if(node.extra && node.extra.global){
                        node.extra.info = newInfo;
                    }
                    if(node.scope && node.scope.bindings){
                        for(var name in node.scope.bindings){
                            if(node.scope.bindings[name].extra.global){
                                node.scope.bindings[name].extra.info = newInfo;
                            }
                        }
                    }
                }
            });
        }


    });

    // Exports
    ns.SpaceTransformer = new SpaceTransformer();


}(exports));

},{"../../analyze/space_analyzer.js":64,"../../base/annotation.js":85,"../../base/common.js":87,"../../base/index.js":90,"../../base/typeinfo.js":92,"./../../interfaces.js":123,"./space-transform-tools.js":119,"esgraph":27,"estraverse":46}],121:[function(require,module,exports){
(function (ns) {

    var Syntax = require('estraverse').Syntax;
    var Base = require("../base/index.js");
    var ANNO = require("../base/annotation.js").ANNO;
    var TypeInfo = require("../base/typeinfo.js").TypeInfo;
    var Shade = require("../interfaces.js");
    var VecBase = require("../base/vec.js");

    var TYPES = Shade.TYPES,
        KINDS = Shade.OBJECT_KINDS;



    ns.removeMemberFromExpression = function (node) {
        return {
            type: Syntax.Identifier,
            name: node.property.name
        }
    }

    ns.generateFreeName = function(name, blockedNames){
        var newName = name.replace(/_+/g, "_"), i = 1;
        while(blockedNames.indexOf(newName) != -1){
            newName = (name + "_" + (++i)).replace(/_+/g, "_");
        }
        blockedNames.push(newName);
        return newName;
    }

    ns.getInternalFunctionName = function(state, key, type, details){
        if(!state.internalFunctions[key]){
            var name = ns.generateFreeName(key, state.blockedNames);
            state.internalFunctions[key] = {
                name: name,
                type: type,
                details: details
            };
        }
        return state.internalFunctions[key].name;
    };


    ns.binaryExpression2FunctionCall = function(node, name) {
        node.right = ns.castToFloat(node.right);
        node.left = ns.castToFloat(node.left);
        return {
            type: Syntax.CallExpression,
            callee: {
                type: Syntax.Identifier,
                name: name
            },
            arguments: [
                node.left,
                node.right
            ],
            extra: {
                type: TYPES.NUMBER
            }
        }
    };

    var Vec = {
        getVecArgs: function(args){
            if(args.length == 0){
                var result = [
                    {
                        type: "Literal",
                        value: "0"
                    }
                ];
                ANNO(result[0]).setType(TYPES.NUMBER);
                return result;
            }
            else{
                return args;
            }
        },

        generateVecFromArgs: function(vecCount, args){
            if(vecCount == 1)
                return args[0];
            if(args.length == 0){
                args = Vec.getVecArgs(args);
            }

            if(args.length == 1 && ANNO(args[0]).isOfKind(KINDS['FLOAT' + vecCount]))
                return args[0];
            var result = {
                type: Syntax.NewExpression,
                callee: {
                    type: Syntax.Identifier,
                    name: "Vec" + vecCount
                },
                arguments: args
            };
            ANNO(result).setType(TYPES.OBJECT, KINDS['FLOAT' + vecCount]);
            ANNO(result.callee).setType(TYPES.FUNCTION);
            return result;
        },

        createSwizzle: function(vecCount, swizzle, node, args, parent){
            if (args.length == 0) {
                node.callee.extra = node.extra;
                return node.callee;
            }
            var singular = swizzle.length == 1;
            var argObject = singular ? node.arguments[0] : Vec.generateVecFromArgs(swizzle.length, node.arguments);
            var replace = {
                type: Syntax.NewExpression,
                callee: {
                   type: Syntax.Identifier,
                   name: "Vec" + vecCount
                },
                arguments: []
            };
            var indices = [];
            for(var i = 0; i < swizzle.length; ++i){
                var idx = VecBase.swizzleToIndex(swizzle.charAt(i));
                indices[idx] = i;
            }
            for(var i = 0; i < vecCount; ++i){
                if(indices[i] !== undefined){
                    replace.arguments[i] = singular ? argObject : {
                        type: Syntax.MemberExpression,
                        object: argObject,
                        property: {
                            type: Syntax.Identifier,
                            name: VecBase.indexToSwizzle(indices[i])
                        }
                    };
                }
                else{
                   replace.arguments[i] = {
                        type: Syntax.MemberExpression,
                        object: node.callee.object,
                        property: {
                            type: Syntax.Identifier,
                            name: VecBase.indexToSwizzle(i)
                        }
                    };
                }
            }
            ANNO(replace).copy(ANNO(node));
            return replace;
        },
        createSwizzleOperator: function(vecCount, swizzle, operator, node, args, parent){
            var singular = swizzle.length == 1;
            var argObject = singular ? node.arguments[0] : Vec.generateVecFromArgs(swizzle.length, node.arguments);
            var replace = {
                type: Syntax.NewExpression,
                callee: {
                   type: Syntax.Identifier,
                   name: "Vec" + vecCount
                },
                arguments: []
            };
            var indices = [];
            for(var i = 0; i < swizzle.length; ++i){
                var idx = VecBase.swizzleToIndex(swizzle.charAt(i));
                indices[idx] = i;
            }
            for(var i = 0; i < vecCount; ++i){
                var thisValue = {
                    type: Syntax.MemberExpression,
                    object: node.callee.object,
                    property: {
                        type: Syntax.Identifier,
                        name: VecBase.indexToSwizzle(i)
                    }
                };
                if(indices[i] !== undefined){
                    replace.arguments[i] = {
                        type: Syntax.BinaryExpression,
                        operator: operator,
                        left: thisValue,
                        right: singular ? argObject : {
                            type: Syntax.MemberExpression,
                            object: argObject,
                            property: {
                                type: Syntax.Identifier,
                                name: VecBase.indexToSwizzle(indices[i])
                            }
                        }
                    }
                }
                else{
                   replace.arguments[i] = thisValue
                }
            }
            ANNO(replace).copy(ANNO(node));
            return replace;
        },

        attachSwizzles: function (instance, vecCount, callExp, callOperatorExp){
            for(var s = 0; s < VecBase.swizzleSets.length; ++s){
                for(var count = 1; count <= 4; ++count){
                    var max = Math.pow(vecCount, count);
                     for(var i = 0; i < max; ++i){
                        var val = i;
                        var key = "";
                        var indices = [], withSetter = (count <= vecCount);
                        for(var  j = 0; j < count; ++j){
                            var idx = val % vecCount;
                            val = Math.floor(val / vecCount);
                            key+= VecBase.swizzleSets[s][idx];
                            if(indices[idx])
                                withSetter = false;
                            else
                                indices[idx] = true;
                        }
                        instance[key] = {
                            callExp: callExp.bind(null, vecCount, key)
                        };
                        if(withSetter && callOperatorExp){
                            for(var operator in VecBase.swizzleOperators){
                                var opSymbol = VecBase.swizzleOperators[operator];
                                instance[key + operator] = {
                                    callExp: callOperatorExp.bind(null, vecCount, key, opSymbol)
                                };
                            }
                        }
                    }
                }
            }
        },

        createOperator: function(vecCount, operator, node, args, parent) {
            var other = Vec.generateVecFromArgs(vecCount, node.arguments);
            var replace = {
                type: Syntax.BinaryExpression,
                operator: operator,
                left: node.callee.object,
                right: other
            };
            ANNO(replace).copy(ANNO(node));
            return replace;
        },

        attachOperators: function(instance, vecCount, operators){
            for(var name in operators){
                var operator = operators[name];
                instance[name] = {
                    callExp: Vec.createOperator.bind(null, vecCount, operator)
                }
            }
        },

        createFunctionCall: function(functionName, secondVecSize, node, args, parent) {
            var replace = {
                type: Syntax.CallExpression,
                callee: {
                    type: Syntax.Identifier,
                    name: functionName
                },
                arguments: [
                    node.callee.object
                ]
            };
            if(secondVecSize){
                var other = Vec.generateVecFromArgs(secondVecSize, node.arguments);
                replace.arguments.push(other);
            }
            ANNO(replace).copy(ANNO(node));
            return replace;
        },

        generateLengthCall: function(node, args, parent){
            if(args.length == 0){
                return Vec.createFunctionCall('length', 0, node, args, parent);
            }
            else{
                 var replace = {
                    type: Syntax.BinaryExpression,
                    operator: '*',
                    left: node.callee.object,
                    right: {
                        type: Syntax.BinaryExpression,
                        operator: '/',
                        left: node.arguments[0],
                        right: Vec.createFunctionCall('length', 0, node, args, parent)
                    }
                };
                ANNO(replace.right).setType(TYPES.NUMBER);
                ANNO(replace).copy(ANNO(node));
                return replace;
            }
        },

        generateConstructor: function(node){
            node.arguments = Vec.getVecArgs(node.arguments);
        }
    };

    var Mat = {
        TYPES: {
            "Mat3" : {kind: KINDS.MATRIX3, colKind: KINDS.FLOAT3, colCount: 3, glslType: "mat3"},
            "Mat4" : {kind: KINDS.MATRIX4, colKind: KINDS.FLOAT4, colCount: 4, glslType: "mat3"}
        },

        generateMatFromArgs: function(matName, args){
            if(args.length == 0){
                args = Vec.getVecArgs(args);
            }

            if(args.length == 1 && ANNO(args[0]).isOfKind( Mat.TYPES[matName].kind))
                return args[0];
            var result = {
                type: Syntax.NewExpression,
                callee: {
                    type: Syntax.Identifier,
                    name: matName
                },
                arguments: args
            };
            ANNO(result).setType(TYPES.OBJECT, Mat.TYPES[matName].kind);
            ANNO(result.callee).setType(TYPES.FUNCTION);
            return result;
        },

        createOperator: function(matName, operator, node, args, parent) {
            var other = Mat.generateMatFromArgs(matName, node.arguments);
            var replace = {
                type: Syntax.BinaryExpression,
                operator: operator,
                left: node.callee.object,
                right: other
            };
            ANNO(replace).copy(ANNO(node));
            return replace;
        },

        attachOperators: function(instance, matName, operators){
            for(var name in operators){
                var operator = operators[name];
                instance[name] = {
                    callExp: Mat.createOperator.bind(null, matName, operator)
                }
            }
        },

        generateColCall: function(matName, node, args, parent, state){
            var memberAccess = {
                type: Syntax.MemberExpression,
                object: node.callee.object,
                property: node.arguments[0],
                computed: true
            };
            ANNO(memberAccess).setType(TYPES.OBJECT, Mat.TYPES[matName].colKind);

            if(args.length == 1){
                return memberAccess;
            }
            else{
                var methodKey = "_" + matName + "_col";
                var methodName = ns.getInternalFunctionName(state, methodKey,
                    "MatCol", {colType: "vec" + Mat.TYPES[matName].colCount, matType: Mat.TYPES[matName].glslType});

                 var replace = {
                    type: Syntax.CallExpression,
                    callee: {type: Syntax.Identifier, name: methodName},
                    arguments: [
                        node.callee.object,
                        node.arguments[0],
                        node.arguments[1]
                    ]
                };
                ANNO(replace).copy(ANNO(node));
                return replace;
            }
        }

    }


    ns.Vec = Vec;
    ns.Mat = Mat;

    ns.castToFloat = function (ast) {
        var exp = ANNO(ast);

        if (!exp.isNumber()) {   // Cast
            return {
                type: Syntax.CallExpression,
                callee: {
                    type: Syntax.Identifier,
                    name: "float"
                },
                arguments: [ast]
            }
        }
        return ast;
    }

    ns.getNameForSystem = function(baseName) {
        return baseName;
    }

    ns.getNameForGlobal = function(baseName) {
        var name = "_env_" + baseName;
        return name.replace(/_+/g, "_");
    }

    /**
     * @param {Object} node
     * @param  {GLTransformContext} context
     * @returns {*}
     */
    ns.castToVec4 = function (node, context) {
        var exp = TypeInfo.createForContext(node, context);

        if (exp.isOfKind(KINDS.FLOAT4) || exp.isOfKind(KINDS.COLOR_CLOSURE))
            return node;

        if (exp.isOfKind(KINDS.FLOAT3)) {
            return {
                type: Syntax.CallExpression,
                callee: {
                    type: Syntax.Identifier,
                    name: "vec4"
                },
                arguments: [node, { type: Syntax.Literal, value: 1.0, extra: { type: TYPES.NUMBER} }]
            }
        }
        Shade.throwError(node, "Can't cast from '" + exp.getTypeString() + "' to vec4");
    }

    ns.extend = Base.extend;
    ns.createClass = Base.createClass;

}(exports))

},{"../base/annotation.js":85,"../base/index.js":90,"../base/typeinfo.js":92,"../base/vec.js":93,"../interfaces.js":123,"estraverse":46}],122:[function(require,module,exports){
(function (ns) {
    var parser = require('esprima'),
        codegen = require('escodegen'),
        parameters = require("./analyze/parameters.js"),
        interfaces = require("./interfaces.js"),
        inference = require("./analyze/typeinference/typeinference.js"),
        sanitizer = require("./analyze/sanitizer/sanitizer.js"),
        Base = require("./base/index.js"),
        GLSLCompiler = require("./generate/glsl/compiler.js").GLSLCompiler,
        GLMatrixCompiler = require("./generate/glmatrix/compiler.js").GLMatrixCompiler,
        LightPassGenerator = require("./generate/light-pass/light-pass-generator.js"),
        resolver = require("./resolve/resolve.js"),
        SpaceTransformer = require("./generate/space/transform.js").SpaceTransformer,
        validator = require("./analyze/validator.js"),
        analyzer = require("./analyze/analyze.js"),
        SpaceVectorType = interfaces.SpaceVectorType,
        SpaceType = interfaces.SpaceType,
        VectorType = interfaces.VectorType,
        SnippetList = require("./generate/snippets/snippet-list.js").SnippetList,
        SnippetEntry = require("./generate/snippets/snippet-list.js").SnippetEntry,
        SnippetConnector = require("./generate/snippets/snippet-connector"),
        GlMatrix = require("./contrib/gl-matrix.js");


    require("./contrib/gl-matrix-extend.js").extend(GlMatrix);


    var WorkingSet = function(){
        this.ast = null;
        this.aast = null;
        this.result = null;
        this.processingData = {};
    };
    Base.extend(WorkingSet.prototype, {
        setAst: function(ast){
            this.ast = ast;
        },
        parse: function(code, opt){
            opt = opt || {};
            this.ast = ns.parse(code, opt);
        },
        analyze: function(inject, implementation, opt){
            opt = opt || {};
            opt.entry = opt.entry || "global.shade";
            opt.validate = opt.validate !== undefined ? opt.validate : true;
            opt.throwOnError = opt.throwOnError !== undefined ? opt.throwOnError : true;
            opt.implementation = implementation;
            opt.inject = inject;
            this.aast = analyzer.analyze(this.ast, this.processingData, opt).ast;
            return this.aast;
        },
        getProcessingData: function(key){
            return this.processingData[key];
        },
        compileFragmentShader: function(opt){
            this.result = ns.compileFragmentShader(this.aast, opt);
            return this.result;
        }
    });



    Base.extend(ns, {

        parse: function(ast, opt) {
            if (typeof ast == 'string') {
                return parser.parse(ast, {raw: true, loc: opt.loc || false });
            }
            return ast;
        },

        /**
         * Analyze the given source and extract all used shader and system parameters
         *
         * @param {function|string} input The function of source code to analyze
         * @param opt Options
         * @returns {{shaderParameters: Array, systemParameters: Array}}
         */
        extractParameters: function (input, opt) {
            if (typeof input == 'function') {
                input = input.toString();
            }
            var ast = parser.parse(input);
            return parameters.extractParameters(ast, opt);
        },

        getSanitizedAst: function(str, opt){
            var ast = this.parse(str, opt);
            return sanitizer.sanitize(ast, opt);
        },

        parseAndInferenceExpression: function (ast, opt) {
            opt = opt || {};
            opt.entry = opt.entry || "global.shade";
            opt.validate = opt.validate !== undefined ? opt.validate : true;
            opt.throwOnError = opt.throwOnError !== undefined ? opt.throwOnError : true;

            ast = ns.parse(ast, opt);
            return analyzer.analyze(ast, {}, opt).ast;
        },

        analyze: function(ast, opt) {
            opt = opt || {};
            ast = ns.parse(ast, opt);

            return analyzer.analyze(ast, {}, opt)
        },

        resolveClosures: function(ast, implementation, processData, opt) {
            opt = opt || {};
            processData = processData || {};
            return resolver.resolveClosuresPreTypeInference(ast, implementation, processData, opt);
        },

        resolveSpaces: function(aast, opt){
            opt = opt || {};
            return SpaceTransformer.transformAast(aast, opt);
        },

        getLightPassAast: function(colorClosureSignatures, inject, opt){
            return LightPassGenerator.generateLightPassAast(colorClosureSignatures, inject)
        },

        compileFragmentShader: function(aast, opt){
            return new GLSLCompiler().compileFragmentShader(aast, opt);
        },

        toJavaScript: function(aast, opt){
            return codegen.generate(aast, opt);
        },
        getSnippetAst: function(code){
            var fullAst;
            if(typeof(code) == "function"){
                code = "METHOD=" + code.toString();
                fullAst = this.getSanitizedAst(code, {}).body[0].expression.right;
            }
            else{
                fullAst = this.getSanitizedAst(Base.deepExtend({}, code), {});
            }
            return fullAst;
        },

        compileJsProgram: function(snippetList, systemParams, defaultIteration){
            var result = SnippetConnector.connectSnippets(snippetList, {
                mode: defaultIteration ? SnippetConnector.MODE.JS_ITERATE : SnippetConnector.MODE.JS_NO_ITERATE});

            var aast = this.parseAndInferenceExpression(result.ast, {
                entry: "global.main",
                validate: true,
                inject: {
                    "this": systemParams,
                    "global.main": result.argTypes
                }
            });

            var compiled = new GLMatrixCompiler().compile(aast, {});
            return {
                code: compiled
            }
        },

        compileVertexShader: function(snippetList, systemParams){
            var result = SnippetConnector.connectSnippets(snippetList, { mode: SnippetConnector.MODE.GLSL_VS });

            var aast = this.parseAndInferenceExpression(result.ast, {
                entry: "global.main",
                validate: true,
                inject: {
                    "this": systemParams,
                    "global.main": result.argTypes
                }
            });

            var inputIndices = {};
            for(var inputName in result.inputIndices){
                inputIndices["_env_" + inputName] =  result.inputIndices[inputName];
            }

            var compiled = new GLSLCompiler().compileVertexShader(aast, {});
            return {
                code: compiled.source,
                inputIndices: inputIndices
            }
        },


        TYPES : interfaces.TYPES,
        OBJECT_KINDS : interfaces.OBJECT_KINDS,
        SOURCES: interfaces.SOURCES,
        SPACE_VECTOR_TYPES: SpaceVectorType,
        Vec2: interfaces.Vec2,
        Vec3: interfaces.Vec3,
        Vec4: interfaces.Vec4,
        Texture: interfaces.Texture,
        Color: interfaces.Color,
        Mat3: interfaces.Mat3,
        Mat4: interfaces.Mat4,
        WorkingSet: WorkingSet,
        SnippetList: SnippetList,
        SnippetEntry: SnippetEntry,
        Math: GlMatrix

});
    /**
     * Library version:
     */
    ns.version = '0.0.1';

}(exports));

},{"./analyze/analyze.js":56,"./analyze/parameters.js":59,"./analyze/sanitizer/sanitizer.js":60,"./analyze/typeinference/typeinference.js":79,"./analyze/validator.js":84,"./base/index.js":90,"./contrib/gl-matrix-extend.js":95,"./contrib/gl-matrix.js":96,"./generate/glmatrix/compiler.js":98,"./generate/glsl/compiler.js":100,"./generate/light-pass/light-pass-generator.js":114,"./generate/snippets/snippet-connector":117,"./generate/snippets/snippet-list.js":118,"./generate/space/transform.js":120,"./interfaces.js":123,"./resolve/resolve.js":126,"escodegen":9,"esprima":45}],123:[function(require,module,exports){
(function (ns) {
    var Base = require("./base/index.js");
    var CodeGen = require("escodegen");
    var VecMath = require("./base/vecmath.js").VecMath;


    /**
     * @enum {string}
     */
    var Types = ns.TYPES = {
        ANY: "any",
        INT: "int",
        NUMBER: "number",
        BOOLEAN: "boolean",
        OBJECT: "object",
        ARRAY: "array",
        NULL: "null",
        UNDEFINED: "undefined",
        FUNCTION: "function",
        STRING: "string",
        INVALID: "invalid"
    }

    var Kinds = ns.OBJECT_KINDS = {
        ANY: "any",
        FLOAT2: "float2", // virtual kinds
        FLOAT3: "float3", // virtual kinds
        FLOAT4: "float4", // virtual kinds
        NORMAL: "normal",
        MATRIX3: "matrix3",
        MATRIX4: "matrix4",
        TEXTURE: "texture",
        COLOR_CLOSURE: "color_closure"
    }

    var Semantics = ns.SEMANTICS = {
        COLOR: 'color',
        NORMAL: 'normal',
        SCALAR_0_TO_1: 'scalar0To1',
        UNKNOWN: 'unknown'
    }

    /**
     * Possible Spaces
     * @enum
     */
    var SpaceType = ns.SpaceType = {
        OBJECT: 0,
        VIEW: 1,
        WORLD: 2,
        RESULT: 5
    };
    var VectorType = ns.VectorType = {
        NONE: 0,
        POINT: 1,
        NORMAL: 2
    };
    ns.SpaceVectorType = {
        OBJECT: SpaceType.OBJECT,
        VIEW_POINT : SpaceType.VIEW + (VectorType.POINT << 3),
        WORLD_POINT : SpaceType.WORLD + (VectorType.POINT << 3),
        VIEW_NORMAL : SpaceType.VIEW + (VectorType.NORMAL << 3),
        WORLD_NORMAL : SpaceType.WORLD + (VectorType.NORMAL << 3),
        RESULT_POINT : SpaceType.RESULT + (VectorType.POINT << 3),
        RESULT_NORMAL : SpaceType.RESULT + (VectorType.NORMAL << 3)
    };
    ns.getVectorFromSpaceVector = function(spaceType){
        return spaceType >> 3;
    }
    ns.getSpaceFromSpaceVector = function(spaceType){
        return spaceType % 8;
    }

    ns.SOURCES = {
        UNIFORM: "uniform",
        VERTEX: "vertex",
        CONSTANT: "constant"
    }

    ns.ColorClosures = {
        "emissive" : {
            input: [
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.COLOR}
            ]
        },
        "diffuse" : {
            input: [
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0 }
            ]
        },
        "phong" : {
            input: [
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0}
            ]
        },
        cookTorrance: {
            input: [
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0.0},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0.0}
            ]
        },
        ward: {
            input: [
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.NORMAL},
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0.0},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0.0}
            ]
        },
        scatter: {
            input: [
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.COLOR},
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 0}
            ]
        },
        "reflect" : {
            input: [
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 1 },
            ]
        },
        "refract" : {
            input: [
                { type: Types.OBJECT, kind: Kinds.FLOAT3, semantic: Semantics.NORMAL},
                { type: Types.NUMBER, semantic: Semantics.SCALAR_0_TO_1, defaultValue: 1 },
                { type: Types.NUMBER, semantic: Semantics.UNKNOWN, defaultValue: 1 },
            ]
        }
    }

    function isArray(v){
        return v instanceof Array ||
            v instanceof Float32Array ||
            v instanceof Float64Array ||
            v instanceof Int16Array ||
            v instanceof Int32Array ||
            v instanceof Int8Array;
    }


    function constructFromMatrix(dest, matSize, args){
        if(args.length > 1){
            for(var i = 0; i < args.length; ++i){
                if(args[i] instanceof Mat3 || args[i] instanceof Mat4 || args[i] instanceof Array)
                    throw "Constructing Matrix from Matrix can only take one argument";
            }
        }
        if(args.length < 1)
            return false;
        if(args.length == 1){
            var srcMat = args[0];
            var srcSize = 0;

            if(srcMat instanceof Mat3) srcSize = 3;
            else if(srcMat instanceof Mat4) srcSize = 4;
            else if(isArray(srcMat)) srcSize = srcMat.length == 16 ? 4 : 3;
            else return false;

            for(var y = 0; y < matSize; y++)
                for(var x = 0; x < matSize; x++){
                    var destIdx = y*matSize + x;
                    if(x < srcSize && y < srcSize){
                        var srcIdx = y*srcSize + x;
                        dest[destIdx] = srcMat[srcIdx];
                    }
                    else dest[destIdx] = x == y ? 1 : 0;
                }
            return true;
        }

    }

    function fillVector(dest, vecSize, arguments){
        var color = false;
        if(arguments.length == 0 ){
            for(var i = 0; i < vecSize; ++i)
                dest[i] = 0;
            if(color) dest[3] = 1;
            return;
        }
        if(arguments.length == 1 && !isNaN(arguments[0])){
            for(var i = 0; i < vecSize; ++i)
                dest[i] = arguments[0];
            if(color) dest[3] = 1;
            return;
        }

        var idx = 0;
        for(var i = 0; idx < vecSize && i < arguments.length; ++i){
            var arg= arguments[i], cnt = 0;

            if(!isNaN(arg)) cnt = 1;
            else if(arg instanceof Vec2) cnt = 2;
            else if(arg instanceof Vec3) cnt = 3;
            else if(arg instanceof Vec4) cnt = 4;
            else if(arg instanceof Mat3) cnt = 9;
            else if(arg instanceof Mat4) cnt = 16;
            else if(Array.isArray(arg) || (typeof arg === "object" && "BYTES_PER_ELEMENT" in arg)) cnt = arg.length;
            else return false;

            if(cnt == 1)
                dest[idx++] = arg || 0;
            else
                for(var j = 0; idx < vecSize && j < cnt; ++j){
                    dest[idx++] = arg[j];
                }
        }
        if(i < arguments.length)
            throw new Error("Too many arguments for " + (color ? "Color" : "Vec" + vecSize) + ".");
        if(idx < vecSize){
            if(color && (idx == 3))
                dest[3] = 1;
            else
                throw new Error("Not enough arguments for " + (color ? "Color" : "Vec" + vecSize) + ".");
        }
    }


    // TODO: Generate Swizzle functions
    var SWIZZLE_KEYS = [
        ['x','y','z','w'],
        ['r', 'g', 'b', 'a'],
        ['s', 't', 'p', 'q']
    ]

    function addSwizzles(prototype, vecCount, maskCount, withSetter){
        var max = Math.pow(vecCount, maskCount);
        for(var i = 0; i < max; ++i){
            var indices = [], keys = ["", "", ""], val = i, args = [];
            var setterArgs = [], generateSetter = withSetter;
            for(var j = 0; j < maskCount; ++j){
                var idx = val % vecCount;
                indices.push(idx);
                if(generateSetter){
                    if(setterArgs[idx] === undefined)
                        setterArgs[idx] = 'other[' + j + ']';
                    else
                        generateSetter = false;
                }
                for(var k = 0; k < SWIZZLE_KEYS.length; ++k){
                    keys[k] += SWIZZLE_KEYS[k][idx];
                }
                val = Math.floor(val / vecCount);
                args.push('this['+ idx + ']' );
            }

            var funcArgs = "";
            var body = '  return getVec' + maskCount + '(' + args.join(", ") +');\n';
            if(generateSetter){
                var assignSetters = [];
                for(var j = 0; j < vecCount; ++j){
                    if(setterArgs[j] === undefined)
                        assignSetters[j] = 'this[' + j + ']';
                    else
                        assignSetters[j] = setterArgs[j];
                }
                switch(maskCount){
                    case 2 : funcArgs = "x, y"; break;
                    case 3 : funcArgs = "x, y, z"; break;
                    case 4 : funcArgs = "x, y, z, w"; break;
                }

                body = "  if(arguments.length == 0)\n  " + body +
                       "  else{\n" +
                       "    var other=getVec" + maskCount + '.apply(null, arguments);\n' +
                       "    return getVec" + vecCount + '(' + assignSetters.join(", ") + ');\n' +
                       "  }\n";
            }
            var functionCode = 'function(' + funcArgs +  '){\n' + body + '}';
            try{
                var result = eval("(" + functionCode + ")");
                for(var j = 0; j < keys.length; ++j)
                    prototype[keys[j]] = result;
            }
            catch(e){
                console.error("Error Compiling Code:\n" + functionCode);
                throw e;
            }
            if(generateSetter){
                addSwizzleOperator(prototype, vecCount, maskCount, keys, "Add", "+", setterArgs);
                addSwizzleOperator(prototype, vecCount, maskCount, keys, "Sub", "-", setterArgs);
                addSwizzleOperator(prototype, vecCount, maskCount, keys, "Mul", "*", setterArgs);
                addSwizzleOperator(prototype, vecCount, maskCount, keys, "Div", "/", setterArgs);
            }
        }
    }
    function addSwizzleOperator(prototype, vecCount, maskCount, keys, methodName, operator, setterArgs){
        var assignSetters = [];
        for(var j = 0; j < vecCount; ++j){
            var prefix = 'this[' + j + ']';
            if(setterArgs[j] === undefined)
                assignSetters[j] = prefix;
            else
                assignSetters[j] = prefix + " " + operator + " " + setterArgs[j];
        }
        var body =  "   var other=getVec" + maskCount + '.apply(null, arguments);\n' +
                    "   return getVec" + vecCount + '(' + assignSetters.join(", ") + ');\n'

        var functionCode = 'function(){\n' + body + '}';
        try{
            var result = eval("(" + functionCode + ")");
            for(var j = 0; j < keys.length; ++j)
                prototype[keys[j] + methodName] = result;
        }
        catch(e){
            console.error("Error Compiling Code:\n" + functionCode);
            throw e;
        }
    }


    /**
    * The virtual Vec2 type
    * @constructor
    */
    var Vec2 = function(x, y) {
        fillVector(this, 2, arguments);
    }


    function getVec2() {
        if(arguments[0] instanceof Vec2)
            return arguments[0];
        var obj = new Vec2();
        Vec2.apply(obj, arguments);
        return obj;
    }

    Vec2.prototype._toFloatArray = function(){
        var res = new Float32Array(2);
        var i = 2; while(i--) res[i] = this[i];
        return res;
    }

    Vec2.prototype.add = function(x, y) { // 0 arguments => identity or error?
        var add = getVec2.apply(null, arguments);
        return new Vec2(this[0] + add[0], this[1] + add[1]);
    }
    Vec2.prototype.sub = function(x, y) {
        var sub = getVec2.apply(null, arguments);
        return new Vec2(this[0] - sub[0], this[1] - sub[1]);
    }
    Vec2.prototype.mul = function(x, y) {
        var other = getVec2.apply(null, arguments);
        return new Vec2(this[0] * other[0], this[1] * other[1]);
    }
    Vec2.prototype.div = function(x, y) {
        var other = getVec2.apply(null, arguments);
        return new Vec2(this[0] / other[0], this[1] / other[1]);
    }
    Vec2.prototype.mod = function(x, y) {
        var other = getVec2.apply(null, arguments);
        return new Vec2(this[0] % other[0], this[1] % other[1]);
    }
    Vec2.prototype.dot = function(x, y) {
        var other = getVec2.apply(null, arguments);
        return this[0] * other[0] + this[1] * other[1];
    }
    Vec2.prototype.abs = function() {
        return new Vec2(Math.abs(this[0]), Math.abs(this[1]));
    }
    Vec2.prototype.length = function(length) {
        if(arguments.length == 0)
            return Math.sqrt(this.dot(this));
        else {
            return this.mul(length / this.length());
        }
    }
    Vec2.prototype.normalize = function() {
        return this.length(1);
    }

    Vec2.prototype.xy = Vec2.prototype.rg = Vec2.prototype.st = function(x, y) {
        if(arguments.length == 0)
            return this;
        else {
            return getVec2.apply(null, arguments);
        }
    }
    Vec2.prototype.x = Vec2.prototype.r = Vec2.prototype.s = function(x) {
        if(arguments.length == 0)
            return this[0];
        else
            return this.xy(x, this[1]);
    }
    Vec2.prototype.y = Vec2.prototype.g = Vec2.prototype.t = function(y) {
        if(arguments.length == 0)
            return this[1];
        else
            return this.xy(this[0], y);
    }

    addSwizzles(Vec2.prototype, 2, 2, true);
    addSwizzles(Vec2.prototype, 2, 3, false);
    addSwizzles(Vec2.prototype, 2, 4, false);


    /**
     * The virtual Vec3 type
     * @constructor
     */
    var Vec3 = function(x, y, z) {
        fillVector(this, 3, arguments);
    }

    function getVec3() {
        if(arguments[0] instanceof Vec3)
            return arguments[0];
        var obj = new Vec3();
        Vec3.apply(obj, arguments);
        return obj;
    }

    Vec3.prototype._toFloatArray = function(){
        var res = new Float32Array(3);
        var i = 3; while(i--) res[i] = this[i];
        return res;
    }

    Vec3.prototype.add = function(x, y, z) {
        var other = getVec3.apply(null, arguments);
        return new Vec3(this[0] + other[0], this[1] + other[1], this[2] + other[2]);
    }
    Vec3.prototype.sub = function(x, y, z) {
        var other = getVec3.apply(null, arguments);
        return new Vec3(this[0] - other[0], this[1] - other[1], this[2] - other[2]);
    }
    Vec3.prototype.mul = function(x, y, z) {
        var other = getVec3.apply(null, arguments);
        return new Vec3(this[0] * other[0], this[1] * other[1], this[2] * other[2]);
    }
    Vec3.prototype.div = function(x, y, z) {
        var other = getVec3.apply(null, arguments);
        return new Vec3(this[0] / other[0], this[1] / other[1], this[2] / other[2]);
    }
    Vec3.prototype.mod = function(x, y, z) {
        var other = getVec3.apply(null, arguments);
        return new Vec3(this[0] % other[0], this[1] % other[1], this[2] % other[2]);
    }
    Vec3.prototype.abs = function() {
        return new Vec3(Math.abs(this[0]), Math.abs(this[1]), Math.abs(this[2]));
    }
    Vec3.prototype.dot = function(x, y, z) {
        var other = getVec3.apply(null, arguments);
        return this[0] * other[0] + this[1] * other[1] + this[2] * other[2];
    }
    Vec3.prototype.cross = function(x, y, z) {
        var other = getVec3.apply(null, arguments);
        var x = this[1] * other[2] - other[1] * this[2];
        var y = this[2] * other[0] - other[2] * this[0];
        var z = this[0] * other[1] - other[0] * this[1];
        return new Vec3(x, y, z);
    }
    Vec3.prototype.length = function(length) {
        if(arguments.length == 0)
            return Math.sqrt(this.dot(this));
        else {
            return this.mul(length / this.length());
        }
    }
    Vec3.prototype.normalize = function() {
        return this.length(1);
    }
    Vec3.prototype.xyz = Vec3.prototype.rgb = Vec3.prototype.stp = function(x, y, z) {
        if(arguments.length == 0)
            return this;
        else
            return new Vec3(x, y, z);
    }
    Vec3.prototype.x = Vec3.prototype.r = Vec3.prototype.s = function(x) {
        if(arguments.length == 0)
            return this[0];
        else
            return new Vec3(x, this[1], this[2]);
    }
    Vec3.prototype.y = Vec3.prototype.g = Vec3.prototype.t = function(y) {
        if(arguments.length == 0)
            return this[1];
        else
            return new Vec3(this[0], y, this[2]);
    }
    Vec3.prototype.z = Vec3.prototype.b = Vec3.prototype.p = function(z) {
        if(arguments.length == 0)
            return this[2];
        else
            return new Vec3(this[0], this[1], z);
    }
    addSwizzles(Vec3.prototype, 3, 2, true);
    addSwizzles(Vec3.prototype, 3, 3, true);
    addSwizzles(Vec3.prototype, 3, 4, false);


    /**
     * The virtual Vec4 type
     * @constructor
     */
    var Vec4 = function(x, y, z, w) {
        fillVector(this, 4, arguments)
    }

    function getVec4() {
        if(arguments[0] instanceof Vec4)
            return arguments[0];
        var obj = new Vec4();
        Vec4.apply(obj, arguments);
        return obj;
    }

    Vec4.prototype._toFloatArray = function(){
        var res = new Float32Array(4);
        var i = 4; while(i--) res[i] = this[i];
        return res;
    }

    Vec4.prototype.add = function(x, y, z, w) {
        var other = getVec4.apply(null, arguments);
        return new Vec4(this[0] + other[0], this[1] + other[1], this[2] + other[2], this[3] + other[3]);
    }
    Vec4.prototype.sub = function(x, y, z, w) {
        var other = getVec4.apply(null, arguments);
        return new Vec4(this[0] - other[0], this[1] - other[1], this[2] - other[2], this[3] - other[3]);
    }
    Vec4.prototype.mul = function(x, y, z, w) {
        var other = getVec4.apply(null, arguments);
        return new Vec4(this[0] * other[0], this[1] * other[1], this[2] * other[2], this[3] * other[3]);
    }
    Vec4.prototype.div = function(x, y, z, w) {
        var other = getVec4.apply(null, arguments);
        return new Vec4(this[0] / other[0], this[1] / other[1], this[2] / other[2], this[3] / other[3]);
    }
    Vec4.prototype.mod = function(x, y, z, w) {
        var other = getVec4.apply(null, arguments);
        return new Vec4(this[0] % other[0], this[1] % other[1], this[2] % other[2], this[3] % other[3]);
    }
    Vec4.prototype.abs = function() {
        return new Vec4(Math.abs(this[0]), Math.abs(this[1]), Math.abs(this[2]), Math.abs(this[3]));
    }
    Vec4.prototype.dot = function(x, y, z, w) {
        var other = getVec4.apply(null, arguments);
        return this[0] * other[0] + this[1] * other[1] + this[2] * other[2] + this[3] * other[3];
    }
    Vec4.prototype.length = function(length) {
        if(arguments.length == 0)
            return Math.sqrt(this.dot(this));
        else {
            return this.mul(length / this.length());
        }
    }
    Vec4.prototype.normalize = function() {
        return this.length(1);
    }
    Vec4.prototype.xyzw = Vec4.prototype.rgba = Vec4.prototype.stpq = function(x, y, z, w) {
        if(arguments.length == 0)
            return this;
        else
            return getVec4.apply(null, arguments);
    }
    Vec4.prototype.x = Vec4.prototype.r = Vec4.prototype.s = function(x) {
        if(arguments.length == 0)
            return this[0];
        else
            return getVec4(x, this[1], this[2], this[3]);
    }

    Vec4.prototype.y = Vec4.prototype.g = Vec4.prototype.t = function(y) {
        if(arguments.length == 0)
            return this[1];
        else
            return getVec4(this[0], y, this[2], this[3]);
    }
    Vec4.prototype.z = Vec4.prototype.b = Vec4.prototype.p = function(z) {
        if(arguments.length == 0)
            return this[2];
        else
            return getVec4(this[0], this[1], z, this[3]);
    }
    Vec4.prototype.w = Vec4.prototype.a = Vec4.prototype.q = function(w) {
        if(arguments.length == 0)
            return this[3];
        else
            return getVec4(this[0], this[1], this[2], w);
    }
    addSwizzles(Vec4.prototype, 4, 2, true);
    addSwizzles(Vec4.prototype, 4, 3, true);
    addSwizzles(Vec4.prototype, 4, 4, true);

    /**
     * The virtual Color type
     * @constructor
     */
    var Color = Vec4;

    /**
     * The virtual Mat3 type
     * @constructor
     */
    var Mat3 = function(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        constructFromMatrix(this, 3, arguments) || fillVector(this, 9, arguments)
    }

    function getMat3() {
        if(arguments[0] instanceof Mat3)
            return arguments[0];
        var obj = new Mat3();
        Mat3.apply(obj, arguments);
        return obj;
    }

    Mat3.prototype._toFloatArray = function(){
        var res = new Float32Array(9);
        var i = 9; while(i--) res[i] = this[i];
        return res;
    }

    Mat3.prototype.add = function(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var other = getMat3.apply(null, arguments);
        return new Mat3(this[0] + other[0], this[1] + other[1], this[2] + other[2],
                        this[3] + other[3], this[4] + other[4], this[5] + other[5],
                        this[6] + other[6], this[7] + other[7], this[8] + other[8]);
    }
    Mat3.prototype.sub = function(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var other = getMat3.apply(null, arguments);
        return new Mat3(this[0] - other[0], this[1] - other[1], this[2] - other[2],
                        this[3] - other[3], this[4] - other[4], this[5] - other[5],
                        this[6] - other[6], this[7] - other[7], this[8] - other[8]);
    }
    Mat3.prototype.mul = function(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var other = getMat3.apply(null, arguments);
        // TODO: Do correct matrix multiplication...
        return null;
    }
    Mat3.prototype.div = function(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var other = getMat3.apply(null, arguments);
        return new Mat3(this[0] / other[0], this[1] / other[1], this[2] / other[2],
                        this[3] / other[3], this[4] / other[4], this[5] / other[5],
                        this[6] / other[6], this[7] / other[7], this[8] / other[8]);
    }

    Mat3.prototype.col = function(idx, x, y, z){
        if(arguments.length == 1){
            return new Vec3(this[3*idx + 0], this[3*idx + 1], this[3*idx + 2]);
        }
        else{
            var input = getVec3.apply(null, Array.prototype.slice.call(arguments, 1));
            var copy = new Mat3(this);
            copy[3*idx + 0] = input[0];
            copy[3*idx + 1] = input[1];
            copy[3*idx + 2] = input[2];
        }
    }
    Mat3.prototype.mulVec = function(x, y, z){
        var other = getVec3.apply(null, arguments);
        return new Vec3(
            other.dot(this[0], this[1], this[2]),
            other.dot(this[3], this[4], this[5]),
            other.dot(this[6], this[7], this[8])
        )
    }

    /**
     * The virtual Mat3 type
     * @constructor
     */
    var Mat4 = function(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        constructFromMatrix(this, 4, arguments) || fillVector(this, 16, arguments);
    }

    function getMat4() {
        if(arguments[0] instanceof Mat4)
            return arguments[0];
        var obj = new Mat4();
        Mat4.apply(obj, arguments);
        return obj;
    }

    Mat4.prototype._toFloatArray = function(){
        var res = new Float32Array(16);
        var i = 16; while(i--) res[i] = this[i];
        return res;
    }

    Mat4.prototype.add = function(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var other = getMat4.apply(null, arguments);
        return new Mat3(this[0] + other[0], this[1] + other[1], this[2] + other[2], this[3] + other[3],
                        this[4] + other[4], this[5] + other[5], this[6] + other[6], this[7] + other[7],
                        this[8] + other[8], this[9] + other[9], this[10] + other[10], this[11] + other[11],
                        this[12] + other[12], this[13] + other[13], this[14] + other[14], this[15] + other[15]);
    }
    Mat4.prototype.sub = function(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var other = getMat4.apply(null, arguments);
        return new Mat3(this[0] - other[0], this[1] - other[1], this[2] - other[2], this[3] - other[3],
                        this[4] - other[4], this[5] - other[5], this[6] - other[6], this[7] - other[7],
                        this[8] - other[8], this[9] - other[9], this[10] - other[10], this[11] - other[11],
                        this[12] - other[12], this[13] - other[13], this[14] - other[14], this[15] - other[15]);
    }
    Mat4.prototype.mul = function(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var other = getMat4.apply(null, arguments);
        // TODO: Do correct matrix multiplication...
        return null;
    }
    Mat4.prototype.div = function(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var other = getMat4.apply(null, arguments);
        return new Mat3(this[0] / other[0], this[1] / other[1], this[2] / other[2], this[3] / other[3],
                        this[4] / other[4], this[5] / other[5], this[6] / other[6], this[7] / other[7],
                        this[8] / other[8], this[9] / other[9], this[10] / other[10], this[11] / other[11],
                        this[12] / other[12], this[13] / other[13], this[14] / other[14], this[15] / other[15]);
    }

    Mat4.prototype.col = function(idx, x, y, z, w){
        if(arguments.length == 1){
            return new Vec4(this[4*idx + 0], this[4*idx + 1], this[4*idx + 2], this[4*idx + 3]);
        }
        else{
            var input = getVec4.apply(null, Array.prototype.slice.call(arguments, 1));
            var copy = new Mat4(this);
            copy[4*idx + 0] = input[0];
            copy[4*idx + 1] = input[1];
            copy[4*idx + 2] = input[2];
            copy[4*idx + 3] = input[3];
        }
    }
    Mat4.prototype.mulVec = function(x, y, z, w){
        var other = getVec4.apply(null, arguments);
        return new Vec4(
            other.dot(this[0], this[1], this[2], this[3]),
            other.dot(this[4], this[5], this[6], this[7]),
            other.dot(this[8], this[9], this[10], this[11]),
            other.dot(this[12], this[13], this[14], this[15])
        );
    }


    /**
     * The virtual Teture type
     * @constructor
     */
    var Texture = function(image) {
        this.image = image;
    }

    Texture.prototype.sample2D = function(x, y) {
        return new Vec4(0, 0, 0, 0);
    }





    var Shade = {};


    // Extensions of Math,
    // TODO: Implement for Vectors
    Math.clamp = function(x, minVal, maxVal) {
        return Math.min(Math.max(x, minVal), maxVal);
    };

    Math.smoothstep = function(edge1, edge2, x) {
        var t = Math.clamp((x - edge1) / (edge2 - edge1), 0.0, 1.0);
        return t * t * (3.0 - 2.0 * t);
    };

    Math.step = function(edge, x) {
        return x < edge ? 0 : 1;
    };

    Math.fract = function(x) {
        return x - Math.floor(x);
    };

    Math.mix = function(x,y,a) {
        var simple = typeof x == 'number';
        var asimple = typeof a == 'number';
        if(simple && asimple)
            return x*(1-a) + y*a;
        if (asimple)
            return x.mul(1-a).add(y.mul(a));
        return x.mul(a.mul(-1).add(1)).add(y.mul(a));
    }

    Math.saturate = function (x) {
        return Math.clamp(x, 0.0, 1.0);
    }



    /**
     * @param {object} node
     * @param {string} msg
     */
    ns.throwError = function(node, msg) {
        var loc = node && node.loc;
        if (loc && loc.start.line) {
            msg = "Line " + loc.start.line + ": " + msg;
        }
        msg += ": " + CodeGen.generate(node);



        var error = new Error(msg);
        error.loc = loc;
        throw error;
    }

    ns.toJavaScript = function(node) {
        return CodeGen.generate(node);
    };

    ns.Vec2 = Vec2;
    ns.Vec3 = Vec3;
    ns.Vec4 = Vec4;
    ns.Mat3 = Mat3;
    ns.Mat4 = Mat4;
    ns.Color = Color;
    ns.Shade = Shade;
    ns.VecMath = VecMath;

}(exports));

},{"./base/index.js":90,"./base/vecmath.js":94,"escodegen":9}],124:[function(require,module,exports){
(function (ns) {

    var Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        parser = require('esprima'),
        Shade = require("../interfaces.js"),
        ANNO = require("./../base/annotation.js").ANNO;

    function handleCallExpression(node) {
        var callee = ANNO(node.callee);
        // console.log("Call", node.callee.property, callee.getTypeString(), node.callee.object)
        if(callee.isOfKind(Shade.OBJECT_KINDS.COLOR_CLOSURE)) {
            ANNO(node).copy(callee);
        }
    }

    function handleNewExpression(node) {
        if (node.callee.name == "Shade") {
            var result = ANNO(node);
            result.setType(Shade.TYPES.OBJECT, Shade.OBJECT_KINDS.COLOR_CLOSURE);
        }
    }

    function handleMemberExpression(node) {
        var object = ANNO(node.object);
        var result = ANNO(node);
        if (object.isOfKind(Shade.OBJECT_KINDS.COLOR_CLOSURE)) {
            var closureName = node.property.name;
            if (!Shade.ColorClosures.hasOwnProperty(closureName)) {
                console.error("No closure for name'", closureName, "'");
                return;
            };
            result.copy(object);
        }
    }

    ns.markColorClosures = function(programAast){
        Traversal.traverse(programAast, {
            leave: function(node, parent){
                 switch (node.type) {
                    case Syntax.CallExpression:
                        return handleCallExpression(node);
                    case Syntax.NewExpression:
                        return handleNewExpression(node);
                    case Syntax.MemberExpression:
                        return handleMemberExpression(node);
                }
            }
        });
    }

}(exports));

},{"../interfaces.js":123,"./../base/annotation.js":85,"esprima":45,"estraverse":46}],125:[function(require,module,exports){
(function (ns) {

    var Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        parser = require('esprima');

    var Shade = require("../interfaces.js"),
    SpaceVectorType = Shade.SpaceVectorType,
    Types = Shade.TYPES,
    Kinds = Shade.OBJECT_KINDS;

    ns.getDefaultValue = function(ccInputDefinition){
        if(ccInputDefinition.defaultValue == undefined)
            throw new Error("ColorClosure input has not default value!");

        if(ccInputDefinition.type == Types.NUMBER || ccInputDefinition.type == Types.INT){
            var result = {
                type: Syntax.Literal,
                value: ccInputDefinition.defaultValue
            }
            return result;
        }
        else{
            throw new Error("Currentlty don't support default values of type " + ccInputDefinition.type + " and kind " + ccInputDefinition.kind);
        }
    }

}(exports));

},{"../interfaces.js":123,"esprima":45,"estraverse":46}],126:[function(require,module,exports){
(function (ns) {

    var ColorClosureMarker = require("./colorclosure-marker.js");

    var c_implementations = {};

    var registerLightingImplementation = ns.registerLightingImplementation = function (name, obj) {
        c_implementations[name] = obj;
    };

    ns.resolveClosuresPreTypeInference = function (aast, implementationName, processingData, opt) {
        if (!implementationName) {
            return aast;
        }
        try {
            var resolverImpl = c_implementations[implementationName];
            if (resolverImpl.resolvePreTypeInference) {
                ColorClosureMarker.markColorClosures(aast);
                return resolverImpl.resolvePreTypeInference(aast, processingData, opt);
            } else
                return aast;
        } catch (e) {
            console.error(e);
        }
        return aast;
    };

    ns.resolveClosuresPostTypeInference = function (aast, implementationName, processingData, opt) {
        if (!implementationName) {
            return aast;
        }
        try {
            var resolverImpl = c_implementations[implementationName];
            if (resolverImpl.resolvePostTypeInference)
                return resolverImpl.resolvePostTypeInference(aast, processingData, opt); else
                return aast;
        } catch (e) {
            console.error(e);
        }
        return aast;
    };

    registerLightingImplementation("xml3d-glsl-forward", require("./xml3d-glsl-forward"));
    registerLightingImplementation("xml3d-glsl-deferred", require("./xml3d-glsl-deferred"));

}(exports));

},{"./colorclosure-marker.js":124,"./xml3d-glsl-deferred":128,"./xml3d-glsl-forward":130}],127:[function(require,module,exports){
(function (ns) {

    var Base = require("../../base/index.js"),
        Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        ANNO = require("./../../base/annotation.js").ANNO,
        DeferredInfo = require("./xml3d-deferred.js");

    var Shade = require("../../interfaces.js"),
        SpaceVectorType = Shade.SpaceVectorType,
        Types = Shade.TYPES,
        Kinds = Shade.OBJECT_KINDS;

    var SpaceTransformTools = require("../../generate/space/space-transform-tools.js"),
        ColorClosureTools = require("../colorclosure-tools.js");

    var ADD_POSITION_TO_ARGS = true;

    var ArgStorageType = ns.ArgStorageType = {
        FLOAT : 'float',
        FLOAT_BYTE: 'floatByte',
        FLOAT_UBYTE: 'floatUByte',
        FLOAT2: 'float2',
        FLOAT3: 'float3',
        FLOAT3_NORMAL: 'float3Normal',
        FLOAT4: 'float4'
    }

    var AMBIENT_DEFINITION = {type: Types.NUMBER, semantic: Shade.SEMANTICS.SCALAR_0_TO_1, defaultValue: 0 };


    ns.ColorClosureSignature = function(){
        this.id = 0;
        this.textureCount = 0;
        this.args = [];
        this.colorClosures = [];
    };
    Base.extend(ns.ColorClosureSignature.prototype, {
        construct: function(returnAast, scope){
            var closureInfo = collectClosureInfo(returnAast);
            var argAast = gatherClosureArgs(this, closureInfo, scope);
            var textures = allocateArgumentsToTextures(this);
            this.id = getSignatureId(this);
            argAast[0].value = this.id; // Set ID for shader id assignment
            return generateAast(textures, argAast);
        }
    });

    // Basic ColorClosureSignature Createion

    function addColorClosure(ccSig, colorClosureName, argIndices, envIndices){
        ccSig.colorClosures.push({
            name: colorClosureName,
            argIndices: argIndices,
            envIndices: envIndices
        });
    }

    function addArgument(ccSig, type, kind, storeType){
        var id = ccSig.args.length;
        ccSig.args.push({
            id: id,
            type: type,
            kind: kind,
            storeType: storeType,
            texIdx: undefined,
            componentIdx: undefined,
            bitIdx: undefined
        });
        return id;
    }

    // Argument Collection

    function collectClosureInfo(returnAast){
        var result = [];
        Traversal.traverse(returnAast, {
                leave: function(node, parent){
                    switch (node.type) {
                        case Syntax.CallExpression:
                            if(node.callee.type == Syntax.MemberExpression
                               && ANNO(node.callee.object).isOfKind(Kinds.COLOR_CLOSURE))
                            {
                                result.push({
                                    name: node.callee.property.name,
                                    args: node.arguments
                                });
                            }
                    }
                }
            });
        result.sort(function(a,b){return a.name < b.name ? -1 : a.name > b.name ? 1 : 0});
        return result;
    }

    function gatherClosureArgs(ccSig, closureInfo, scope){
        var argCache = {}, argAast = [];

        // Add argument for signature id;
        getCachedArgument(ccSig, {type: Types.INT}, {type: "Literal", value: "ID_UNSPECIFIED"}, argCache, argAast);
        if(ADD_POSITION_TO_ARGS)
            addPositionArgument(ccSig, argCache, argAast);
        var ambientValue = { type: Syntax.LogicalExpression, operator : "||",
                        left: getEnvAccess("ambientIntensity", AMBIENT_DEFINITION),
                        right: ColorClosureTools.getDefaultValue(AMBIENT_DEFINITION) };

        getCachedArgument(ccSig, AMBIENT_DEFINITION, ambientValue, argCache, argAast);

        for(var i = 0; i < closureInfo.length; ++i){
            var cInfo = closureInfo[i];
            var closureDefinition = Shade.ColorClosures[cInfo.name];
            if(!closureDefinition)
                throw new Error("Unknown Color closure '" + cInfo.name + "'");
            var argIndices = [], value;
            for(var j = 0; j < closureDefinition.input.length; ++j){
                var inputDefinition = closureDefinition.input[j];
                if(j < cInfo.args.length)
                    value = cInfo.args[j];
                else
                    value = ColorClosureTools.getDefaultValue(inputDefinition);
                var space = DeferredInfo[cInfo.name] && DeferredInfo[cInfo.name].inputSpaces[j];
                argIndices.push(getCachedArgument(ccSig, inputDefinition, value, argCache, argAast, space));
            }
            var envIndices = {};
            for(var property in closureDefinition.env){
                var envDefinition = closureDefinition.env[property];
                // TODO: Determine if env property is undefined and use defaultValue in this case;
                value = { type: Syntax.LogicalExpression, operator : "||",
                        left: getEnvAccess(property, envDefinition),
                        right: ColorClosureTools.getDefaultValue(envDefinition) };
                envIndices[property] = getCachedArgument(ccSig, envDefinition, value, argCache, argAast);
            }
            addColorClosure(ccSig, cInfo.name, argIndices, envIndices);
       }
       return argAast;
    }

    function addPositionArgument(ccSig, argCache, argAast){
        var positionLookup = { type: Syntax.MemberExpression,
            object: { type: Syntax.Identifier, name: "_env"},
            property: { type: Syntax.Identifier, name: "position"}
        }
        // ANNO(positionLookup).setType(Types.OBJECT, Kinds.FLOAT3);
        // ANNO(positionLookup.object).setType(Types.OBJECT, Kinds.ANY);
        // ANNO(positionLookup.object).setGlobal(true);
        getCachedArgument(ccSig, {type: Types.OBJECT, kind: Kinds.FLOAT3}, positionLookup, argCache, argAast,
            SpaceVectorType.VIEW_POINT);
    }

    function getCachedArgument(ccSig, inputDefinition, inputAast, argCache, argAast, space){
        space = space || SpaceVectorType.OBJECT;
        inputAast = space ? SpaceTransformTools.getSpaceTransformCall(inputAast, space) : inputAast;
        var keyAast = Base.deepExtend({}, inputAast);
        cleanAast(keyAast);
        var storageType = getStorageType(inputDefinition);
        var key = storageType + ";" + JSON.stringify(keyAast);
        if(argCache[key] === undefined){
            var argId = addArgument(ccSig, inputDefinition.type, inputDefinition.kind, storageType);
            argCache[key] = argId;
            argAast.push(inputAast);
        }
        return argCache[key];
    }
    /* Remove all range properties from the aast */
    function cleanAast(aast){
        for(var i in aast){
            if(i == "range" || i == "loc"){
                delete aast[i];
            }
            else if(typeof aast[i] == "object"){
                cleanAast(aast[i]);
            }
        }
    }

    function getStorageType(closureInputType){
        if(closureInputType.type == Types.NUMBER || closureInputType.type == Types.INT){
            return ArgStorageType.FLOAT;
        }
        else if(closureInputType.type == Types.OBJECT){
            switch(closureInputType.kind){
                case Kinds.FLOAT2: return ArgStorageType.FLOAT2;
                case Kinds.FLOAT3: return ArgStorageType.FLOAT3;
                case Kinds.FLOAT4: return ArgStorageType.FLOAT4;
                default:
                    throw new Error("Deferred input of this kind not supported: " + closureInputType.kind);
            };
        }
        else{
            throw new Error("Deferred input of this type not supported: " + closureInputType.type);
        }
    }

    function getEnvAccess(property, definition){
        var result = {
            type: Syntax.MemberExpression,
            object: {type: Syntax.Identifier, name: "_env" },
            property: {type: Syntax.Identifier, name: property }
        }
        // ANNO(result).setType(definition.type, definition.kind);
        // var objAnno = ANNO(result.object);
        // objAnno.setType(Types.OBJECT, Kinds.ANY);
        // objAnno.setGlobal(true);
        return result;
    }


    // Argument Allocation


    function allocateArgumentsToTextures(ccSig){
        var argCopy = ccSig.args.slice( ADD_POSITION_TO_ARGS ? 3 : 2);
        argCopy.sort(function(a, b){
            return getStorageSize(a.storeType) - getStorageSize(b.storeType);
        });
        argCopy.push(ccSig.args[ADD_POSITION_TO_ARGS ? 2 : 1]); // Ambient comes third.
        if(ADD_POSITION_TO_ARGS)
            argCopy.push(ccSig.args[1]); // POSITION comes second.
        argCopy.push(ccSig.args[0]); // ID argument always comes first (and thus: last in this array)
        var textures = [];
        var i = argCopy.length;
        while(i--){
            var arg = argCopy[i];
            assignTextureSlot(arg, textures);
        }
        ccSig.textureCount = textures.length;
        return textures;
    }
    function assignTextureSlot(arg, textures){
        var size = getStorageSize(arg.storeType);
        for(var i = 0; i < textures.length; i++){
            var tex = textures[i];
            if(size < 32){
                throw new Error("We currently don't support storing of values smaller than 32 bit");
            }
            else if(tex.usedComponents + size / 32 <= 4){
                arg.texIdx = i;
                arg.componentIdx = tex.usedComponents;
                arg.bitIdx = 0;
                tex.usedComponents += size / 32;
                tex.usedBits = 0;
                tex.storedArgs.push(arg);
                return;
            }
        }
        arg.texIdx = textures.length;
        arg.componentIdx = 0;
        arg.bitIdx = 0;
        if(size < 32){
            throw new Error("We currently don't support storing of values smaller than 32 bit");
        }
        else{
            textures.push({
                usedComponents: size / 32,
                usedBits: 0,
                storedArgs: [arg]
            });
        }
    }

    function getStorageSize(storeType){
        switch(storeType){
            case ArgStorageType.FLOAT: return 32;
            case ArgStorageType.FLOAT_BYTE: return 8;
            case ArgStorageType.FLOAT_UBYTE: return 8;
            case ArgStorageType.FLOAT2: return 64;
            case ArgStorageType.FLOAT3: return 96;
            case ArgStorageType.FLOAT3_NORMAL: return 24;
            case ArgStorageType.FLOAT4: return 128;
        }
    }

    // Get ColorClosureSignature ID

    var c_SignatureNextId = 0;
    var c_SignatureIDCache = {};

    ns.ColorClosureSignature.clearIdCache = function(){
        c_SignatureNextId = 0;
        c_SignatureIDCache = {};
    }

    function getSignatureId(ccSig){
        var key = "";
        for(var i = 0; i < ccSig.args.length; ++i){
            var arg = ccSig.args[i];
            key += getArgumentKey(arg) + ";"
        }
        for(i = 0; i < ccSig.colorClosures.length; ++i){
            var closure = ccSig.colorClosures[i];
            key += closure.name + "," + closure.argIndices.join(",");
            for(var prop in closure.envIndices){
                key += "," + prop + ">" + closure.envIndices[i];
            }
        }
        if(c_SignatureIDCache[key] === undefined){
            c_SignatureIDCache[key] = c_SignatureNextId;
            c_SignatureNextId++;
        }
        return c_SignatureIDCache[key];
    }

    function getArgumentKey(arg){
        return arg.type + "," + arg.kind + "," + arg.storeType + "," + arg.texIdx + ","
            + arg.componentIdx + "," + arg.bitIdx;
    }

    // Aast generation

    function generateAast(textures, argAast){
        var arrayExpression = { type: Syntax.ArrayExpression, elements: []};
        for(var i = 0; i < textures.length; ++i){
            var vectorExpression = generateVectorAast(textures[i], argAast);
            arrayExpression.elements.push(vectorExpression);
        }
        // ANNO(arrayExpression).setType(Types.ARRAY);

        var returnStatement = {type: Syntax.ReturnStatement, argument: arrayExpression};
        return returnStatement;
    }

    function generateVectorAast(texture, argAast){
        var vecArgs = [];
        for(var i = 0; i < texture.storedArgs.length; ++i){
            var arg = texture.storedArgs[i];
            var size = getStorageSize(arg.storeType);
            if(size < 32){
                throw new Error("We currently don't support storing of values smaller than 32 bit");
            }
            else{
                vecArgs.push(argAast[arg.id]);
            }
        }
        for(i = texture.usedComponents; i < 4; ++i){
            var zeroLiteral = { type: Syntax.Literal, value: "0" };
            // ANNO(zeroLiteral).setType(Types.INT);
            vecArgs.push(zeroLiteral);
        }
        var result = { type: Syntax.NewExpression, callee: { type: Syntax.Identifier, name: "Vec4"}, arguments: vecArgs};
        // ANNO(result).setType(Types.OBJECT, Kinds.FLOAT4);
        return result;
    }


}(exports));

},{"../../base/index.js":90,"../../generate/space/space-transform-tools.js":119,"../../interfaces.js":123,"../colorclosure-tools.js":125,"./../../base/annotation.js":85,"./xml3d-deferred.js":129,"estraverse":46}],128:[function(require,module,exports){
(function (ns) {

    var Closures = require("./xml3d-deferred.js"),
        Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        parser = require('esprima'),
        Shade = require("../../interfaces.js"),
        ANNO = require("./../../base/annotation.js").ANNO,
        sanitizer = require("./../../analyze/sanitizer/sanitizer.js"),
        ColorClosureSignature = require("./color-closure-signature.js").ColorClosureSignature;


    ns.resolvePreTypeInference = function (aast, processData, opt) {
        var state = {
            colorClosureSignatures: [],
            inMain: false
        };
        var globalScrope = aast.scope;
        aast = Traversal.replace(aast, {
            enter: function(node, parent){
                switch(node.type){
                    case Syntax.FunctionDeclaration:
                        // TODO: Properly determine if we are in main function
                        if(node.id.name == "shade")
                            state.inMain = true;
                        else
                            this.skip();
                        break;
                }
            },
            leave: function(node, parent){
                switch(node.type){
                    case Syntax.FunctionDeclaration:
                        // TODO: Properly determine if we are in main function
                        if(node.id.name == "shade")
                            state.inMain = false;
                        break;
                    case Syntax.ReturnStatement:
                        if(state.inMain){
                            var signature = new ColorClosureSignature();
                            var replacement = signature.construct(node, globalScrope);
                            state.colorClosureSignatures.push(signature);
                            return replacement;
                        }
                }
            }
        })

        processData['colorClosureSignatures'] = state.colorClosureSignatures;

        return aast;
    }

}(exports));

},{"../../interfaces.js":123,"./../../analyze/sanitizer/sanitizer.js":60,"./../../base/annotation.js":85,"./color-closure-signature.js":127,"./xml3d-deferred.js":129,"esprima":45,"estraverse":46}],129:[function(require,module,exports){
(function (ns) {

        var Shade = require("../../interfaces.js"),
            SpaceVectorType = Shade.SpaceVectorType;

        ns.emissive = {
            inputSpaces: [
                SpaceVectorType.OBJECT
            ]
        }

        ns.diffuse = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT
            ]
        }

        ns.phong = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT
            ]
        }

        ns.cookTorrance = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT,
                SpaceVectorType.OBJECT
            ]
        }

        ns.ward = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT,
                SpaceVectorType.OBJECT
            ]
        }

        ns.scatter = {
            inputSpaces: [
                SpaceVectorType.OBJECT,
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT
            ]
        }

        ns.reflect = {
            inputSpaces: [
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT
            ]
        }

        ns.refract = {
            inputSpaces: [
                SpaceVectorType.VIEW_NORMAL,
                SpaceVectorType.OBJECT,
                SpaceVectorType.OBJECT
            ]
        }

}(exports));

},{"../../interfaces.js":123}],130:[function(require,module,exports){
(function (ns) {

    var ClosuresImpl = require("./xml3d-forward.js"),
        LightLoop = require("./light-loop.js").LightLoop,
        Traversal = require('estraverse'),
        Syntax = Traversal.Syntax,
        parser = require('esprima'),
        Shade = require("../../interfaces.js"),
        ANNO = require("./../../base/annotation.js").ANNO,
        sanitizer = require("./../../analyze/sanitizer/sanitizer.js");

    var SpaceTransformTools = require("../../generate/space/space-transform-tools.js"),
        ColorClosureTools = require("../colorclosure-tools.js");



    function containsClosure(arr, name) {
        return arr.some(function (func) {
            return func.id.name == name;
        });
    }

    function getInjectAddition(destName, functionName, inputPre, ccName, colorClosureIndex ){
        var args = [];
        for(var i = 0; i < inputPre.length; ++i){
            args.push({ type: Syntax.Identifier, name: inputPre[i]});
        }
        var inputsCnt = Shade.ColorClosures[ccName].input.length;
        for(var i = 0; i < inputsCnt; ++i){
            args.push({ type: Syntax.Identifier, name: getColorClosureInputArg(colorClosureIndex, i)});
        }
        return {
            type: Syntax.ExpressionStatement,
            expression: { type: Syntax.AssignmentExpression,
                operator: "=",
                left: { type: Syntax.Identifier, name: destName},
                right: { type: Syntax.CallExpression,
                    callee: { type: Syntax.MemberExpression,
                        object: {type: Syntax.Identifier, name: destName},
                        property: {type: Syntax.Identifier, name: "add"}
                    },
                    arguments: [{ type: Syntax.CallExpression,
                        callee: {type: Syntax.Identifier, name: functionName},
                        arguments: args
                    }]
              }}
        };
    }

    function getColorClosureInject(ccName, functionMember, state){
        if(!ClosuresImpl[ccName])
            console.error("No implementation available for ColorClosure '" + ccName + "'" );
        if(!ClosuresImpl[ccName][functionMember])
            return null;
        var functionName = ccName + "_" + functionMember;
        if (!containsClosure(state.newFunctions, functionName)){
            var closureImplementation = ClosuresImpl[ccName][functionMember];
            try {
                var closureAST = parser.parse(closureImplementation.toString(), { raw: true });
                closureAST = sanitizer.sanitize(closureAST);
                closureAST.body[0].id.name = functionName;
                state.newFunctions.push(closureAST.body[0]);
            } catch (e) {
                console.error("Error in analysis of closure '", ccName + ">" + functionMember, "'", e);
                return;
            }
        }
        return functionName;
    }


    function injectBrdfEntry(ccNames, state){
        var result = {
            type: Syntax.BlockStatement,
            body: []
        };
        for(var i = 0; i < ccNames.length; ++i){
            var fName, ccName = ccNames[i];
            if(fName = getColorClosureInject(ccName, "getDiffuse", state)){
                result.body.push(getInjectAddition("kd", fName, ["L", "V"], ccName, i));
            }
            if(fName = getColorClosureInject(ccName, "getSpecular", state)){
                result.body.push(getInjectAddition("ks", fName, ["L", "V"], ccName, i));
            }
        }
        return result;
    }

    function injectAmbientEntry(ccNames, state){
        var result = {
            type: Syntax.BlockStatement,
            body: []
        };
        for(var i = 0; i < ccNames.length; ++i){
            var fName, ccName = ccNames[i];
            if(fName = getColorClosureInject(ccName, "getAmbient", state)){
                result.body.push(getInjectAddition("ambientColor", fName, ["ambientIntensity"], ccName, i));
            }
        }
        return result;
    }

    function injectEmissiveEntry(ccNames, state) {
        var result = {
            type: Syntax.BlockStatement,
            body: []
        };
        for(var i = 0; i < ccNames.length; ++i){
            var fName, ccName = ccNames[i];
            if(fName = getColorClosureInject(ccName, "getEmissive", state)){
                result.body.push(getInjectAddition("emissiveColor", fName, [], ccName, i));
            }
        }
        return result;
    }

    function injectRefractReflectEntry(ccNames, state){
        var result = {
            type: Syntax.BlockStatement,
            body: []
        };
        for(var i = 0; i < ccNames.length; ++i){
            var fName, ccName = ccNames[i];
            if(fName = getColorClosureInject(ccName, "getRefract", state)){
                result.body.push(getInjectAddition("refractColor", fName, ["position"], ccName, i));
            }
            if(fName = getColorClosureInject(ccName, "getReflect", state)){
                result.body.push(getInjectAddition("reflectColor", fName, ["position"], ccName, i));
            }
        }
        return result;
    }

    function injectColorClosureCalls(lightLoopFunction, ccNames, state){
        var result = Traversal.replace(lightLoopFunction.body, {
            enter: function(node, parent){
                if(node.type == Syntax.ExpressionStatement && node.expression.type == Syntax.Literal){
                    switch(node.expression.value){
                        case "BRDF_ENTRY": return injectBrdfEntry(ccNames, state);
                        case "AMBIENT_ENTRY": return injectAmbientEntry(ccNames, state);
                        case "EMISSIVE_ENTRY": return injectEmissiveEntry(ccNames, state);
                        case "REFRACT_REFLECT_ENTRY": return injectRefractReflectEntry(ccNames, state);
                    };

                }
            }
        });
        return result;
    }

    function getColorClosureInputArg(ccIndex, inputIndex){
        return "_cc" + ccIndex + "Input" + inputIndex;
    }

    function createLightLoopFunction(lightLoopFunctionName, ccNames, state){
        try {
            var lightLoopAst = parser.parse(LightLoop.toString(), { raw: true });
        } catch (e) {
            console.error("Error in analysis of the lightLoop", e);
            return;
        }
        var functionAast = lightLoopAst.body[0];
        functionAast.id.name = lightLoopFunctionName;

        for(var i = 0; i < ccNames.length; ++i){
            var ccName = ccNames[i];
            var ccInput = Shade.ColorClosures[ccName].input;
            for(var j = 0; j < ccInput.length; ++j){
                functionAast.params.push({
                    type: Syntax.Identifier,
                    name: getColorClosureInputArg(i,j)
                });
            }
        }
        injectColorClosureCalls(functionAast, ccNames, state);

        lightLoopAst = sanitizer.sanitize(lightLoopAst);
        return lightLoopAst.body[0];
    }

    function getLightLoopFunction(colorClosureList, state){
        var ccNames = [];
        for(var i = 0; i < colorClosureList.length; ++i)
            ccNames.push(colorClosureList[i].name);
        var lightLoopFunctionName = "lightLoop_" + ccNames.join("_");
        if (!containsClosure(state.newFunctions, lightLoopFunctionName)){
            state.newFunctions.push(createLightLoopFunction(lightLoopFunctionName, ccNames, state));
        }
        return lightLoopFunctionName;
    }

    function handleCallExpression(node, state, colorClosureList) {
        var callee = ANNO(node.callee);
        // console.log("Call", node.callee.property, callee.getTypeString(), node.callee.object)
        if(callee.isOfKind(Shade.OBJECT_KINDS.COLOR_CLOSURE)) {
            colorClosureList.push({ name: node.callee.property.name, args: node.arguments });
        }
    }

    function handleMemberExpression(node, state, parent) {
        var object = ANNO(node.object);
        if (object.isOfKind(Shade.OBJECT_KINDS.COLOR_CLOSURE)) {
            var closureName = node.property.name;
            if (!ClosuresImpl.hasOwnProperty(closureName)) {
                console.error("No implementation for closure '", closureName, "'");
                return;
            };
        }
    }

    function getClosureList(returnAast, state){
        var colorClosureList = [];
        Traversal.traverse(returnAast, {
            leave: function(node, parent){
                 switch (node.type) {
                    case Syntax.CallExpression:
                        return handleCallExpression(node, state, colorClosureList);
                    case Syntax.MemberExpression:
                        return handleMemberExpression(node, state, parent);
                }
            }
        });
        colorClosureList.sort(function (a, b){ return a.name < b.name ? -1 : a.name > b.name ? 1 : 0 });
        return colorClosureList;
    }

    function generateLightLoopCall(lightLoopFunction, colorClosureList, state){
        var args = [];

        var posArg = state.positionArg;
        if(!state.noSpaceTransform)
            posArg = SpaceTransformTools.getSpaceTransformCall(posArg, Shade.SpaceVectorType.VIEW_POINT);
        args.push(posArg)
        args.push(state.ambientArg);
        for(var i = 0; i < colorClosureList.length; ++i){
            var ccEntry = colorClosureList[i];
            var ccInput = Shade.ColorClosures[ccEntry.name].input;
            for(var j = 0; j < ccInput.length; ++j){
                var arg = ccEntry.args[j];
                if(!arg)
                    arg = ColorClosureTools.getDefaultValue(ccInput[j]);
                if(ccInput[j].semantic == Shade.SEMANTICS.NORMAL && !state.noSpaceTransform)
                    arg = SpaceTransformTools.getSpaceTransformCall(arg, Shade.SpaceVectorType.VIEW_NORMAL);
                args.push(arg);
            }
        }
        return {
            type: Syntax.CallExpression,
            callee: {type: Syntax.Identifier, name: lightLoopFunction},
            arguments: args
        };
    }

    function handleReturnStatement(returnAast, state){
        var list = getClosureList(returnAast, state);
        if(list.length == 0)
            return;
        var lightLoopFunction = getLightLoopFunction(list, state);
        var lighLoopCall = generateLightLoopCall(lightLoopFunction, list, state);
        returnAast.argument = lighLoopCall;
    }


    function replaceReturnStatements(programAast, state){
        var result = Traversal.replace(programAast, {
            enter: function(node, parent){
                 switch (node.type) {
                    case Syntax.ReturnStatement:
                        this.skip();
                        return handleReturnStatement(node, state);
                }
            }
        });
        return result;
    }

    function getEnvParameter(property){
        return { type: Syntax.MemberExpression,
                object: { type: Syntax.Identifier, name: "_env" },
                property: { type: Syntax.Identifier, name: property}};
    }

    ns.resolvePreTypeInference = function (ast, processData, opt) {
        var state = {
            positionArg: opt && opt.lightLoopPositionArg || null,
            ambientArg: opt && opt.lightLoopAmbientArg || null,
            noSpaceTransform: opt && opt.lightLoopNoSpaceTransform || false,
            program: ast,
            newFunctions: []
        }
        if(!state.positionArg)
            state.positionArg = getEnvParameter("position");
        if(!state.ambientArg)
            state.ambientArg = { type: Syntax.LogicalExpression, operator: "||",
                                 left: getEnvParameter("ambientIntensity"),
                                 right: {type: Syntax.Literal, value: 0} };

        ast = replaceReturnStatements(ast, state);

        state.newFunctions.forEach(function(newFunction) {
            state.program.body.unshift(newFunction);
        })

        return ast;
    }

}(exports));

},{"../../generate/space/space-transform-tools.js":119,"../../interfaces.js":123,"../colorclosure-tools.js":125,"./../../analyze/sanitizer/sanitizer.js":60,"./../../base/annotation.js":85,"./light-loop.js":131,"./xml3d-forward.js":132,"esprima":45,"estraverse":46}],131:[function(require,module,exports){
/**
 * Created with JetBrains WebStorm.
 * User: lachsen
 * Date: 12/17/13
 * Time: 1:21 PM
 * To change this template use File | Settings | File Templates.
 */
(function (ns) {

ns.LightLoop = function LightLoop(position, ambientIntensity){
    var V = position.flip().normalize(), dist, atten;
    var kdComplete = new Vec3(0,0,0), ksComplete = new Vec3(0,0,0);
    if (this.MAX_POINTLIGHTS)
    for (var i = 0; i < this.MAX_POINTLIGHTS; i++) {
        if (!this.pointLightOn[i])
            continue;

        var L = this.viewMatrix.mulVec(this.pointLightPosition[i], 1.0).xyz();
        L = L.sub(position);
        dist = L.length();
        L = L.normalize();

        var kd = new Vec3(0,0,0), ks = new Vec3(0,0,0);
        "BRDF_ENTRY";

        atten = 1.0 / (this.pointLightAttenuation[i].x() + this.pointLightAttenuation[i].y() * dist + this.pointLightAttenuation[i].z() * dist * dist);
        kd = kd.mul(this.pointLightIntensity[i]).mul(atten);
        ks = ks.mul(this.pointLightIntensity[i]).mul(atten);
        kdComplete = kdComplete.add(kd);
        ksComplete = ksComplete.add(ks);
    }
    if (this.MAX_DIRECTIONALLIGHTS)
    for (i = 0; i < this.MAX_DIRECTIONALLIGHTS; i++) {
        if (!this.directionalLightOn[i])
            continue;

        L = this.viewMatrix.mulVec(this.directionalLightDirection[i], 0).xyz();
        L = L.flip().normalize();

        var kd = new Vec3(0,0,0), ks = new Vec3(0,0,0);
        "BRDF_ENTRY";

        kd = kd.mul(this.directionalLightIntensity[i]);
        ks = ks.mul(this.directionalLightIntensity[i]);
        kdComplete = kdComplete.add(kd);
        ksComplete = ksComplete.add(ks);
    }
    if (this.MAX_SPOTLIGHTS)
    for (i = 0; i < this.MAX_SPOTLIGHTS; i++) {
        if (this.spotLightOn[i]) {
            L = this.viewMatrix.mulVec(this.spotLightPosition[i], 1.0).xyz();
            L = L.sub(position);
            dist = L.length();
            L = L.normalize();

            var lDirection = this.viewMatrix.mulVec(this.spotLightDirection[i].flip(), 0).xyz().normalize();
            var angle = L.dot(lDirection);
            if(angle > this.spotLightCosFalloffAngle[i]) {
                var kd = new Vec3(0,0,0), ks = new Vec3(0,0,0);
                "BRDF_ENTRY";

                var c = 1.0;
                if (this.spotLightCastShadow[i]) {
                    var wpos = this.viewInverseMatrix.mulVec(position, 1.0).xyz();

                    var lsPos = this.spotLightMatrix[i].mulVec(new Vec4(wpos, 1));
                    var perspectiveDivPos = lsPos.xyz().div(lsPos.w()).mul(0.5).add(0.5);
                    var lsDepth = perspectiveDivPos.z() - this.spotLightShadowBias[i];

                    var lightuv = perspectiveDivPos.xy();
                    var bitShift = new Vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );

                    var texSize = new Vec2(Math.max(this.coords.x(), this.coords.y())).mul(2);
                    var texelSize = new Vec2(1.0, 1.0).div(texSize);
                    var f = Math.fract(lightuv.mul(texSize).add(0.5));
                    var centroidUV = Math.floor(lightuv.mul(texSize).add(0.5));
                    centroidUV = centroidUV.div(texSize);

                    var lb = this.spotLightShadowMap[i].sample2D(centroidUV.add(texelSize.mul(new Vec2(0.0, 0.0)))).dot(bitShift);
                    if (lb >= lsDepth)
                        lb = 1.0;
                    else
                        lb = 0.0;

                    var lt = this.spotLightShadowMap[i].sample2D(centroidUV.add(texelSize.mul(new Vec2(0.0, 1.0)))).dot(bitShift)
                    if (lt >= lsDepth)
                        lt = 1.0;
                    else
                        lt = 0.0;

                    var rb = this.spotLightShadowMap[i].sample2D(centroidUV.add(texelSize.mul(new Vec2(1.0, 0.0)))).dot(bitShift);
                    if (rb >= lsDepth)
                        rb = 1.0;
                    else
                        rb = 0.0;

                    var rt = this.spotLightShadowMap[i].sample2D(centroidUV.add(texelSize.mul(new Vec2(1.0, 1.0)))).dot(bitShift);
                    if (rt >= lsDepth)
                        rt = 1.0;
                    else
                        rt = 0.0;

                    var a = Math.mix(lb, lt, f.y());
                    var b = Math.mix(rb, rt, f.y());
                    c = Math.mix(a, b, f.x());
                }

                var softness = 1.0;
                if(angle < this.spotLightCosSoftFalloffAngle[i])
                    softness = (angle - this.spotLightCosFalloffAngle[i]) /
                        (this.spotLightCosSoftFalloffAngle[i] -  this.spotLightCosFalloffAngle[i]);

                atten = 1.0 / (this.spotLightAttenuation[i].x() + this.spotLightAttenuation[i].y() * dist + this.spotLightAttenuation[i].z() * dist * dist);
                kd = kd.mul(this.spotLightIntensity[i]).mul(atten * softness * c);
                ks = ks.mul(this.spotLightIntensity[i]).mul(atten * softness * c);
                kdComplete = kdComplete.add(kd);
                ksComplete = ksComplete.add(ks);
            }
        }
    }
    var ambientColor = new Vec3(0,0,0);
    "AMBIENT_ENTRY";
    kdComplete = kdComplete.add(ambientColor);
    var emissiveColor = new Vec3(0, 0, 0);
    "EMISSIVE_ENTRY"
    if (this.ssaoMap) {
        kdComplete = kdComplete.mul(1 - this.ssaoMap.sample2D(this.normalizedCoords).r());
    }
    var refractColor = new Vec3(0, 0, 0);
    var reflectColor = new Vec3(0, 0, 0);
    "REFRACT_REFLECT_ENTRY"
    return Math.pow(new Vec4(emissiveColor.add(kdComplete.add(ksComplete)).add(refractColor).add(reflectColor), 1.0), new Vec4(1/2.2));
}

}(exports));

},{}],132:[function(require,module,exports){
(function (ns) {

        ns.emissive = {
            getEmissive: function getEmissive(color){
                return color;
            }
        };

        ns.diffuse = {
            getDiffuse: function getDiffuse(L, V, color, N, roughness){
                // If a roughness is defined we use Oren Nayar brdf.
                var a, b, NdotV, thetaOut, phiOut, thetaIn;
                var cosPhiDiff, alpha, beta;
                var NdotL = Math.saturate(N.dot(L));

                // Lambertian reflection is constant over the hemisphere.
                var brdf = 1.0;

                if (roughness > 0) {
                    a = 1.0 - (roughness * roughness) / (2 * (roughness * roughness + 0.33));
                    b = 0.45 * (roughness * roughness) / (roughness * roughness + 0.09);
                    NdotV = N.dot(V);
                    thetaOut = Math.acos(NdotV);
                    phiOut = V.sub(N.mul(NdotV)).normalize();
                    thetaIn = Math.acos(NdotL);
                    cosPhiDiff = phiOut.dot(L.sub(N.mul(NdotL)).normalize());
                    alpha = Math.max(thetaOut, thetaIn);
                    beta = Math.min(thetaOut, thetaIn);
                    brdf = (a + b * Math.saturate(cosPhiDiff) * Math.sin(alpha) * Math.tan(beta));
                }
                brdf *= NdotL;
                return color.mul(brdf);
            },

            getAmbient: function getAmbient(ambientIntensity, color, N, roughness){
                return color.mul(ambientIntensity);
            }
        };

        ns.phong = {
            getSpecular: function getSpecular(L, V, color, N, shininess){
                var R = L.reflect(N).normalize();
                var eyeVector = V.flip();
                return color.mul(Math.pow(Math.max(R.dot(eyeVector),0.0), shininess*128.0));
            }
        };

        ns.cookTorrance = {
            getSpecular: function getSpecular(L, V, color, N, ior, roughness){
                var R0 = Math.pow((1 - ior) / (1 + ior), 2);
                var H = V.add(L).normalize(),
                    NdotH = N.dot(H),
                    NdotL = Math.saturate(N.dot(L)),
                    HdotN = H.dot(N),
                    HdotL = H.dot(L),
                    HdotV = H.dot(V),
                    NdotV = N.dot(V);

                // Beckmann distribution
                var alpha = Math.acos(NdotH),
                    numerator = Math.exp(-Math.pow(Math.tan(alpha) / roughness, 2)),
                    denominator = Math.pow(roughness, 2) * Math.pow(NdotH, 4),
                    d =  Math.max(0, numerator / denominator);

                // Geometric attenuation
                var G1 = 2 * HdotN * NdotV / HdotV,
                    G2 = 2 * HdotN * NdotL / HdotV,
                    g =  Math.min(1, Math.max(0, Math.min(G1, G2))),
                    f = Math.max(0, R0 + (1 - R0) * Math.pow(1 - NdotH, 5));

                var brdf = d * g * f / (Math.PI * NdotV);
                return color.mul(brdf);
            }
        };

        ns.ward = {
            getSpecular: function getSpecular(L, V, color, N, T, ax, ay){
                var H = L.add(V).normalize();
                var B = N.cross(T).normalize();
                var NdotV = N.dot(V);
                var NdotL = Math.saturate(N.dot(L));
                var NdotH = N.dot(H);
                var HdotT = H.dot(T);
                var HdotB = H.dot(B);

                var first = 1 / (4 * Math.PI * ax * ay * Math.sqrt(NdotL * NdotV));
                var beta = -(Math.pow(HdotT / ax, 2) + Math.pow(HdotB / ay, 2)) / (NdotH * NdotH);
                var second = Math.exp(beta);
                var brdf = Math.max(0, first * second) * NdotL;

                return color.mul(brdf);
            }
        };

        ns.scatter = {
            getSpecular: function getSpecular(L, V, color, N, wrap, scatterWidth){
                var NdotL = Math.saturate(N.dot(L));

                var NdotLWrap = (NdotL + wrap) / (1 + wrap);
                var scatter = Math.smoothstep(0.0, scatterWidth, NdotLWrap) * Math.smoothstep(scatterWidth * 2.0, scatterWidth, NdotLWrap);

                return color.mul(scatter);
            }
        };

        ns.reflect = {
            getReflect: function getReflect(position, N, factor) {
                N = this.viewInverseMatrix.mulVec(N, 0).xyz();
                var I = this.viewInverseMatrix.mulVec(position, 1.0).xyz().sub(this.cameraPosition).normalize();
                var reflection3D = I.reflect(N).normalize();
                var reflection2D = new Vec2((Math.atan2(-reflection3D.z(), reflection3D.x()) + Math.PI) / (2 * Math.PI), (Math.asin(reflection3D.y()) + Math.PI / 2.0) / Math.PI);
                return Math.pow(this.environment.sample2D(reflection2D).rgb(), new Vec3(2.2)).mul(factor);
            }
        };

        ns.refract = {
            getRefract: function getRefract(position, N, eta, factor) {
                N = this.viewInverseMatrix.mulVec(N, 0).xyz();
                var I = this.viewInverseMatrix.mulVec(position, 1.0).xyz().sub(this.cameraPosition).normalize();
                var refraction3D = I.refract(N, eta).normalize();
                var refraction2D = new Vec2((Math.atan2(-refraction3D.z(), refraction3D.x()) + Math.PI) / (2 * Math.PI), (Math.asin(refraction3D.y()) + Math.PI / 2.0) / Math.PI);
                return Math.pow(this.environment.sample2D(refraction2D).rgb(), new Vec3(2.2)).mul(factor);
            }
        };

}(exports));

},{}]},{},[122])(122)
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcZ3J1bnQtYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9hbmFseXNlcy9pbmRleC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2FuYWx5c2VzL2xpYi9leGFtcGxlcy9hdmFpbGFibGVleHByZXNzaW9ucy5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2FuYWx5c2VzL2xpYi9leGFtcGxlcy9pbmRleC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2FuYWx5c2VzL2xpYi9leGFtcGxlcy9saXZldmFyaWFibGVzLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvYW5hbHlzZXMvbGliL2luZGV4LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvYW5hbHlzZXMvbGliL3F1ZXVlLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvYW5hbHlzZXMvbGliL3NldC5qcyIsIm5vZGVfbW9kdWxlc1xcZXM2LW1hcC1zaGltXFxlczYtbWFwLXNoaW0uanMiLCJub2RlX21vZHVsZXNcXGVzY29kZWdlblxcZXNjb2RlZ2VuLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9lc3RyYXZlcnNlL2VzdHJhdmVyc2UuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL2FzdC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvZXN1dGlscy9saWIvY29kZS5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvZXN1dGlscy9saWIva2V5d29yZC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvZXN1dGlscy9saWIvdXRpbHMuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYXJyYXktc2V0LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2Jhc2U2NC12bHEuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmFzZTY0LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2JpbmFyeS1zZWFyY2guanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvbWFwcGluZy1saXN0LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW5vZGUuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvdXRpbC5qcyIsIm5vZGVfbW9kdWxlc1xcZXNjb2RlZ2VuXFxub2RlX21vZHVsZXNcXHNvdXJjZS1tYXBcXG5vZGVfbW9kdWxlc1xcYW1kZWZpbmVcXGFtZGVmaW5lLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL3BhY2thZ2UuanNvbiIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzZ3JhcGgvbGliL2RvdC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzZ3JhcGgvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzXFxlc2dyYXBoXFxub2RlX21vZHVsZXNcXGVzY29kZWdlblxcZXNjb2RlZ2VuLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZXNncmFwaC9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2Jhc2ljLXNvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2dyYXBoL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmluYXJ5LXNlYXJjaC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzZ3JhcGgvbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9pbmRleGVkLXNvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2dyYXBoL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1jb25zdW1lci5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2VzZ3JhcGgvbm9kZV9tb2R1bGVzL2VzY29kZWdlbi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIm5vZGVfbW9kdWxlc1xcZXNncmFwaFxcbm9kZV9tb2R1bGVzXFxlc2NvZGVnZW5cXG5vZGVfbW9kdWxlc1xcc291cmNlLW1hcFxcbm9kZV9tb2R1bGVzXFxhbWRlZmluZVxcYW1kZWZpbmUuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy9lc2dyYXBoL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vcGFja2FnZS5qc29uIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZXNwcmltYS9lc3ByaW1hLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZXN0cmF2ZXJzZS9lc3RyYXZlcnNlLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXNcXGdydW50LWJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxwYXRoLWJyb3dzZXJpZnlcXGluZGV4LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlc1xcZ3J1bnQtYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXHV0aWxcXHV0aWwuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL25vZGVfbW9kdWxlcy93YWxrZXMvbGliL2luZGV4LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS9hbmFseXNpc2NvbnRleHQuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9hbmFseXplL2FuYWx5emUuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9hbmFseXplL2NvbnN0YW50cy9ldmFsdWF0b3IuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9hbmFseXplL2NvbnN0YW50cy9zdGF0aWNUcmFuc2Zvcm1lci5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvcGFyYW1ldGVycy5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvc2FuaXRpemVyL3Nhbml0aXplci5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvc2FuaXRpemVyL3N0YXRlbWVudC1zcGxpdC10cmF2ZXJzZXIuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9hbmFseXplL3NlbWFudGljcy9zZW1hbnRpY3MuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9hbmFseXplL3NldHRvb2xzLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS9zcGFjZV9hbmFseXplci5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9pbmZlcl9leHByZXNzaW9uLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L2NvbG9yY2xvc3VyZS5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS9pbmRleC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS9tYXQzLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L21hdDQuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvbWF0aC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS9zaGFkZS5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS9zcGFjZS5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS9zeXN0ZW0uanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvdGV4dHVyZS5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS90b29scy5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS9yZWdpc3RyeS92ZWMyLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3ZlYzMuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9hbmFseXplL3R5cGVpbmZlcmVuY2UvcmVnaXN0cnkvdmVjNC5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2FuYWx5emUvdHlwZWluZmVyZW5jZS90eXBlaW5mZXJlbmNlLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS91bmlmb3JtRXhwcmVzc2lvbnMvZXZhbHVhdG9yLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS91bmlmb3JtRXhwcmVzc2lvbnMvdW5pZm9ybUFuYWx5c2lzLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS91bmlmb3JtRXhwcmVzc2lvbnMvdW5pZm9ybVNldHRlclRyYW5zZm9ybWF0aW9uLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS91bmlmb3JtRXhwcmVzc2lvbnMvdW5pZm9ybVRyYW5zZm9ybWVyLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYW5hbHl6ZS92YWxpZGF0b3IuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9iYXNlL2Fubm90YXRpb24uanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9iYXNlL2FzdHRvb2xzLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYmFzZS9jb21tb24uanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9iYXNlL2NvbnRleHQuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9iYXNlL2Vycm9ycy5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2Jhc2UvaW5kZXguanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9iYXNlL3Njb3BlLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYmFzZS90eXBlaW5mby5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2Jhc2UvdmVjLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvYmFzZS92ZWNtYXRoLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvY29udHJpYi9nbC1tYXRyaXgtZXh0ZW5kLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvY29udHJpYi9nbC1tYXRyaXguanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9iYXNlL2V4cHJlc3Npb24taGFuZGxlci5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2dlbmVyYXRlL2dsbWF0cml4L2NvbXBpbGVyLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xtYXRyaXgvdHJhbnNmb3JtLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9jb21waWxlci5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2dlbmVyYXRlL2dsc2wvZ2xzbC1nZW5lcmF0ZS5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2dlbmVyYXRlL2dsc2wvcmVnaXN0cnkvaW5kZXguanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9nbHNsL3JlZ2lzdHJ5L21hdDMuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9nbHNsL3JlZ2lzdHJ5L21hdDQuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9nbHNsL3JlZ2lzdHJ5L21hdGguanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9nbHNsL3JlZ2lzdHJ5L3NoYWRlLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS9zcGFjZS5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2dlbmVyYXRlL2dsc2wvcmVnaXN0cnkvc3lzdGVtLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS90ZXh0dXJlLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS92ZWMyLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS92ZWMzLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC9yZWdpc3RyeS92ZWM0LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvZ2xzbC90cmFuc2Zvcm0uanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9saWdodC1wYXNzL2xpZ2h0LXBhc3MtZ2VuZXJhdG9yLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvbGlnaHQtcGFzcy9saWdodC1wYXNzLXRlbXBsYXRlLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvc2ltcGxlLXN0YXRlbWVudC9zaW1wbGUtc3RhdGVtZW50LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvZ2VuZXJhdGUvc25pcHBldHMvc25pcHBldC1jb25uZWN0b3IuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9zbmlwcGV0cy9zbmlwcGV0LWxpc3QuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9zcGFjZS9zcGFjZS10cmFuc2Zvcm0tdG9vbHMuanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS9zcGFjZS90cmFuc2Zvcm0uanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9nZW5lcmF0ZS90b29scy5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL2luZGV4LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvaW50ZXJmYWNlcy5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL3Jlc29sdmUvY29sb3JjbG9zdXJlLW1hcmtlci5qcyIsImQ6L0NvZGUvaHRkb2NzL3NoYWRlanMvc3JjL3Jlc29sdmUvY29sb3JjbG9zdXJlLXRvb2xzLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvcmVzb2x2ZS9yZXNvbHZlLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWRlZmVycmVkL2NvbG9yLWNsb3N1cmUtc2lnbmF0dXJlLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWRlZmVycmVkL2luZGV4LmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWRlZmVycmVkL3htbDNkLWRlZmVycmVkLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWZvcndhcmQvaW5kZXguanMiLCJkOi9Db2RlL2h0ZG9jcy9zaGFkZWpzL3NyYy9yZXNvbHZlL3htbDNkLWdsc2wtZm9yd2FyZC9saWdodC1sb29wLmpzIiwiZDovQ29kZS9odGRvY3Mvc2hhZGVqcy9zcmMvcmVzb2x2ZS94bWwzZC1nbHNsLWZvcndhcmQveG1sM2QtZm9yd2FyZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzkvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2a0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Z6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHBJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKTtcbiIsIlxudmFyIHdhbGtlcyA9IHJlcXVpcmUoJ3dhbGtlcycpO1xudmFyIHdvcmtsaXN0ID0gcmVxdWlyZSgnLi4vJyk7XG52YXIgU2V0ID0gcmVxdWlyZSgnLi4vc2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXZhaWxhYmxlRXhwcmVzc2lvbnM7XG5cbi8qXG5TbyBoZXJlIGlzIHRoZSBzdG9yeTpcbkVhY2ggbm9kZSBpcyBzdXBwb3NlZCB0byBoYXZlIGEgYFNldGAgb2YgZXhwcmVzc2lvbnMuIEFuZCBmb3IgZWFjaCBleHByZXNzaW9uLFxuSSB3YW50IHRvIHNhdmUgdGhlIGBTZXRgIG9mIGNvbnRhaW5lZCB2YXJpYWJsZXMgZm9yIGVhc2llciBraWxsaW5nLlxuXG5TaW5jZSBKUyBoYXMgbm8gcmVjb3JkcyB5ZXQgKHNlZSBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1zdHJhd21hbjpyZWNvcmRzIClcbmFuZCBubyBjb25jZXB0IG9mIHN0cnVjdHVyYWwgZXF1YWxpdHksIGFuIGV4cHJlc3Npb24gcmVwcmVzZW50ZWQgYnkgYW4gQVNUIG5vZGVcbmlzICpuZXZlciBldmVyKiBlcXVhbCB0byBhbiBzdHJ1Y3R1cmFsbHkgZXF1YWwgZXhwcmVzc2lvbiB1bmxlc3MgaXRzIHRoZVxuaWRlbnRpY2FsIG5vZGUuXG5UaGUgc2FtZSBnb2VzIGZvciBgU2V0YHMuIFNpbmNlIHRoZXkgYXJlIGp1c3Qgc2hpbW1lZCB1c2luZyBub3JtYWwgT2JqZWN0cywgdGhleVxuYXJlICpuZXZlciBldmVyKiBlcXVhbCwgYWx0aG91Z2ggdGhleSBjb250YWluIHRoZSBleGFjdCBzYW1lIG1lbWJlcnMuXG5cblNvIGFzIGEgd29ya2Fyb3VuZCwgSSBgSlNPTi5zdHJpbmdpZnlgIHRoZSBleHByZXNzaW9uIHRvIHNhdmUgaXQgaW4gdGhlIFNldCBhbmRcbnVzZSBhIG1hcHBpbmcgdGFibGUgdG8gZ2V0IHRvIHRoZSBleHByZXNzaW9uIG9iamVjdCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgc2V0IG9mXG52YXJpYWJsZXMuXG5cbk9mIGNvdXJzZSwgSSBjb3VsZCBqdXN0IHVzZSBhIGN1c3RvbSBTZXQgaW1wbGVtZW50YXRpb24gd2hpY2ggdXNlcyBhIGN1c3RvbVxuZXF1YWxpdHkgY2hlY2sgZnVuY3Rpb24uIEJ1dCBJIHdhbnQgdG8gYmUgZm9yd2FyZC1jb21wYXRpYmxlIHdpdGggdGhlIHVwY29taW5nXG5FUzYgc3RhbmRhcmQsIHdoaWNoIHNob3VsZCBwcm92aWRlIGEgTygxKSBTZXRzLCBpbnN0ZWFkIG9mIHRoZSBPKG4pIHNoaW0uXG4qL1xuXG5mdW5jdGlvbiBhdmFpbGFibGVFeHByZXNzaW9ucyhjZmcpIHtcblx0dmFyIGV4cHJlc3Npb25NYXAgPSB7fTtcblxuXHRmdW5jdGlvbiBmaW5kRXhwcmVzc2lvbnMoYXN0KSB7XG5cdFx0dmFyIGV4cHJlc3Npb25zID0gbmV3IFNldCgpO1xuXHRcdC8vIEZJWE1FOiBqdXN0IGhhbmRsaW5nIGJpbmFyeSBleHByZXNzaW9ucyBzbyBmYXJcblx0XHR3YWxrZXMoYXN0LCB7XG5cdFx0XHRJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgU2V0KHRoaXMubmFtZSk7XG5cdFx0XHR9LFxuXHRcdFx0TGl0ZXJhbDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFNldCgpO1xuXHRcdFx0fSxcblx0XHRcdEJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChyZWN1cnNlKSB7XG5cdFx0XHRcdHZhciBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuXHRcdFx0XHRleHByZXNzaW9ucy5hZGQoc3RyaW5naWZpZWQpO1xuXHRcdFx0XHRpZiAoc3RyaW5naWZpZWQgaW4gZXhwcmVzc2lvbk1hcCkge1xuXHRcdFx0XHRcdHJldHVybiBleHByZXNzaW9uTWFwW3N0cmluZ2lmaWVkXS52YXJpYWJsZXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHJpZ2h0ID0gcmVjdXJzZSh0aGlzLnJpZ2h0KTtcblx0XHRcdFx0dmFyIGxlZnQgPSByZWN1cnNlKHRoaXMubGVmdCk7XG5cdFx0XHRcdHZhciB2YXJpYWJsZXMgPSBTZXQudW5pb24obGVmdCwgcmlnaHQpO1xuXHRcdFx0XHRleHByZXNzaW9uTWFwW3N0cmluZ2lmaWVkXSA9IHtcblx0XHRcdFx0XHRleHByZXNzaW9uOiB0aGlzLFxuXHRcdFx0XHRcdHZhcmlhYmxlczogdmFyaWFibGVzXG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiB2YXJpYWJsZXM7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuXHR9XG5cblx0Ly8gcnVuIHRoZSBhbGdvcml0aG1cblx0dmFyIG91dHB1dCA9IHdvcmtsaXN0KGNmZywgZnVuY3Rpb24gKGlucHV0LCBsaXN0KSB7XG5cdFx0aWYgKHRoaXMudHlwZSB8fCAhdGhpcy5hc3ROb2RlKVxuXHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdHZhciBraWxsID0gdGhpcy5raWxsID0gdGhpcy5raWxsIHx8IGZpbmRBc3NpZ25tZW50cyh0aGlzLmFzdE5vZGUpO1xuXHRcdHZhciBnZW5lcmF0ZSA9IHRoaXMuZ2VuZXJhdGUgPSB0aGlzLmdlbmVyYXRlIHx8IGZpbmRFeHByZXNzaW9ucyh0aGlzLmFzdE5vZGUpO1xuXHRcdHZhciBraWxsZWQgPSBuZXcgU2V0KGlucHV0LnZhbHVlcygpLmZpbHRlcihmdW5jdGlvbiAoZXhwcikge1xuXHRcdFx0dmFyIHZhcmlhYmxlcyA9IGV4cHJlc3Npb25NYXBbZXhwcl0udmFyaWFibGVzO1xuXHRcdFx0cmV0dXJuICFTZXQuaW50ZXJzZWN0KHZhcmlhYmxlcywga2lsbCkuc2l6ZTtcblx0XHR9KSk7XG5cdFx0cmV0dXJuIFNldC51bmlvbihraWxsZWQsIGdlbmVyYXRlKTtcblx0fSwge2RpcmVjdGlvbjogJ2ZvcndhcmQnLCBtZXJnZTogd29ya2xpc3QubWVyZ2UoU2V0LmludGVyc2VjdCl9KTtcblxuXHQvLyBnbyBvdmVyIGFsbCB0aGUgbm9kZXMgYW5kIHB1c2ggZG93biB0aGUgcmVhbCBvYmplY3RzIGludG8gdGhlIG91dHB1dFxuXHRjZmdbMl0uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuXHRcdHZhciBvdXQgPSBvdXRwdXQuZ2V0KG5vZGUpO1xuXHRcdG91dHB1dC5zZXQobm9kZSwgbmV3IFNldChvdXQudmFsdWVzKCkubWFwKGZ1bmN0aW9uIChleHByKSB7XG5cdFx0XHRyZXR1cm4gZXhwcmVzc2lvbk1hcFtleHByXS5leHByZXNzaW9uO1xuXHRcdH0pKSk7XG5cdH0pO1xuXG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRBc3NpZ25tZW50cyhhc3QpIHtcblx0dmFyIHZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcblx0d2Fsa2VzKGFzdCwge1xuXHRcdEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAocmVjdXJzZSkge1xuXHRcdFx0aWYgKHRoaXMubGVmdC50eXBlID09PSAnSWRlbnRpZmllcicpXG5cdFx0XHRcdHZhcmlhYmxlcy5hZGQodGhpcy5sZWZ0Lm5hbWUpO1xuXHRcdFx0cmVjdXJzZSh0aGlzLnJpZ2h0KTtcblx0XHR9LFxuXHRcdFZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdHZhcmlhYmxlcy5hZGQodGhpcy5pZC5uYW1lKTtcblx0XHRcdGlmICh0aGlzLmluaXQpXG5cdFx0XHRcdHJlY3Vyc2UodGhpcy5pbml0KTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gdmFyaWFibGVzO1xufVxuXG4iLCJcbmV4cG9ydHMubGl2ZVZhcmlhYmxlcyA9IHJlcXVpcmUoJy4vbGl2ZXZhcmlhYmxlcycpO1xuZXhwb3J0cy5hdmFpbGFibGVFeHByZXNzaW9ucyA9IHJlcXVpcmUoJy4vYXZhaWxhYmxlZXhwcmVzc2lvbnMnKTtcblxuIiwiXG52YXIgd2Fsa2VzID0gcmVxdWlyZSgnd2Fsa2VzJyk7XG52YXIgd29ya2xpc3QgPSByZXF1aXJlKCcuLi8nKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuLi9zZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBsaXZlVmFyaWFibGVzO1xuXG5mdW5jdGlvbiBsaXZlVmFyaWFibGVzKGNmZykge1xuXHRyZXR1cm4gd29ya2xpc3QoY2ZnLCBmdW5jdGlvbiAoaW5wdXQpIHtcblx0XHRpZiAodGhpcy50eXBlIHx8ICF0aGlzLmFzdE5vZGUpXG5cdFx0XHRyZXR1cm4gaW5wdXQ7XG5cdFx0dmFyIGtpbGwgPSB0aGlzLmtpbGwgPSB0aGlzLmtpbGwgfHwgZmluZEFzc2lnbm1lbnRzKHRoaXMuYXN0Tm9kZSk7XG5cdFx0dmFyIGdlbmVyYXRlID0gdGhpcy5nZW5lcmF0ZSA9IHRoaXMuZ2VuZXJhdGUgfHwgZmluZFZhcmlhYmxlcyh0aGlzLmFzdE5vZGUpO1xuXHRcdHJldHVybiBTZXQudW5pb24oU2V0Lm1pbnVzKGlucHV0LCBraWxsKSwgZ2VuZXJhdGUpO1xuXHR9LCB7ZGlyZWN0aW9uOiAnYmFja3dhcmQnfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRBc3NpZ25tZW50cyhhc3ROb2RlKSB7XG5cdHZhciB2YXJpYWJsZXMgPSBuZXcgU2V0KCk7XG5cdHdhbGtlcyhhc3ROb2RlLCB7XG5cdFx0QXNzaWdubWVudEV4cHJlc3Npb246IGZ1bmN0aW9uIChyZWN1cnNlKSB7XG5cdFx0XHRpZiAodGhpcy5sZWZ0LnR5cGUgPT09ICdJZGVudGlmaWVyJylcblx0XHRcdFx0dmFyaWFibGVzLmFkZCh0aGlzLmxlZnQubmFtZSk7XG5cdFx0XHRyZWN1cnNlKHRoaXMucmlnaHQpO1xuXHRcdH0sXG5cdFx0RnVuY3Rpb25EZWNsYXJhdGlvbjogZnVuY3Rpb24gKCkge30sXG5cdFx0RnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7fSxcblx0XHRWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uIChyZWN1cnNlKSB7XG5cdFx0XHR2YXJpYWJsZXMuYWRkKHRoaXMuaWQubmFtZSk7XG5cdFx0XHRpZiAodGhpcy5pbml0KVxuXHRcdFx0XHRyZWN1cnNlKHRoaXMuaW5pdCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHZhcmlhYmxlcztcbn1cbmZ1bmN0aW9uIGZpbmRWYXJpYWJsZXMoYXN0Tm9kZSkge1xuXHR2YXIgdmFyaWFibGVzID0gbmV3IFNldCgpO1xuXHR3YWxrZXMoYXN0Tm9kZSwge1xuXHRcdEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAocmVjdXJzZSkge1xuXHRcdFx0aWYgKHRoaXMubGVmdC50eXBlICE9PSAnSWRlbnRpZmllcicpXG5cdFx0XHRcdHJlY3Vyc2UodGhpcy5sZWZ0KTtcblx0XHRcdHJlY3Vyc2UodGhpcy5yaWdodCk7XG5cdFx0fSxcblx0XHRGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbiAoKSB7fSxcblx0XHRGdW5jdGlvbkV4cHJlc3Npb246IGZ1bmN0aW9uICgpIHt9LFxuXHRcdElkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhcmlhYmxlcy5hZGQodGhpcy5uYW1lKTtcblx0XHR9LFxuXHRcdE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChyZWN1cnNlKSB7XG5cdFx0XHRyZWN1cnNlKHRoaXMub2JqZWN0KTtcblx0XHR9LFxuXHRcdFByb3BlcnR5OiBmdW5jdGlvbiAocmVjdXJzZSkge1xuXHRcdFx0cmVjdXJzZSh0aGlzLnZhbHVlKTtcblx0XHR9LFxuXHRcdFZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdHJlY3Vyc2UodGhpcy5pbml0KTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gdmFyaWFibGVzO1xufVxuXG4iLCJcbnZhciBRdWV1ZSA9IHJlcXVpcmUoJy4vcXVldWUnKTtcbnZhciBTZXQgPSByZXF1aXJlKCcuL3NldCcpO1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gd29ya2xpc3Q7XG5cbi8vIGV4cG9zZSB0aGUgdXRpbGl0aWVzIHRvIGhhdmUgdGhlbSB0ZXN0ZWQgc2VwYXJhdGVseVxuZXhwb3J0cy5RdWV1ZSA9IFF1ZXVlO1xuZXhwb3J0cy5TZXQgPSBTZXQ7XG5leHBvcnRzLmV4YW1wbGVzID0gcmVxdWlyZSgnLi9leGFtcGxlcycpO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgZ2VuZXJhbCB3b3JrbGlzdCBhbGdvcml0aG1cbiAqIGBjZmdgIGlzIGEgY29udHJvbCBmbG93IGdyYXBoIGNyZWF0ZWQgYnkgYGVzZ3JhcGhgLFxuICogYHRyYW5zZmVyRnVuY3Rpb25gIGdldHMgY2FsbGVkIHdpdGggKHRoaXMgPSBub2RlLCBpbnB1dCwgd29ya2xpc3QpXG4gKiBpdCBvcGVyYXRlcyBvbiB0aGUgaW5wdXQgYFNldGAgYW5kIGNhbiByZXR1cm4gYW4gb3V0cHV0IHNldCwgaW4gd2hpY2ggY2FzZVxuICogdGhlIHdvcmtsaXN0IGFsZ29yaXRobSBhdXRvbWF0aWNhbGx5IGVucXVldWVzIGFsbCB0aGUgc3VjY2Vzc29yIG5vZGVzLCBvciBpdFxuICogbWlnaHQgcmV0dXJuIGFuIHtvdXRwdXQ6IG91dHB1dCwgZW5xdWV1ZTogZmFsc2V9IG9iamVjdCBpbiB3aGljaCBjYXNlIGl0IGlzXG4gKiBpdHNlbGYgcmVzcG9uc2libGUgdG8gZW5xdWV1ZSB0aGUgc3VjY2Vzc29yIG5vZGVzLlxuICogYG9wdGlvbnNgIGRlZmluZXMgdGhlIGBkaXJlY3Rpb25gLCBhIGBtZXJnZWAgZnVuY3Rpb24gYW5kIGFuIGBlcXVhbHNgXG4gKiBmdW5jdGlvbiB3aGljaCBtZXJnZSB0aGUgaW5wdXRzIHRvIGEgbm9kZSBhbmQgZGV0ZXJtaW5lIGlmIGEgbm9kZSBoYXMgY2hhbmdlZFxuICogaXRzIG91dHB1dCByZXNwZWN0aXZlbHkuXG4gKiBSZXR1cm5zIGEgYE1hcGAgZnJvbSBub2RlIC0+IG91dHB1dFxuICovXG5mdW5jdGlvbiB3b3JrbGlzdChjZmcsIHRyYW5zZmVyRnVuY3Rpb24sIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdHZhciBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCAnZm9yd2FyZCc7XG5cdHZhciBtZXJnZSA9IG9wdGlvbnMubWVyZ2UgfHwgd29ya2xpc3QubWVyZ2UoU2V0LnVuaW9uKTtcblx0dmFyIGVxdWFscyA9IG9wdGlvbnMuZXF1YWxzIHx8IFNldC5lcXVhbHM7XG5cdHZhciBsaXN0ID0gbmV3IFF1ZXVlKCk7XG5cdGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuXHRcdGxpc3QucHVzaChjZmdbMF0pO1xuXHRcdHZhciBwcmVkZWNlc3NvcnMgPSB3b3JrbGlzdC5wcmVkZWNlc3NvcnM7XG5cdFx0dmFyIHN1Y2Nlc3NvcnMgPSB3b3JrbGlzdC5zdWNjZXNzb3JzO1xuXHR9IGVsc2Uge1xuXHRcdGxpc3QucHVzaChjZmdbMV0pO1xuXHRcdHZhciBwcmVkZWNlc3NvcnMgPSB3b3JrbGlzdC5zdWNjZXNzb3JzO1xuXHRcdHZhciBzdWNjZXNzb3JzID0gd29ya2xpc3QucHJlZGVjZXNzb3JzO1xuXHR9XG5cdHZhciBzdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgbmV3IFNldCgpO1xuXG5cdHZhciBvdXRwdXQgPSBuZXcgTWFwKCk7XG5cdHdoaWxlIChsaXN0Lmxlbmd0aCkge1xuXHRcdHZhciBub2RlID0gbGlzdC5zaGlmdCgpO1xuXHRcdHZhciBwcmUgPSBwcmVkZWNlc3NvcnMobm9kZSlcblx0XHRcdC5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG91dHB1dC5nZXQobik7IH0pO1xuXHRcdHZhciBpbnB1dCA9IHByZS5sZW5ndGggPyBtZXJnZShwcmUpIDogc3RhcnQ7XG5cdFx0dmFyIG9sZE91dHB1dCA9IG91dHB1dC5nZXQobm9kZSk7XG5cdFx0dmFyIG91dCA9IHRyYW5zZmVyRnVuY3Rpb24uY2FsbChub2RlLCBpbnB1dCwgbGlzdCwgb2xkT3V0cHV0KTtcblx0XHRpZiAoIW91dCB8fCBvdXQgaW5zdGFuY2VvZiBTZXQpXG5cdFx0XHRvdXQgPSB7b3V0cHV0OiBvdXQsIGVucXVldWU6IHRydWV9O1xuXHRcdG91dHB1dC5zZXQobm9kZSwgb3V0Lm91dHB1dCk7XG5cdFx0aWYgKG91dC5lbnF1ZXVlICYmICghb2xkT3V0cHV0IHx8ICFlcXVhbHMob3V0Lm91dHB1dCwgb2xkT3V0cHV0KSkpXG5cdFx0XHRzdWNjZXNzb3JzKG5vZGUpLmZvckVhY2gobGlzdC5wdXNoLmJpbmQobGlzdCkpO1xuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59O1xuXG53b3JrbGlzdC5wcmVkZWNlc3NvcnMgPSBmdW5jdGlvbiAobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5wcmV2O1xufTtcbndvcmtsaXN0LnN1Y2Nlc3NvcnMgPSBmdW5jdGlvbiAobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5uZXh0O1xufTtcblxud29ya2xpc3QubWVyZ2UgPSBmdW5jdGlvbiAoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChpbnB1dHMpIHtcblx0XHRpZiAoaW5wdXRzLmxlbmd0aCA9PSAxKVxuXHRcdFx0cmV0dXJuIG5ldyBTZXQoaW5wdXRzWzBdKTtcblx0XHRyZXR1cm4gaW5wdXRzLnJlZHVjZShmbik7XG5cdH07XG59O1xuXG4iLCJcbm1vZHVsZS5leHBvcnRzID0gUXVldWU7XG5cbi8qKlxuICogVGhpcyBpcyBhIHJlYWxseSBzbWFsbCBwcmlvcml0eSBxdWV1ZSB0aGF0IG1ha2VzIHN1cmUgdGhhdCBkdXBsaWNhdGUgZWxlbWVudHNcbiAqIGFyZSBiZWluZyBpbnNlcnRlZCBhdCB0aGUgZW5kXG4gKi9cbmZ1bmN0aW9uIFF1ZXVlKCkge1xuXHR2YXIgcSA9IFtdO1xuXHRxLl9fcHJvdG9fXyA9IFF1ZXVlLnByb3RvdHlwZTtcblx0cmV0dXJuIHE7XG59XG5cblF1ZXVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXJyYXkucHJvdG90eXBlKTtcblF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gUXVldWVfcHVzaChlbGVtKSB7XG5cdHZhciBwb3MgPSB0aGlzLmluZGV4T2YoZWxlbSk7XG5cdGlmIChwb3MgIT0gLTEpXG5cdFx0dGhpcy5zcGxpY2UocG9zLCAxKTtcblx0QXJyYXkucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBlbGVtKTtcbn07XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuXG4vKipcbiAqIEVTNiBTZXRzIGluIGBub2RlIC0taGFybW9ueWAgZG8gbm90IHByb3ZpZGUgYC52YWx1ZXMoKWAgb3IgYGZvciBvZmAgaXRlcmF0aW9uXG4gKiB5ZXQsIHNvIHRoZXkgYXJlIHByZXR0eSB1c2VsZXNzIDotKFxuICogVGhpcyBTZXQgYWxzbyBkb2VzIG5vdCB1c2UgYE9iamVjdC5pc2A7IHdlIGRvIG5vdCBjYXJlIGFib3V0IE5hTiwgLTAsICswXG4gKi9cbmZ1bmN0aW9uIFNldChlbGVtZW50cykge1xuXHR0aGlzLl92YWx1ZXMgPSBbXTtcblx0aWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxuXHRcdGVsZW1lbnRzLmZvckVhY2godGhpcy5hZGQuYmluZCh0aGlzKSk7XG5cdGVsc2UgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgU2V0KVxuXHRcdGVsZW1lbnRzLl92YWx1ZXMuZm9yRWFjaCh0aGlzLmFkZC5iaW5kKHRoaXMpKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXQucHJvdG90eXBlLCAnc2l6ZScsIHtcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoO1xuXHR9XG59KTtcblNldC5wcm90b3R5cGUuX2kgPSBmdW5jdGlvbiBTZXRfX2koZWxlbSkge1xuXHRyZXR1cm4gdGhpcy5fdmFsdWVzLmluZGV4T2YoZWxlbSk7XG59O1xuU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTZXRfYWRkKGVsZW0pIHtcblx0aWYgKCF0aGlzLmhhcyhlbGVtKSlcblx0XHR0aGlzLl92YWx1ZXMucHVzaChlbGVtKTtcbn07XG5TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIFNldF9oYXMoZWxlbSkge1xuXHRyZXR1cm4gISF+dGhpcy5faShlbGVtKTtcbn07XG5TZXQucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIFNldF9kZWxldGUoZWxlbSkge1xuXHR2YXIgaSA9IHRoaXMuX2koZWxlbSk7XG5cdGlmICghfmkpXG5cdFx0cmV0dXJuO1xuXHR0aGlzLl92YWx1ZXMuc3BsaWNlKGksIDEpO1xufTtcblNldC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gU2V0X3ZhbHVlcygpIHtcblx0cmV0dXJuIFtdLmNvbmNhdCh0aGlzLl92YWx1ZXMpO1xufTtcblxuLy8gZm9yd2FyZCBzb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyBmcm9tIEFycmF5LnByb3RvdHlwZVxuW1xuXHQnc29tZScsXG5cdCdtYXAnLFxuXHQnZXZlcnknLFxuXHQnZmlsdGVyJyxcblx0J2ZvckVhY2gnXG5dLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXHRTZXQucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZVttZXRob2RdLmFwcGx5KHRoaXMuX3ZhbHVlcywgYXJndW1lbnRzKTtcblx0fVxufSk7XG5cbi8vIHNvbWUgY29udmVuaWVuY2UgZnVuY3Rpb25zXG5TZXQucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gU2V0X2ZpcnN0KCkge1xuXHRyZXR1cm4gdGhpcy5fdmFsdWVzWzBdO1xufTtcblNldC5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYikge1xuXHRpZiAoIWEgJiYgYilcblx0XHRyZXR1cm4gbmV3IFNldChiKTtcblx0aWYgKCFiICYmIGEpXG5cdFx0cmV0dXJuIG5ldyBTZXQoYSk7XG5cdHZhciBzID0gbmV3IFNldCgpO1xuXHRhLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmIChiLmhhcyh2YWwpKVxuXHRcdFx0cy5hZGQodmFsKTtcblx0fSk7XG5cdHJldHVybiBzO1xufTtcblNldC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uKGEsIGIpIHtcblx0aWYgKCFhICYmIGIpXG5cdFx0cmV0dXJuIG5ldyBTZXQoYik7XG5cdHZhciBzID0gbmV3IFNldChhKTtcblx0aWYgKGIpXG5cdFx0Yi5mb3JFYWNoKHMuYWRkLmJpbmQocykpO1xuXHRyZXR1cm4gcztcbn07XG5TZXQuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcblx0aWYgKGEuc2l6ZSAhPSBiLnNpemUpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gYS5ldmVyeShmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIGIuaGFzKHZhbCk7XG5cdH0pO1xufTtcblNldC5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKGEsIGIpIHtcblx0dmFyIHMgPSBuZXcgU2V0KGEpO1xuXHRiLmZvckVhY2gocy5kZWxldGUuYmluZChzKSk7XG5cdHJldHVybiBzO1xufTtcblxuIiwiLy8hIENvcHlyaWdodCAyMDEyIEVyaWMgV2VuZGVsaW4gLSBNSVQgTGljZW5zZVxuXG4vKipcbiAqIGVzNi1tYXAtc2hpbS5qcyBpcyBhIERFU1RSVUNUSVZFIHNoaW0gdGhhdCBmb2xsb3dzIHRoZSBsYXRlc3QgTWFwIHNwZWNpZmljYXRpb24gYXMgY2xvc2VseSBhcyBwb3NzaWJsZS5cbiAqIEl0IGlzIGRlc3RydWN0aXZlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG92ZXJyaWRlcyBuYXRpdmUgaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoaXMgbGlicmFyeSBhc3N1bWVzIEVTNSBmdW5jdGlvbmFsaXR5OiBPYmplY3QuY3JlYXRlLCBPYmplY3QuZGVmaW5lUHJvcGVydHksIEFycmF5LmluZGV4T2YsIEZ1bmN0aW9uLmJpbmRcbiAqL1xuKGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIGZ1bmN0aW9uIE1hcChpdGVyYWJsZSkge1xuICAgICAgICB2YXIgX2l0ZW1zID0gW107XG4gICAgICAgIHZhciBfa2V5cyA9IFtdO1xuICAgICAgICB2YXIgX3ZhbHVlcyA9IFtdO1xuXG4gICAgICAgIC8vIE9iamVjdC5pcyBwb2x5ZmlsbCwgY291cnRlc3kgb2YgQFdlYlJlZmxlY3Rpb25cbiAgICAgICAgdmFyIGlzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhID09PSBiID9cbiAgICAgICAgICAgICAgICBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiIDpcbiAgICAgICAgICAgICAgICBhICE9IGEgJiYgYiAhPSBiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1vcmUgcmVsaWFibGUgaW5kZXhPZiwgY291cnRlc3kgb2YgQFdlYlJlZmxlY3Rpb25cbiAgICAgICAgdmFyIGJldHRlckluZGV4T2YgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYodmFsdWUgIT0gdmFsdWUgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSB0aGlzLmxlbmd0aDsgaS0tICYmICFpcyh0aGlzW2ldLCB2YWx1ZSk7KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSA9IFtdLmluZGV4T2YuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgTWFwSXRlcmF0b3IgPSBmdW5jdGlvbiBNYXBJdGVyYXRvcihtYXAsIGtpbmQpIHtcbiAgICAgICAgICAgIHZhciBfaW5kZXggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAgICAgICAgIG5leHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgaW5kZXggaXMgd2l0aGluIGJvdW5kc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pbmRleCA8IG1hcC5pdGVtcygpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2tleXMnOiByZXR1cm4gbWFwLmtleXMoKVtfaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbHVlcyc6IHJldHVybiBtYXAudmFsdWVzKClbX2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdrZXlzK3ZhbHVlcyc6IHJldHVybiBbXS5zbGljZS5jYWxsKG1hcC5pdGVtcygpW19pbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaXRlcmF0b3IgdHlwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2Ugc3VyZSBJJ20gaW50ZXJwcmV0aW5nIHRoZSBzcGVjIGNvcnJlY3RseSBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0b3AgSXRlcmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0b1N0cmluZzoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX3NldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGtleSBleGlzdHMgYW5kIG92ZXJ3cml0ZVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gYmV0dGVySW5kZXhPZi5jYWxsKF9rZXlzLCBrZXkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBfaXRlbXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2l0ZW1zLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICBfa2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgX3ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2V0SXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaXRlcmFibGUgcGFzc2VkIHRvIE1hcCBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc2V0KGl0ZW1bMF0sIGl0ZW1bMV0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZJWE1FOiBhY2NvbW1vZGF0ZSBhbnkgY2xhc3MgdGhhdCBkZWZpbmVzIGFuIEBAaXRlcmF0b3IgbWV0aG9kIHRoYXQgcmV0dXJuc1xuICAgICAgICAvLyAgICAgIGFuIGl0ZXJhdG9yIG9iamVjdCB0aGF0IHByb2R1Y2VzIHR3byBlbGVtZW50IGFycmF5LWxpa2Ugb2JqZWN0c1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVyYWJsZSkpIHtcbiAgICAgICAgICAgIGl0ZXJhYmxlLmZvckVhY2goc2V0SXRlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlcmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBNYXAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKE1hcFByb3RvdHlwZSwge1xuICAgICAgICAgICAgaXRlbXM6e1xuICAgICAgICAgICAgICAgIHZhbHVlOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChfaXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlzOntcbiAgICAgICAgICAgICAgICB2YWx1ZTpmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoX2tleXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZXM6e1xuICAgICAgICAgICAgICAgIHZhbHVlOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChfdmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzOntcbiAgICAgICAgICAgICAgICB2YWx1ZTpmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogY2hlY2sgaG93IHNwZWMgcmVhZHMgYWJvdXQgbnVsbCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYmV0dGVySW5kZXhPZi5jYWxsKF9rZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OntcbiAgICAgICAgICAgICAgICB2YWx1ZTpmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYmV0dGVySW5kZXhPZi5jYWxsKF9rZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMSA/IF92YWx1ZXNbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6e1xuICAgICAgICAgICAgICAgIHZhbHVlOiBfc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2l6ZTp7XG4gICAgICAgICAgICAgICAgZ2V0OmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2l0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYXI6e1xuICAgICAgICAgICAgICAgIHZhbHVlOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfa2V5cy5sZW5ndGggPSBfdmFsdWVzLmxlbmd0aCA9IF9pdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVsZXRlJzp7XG4gICAgICAgICAgICAgICAgdmFsdWU6ZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGJldHRlckluZGV4T2YuY2FsbChfa2V5cywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yRWFjaDp7XG4gICAgICAgICAgICAgICAgdmFsdWU6ZnVuY3Rpb24oY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tmbiAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNhbGxiYWNrIGZ1bmN0aW9uIGdpdmVuIHRvIGZvckVhY2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyeU5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0cnlOZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdHJ5TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4uYXBwbHkoYXJndW1lbnRzWzFdLCBbY3VycmVudFsxXSwgY3VycmVudFswXSwgdGhpc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdHJ5TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGl0ZXJhdG9yOntcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgJ2tleXMrdmFsdWVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvU3RyaW5nOntcbiAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW09iamVjdCBNYXBdJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBub3RJbk5vZGUgPSBtb2R1bGUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIHdpbmRvdyA9IG5vdEluTm9kZSA/IHRoaXMgOiBnbG9iYWw7XG4gICAgdmFyIG1vZHVsZSA9IG5vdEluTm9kZSA/IHt9IDogZXhwb3J0cztcbiAgICB2YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcblxuICAgIE1hcC5wcm90b3R5cGUgPSBNYXBQcm90b3R5cGUgPSBNYXAoKTtcblxuICAgIHdpbmRvdy5NYXAgPSBtb2R1bGUuTWFwID0gd2luZG93Lk1hcCB8fCBNYXA7XG59LmNhbGwodGhpcywgdHlwZW9mIGV4cG9ydHMpKTtcbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDE0IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDE1IEluZ3ZhciBTdGVwYW55YW4gPG1lQHJyZXZlcnNlci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxNCBJdmFuIE5pa3VsaW4gPGlmYWFhbkBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1pY2hhZWwgRmljYXJyYSA8ZXNjb2RlZ2VuLmNvcHlyaWdodEBtaWNoYWVsLmZpY2FycmEubWU+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMyBJcmFrbGkgR296YWxpc2h2aWxpIDxyZm9iaWNAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgUm9iZXJ0IEd1c3QtQmFyZG9uIDxkb25hdGVAcm9iZXJ0Lmd1c3QtYmFyZG9uLm9yZz5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvaG4gRnJlZW1hbiA8amZyZWVtYW4wOEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMS0yMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgcmVxdWlyZTp0cnVlLCBnbG9iYWw6dHJ1ZSovXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTeW50YXgsXG4gICAgICAgIFByZWNlZGVuY2UsXG4gICAgICAgIEJpbmFyeVByZWNlZGVuY2UsXG4gICAgICAgIFNvdXJjZU5vZGUsXG4gICAgICAgIGVzdHJhdmVyc2UsXG4gICAgICAgIGVzdXRpbHMsXG4gICAgICAgIGlzQXJyYXksXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGluZGVudCxcbiAgICAgICAganNvbixcbiAgICAgICAgcmVudW1iZXIsXG4gICAgICAgIGhleGFkZWNpbWFsLFxuICAgICAgICBxdW90ZXMsXG4gICAgICAgIGVzY2FwZWxlc3MsXG4gICAgICAgIG5ld2xpbmUsXG4gICAgICAgIHNwYWNlLFxuICAgICAgICBwYXJlbnRoZXNlcyxcbiAgICAgICAgc2VtaWNvbG9ucyxcbiAgICAgICAgc2FmZUNvbmNhdGVuYXRpb24sXG4gICAgICAgIGRpcmVjdGl2ZSxcbiAgICAgICAgZXh0cmEsXG4gICAgICAgIHBhcnNlLFxuICAgICAgICBzb3VyY2VNYXAsXG4gICAgICAgIHNvdXJjZUNvZGUsXG4gICAgICAgIHByZXNlcnZlQmxhbmtMaW5lcyxcbiAgICAgICAgRk9STUFUX01JTklGWSxcbiAgICAgICAgRk9STUFUX0RFRkFVTFRTO1xuXG4gICAgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcbiAgICBlc3V0aWxzID0gcmVxdWlyZSgnZXN1dGlscycpO1xuXG4gICAgU3ludGF4ID0gZXN0cmF2ZXJzZS5TeW50YXg7XG5cbiAgICAvLyBHZW5lcmF0aW9uIGlzIGRvbmUgYnkgZ2VuZXJhdGVFeHByZXNzaW9uLlxuICAgIGZ1bmN0aW9uIGlzRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24uaGFzT3duUHJvcGVydHkobm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0aW9uIGlzIGRvbmUgYnkgZ2VuZXJhdGVTdGF0ZW1lbnQuXG4gICAgZnVuY3Rpb24gaXNTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gQ29kZUdlbmVyYXRvci5TdGF0ZW1lbnQuaGFzT3duUHJvcGVydHkobm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICBQcmVjZWRlbmNlID0ge1xuICAgICAgICBTZXF1ZW5jZTogMCxcbiAgICAgICAgWWllbGQ6IDEsXG4gICAgICAgIEF3YWl0OiAxLFxuICAgICAgICBBc3NpZ25tZW50OiAxLFxuICAgICAgICBDb25kaXRpb25hbDogMixcbiAgICAgICAgQXJyb3dGdW5jdGlvbjogMixcbiAgICAgICAgTG9naWNhbE9SOiAzLFxuICAgICAgICBMb2dpY2FsQU5EOiA0LFxuICAgICAgICBCaXR3aXNlT1I6IDUsXG4gICAgICAgIEJpdHdpc2VYT1I6IDYsXG4gICAgICAgIEJpdHdpc2VBTkQ6IDcsXG4gICAgICAgIEVxdWFsaXR5OiA4LFxuICAgICAgICBSZWxhdGlvbmFsOiA5LFxuICAgICAgICBCaXR3aXNlU0hJRlQ6IDEwLFxuICAgICAgICBBZGRpdGl2ZTogMTEsXG4gICAgICAgIE11bHRpcGxpY2F0aXZlOiAxMixcbiAgICAgICAgVW5hcnk6IDEzLFxuICAgICAgICBQb3N0Zml4OiAxNCxcbiAgICAgICAgQ2FsbDogMTUsXG4gICAgICAgIE5ldzogMTYsXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlOiAxNyxcbiAgICAgICAgTWVtYmVyOiAxOCxcbiAgICAgICAgUHJpbWFyeTogMTlcbiAgICB9O1xuXG4gICAgQmluYXJ5UHJlY2VkZW5jZSA9IHtcbiAgICAgICAgJ3x8JzogUHJlY2VkZW5jZS5Mb2dpY2FsT1IsXG4gICAgICAgICcmJic6IFByZWNlZGVuY2UuTG9naWNhbEFORCxcbiAgICAgICAgJ3wnOiBQcmVjZWRlbmNlLkJpdHdpc2VPUixcbiAgICAgICAgJ14nOiBQcmVjZWRlbmNlLkJpdHdpc2VYT1IsXG4gICAgICAgICcmJzogUHJlY2VkZW5jZS5CaXR3aXNlQU5ELFxuICAgICAgICAnPT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnIT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnPT09JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJyE9PSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICdpcyc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICdpc250JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJzwnOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc+JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPD0nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc+PSc6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJ2luJzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnaW5zdGFuY2VvZic6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJzw8JzogUHJlY2VkZW5jZS5CaXR3aXNlU0hJRlQsXG4gICAgICAgICc+Pic6IFByZWNlZGVuY2UuQml0d2lzZVNISUZULFxuICAgICAgICAnPj4+JzogUHJlY2VkZW5jZS5CaXR3aXNlU0hJRlQsXG4gICAgICAgICcrJzogUHJlY2VkZW5jZS5BZGRpdGl2ZSxcbiAgICAgICAgJy0nOiBQcmVjZWRlbmNlLkFkZGl0aXZlLFxuICAgICAgICAnKic6IFByZWNlZGVuY2UuTXVsdGlwbGljYXRpdmUsXG4gICAgICAgICclJzogUHJlY2VkZW5jZS5NdWx0aXBsaWNhdGl2ZSxcbiAgICAgICAgJy8nOiBQcmVjZWRlbmNlLk11bHRpcGxpY2F0aXZlXG4gICAgfTtcblxuICAgIC8vRmxhZ3NcbiAgICB2YXIgRl9BTExPV19JTiA9IDEsXG4gICAgICAgIEZfQUxMT1dfQ0FMTCA9IDEgPDwgMSxcbiAgICAgICAgRl9BTExPV19VTlBBUkFUSF9ORVcgPSAxIDw8IDIsXG4gICAgICAgIEZfRlVOQ19CT0RZID0gMSA8PCAzLFxuICAgICAgICBGX0RJUkVDVElWRV9DVFggPSAxIDw8IDQsXG4gICAgICAgIEZfU0VNSUNPTE9OX09QVCA9IDEgPDwgNTtcblxuICAgIC8vRXhwcmVzc2lvbiBmbGFnIHNldHNcbiAgICAvL05PVEU6IEZsYWcgb3JkZXI6XG4gICAgLy8gRl9BTExPV19JTlxuICAgIC8vIEZfQUxMT1dfQ0FMTFxuICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXXG4gICAgdmFyIEVfRlRUID0gRl9BTExPV19DQUxMIHwgRl9BTExPV19VTlBBUkFUSF9ORVcsXG4gICAgICAgIEVfVFRGID0gRl9BTExPV19JTiB8IEZfQUxMT1dfQ0FMTCxcbiAgICAgICAgRV9UVFQgPSBGX0FMTE9XX0lOIHwgRl9BTExPV19DQUxMIHwgRl9BTExPV19VTlBBUkFUSF9ORVcsXG4gICAgICAgIEVfVEZGID0gRl9BTExPV19JTixcbiAgICAgICAgRV9GRlQgPSBGX0FMTE9XX1VOUEFSQVRIX05FVyxcbiAgICAgICAgRV9URlQgPSBGX0FMTE9XX0lOIHwgRl9BTExPV19VTlBBUkFUSF9ORVc7XG5cbiAgICAvL1N0YXRlbWVudCBmbGFnIHNldHNcbiAgICAvL05PVEU6IEZsYWcgb3JkZXI6XG4gICAgLy8gRl9BTExPV19JTlxuICAgIC8vIEZfRlVOQ19CT0RZXG4gICAgLy8gRl9ESVJFQ1RJVkVfQ1RYXG4gICAgLy8gRl9TRU1JQ09MT05fT1BUXG4gICAgdmFyIFNfVEZGRiA9IEZfQUxMT1dfSU4sXG4gICAgICAgIFNfVEZGVCA9IEZfQUxMT1dfSU4gfCBGX1NFTUlDT0xPTl9PUFQsXG4gICAgICAgIFNfRkZGRiA9IDB4MDAsXG4gICAgICAgIFNfVEZURiA9IEZfQUxMT1dfSU4gfCBGX0RJUkVDVElWRV9DVFgsXG4gICAgICAgIFNfVFRGRiA9IEZfQUxMT1dfSU4gfCBGX0ZVTkNfQk9EWTtcblxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHRPcHRpb25zKCkge1xuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGVudDogbnVsbCxcbiAgICAgICAgICAgIGJhc2U6IG51bGwsXG4gICAgICAgICAgICBwYXJzZTogbnVsbCxcbiAgICAgICAgICAgIGNvbW1lbnQ6IGZhbHNlLFxuICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgaW5kZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnICAgICcsXG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IDAsXG4gICAgICAgICAgICAgICAgICAgIGFkanVzdE11bHRpbGluZUNvbW1lbnQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXdsaW5lOiAnXFxuJyxcbiAgICAgICAgICAgICAgICBzcGFjZTogJyAnLFxuICAgICAgICAgICAgICAgIGpzb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbnVtYmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBoZXhhZGVjaW1hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVvdGVzOiAnc2luZ2xlJyxcbiAgICAgICAgICAgICAgICBlc2NhcGVsZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb21wYWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRoZXNlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW1pY29sb25zOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNhZmVDb25jYXRlbmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUJsYW5rTGluZXM6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW96OiB7XG4gICAgICAgICAgICAgICAgY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3Rhcmxlc3NHZW5lcmF0b3I6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc291cmNlTWFwOiBudWxsLFxuICAgICAgICAgICAgc291cmNlTWFwUm9vdDogbnVsbCxcbiAgICAgICAgICAgIHNvdXJjZU1hcFdpdGhDb2RlOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICByYXc6IHRydWUsXG4gICAgICAgICAgICB2ZXJiYXRpbTogbnVsbCxcbiAgICAgICAgICAgIHNvdXJjZUNvZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdSZXBlYXQoc3RyLCBudW0pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIGZvciAobnVtIHw9IDA7IG51bSA+IDA7IG51bSA+Pj49IDEsIHN0ciArPSBzdHIpIHtcbiAgICAgICAgICAgIGlmIChudW0gJiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNMaW5lVGVybWluYXRvcihzdHIpIHtcbiAgICAgICAgcmV0dXJuICgvW1xcclxcbl0vZykudGVzdChzdHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZHNXaXRoTGluZVRlcm1pbmF0b3Ioc3RyKSB7XG4gICAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuICYmIGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKHN0ci5jaGFyQ29kZUF0KGxlbiAtIDEpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIG92ZXJyaWRlKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gb3ZlcnJpZGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURlZXBseSh0YXJnZXQsIG92ZXJyaWRlKSB7XG4gICAgICAgIHZhciBrZXksIHZhbDtcblxuICAgICAgICBmdW5jdGlvbiBpc0hhc2hPYmplY3QodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0ICYmICEodGFyZ2V0IGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IG92ZXJyaWRlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGlzSGFzaE9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hhc2hPYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVEZWVwbHkodGFyZ2V0W2tleV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHVwZGF0ZURlZXBseSh7fSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHBvaW50LCB0ZW1wLCBleHBvbmVudCwgcG9zO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtZXJpYyBsaXRlcmFsIHdob3NlIHZhbHVlIGlzIE5hTicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWVyaWMgbGl0ZXJhbCB3aG9zZSB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAxIC8gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24gPyAnbnVsbCcgOiByZW51bWJlciA/ICcxZTQwMCcgOiAnMWUrNDAwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9ICcnICsgdmFsdWU7XG4gICAgICAgIGlmICghcmVudW1iZXIgfHwgcmVzdWx0Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBwb2ludCA9IHJlc3VsdC5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmICghanNvbiAmJiByZXN1bHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzMCAgLyogMCAqLyAmJiBwb2ludCA9PT0gMSkge1xuICAgICAgICAgICAgcG9pbnQgPSAwO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXAgPSByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKCdlKycsICdlJyk7XG4gICAgICAgIGV4cG9uZW50ID0gMDtcbiAgICAgICAgaWYgKChwb3MgPSB0ZW1wLmluZGV4T2YoJ2UnKSkgPiAwKSB7XG4gICAgICAgICAgICBleHBvbmVudCA9ICt0ZW1wLnNsaWNlKHBvcyArIDEpO1xuICAgICAgICAgICAgdGVtcCA9IHRlbXAuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnQgPj0gMCkge1xuICAgICAgICAgICAgZXhwb25lbnQgLT0gdGVtcC5sZW5ndGggLSBwb2ludCAtIDE7XG4gICAgICAgICAgICB0ZW1wID0gKyh0ZW1wLnNsaWNlKDAsIHBvaW50KSArIHRlbXAuc2xpY2UocG9pbnQgKyAxKSkgKyAnJztcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSAwO1xuICAgICAgICB3aGlsZSAodGVtcC5jaGFyQ29kZUF0KHRlbXAubGVuZ3RoICsgcG9zIC0gMSkgPT09IDB4MzAgIC8qIDAgKi8pIHtcbiAgICAgICAgICAgIC0tcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgIT09IDApIHtcbiAgICAgICAgICAgIGV4cG9uZW50IC09IHBvcztcbiAgICAgICAgICAgIHRlbXAgPSB0ZW1wLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9uZW50ICE9PSAwKSB7XG4gICAgICAgICAgICB0ZW1wICs9ICdlJyArIGV4cG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGVtcC5sZW5ndGggPCByZXN1bHQubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIChoZXhhZGVjaW1hbCAmJiB2YWx1ZSA+IDFlMTIgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlICYmICh0ZW1wID0gJzB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KSkubGVuZ3RoIDwgcmVzdWx0Lmxlbmd0aCkpICYmXG4gICAgICAgICAgICAgICAgK3RlbXAgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSB2YWxpZCBSZWdFeHAgZXhwcmVzc2lvbi5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2l2IEVuZ2luZVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcmFjdGVyKGNoLCBwcmV2aW91c0lzQmFja3NsYXNoKSB7XG4gICAgICAgIC8vIG5vdCBoYW5kbGluZyAnXFwnIGFuZCBoYW5kbGluZyBcXHUyMDI4IG9yIFxcdTIwMjkgdG8gdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKChjaCAmIH4xKSA9PT0gMHgyMDI4KSB7XG4gICAgICAgICAgICByZXR1cm4gKHByZXZpb3VzSXNCYWNrc2xhc2ggPyAndScgOiAnXFxcXHUnKSArICgoY2ggPT09IDB4MjAyOCkgPyAnMjAyOCcgOiAnMjAyOScpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gMTMpIHsgIC8vIFxcbiwgXFxyXG4gICAgICAgICAgICByZXR1cm4gKHByZXZpb3VzSXNCYWNrc2xhc2ggPyAnJyA6ICdcXFxcJykgKyAoKGNoID09PSAxMCkgPyAnbicgOiAncicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVJlZ0V4cChyZWcpIHtcbiAgICAgICAgdmFyIG1hdGNoLCByZXN1bHQsIGZsYWdzLCBpLCBpeiwgY2gsIGNoYXJhY3RlckluQnJhY2ssIHByZXZpb3VzSXNCYWNrc2xhc2g7XG5cbiAgICAgICAgcmVzdWx0ID0gcmVnLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHJlZy5zb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIGV4dHJhY3QgZmxhZyBmcm9tIHRvU3RyaW5nIHJlc3VsdFxuICAgICAgICAgICAgbWF0Y2ggPSByZXN1bHQubWF0Y2goL1xcLyhbXi9dKikkLyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxhZ3MgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgICAgICBjaGFyYWN0ZXJJbkJyYWNrID0gZmFsc2U7XG4gICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHJlZy5zb3VyY2UubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIGNoID0gcmVnLnNvdXJjZS5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c0lzQmFja3NsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJJbkJyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDkzKSB7ICAvLyBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVySW5CcmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0NykgeyAgLy8gL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSA5MSkgeyAgLy8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckluQnJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVSZWdFeHBDaGFyYWN0ZXIoY2gsIHByZXZpb3VzSXNCYWNrc2xhc2gpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gY2ggPT09IDkyOyAgLy8gXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBuZXcgUmVnRXhwKFwiXFxcXFxcbicpIGlzIHByb3ZpZGVkLCBjcmVhdGUgL1xcbi9cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcihjaCwgcHJldmlvdXNJc0JhY2tzbGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbGlrZSAvXFxcXFsvXS9cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNJc0JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICcvJyArIHJlc3VsdCArICcvJyArIGZsYWdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVBbGxvd2VkQ2hhcmFjdGVyKGNvZGUsIG5leHQpIHtcbiAgICAgICAgdmFyIGhleDtcblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwOCAgLyogXFxiICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxiJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDBDICAvKiBcXGYgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MDkgIC8qIFxcdCAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdCc7XG4gICAgICAgIH1cblxuICAgICAgICBoZXggPSBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoanNvbiB8fCBjb2RlID4gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgKyAnMDAwMCcuc2xpY2UoaGV4Lmxlbmd0aCkgKyBoZXg7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDAwICYmICFlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQobmV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXDAnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAwQiAgLyogXFx2ICovKSB7IC8vICdcXHYnXG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx4MEInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxceCcgKyAnMDAnLnNsaWNlKGhleC5sZW5ndGgpICsgaGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlRGlzYWxsb3dlZENoYXJhY3Rlcihjb2RlKSB7XG4gICAgICAgIGlmIChjb2RlID09PSAweDVDICAvKiBcXCAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcXFxcXCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwQSAgLyogXFxuICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDBEICAvKiBcXHIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHInO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MjAyOCkge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTIwMjgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MjAyOSkge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTIwMjknO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3RseSBjbGFzc2lmaWVkIGNoYXJhY3RlcicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZURpcmVjdGl2ZShzdHIpIHtcbiAgICAgICAgdmFyIGksIGl6LCBjb2RlLCBxdW90ZTtcblxuICAgICAgICBxdW90ZSA9IHF1b3RlcyA9PT0gJ2RvdWJsZScgPyAnXCInIDogJ1xcJyc7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RyLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSAweDI3ICAvKiAnICovKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnXCInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICAvKiBcIiAqLykge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJ1xcJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NUMgIC8qIFxcICovKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1b3RlICsgc3RyICsgcXVvdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsIGksIGxlbiwgY29kZSwgc2luZ2xlUXVvdGVzID0gMCwgZG91YmxlUXVvdGVzID0gMCwgc2luZ2xlLCBxdW90ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSAweDI3ICAvKiAnICovKSB7XG4gICAgICAgICAgICAgICAgKytzaW5nbGVRdW90ZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgIC8qIFwiICovKSB7XG4gICAgICAgICAgICAgICAgKytkb3VibGVRdW90ZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MkYgIC8qIC8gKi8gJiYganNvbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNvZGUpIHx8IGNvZGUgPT09IDB4NUMgIC8qIFxcICovKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZURpc2FsbG93ZWRDaGFyYWN0ZXIoY29kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChqc29uICYmIGNvZGUgPCAweDIwICAvKiBTUCAqLykgfHwgIShqc29uIHx8IGVzY2FwZWxlc3MgfHwgKGNvZGUgPj0gMHgyMCAgLyogU1AgKi8gJiYgY29kZSA8PSAweDdFICAvKiB+ICovKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlQWxsb3dlZENoYXJhY3Rlcihjb2RlLCBzdHIuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzaW5nbGUgPSAhKHF1b3RlcyA9PT0gJ2RvdWJsZScgfHwgKHF1b3RlcyA9PT0gJ2F1dG8nICYmIGRvdWJsZVF1b3RlcyA8IHNpbmdsZVF1b3RlcykpO1xuICAgICAgICBxdW90ZSA9IHNpbmdsZSA/ICdcXCcnIDogJ1wiJztcblxuICAgICAgICBpZiAoIShzaW5nbGUgPyBzaW5nbGVRdW90ZXMgOiBkb3VibGVRdW90ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUgKyByZXN1bHQgKyBxdW90ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gcXVvdGU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoKGNvZGUgPT09IDB4MjcgIC8qICcgKi8gJiYgc2luZ2xlKSB8fCAoY29kZSA9PT0gMHgyMiAgLyogXCIgKi8gJiYgIXNpbmdsZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgcXVvdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmxhdHRlbiBhbiBhcnJheSB0byBhIHN0cmluZywgd2hlcmUgdGhlIGFycmF5IGNhbiBjb250YWluXG4gICAgICogZWl0aGVyIHN0cmluZ3Mgb3IgbmVzdGVkIGFycmF5c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5Ub1N0cmluZyhhcnIpIHtcbiAgICAgICAgdmFyIGksIGl6LCBlbGVtLCByZXN1bHQgPSAnJztcbiAgICAgICAgZm9yIChpID0gMCwgaXogPSBhcnIubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgZWxlbSA9IGFycltpXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBpc0FycmF5KGVsZW0pID8gZmxhdHRlblRvU3RyaW5nKGVsZW0pIDogZWxlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgZ2VuZXJhdGVkIHRvIGEgU291cmNlTm9kZSB3aGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZ2VuZXJhdGVkLCBub2RlKSB7XG4gICAgICAgIGlmICghc291cmNlTWFwKSB7XG4gICAgICAgICAgICAvLyB3aXRoIG5vIHNvdXJjZSBtYXBzLCBnZW5lcmF0ZWQgaXMgZWl0aGVyIGFuXG4gICAgICAgICAgICAvLyBhcnJheSBvciBhIHN0cmluZy4gIGlmIGFuIGFycmF5LCBmbGF0dGVuIGl0LlxuICAgICAgICAgICAgLy8gaWYgYSBzdHJpbmcsIGp1c3QgcmV0dXJuIGl0XG4gICAgICAgICAgICBpZiAoaXNBcnJheShnZW5lcmF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5Ub1N0cmluZyhnZW5lcmF0ZWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWQgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmxvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUobnVsbCwgbnVsbCwgc291cmNlTWFwLCBnZW5lcmF0ZWQsIG5vZGUubmFtZSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUobm9kZS5sb2Muc3RhcnQubGluZSwgbm9kZS5sb2Muc3RhcnQuY29sdW1uLCAoc291cmNlTWFwID09PSB0cnVlID8gbm9kZS5sb2Muc291cmNlIHx8IG51bGwgOiBzb3VyY2VNYXApLCBnZW5lcmF0ZWQsIG5vZGUubmFtZSB8fCBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub0VtcHR5U3BhY2UoKSB7XG4gICAgICAgIHJldHVybiAoc3BhY2UpID8gc3BhY2UgOiAnICc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gam9pbihsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgbGVmdFNvdXJjZSxcbiAgICAgICAgICAgIHJpZ2h0U291cmNlLFxuICAgICAgICAgICAgbGVmdENoYXJDb2RlLFxuICAgICAgICAgICAgcmlnaHRDaGFyQ29kZTtcblxuICAgICAgICBsZWZ0U291cmNlID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChsZWZ0KS50b1N0cmluZygpO1xuICAgICAgICBpZiAobGVmdFNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbcmlnaHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmlnaHRTb3VyY2UgPSB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJpZ2h0KS50b1N0cmluZygpO1xuICAgICAgICBpZiAocmlnaHRTb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xlZnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVmdENoYXJDb2RlID0gbGVmdFNvdXJjZS5jaGFyQ29kZUF0KGxlZnRTb3VyY2UubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJpZ2h0Q2hhckNvZGUgPSByaWdodFNvdXJjZS5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIGlmICgobGVmdENoYXJDb2RlID09PSAweDJCICAvKiArICovIHx8IGxlZnRDaGFyQ29kZSA9PT0gMHgyRCAgLyogLSAqLykgJiYgbGVmdENoYXJDb2RlID09PSByaWdodENoYXJDb2RlIHx8XG4gICAgICAgICAgICBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydChsZWZ0Q2hhckNvZGUpICYmIGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0KHJpZ2h0Q2hhckNvZGUpIHx8XG4gICAgICAgICAgICBsZWZ0Q2hhckNvZGUgPT09IDB4MkYgIC8qIC8gKi8gJiYgcmlnaHRDaGFyQ29kZSA9PT0gMHg2OSAgLyogaSAqLykgeyAvLyBpbmZpeCB3b3JkIG9wZXJhdG9ycyBhbGwgc3RhcnQgd2l0aCBgaWBcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgbm9FbXB0eVNwYWNlKCksIHJpZ2h0XTtcbiAgICAgICAgfSBlbHNlIGlmIChlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGxlZnRDaGFyQ29kZSkgfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IobGVmdENoYXJDb2RlKSB8fFxuICAgICAgICAgICAgICAgIGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UocmlnaHRDaGFyQ29kZSkgfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IocmlnaHRDaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbGVmdCwgc3BhY2UsIHJpZ2h0XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRJbmRlbnQoc3RtdCkge1xuICAgICAgICByZXR1cm4gW2Jhc2UsIHN0bXRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhJbmRlbnQoZm4pIHtcbiAgICAgICAgdmFyIHByZXZpb3VzQmFzZTtcbiAgICAgICAgcHJldmlvdXNCYXNlID0gYmFzZTtcbiAgICAgICAgYmFzZSArPSBpbmRlbnQ7XG4gICAgICAgIGZuKGJhc2UpO1xuICAgICAgICBiYXNlID0gcHJldmlvdXNCYXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNlcyhzdHIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYgKGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKHN0ci5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc3RyLmxlbmd0aCAtIDEpIC0gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RNdWx0aWxpbmVDb21tZW50KHZhbHVlLCBzcGVjaWFsQmFzZSkge1xuICAgICAgICB2YXIgYXJyYXksIGksIGxlbiwgbGluZSwgaiwgc3BhY2VzLCBwcmV2aW91c0Jhc2UsIHNuO1xuXG4gICAgICAgIGFycmF5ID0gdmFsdWUuc3BsaXQoL1xcclxcbnxbXFxyXFxuXS8pO1xuICAgICAgICBzcGFjZXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAgIC8vIGZpcnN0IGxpbmUgZG9lc24ndCBoYXZlIGluZGVudGF0aW9uXG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBsaW5lID0gYXJyYXlbaV07XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgbGluZS5sZW5ndGggJiYgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShsaW5lLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwYWNlcyA+IGopIHtcbiAgICAgICAgICAgICAgICBzcGFjZXMgPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjaWFsQmFzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIHBhdHRlcm4gbGlrZVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICB2YXIgdCA9IDIwOyAgLypcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAqIHRoaXMgaXMgY29tbWVudFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICAgICAgaWYgKGFycmF5WzFdW3NwYWNlc10gPT09ICcqJykge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxCYXNlICs9ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2UgPSBzcGVjaWFsQmFzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcGFjZXMgJiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gLypcbiAgICAgICAgICAgICAgICAvLyAgKlxuICAgICAgICAgICAgICAgIC8vICAqL1xuICAgICAgICAgICAgICAgIC8vIElmIHNwYWNlcyBhcmUgb2RkIG51bWJlciwgYWJvdmUgcGF0dGVybiBpcyBjb25zaWRlcmVkLlxuICAgICAgICAgICAgICAgIC8vIFdlIHdhc3RlIDEgc3BhY2UuXG4gICAgICAgICAgICAgICAgLS1zcGFjZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91c0Jhc2UgPSBiYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHNuID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChhZGRJbmRlbnQoYXJyYXlbaV0uc2xpY2Uoc3BhY2VzKSkpO1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBzb3VyY2VNYXAgPyBzbi5qb2luKCcnKSA6IHNuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFzZSA9IHByZXZpb3VzQmFzZTtcblxuICAgICAgICByZXR1cm4gYXJyYXkuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQsIHNwZWNpYWxCYXNlKSB7XG4gICAgICAgIGlmIChjb21tZW50LnR5cGUgPT09ICdMaW5lJykge1xuICAgICAgICAgICAgaWYgKGVuZHNXaXRoTGluZVRlcm1pbmF0b3IoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJy8vJyArIGNvbW1lbnQudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1c2UgTGluZVRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gJy8vJyArIGNvbW1lbnQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYS5mb3JtYXQuaW5kZW50LmFkanVzdE11bHRpbGluZUNvbW1lbnQgJiYgL1tcXG5cXHJdLy50ZXN0KGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRqdXN0TXVsdGlsaW5lQ29tbWVudCgnLyonICsgY29tbWVudC52YWx1ZSArICcqLycsIHNwZWNpYWxCYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy8qJyArIGNvbW1lbnQudmFsdWUgKyAnKi8nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENvbW1lbnRzKHN0bXQsIHJlc3VsdCkge1xuICAgICAgICB2YXIgaSwgbGVuLCBjb21tZW50LCBzYXZlLCB0YWlsaW5nVG9TdGF0ZW1lbnQsIHNwZWNpYWxCYXNlLCBmcmFnbWVudCxcbiAgICAgICAgICAgIGV4dFJhbmdlLCByYW5nZSwgcHJldlJhbmdlLCBwcmVmaXgsIGluZml4LCBzdWZmaXgsIGNvdW50O1xuXG4gICAgICAgIGlmIChzdG10LmxlYWRpbmdDb21tZW50cyAmJiBzdG10LmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzYXZlID0gcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZXh0UmFuZ2UgPSBjb21tZW50LmV4dGVuZGVkUmFuZ2U7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21tZW50LnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc291cmNlQ29kZS5zdWJzdHJpbmcoZXh0UmFuZ2VbMF0sIHJhbmdlWzBdKTtcbiAgICAgICAgICAgICAgICBjb3VudCA9IChwcmVmaXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyaW5nUmVwZWF0KCdcXG4nLCBjb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmV2UmFuZ2UgPSByYW5nZTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHN0bXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LmxlYWRpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21tZW50LnJhbmdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGluZml4ID0gc291cmNlQ29kZS5zdWJzdHJpbmcocHJldlJhbmdlWzFdLCByYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gKGluZml4Lm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyaW5nUmVwZWF0KCdcXG4nLCBjb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJldlJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3VmZml4ID0gc291cmNlQ29kZS5zdWJzdHJpbmcocmFuZ2VbMV0sIGV4dFJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICBjb3VudCA9IChzdWZmaXgubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0cmluZ1JlcGVhdCgnXFxuJywgY291bnQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChzYWZlQ29uY2F0ZW5hdGlvbiAmJiBzdG10LnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtICYmIHN0bXQuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpO1xuICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJ1xcbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHN0bXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LmxlYWRpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoZnJhZ21lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChzYXZlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RtdC50cmFpbGluZ0NvbW1lbnRzKSB7XG5cbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC50cmFpbGluZ0NvbW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGV4dFJhbmdlID0gY29tbWVudC5leHRlbmRlZFJhbmdlO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tbWVudC5yYW5nZTtcblxuICAgICAgICAgICAgICAgIHByZWZpeCA9IHNvdXJjZUNvZGUuc3Vic3RyaW5nKGV4dFJhbmdlWzBdLCByYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgY291bnQgPSAocHJlZml4Lm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RyaW5nUmVwZWF0KCdcXG4nLCBjb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhaWxpbmdUb1N0YXRlbWVudCA9ICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBzcGVjaWFsQmFzZSA9IHN0cmluZ1JlcGVhdCgnICcsIGNhbGN1bGF0ZVNwYWNlcyh0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKFtiYXNlLCByZXN1bHQsIGluZGVudF0pLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdG10LnRyYWlsaW5nQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQudHJhaWxpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhaWxpbmdUb1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRhcmdldCBsaWtlIGZvbGxvd2luZyBzY3JpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXIgdCA9IDIwOyAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICogVGhpcyBpcyBjb21tZW50IG9mIHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIGluZGVudF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIHNwZWNpYWxCYXNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlQ29tbWVudChjb21tZW50LCBzcGVjaWFsQmFzZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgYWRkSW5kZW50KGdlbmVyYXRlQ29tbWVudChjb21tZW50KSldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBsZW4gLSAxICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgJ1xcbiddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUJsYW5rTGluZXMoc3RhcnQsIGVuZCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBqLCBuZXdsaW5lQ291bnQgPSAwO1xuXG4gICAgICAgIGZvciAoaiA9IHN0YXJ0OyBqIDwgZW5kOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VDb2RlW2pdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIG5ld2xpbmVDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMTsgaiA8IG5ld2xpbmVDb3VudDsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcmVudGhlc2l6ZSh0ZXh0LCBjdXJyZW50LCBzaG91bGQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBzaG91bGQpIHtcbiAgICAgICAgICAgIHJldHVybiBbJygnLCB0ZXh0LCAnKSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlVmVyYmF0aW1TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHZhciBpLCBpeiwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcuc3BsaXQoL1xcclxcbnxcXG4vKTtcbiAgICAgICAgZm9yIChpID0gMSwgaXogPSByZXN1bHQubGVuZ3RoOyBpIDwgaXo7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gbmV3bGluZSArIGJhc2UgKyByZXN1bHRbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVZlcmJhdGltKGV4cHIsIHByZWNlZGVuY2UpIHtcbiAgICAgICAgdmFyIHZlcmJhdGltLCByZXN1bHQsIHByZWM7XG4gICAgICAgIHZlcmJhdGltID0gZXhwcltleHRyYS52ZXJiYXRpbV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2ZXJiYXRpbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShnZW5lcmF0ZVZlcmJhdGltU3RyaW5nKHZlcmJhdGltKSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB2ZXJiYXRpbSBpcyBvYmplY3RcbiAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlVmVyYmF0aW1TdHJpbmcodmVyYmF0aW0uY29udGVudCk7XG4gICAgICAgICAgICBwcmVjID0gKHZlcmJhdGltLnByZWNlZGVuY2UgIT0gbnVsbCkgPyB2ZXJiYXRpbS5wcmVjZWRlbmNlIDogUHJlY2VkZW5jZS5TZXF1ZW5jZTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShyZXN1bHQsIHByZWMsIHByZWNlZGVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0LCBleHByKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb2RlR2VuZXJhdG9yKCkge1xuICAgIH1cblxuICAgIC8vIEhlbHBlcnMuXG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5tYXliZUJsb2NrID0gZnVuY3Rpb24oc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgbm9MZWFkaW5nQ29tbWVudCwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgbm9MZWFkaW5nQ29tbWVudCA9ICFleHRyYS5jb21tZW50IHx8ICFzdG10LmxlYWRpbmdDb21tZW50cztcblxuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQgJiYgbm9MZWFkaW5nQ29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzcGFjZSwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LCBmbGFncyldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0bXQudHlwZSA9PT0gU3ludGF4LkVtcHR5U3RhdGVtZW50ICYmIG5vTGVhZGluZ0NvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAnOyc7XG4gICAgICAgIH1cblxuICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICBuZXdsaW5lLFxuICAgICAgICAgICAgICAgIGFkZEluZGVudCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQsIGZsYWdzKSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLm1heWJlQmxvY2tTdWZmaXggPSBmdW5jdGlvbiAoc3RtdCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBlbmRzID0gZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiAoIWV4dHJhLmNvbW1lbnQgfHwgIXN0bXQubGVhZGluZ0NvbW1lbnRzKSAmJiAhZW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHQsIHNwYWNlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kcykge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXN1bHQsIGJhc2VdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmVzdWx0LCBuZXdsaW5lLCBiYXNlXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZVdoZW5OZWVkZWQobm9kZS5uYW1lLCBub2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUFzeW5jUHJlZml4KG5vZGUsIHNwYWNlUmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuYXN5bmMgPyAnYXN5bmMnICsgKHNwYWNlUmVxdWlyZWQgPyBub0VtcHR5U3BhY2UoKSA6IHNwYWNlKSA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3RhclN1ZmZpeChub2RlKSB7XG4gICAgICAgIHZhciBpc0dlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yICYmICFleHRyYS5tb3ouc3Rhcmxlc3NHZW5lcmF0b3I7XG4gICAgICAgIHJldHVybiBpc0dlbmVyYXRvciA/ICcqJyArIHNwYWNlIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVNZXRob2RQcmVmaXgocHJvcCkge1xuICAgICAgICB2YXIgZnVuYyA9IHByb3AudmFsdWU7XG4gICAgICAgIGlmIChmdW5jLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVBc3luY1ByZWZpeChmdW5jLCAhcHJvcC5jb21wdXRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBzcGFjZSBiZWZvcmUgbWV0aG9kIG5hbWVcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVN0YXJTdWZmaXgoZnVuYykgPyAnKicgOiAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlUGF0dGVybiA9IGZ1bmN0aW9uIChub2RlLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSWRlbnRpZmllcihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24obm9kZSwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQsIGhhc0RlZmF1bHQ7XG5cbiAgICAgICAgaGFzRGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiAmJlxuICAgICAgICAgICAgICAgICFub2RlLnJlc3QgJiYgKCFub2RlLmRlZmF1bHRzIHx8IG5vZGUuZGVmYXVsdHMubGVuZ3RoID09PSAwKSAmJlxuICAgICAgICAgICAgICAgIG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBub2RlLnBhcmFtc1swXS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgLy8gYXJnID0+IHsgfSBjYXNlXG4gICAgICAgICAgICByZXN1bHQgPSBbZ2VuZXJhdGVBc3luY1ByZWZpeChub2RlLCB0cnVlKSwgZ2VuZXJhdGVJZGVudGlmaWVyKG5vZGUucGFyYW1zWzBdKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA/IFtnZW5lcmF0ZUFzeW5jUHJlZml4KG5vZGUsIGZhbHNlKV0gOiBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcoJyk7XG4gICAgICAgICAgICBpZiAobm9kZS5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGhhc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBub2RlLnBhcmFtcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHQgJiYgbm9kZS5kZWZhdWx0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVBc3NpZ25tZW50KG5vZGUucGFyYW1zW2ldLCBub2RlLmRlZmF1bHRzW2ldLCAnPScsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlUGF0dGVybihub2RlLnBhcmFtc1tpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5yZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUlkZW50aWZpZXIobm9kZS5yZXN0KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciByZXN1bHQsIGV4cHI7XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJz0+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICBleHByID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24obm9kZS5ib2R5LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKTtcbiAgICAgICAgICAgIGlmIChleHByLnRvU3RyaW5nKCkuY2hhckF0KDApID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBleHByID0gWycoJywgZXhwciwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4cHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKG5vZGUuYm9keSwgU19UVEZGKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZUl0ZXJhdGlvbkZvclN0YXRlbWVudCA9IGZ1bmN0aW9uIChvcGVyYXRvciwgc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFsnZm9yJyArIHNwYWNlICsgJygnXSwgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHN0bXQubGVmdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdG10LmxlZnQua2luZCArIG5vRW1wdHlTcGFjZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmxlZnQuZGVjbGFyYXRpb25zWzBdLCBTX0ZGRkYpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5sZWZ0LCBQcmVjZWRlbmNlLkNhbGwsIEVfVFRUKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBvcGVyYXRvcik7XG4gICAgICAgICAgICByZXN1bHQgPSBbam9pbihcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5yaWdodCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpXG4gICAgICAgICAgICApLCAnKSddO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVQcm9wZXJ0eUtleSA9IGZ1bmN0aW9uIChleHByLCBjb21wdXRlZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnWycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwciwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnXScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVBc3NpZ25tZW50ID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBvcGVyYXRvciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKFByZWNlZGVuY2UuQXNzaWdubWVudCA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZfQUxMT1dfSU47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGxlZnQsIFByZWNlZGVuY2UuQ2FsbCwgZmxhZ3MpLFxuICAgICAgICAgICAgICAgIHNwYWNlICsgb3BlcmF0b3IgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihyaWdodCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBmbGFncylcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLnNlbWljb2xvbiA9IGZ1bmN0aW9uIChmbGFncykge1xuICAgICAgICBpZiAoIXNlbWljb2xvbnMgJiYgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzsnO1xuICAgIH07XG5cbiAgICAvLyBTdGF0ZW1lbnRzLlxuXG4gICAgQ29kZUdlbmVyYXRvci5TdGF0ZW1lbnQgPSB7XG5cbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJhbmdlLCBjb250ZW50LCByZXN1bHQgPSBbJ3snLCBuZXdsaW5lXSwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBmdW5jdGlvbnMgd2l0aG91dCBhbnkgY29kZVxuICAgICAgICAgICAgICAgIGlmIChzdG10LmJvZHkubGVuZ3RoID09PSAwICYmIHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHN0bXQucmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVsxXSAtIHJhbmdlWzBdID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHNvdXJjZUNvZGUuc3Vic3RyaW5nKHJhbmdlWzBdICsgMSwgcmFuZ2VbMV0gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50WzBdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsneyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaSwgaXosIGZyYWdtZW50LCBib2R5RmxhZ3M7XG4gICAgICAgICAgICAgICAgYm9keUZsYWdzID0gU19URkZGO1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIEZfRlVOQ19CT0RZKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX0RJUkVDVElWRV9DVFg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LmJvZHkubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGJlZm9yZSB0aGUgZmlyc3QgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5ib2R5WzBdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHN0bXQuYm9keVswXS5sZWFkaW5nQ29tbWVudHNbMF0uZXh0ZW5kZWRSYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHNvdXJjZUNvZGUuc3Vic3RyaW5nKHJhbmdlWzBdLCByYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50WzBdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gWyd7J107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQmxhbmtMaW5lcyhzdG10LnJhbmdlWzBdLCBzdG10LmJvZHlbMF0ucmFuZ2VbMF0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGJldHdlZW4gbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5W2kgLSAxXS50cmFpbGluZ0NvbW1lbnRzICAmJiAhc3RtdC5ib2R5W2ldLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5ib2R5W2kgLSAxXS5yYW5nZVsxXSwgc3RtdC5ib2R5W2ldLnJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5ib2R5W2ldLmxlYWRpbmdDb21tZW50cyAmJiBwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmJvZHlbaV0sIGJvZHlGbGFncyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGFkZEluZGVudCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYm9keVtpXSwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcyAmJiBpIDwgaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWRkIGEgbmV3IGxpbmUgaWYgdGhlcmUgYXJlIGxlYWRpbmcgY29tZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBuZXh0IHN0YXRlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5W2kgKyAxXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYWZ0ZXIgdGhlIGxhc3QgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5W2ldLnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpXS5yYW5nZVsxXSwgc3RtdC5yYW5nZVsxXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KCd9JykpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBCcmVha1N0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYnJlYWsgJyArIHN0bXQubGFiZWwubmFtZSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnYnJlYWsnICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjb250aW51ZSAnICsgc3RtdC5sYWJlbC5uYW1lICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdjb250aW51ZScgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2xhc3NCb2R5OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbICd7JywgbmV3bGluZV0sIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuYm9keS5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuYm9keVtpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ30nKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudDtcbiAgICAgICAgICAgIHJlc3VsdCAgPSBbJ2NsYXNzICcgKyBzdG10LmlkLm5hbWVdO1xuICAgICAgICAgICAgaWYgKHN0bXQuc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gam9pbignZXh0ZW5kcycsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3VwZXJDbGFzcywgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYm9keSwgU19URkZUKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmEucmF3ICYmIHN0bXQucmF3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0bXQucmF3ICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZURpcmVjdGl2ZShzdG10LmRpcmVjdGl2ZSkgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIGBkbyA0MiB3aGlsZSAoY29uZClgIGlzIFN5bnRheCBFcnJvci4gV2UgbmVlZCBzZW1pY29sb24uXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gam9pbignZG8nLCB0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAnd2hpbGUnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgJyknICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDYXRjaENsYXVzZTogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBndWFyZDtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ2NhdGNoJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnBhcmFtLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5ndWFyZCkge1xuICAgICAgICAgICAgICAgICAgICBndWFyZCA9IHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZ3VhcmQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZSgyLCAwLCAnIGlmICcsIGd1YXJkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RlYnVnZ2VyJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBFbXB0eVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJzsnO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbICdleHBvcnQnIF0sIGJvZHlGbGFncywgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGJvZHlGbGFncyA9IChmbGFncyAmIEZfU0VNSUNPTE9OX09QVCkgPyBTX1RGRlQgOiBTX1RGRkY7XG5cbiAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IEhvaXN0YWJsZURlY2xhcmF0aW9uW0RlZmF1bHRdXG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBBc3NpZ25tZW50RXhwcmVzc2lvbltJbl0gO1xuICAgICAgICAgICAgaWYgKHN0bXRbJ2RlZmF1bHQnXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAnZGVmYXVsdCcpO1xuICAgICAgICAgICAgICAgIGlmIChpc1N0YXRlbWVudChzdG10LmRlY2xhcmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmRlY2xhcmF0aW9uLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5kZWNsYXJhdGlvbiwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkgKyB0aGlzLnNlbWljb2xvbihmbGFncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBleHBvcnQgVmFyaWFibGVTdGF0ZW1lbnRcbiAgICAgICAgICAgIC8vIGV4cG9ydCBEZWNsYXJhdGlvbltEZWZhdWx0XVxuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5kZWNsYXJhdGlvbiwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV4cG9ydCAqIEZyb21DbGF1c2UgO1xuICAgICAgICAgICAgLy8gZXhwb3J0IEV4cG9ydENsYXVzZVtOb1JlZmVyZW5jZV0gRnJvbUNsYXVzZSA7XG4gICAgICAgICAgICAvLyBleHBvcnQgRXhwb3J0Q2xhdXNlIDtcbiAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgJ3snICsgc3BhY2UgKyAnfScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RtdC5zcGVjaWZpZXJzWzBdLnR5cGUgPT09IFN5bnRheC5FeHBvcnRCYXRjaFNwZWNpZmllcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzWzBdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAneycpO1xuICAgICAgICAgICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpejtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LnNwZWNpZmllcnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhc2UgKyAnfScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG10LnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Zyb20nICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb2R1bGVTcGVjaWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc291cmNlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zZW1pY29sb24oZmxhZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQ2xhc3NQcmVmaXhlZChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlO1xuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5zbGljZSgwLCA1KSAhPT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGUgPSBmcmFnbWVudC5jaGFyQ29kZUF0KDUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlID09PSAweDdCICAvKiAneycgKi8gfHwgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShjb2RlKSB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNGdW5jdGlvblByZWZpeGVkKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LnNsaWNlKDAsIDgpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29kZSA9IGZyYWdtZW50LmNoYXJDb2RlQXQoOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUgPT09IDB4MjggLyogJygnICovIHx8IGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoY29kZSkgfHwgY29kZSA9PT0gMHgyQSAgLyogJyonICovIHx8IGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNvZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0FzeW5jUHJlZml4ZWQoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSwgaSwgaXo7XG4gICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LnNsaWNlKDAsIDUpICE9PSAnYXN5bmMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGZyYWdtZW50LmNoYXJDb2RlQXQoNSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gNiwgaXogPSBmcmFnbWVudC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShmcmFnbWVudC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LnNsaWNlKGksIGkgKyA4KSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGUgPSBmcmFnbWVudC5jaGFyQ29kZUF0KGkgKyA4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZSA9PT0gMHgyOCAvKiAnKCcgKi8gfHwgZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShjb2RlKSB8fCBjb2RlID09PSAweDJBICAvKiAnKicgKi8gfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IoY29kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IFt0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmV4cHJlc3Npb24sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKV07XG4gICAgICAgICAgICAvLyAxMi40ICd7JywgJ2Z1bmN0aW9uJywgJ2NsYXNzJyBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHBvc2l0aW9uLlxuICAgICAgICAgICAgLy8gd3JhcCBleHByZXNzaW9uIHdpdGggcGFyZW50aGVzZXNcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQuY2hhckNvZGVBdCgwKSA9PT0gMHg3QiAgLyogJ3snICovIHx8ICAvLyBPYmplY3RFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIGlzQ2xhc3NQcmVmaXhlZChmcmFnbWVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvblByZWZpeGVkKGZyYWdtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICBpc0FzeW5jUHJlZml4ZWQoZnJhZ21lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChkaXJlY3RpdmUgJiYgKGZsYWdzICYgRl9ESVJFQ1RJVkVfQ1RYKSAmJiBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gU3ludGF4LkxpdGVyYWwgJiYgdHlwZW9mIHN0bXQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWycoJywgcmVzdWx0LCAnKScgKyB0aGlzLnNlbWljb2xvbihmbGFncyldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnNlbWljb2xvbihmbGFncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBFUzY6IDE1LjIuMSB2YWxpZCBpbXBvcnQgZGVjbGFyYXRpb25zOlxuICAgICAgICAgICAgLy8gICAgIC0gaW1wb3J0IEltcG9ydENsYXVzZSBGcm9tQ2xhdXNlIDtcbiAgICAgICAgICAgIC8vICAgICAtIGltcG9ydCBNb2R1bGVTcGVjaWZpZXIgO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgY3Vyc29yLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gSWYgbm8gSW1wb3J0Q2xhdXNlIGlzIHByZXNlbnQsXG4gICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBiZSBgaW1wb3J0IE1vZHVsZVNwZWNpZmllcmAgc28gc2tpcCBgZnJvbWBcbiAgICAgICAgICAgIC8vIE1vZHVsZVNwZWNpZmllciBpcyBTdHJpbmdMaXRlcmFsLlxuICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpbXBvcnQgTW9kdWxlU3BlY2lmaWVyIDtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAnaW1wb3J0JyxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vZHVsZVNwZWNpZmllclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNvdXJjZSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbXBvcnQgSW1wb3J0Q2xhdXNlIEZyb21DbGF1c2UgO1xuICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICdpbXBvcnQnXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY3Vyc29yID0gMDtcblxuICAgICAgICAgICAgLy8gSW1wb3J0ZWRCaW5kaW5nXG4gICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0udHlwZSA9PT0gU3ludGF4LkltcG9ydERlZmF1bHRTcGVjaWZpZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICsrY3Vyc29yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdLnR5cGUgPT09IFN5bnRheC5JbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmFtZVNwYWNlSW1wb3J0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zcGVjaWZpZXJzW2N1cnNvcl0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOYW1lZEltcG9ydHNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UgKyAneycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoc3RtdC5zcGVjaWZpZXJzLmxlbmd0aCAtIGN1cnNvcikgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltcG9ydCB7IC4uLiB9IGZyb20gXCIuLi5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UgKyAnfScgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgLi4uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgLi4uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBmcm9tIFwiLi4uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gY3Vyc29yLCBpeiA9IHN0bXQuc3BlY2lmaWVycy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiYXNlICsgJ30nICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICdmcm9tJyArIHNwYWNlLFxuICAgICAgICAgICAgICAgIC8vIE1vZHVsZVNwZWNpZmllclxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc291cmNlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24oZmxhZ3MpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBpdGVtRmxhZ3MgPSAoZmxhZ3MgJiBGX0FMTE9XX0lOKSA/IEVfVFRUIDogRV9GVFQ7XG4gICAgICAgICAgICBpZiAoc3RtdC5pbml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5pZCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBpdGVtRmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgJz0nLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5pbml0LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGl0ZW1GbGFncylcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVQYXR0ZXJuKHN0bXQuaWQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgaXRlbUZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIFZhcmlhYmxlRGVjbGFyYXRvciBpcyB0eXBlZCBhcyBTdGF0ZW1lbnQsXG4gICAgICAgICAgICAvLyBidXQgam9pbmVkIHdpdGggY29tbWEgKG5vdCBMaW5lVGVybWluYXRvcikuXG4gICAgICAgICAgICAvLyBTbyBpZiBjb21tZW50IGlzIGF0dGFjaGVkIHRvIHRhcmdldCBub2RlLCB3ZSBzaG91bGQgc3BlY2lhbGl6ZS5cbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6LCBub2RlLCBib2R5RmxhZ3MsIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXN1bHQgPSBbIHN0bXQua2luZCBdO1xuXG4gICAgICAgICAgICBib2R5RmxhZ3MgPSAoZmxhZ3MgJiBGX0FMTE9XX0lOKSA/IFNfVEZGRiA6IFNfRkZGRjtcblxuICAgICAgICAgICAgZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHN0bXQuZGVjbGFyYXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50ICYmIG5vZGUubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgYm9keUZsYWdzKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vRW1wdHlTcGFjZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZVN0YXRlbWVudChub2RlLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IHN0bXQuZGVjbGFyYXRpb25zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHN0bXQuZGVjbGFyYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudCAmJiBub2RlLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChub2RlLCBib2R5RmxhZ3MpKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RtdC5kZWNsYXJhdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoYmxvY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBibG9jaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnNlbWljb2xvbihmbGFncykpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFRocm93U3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbam9pbihcbiAgICAgICAgICAgICAgICAndGhyb3cnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuYXJndW1lbnQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKVxuICAgICAgICAgICAgKSwgdGhpcy5zZW1pY29sb24oZmxhZ3MpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBUcnlTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXosIGd1YXJkZWRIYW5kbGVycztcblxuICAgICAgICAgICAgcmVzdWx0ID0gWyd0cnknLCB0aGlzLm1heWJlQmxvY2soc3RtdC5ibG9jaywgU19URkZGKV07XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5ibG9jaywgcmVzdWx0KTtcblxuICAgICAgICAgICAgaWYgKHN0bXQuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBvbGQgaW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LmhhbmRsZXJzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5oYW5kbGVyc1tpXSwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBpICsgMSAhPT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmhhbmRsZXJzW2ldLmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGd1YXJkZWRIYW5kbGVycyA9IHN0bXQuZ3VhcmRlZEhhbmRsZXJzIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBndWFyZGVkSGFuZGxlcnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChndWFyZGVkSGFuZGxlcnNbaV0sIFNfVEZGRikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIgfHwgaSArIDEgIT09IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoZ3VhcmRlZEhhbmRsZXJzW2ldLmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBuZXcgaW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShzdG10LmhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuaGFuZGxlci5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5oYW5kbGVyW2ldLCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIgfHwgaSArIDEgIT09IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmhhbmRsZXJbaV0uYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmhhbmRsZXIsIFNfVEZGRikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuaGFuZGxlci5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFsnZmluYWxseScsIHRoaXMubWF5YmVCbG9jayhzdG10LmZpbmFsaXplciwgU19URkZGKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQsIGksIGl6LCBib2R5RmxhZ3MsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnc3dpdGNoJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmRpc2NyaW1pbmFudCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAnKScgKyBzcGFjZSArICd7JyArIG5ld2xpbmVcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc3RtdC5jYXNlcykge1xuICAgICAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZGRjtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHN0bXQuY2FzZXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5jYXNlc1tpXSwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCgnfScpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3dpdGNoQ2FzZTogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudCwgaSwgaXosIGJvZHlGbGFncywgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC50ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW4oJ2Nhc2UnLCB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnOidcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ2RlZmF1bHQ6J107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgaXogPSBzdG10LmNvbnNlcXVlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChpeiAmJiBzdG10LmNvbnNlcXVlbnRbMF0udHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhhdC5tYXliZUJsb2NrKHN0bXQuY29uc2VxdWVudFswXSwgU19URkZGKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaXogJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZGRjtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGl6IC0gMSAmJiBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGFkZEluZGVudCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuY29uc2VxdWVudFtpXSwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxICE9PSBpeiAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSWZTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgYm9keUZsYWdzLCBzZW1pY29sb25PcHRpb25hbCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICdpZicgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbWljb2xvbk9wdGlvbmFsID0gZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGRkY7XG4gICAgICAgICAgICBpZiAoc2VtaWNvbG9uT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0bXQuYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuY29uc2VxdWVudCwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuY29uc2VxdWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5hbHRlcm5hdGUudHlwZSA9PT0gU3ludGF4LklmU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbJ2Vsc2UgJywgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmFsdGVybmF0ZSwgYm9keUZsYWdzKV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBqb2luKCdlbHNlJywgdGhpcy5tYXliZUJsb2NrKHN0bXQuYWx0ZXJuYXRlLCBib2R5RmxhZ3MpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5jb25zZXF1ZW50LCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRm9yU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWydmb3InICsgc3BhY2UgKyAnKCddO1xuICAgICAgICAgICAgICAgIGlmIChzdG10LmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuaW5pdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmluaXQsIFNfRkZGRikpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRl9BTExPV19JTiBiZWNvbWVzIGZhbHNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5pbml0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX0ZUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJzsnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc7Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQudGVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJzsnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG10LnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudXBkYXRlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEZvckluU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSXRlcmF0aW9uRm9yU3RhdGVtZW50KCdpbicsIHN0bXQsIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKTtcbiAgICAgICAgfSxcblxuICAgICAgICBGb3JPZlN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUl0ZXJhdGlvbkZvclN0YXRlbWVudCgnb2YnLCBzdG10LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3N0bXQubGFiZWwubmFtZSArICc6JywgdGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBQcm9ncmFtOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCBpLCBpeiwgYm9keUZsYWdzO1xuICAgICAgICAgICAgaXogPSBzdG10LmJvZHkubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0ID0gW3NhZmVDb25jYXRlbmF0aW9uICYmIGl6ID4gMCA/ICdcXG4nIDogJyddO1xuICAgICAgICAgICAgYm9keUZsYWdzID0gU19URlRGO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNhZmVDb25jYXRlbmF0aW9uICYmIGkgPT09IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBiZWZvcmUgdGhlIGZpcnN0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5WzBdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQmxhbmtMaW5lcyhzdG10LnJhbmdlWzBdLCBzdG10LmJvZHlbaV0ucmFuZ2VbMF0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGJldHdlZW4gbGluZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpIC0gMV0udHJhaWxpbmdDb21tZW50cyAmJiAhc3RtdC5ib2R5W2ldLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQmxhbmtMaW5lcyhzdG10LmJvZHlbaSAtIDFdLnJhbmdlWzFdLCBzdG10LmJvZHlbaV0ucmFuZ2VbMF0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGFkZEluZGVudCh0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuYm9keVtpXSwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6ICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5W2kgKyAxXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGFmdGVyIHRoZSBsYXN0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaV0udHJhaWxpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQmxhbmtMaW5lcyhzdG10LmJvZHlbaV0ucmFuZ2VbMV0sIHN0bXQucmFuZ2VbMV0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUFzeW5jUHJlZml4KHN0bXQsIHRydWUpLFxuICAgICAgICAgICAgICAgICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVTdGFyU3VmZml4KHN0bXQpIHx8IG5vRW1wdHlTcGFjZSgpLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlSWRlbnRpZmllcihzdG10LmlkKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KHN0bXQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIFJldHVyblN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5hcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbam9pbihcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuYXJndW1lbnQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKVxuICAgICAgICAgICAgICAgICksIHRoaXMuc2VtaWNvbG9uKGZsYWdzKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWydyZXR1cm4nICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBXaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ3doaWxlJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgV2l0aFN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGgnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQub2JqZWN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgbWVyZ2UoQ29kZUdlbmVyYXRvci5wcm90b3R5cGUsIENvZGVHZW5lcmF0b3IuU3RhdGVtZW50KTtcblxuICAgIC8vIEV4cHJlc3Npb25zLlxuXG4gICAgQ29kZUdlbmVyYXRvci5FeHByZXNzaW9uID0ge1xuXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpejtcbiAgICAgICAgICAgIGlmIChQcmVjZWRlbmNlLlNlcXVlbmNlIDwgcHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgICAgIGZsYWdzIHw9IEZfQUxMT1dfSU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5leHByZXNzaW9ucy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5leHByZXNzaW9uc1tpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBmbGFncykpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVBc3NpZ25tZW50KGV4cHIubGVmdCwgZXhwci5yaWdodCwgZXhwci5vcGVyYXRvciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUodGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByKSwgUHJlY2VkZW5jZS5BcnJvd0Z1bmN0aW9uLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgaWYgKFByZWNlZGVuY2UuQ29uZGl0aW9uYWwgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnRlc3QsIFByZWNlZGVuY2UuTG9naWNhbE9SLCBmbGFncyksXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlICsgJz8nICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuY29uc2VxdWVudCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBmbGFncyksXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlICsgJzonICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYWx0ZXJuYXRlLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGZsYWdzKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgUHJlY2VkZW5jZS5Db25kaXRpb25hbCxcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkJpbmFyeUV4cHJlc3Npb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgY3VycmVudFByZWNlZGVuY2UsIGZyYWdtZW50LCBsZWZ0U291cmNlO1xuICAgICAgICAgICAgY3VycmVudFByZWNlZGVuY2UgPSBCaW5hcnlQcmVjZWRlbmNlW2V4cHIub3BlcmF0b3JdO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByZWNlZGVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmxlZnQsIGN1cnJlbnRQcmVjZWRlbmNlLCBmbGFncyk7XG5cbiAgICAgICAgICAgIGxlZnRTb3VyY2UgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAobGVmdFNvdXJjZS5jaGFyQ29kZUF0KGxlZnRTb3VyY2UubGVuZ3RoIC0gMSkgPT09IDB4MkYgLyogLyAqLyAmJiBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydChleHByLm9wZXJhdG9yLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW2ZyYWdtZW50LCBub0VtcHR5U3BhY2UoKSwgZXhwci5vcGVyYXRvcl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oZnJhZ21lbnQsIGV4cHIub3BlcmF0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQsIGN1cnJlbnRQcmVjZWRlbmNlICsgMSwgZmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvciA9PT0gJy8nICYmIGZyYWdtZW50LnRvU3RyaW5nKCkuY2hhckF0KDApID09PSAnLycgfHxcbiAgICAgICAgICAgIGV4cHIub3BlcmF0b3Iuc2xpY2UoLTEpID09PSAnPCcgJiYgZnJhZ21lbnQudG9TdHJpbmcoKS5zbGljZSgwLCAzKSA9PT0gJyEtLScpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiAnLycgY29uY2F0cyB3aXRoICcvJyBvciBgPGAgY29uY2F0cyB3aXRoIGAhLS1gLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBjb21tZW50IHN0YXJ0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIub3BlcmF0b3IgPT09ICdpbicgJiYgIShmbGFncyAmIEZfQUxMT1dfSU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHJlc3VsdCwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBjdXJyZW50UHJlY2VkZW5jZSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXo7XG4gICAgICAgICAgICAvLyBGX0FMTE9XX1VOUEFSQVRIX05FVyBiZWNvbWVzIGZhbHNlLlxuICAgICAgICAgICAgcmVzdWx0ID0gW3RoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuY2FsbGVlLCBQcmVjZWRlbmNlLkNhbGwsIEVfVFRGKV07XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKCcpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByWydhcmd1bWVudHMnXS5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwclsnYXJndW1lbnRzJ11baV0sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcblxuICAgICAgICAgICAgaWYgKCEoZmxhZ3MgJiBGX0FMTE9XX0NBTEwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHJlc3VsdCwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLkNhbGwsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIE5ld0V4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgbGVuZ3RoLCBpLCBpeiwgaXRlbUZsYWdzO1xuICAgICAgICAgICAgbGVuZ3RoID0gZXhwclsnYXJndW1lbnRzJ10ubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBGX0FMTE9XX0NBTEwgYmVjb21lcyBmYWxzZS5cbiAgICAgICAgICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXIG1heSBiZWNvbWUgZmFsc2UuXG4gICAgICAgICAgICBpdGVtRmxhZ3MgPSAoZmxhZ3MgJiBGX0FMTE9XX1VOUEFSQVRIX05FVyAmJiAhcGFyZW50aGVzZXMgJiYgbGVuZ3RoID09PSAwKSA/IEVfVEZUIDogRV9URkY7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oXG4gICAgICAgICAgICAgICAgJ25ldycsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5jYWxsZWUsIFByZWNlZGVuY2UuTmV3LCBpdGVtRmxhZ3MpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIEZfQUxMT1dfVU5QQVJBVEhfTkVXKSB8fCBwYXJlbnRoZXNlcyB8fCBsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJygnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwclsnYXJndW1lbnRzJ11baV0sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5OZXcsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXIGJlY29tZXMgZmFsc2UuXG4gICAgICAgICAgICByZXN1bHQgPSBbdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5vYmplY3QsIFByZWNlZGVuY2UuQ2FsbCwgKGZsYWdzICYgRl9BTExPV19DQUxMKSA/IEVfVFRGIDogRV9URkYpXTtcblxuICAgICAgICAgICAgaWYgKGV4cHIuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnWycpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucHJvcGVydHksIFByZWNlZGVuY2UuU2VxdWVuY2UsIGZsYWdzICYgRl9BTExPV19DQUxMID8gRV9UVFQgOiBFX1RGVCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCddJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHByLm9iamVjdC50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiB0eXBlb2YgZXhwci5vYmplY3QudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBhbGwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAxLiBObyBmbG9hdGluZyBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDIuIERvbid0IGhhdmUgZXhwb25lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vICAgMy4gVGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgZGVjaW1hbCBkaWdpdFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDQuIE5vdCBoZXhhZGVjaW1hbCBPUiBvY3RhbCBudW1iZXIgbGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgYWRkIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5pbmRleE9mKCcuJykgPCAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIS9bZUV4WF0vLnRlc3QoZnJhZ21lbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXN1dGlscy5jb2RlLmlzRGVjaW1hbERpZ2l0KGZyYWdtZW50LmNoYXJDb2RlQXQoZnJhZ21lbnQubGVuZ3RoIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShmcmFnbWVudC5sZW5ndGggPj0gMiAmJiBmcmFnbWVudC5jaGFyQ29kZUF0KDApID09PSA0OCkgIC8vICcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlSWRlbnRpZmllcihleHByLnByb3BlcnR5KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk1lbWJlciwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCByaWdodENoYXJDb2RlLCBsZWZ0U291cmNlLCBsZWZ0Q2hhckNvZGU7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuVW5hcnksIEVfVFRUKTtcblxuICAgICAgICAgICAgaWYgKHNwYWNlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oZXhwci5vcGVyYXRvciwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbZXhwci5vcGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIub3BlcmF0b3IubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUsIHZvaWQsIHR5cGVvZlxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYHR5cGVvZiBbXWAsIG5vdCBgdHlwZW9mW11gXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBpbnNlcnRpbmcgc3BhY2VzIGJldHdlZW4gb3BlcmF0b3IgYW5kIGFyZ3VtZW50IGlmIGl0IGlzIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpa2UsIGAhY29uZGBcbiAgICAgICAgICAgICAgICAgICAgbGVmdFNvdXJjZSA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2hhckNvZGUgPSBsZWZ0U291cmNlLmNoYXJDb2RlQXQobGVmdFNvdXJjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDaGFyQ29kZSA9IGZyYWdtZW50LnRvU3RyaW5nKCkuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKChsZWZ0Q2hhckNvZGUgPT09IDB4MkIgIC8qICsgKi8gfHwgbGVmdENoYXJDb2RlID09PSAweDJEICAvKiAtICovKSAmJiBsZWZ0Q2hhckNvZGUgPT09IHJpZ2h0Q2hhckNvZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0KGxlZnRDaGFyQ29kZSkgJiYgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnQocmlnaHRDaGFyQ29kZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5VbmFyeSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoZXhwci5kZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd5aWVsZConO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAneWllbGQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIuYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuWWllbGQsIEVfVFRUKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5ZaWVsZCwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgIGV4cHIuZGVsZWdhdGUgPyAnYXdhaXQqJyA6ICdhd2FpdCcsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5Bd2FpdCwgRV9UVFQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuQXdhaXQsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgaWYgKGV4cHIucHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwci5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuVW5hcnksIEVfVFRUKVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBQcmVjZWRlbmNlLlVuYXJ5LFxuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCBQcmVjZWRlbmNlLlBvc3RmaXgsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwci5vcGVyYXRvclxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgUHJlY2VkZW5jZS5Qb3N0Zml4LFxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBc3luY1ByZWZpeChleHByLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAnZnVuY3Rpb24nXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGV4cHIuaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZVN0YXJTdWZmaXgoZXhwcikgfHwgbm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlSWRlbnRpZmllcihleHByLmlkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlU3RhclN1ZmZpeChleHByKSB8fCBzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0QmF0Y2hTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuICcqJztcbiAgICAgICAgfSxcblxuICAgICAgICBBcnJheVBhdHRlcm46IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQXJyYXlFeHByZXNzaW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgbXVsdGlsaW5lLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIGlmICghZXhwci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tdJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11bHRpbGluZSA9IGV4cHIuZWxlbWVudHMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFsnWycsIG11bHRpbGluZSA/IG5ld2xpbmUgOiAnJ107XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHByLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA9PT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5lbGVtZW50c1tpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmUgJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBiYXNlIDogJycpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gWydjbGFzcyddO1xuICAgICAgICAgICAgaWYgKGV4cHIuaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5pZCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLnN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oJ2V4dGVuZHMnLCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnN1cGVyQ2xhc3MsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZVN0YXRlbWVudChleHByLmJvZHksIFNfVEZGVCkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGV4cHJbJ3N0YXRpYyddKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWydzdGF0aWMnICsgc3BhY2VdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLmtpbmQgPT09ICdnZXQnIHx8IGV4cHIua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgam9pbihleHByLmtpbmQsIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWV0aG9kUHJlZml4KGV4cHIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFByb3BlcnR5OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHByLmtpbmQgPT09ICdnZXQnIHx8IGV4cHIua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBleHByLmtpbmQsIG5vRW1wdHlTcGFjZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIuc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWV0aG9kUHJlZml4KGV4cHIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICc6JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudmFsdWUsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIG11bHRpbGluZSwgcmVzdWx0LCBmcmFnbWVudCwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAne30nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCA+IDE7XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0aWVzWzBdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBpc3N1ZXMgNFxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmFuc2Zvcm0gZnJvbVxuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe1xuICAgICAgICAgICAgICAgIC8vICAgICAgIG1ldGhvZDI6IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgICAvLyB0b1xuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe21ldGhvZDI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICB9fSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyAneycsIHNwYWNlLCBmcmFnbWVudCwgc3BhY2UsICd9JyBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsgJ3snLCBuZXdsaW5lLCBpbmRlbnQsIGZyYWdtZW50IF07XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0aWVzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIE9iamVjdFBhdHRlcm46IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXosIG11bHRpbGluZSwgcHJvcGVydHksIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFleHByLnByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG11bHRpbGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV4cHIucHJvcGVydGllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IGV4cHIucHJvcGVydGllc1swXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkudmFsdWUudHlwZSAhPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBleHByLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHkuc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBbJ3snLCBtdWx0aWxpbmUgPyBuZXdsaW5lIDogJycgXTtcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnRpZXNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG11bHRpbGluZSAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG11bHRpbGluZSA/IGJhc2UgOiAnJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnfScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoaXMnO1xuICAgICAgICB9LFxuXG4gICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSWRlbnRpZmllcihleHByKTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5pZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbJyonXTtcbiAgICAgICAgICAgIGlmIChleHByLmlkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UgKyAnYXMnICsgbm9FbXB0eVNwYWNlKCkgKyBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5pZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXhwb3J0U3BlY2lmaWVyKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsgZXhwci5pZC5uYW1lIF07XG4gICAgICAgICAgICBpZiAoZXhwci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCkgKyAnYXMnICsgbm9FbXB0eVNwYWNlKCkgKyBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5uYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIExpdGVyYWw6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJhdztcbiAgICAgICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KCdyYXcnKSAmJiBwYXJzZSAmJiBleHRyYS5yYXcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByYXcgPSBwYXJzZShleHByLnJhdykuYm9keVswXS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3LnR5cGUgPT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3LnZhbHVlID09PSBleHByLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIucmF3O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgdXNlIHJhdyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVN0cmluZyhleHByLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZU51bWJlcihleHByLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwci52YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVJlZ0V4cChleHByLnZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBHZW5lcmF0b3JFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNvbXByZWhlbnNpb25FeHByZXNzaW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0b3JFeHByZXNzaW9uIHNob3VsZCBiZSBwYXJlbnRoZXNpemVkIHdpdGggKC4uLiksIENvbXByZWhlbnNpb25FeHByZXNzaW9uIHdpdGggWy4uLl1cbiAgICAgICAgICAgIC8vIER1ZSB0byBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODM0NjggcG9zaXRpb24gb2YgZXhwci5ib2R5IGNhbiBkaWZmZXIgaW4gU3BpZGVybW9ua2V5IGFuZCBFUzZcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXosIGZyYWdtZW50LCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHJlc3VsdCA9IChleHByLnR5cGUgPT09IFN5bnRheC5HZW5lcmF0b3JFeHByZXNzaW9uKSA/IFsnKCddIDogWydbJ107XG5cbiAgICAgICAgICAgIGlmIChleHRyYS5tb3ouY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5ib2R5LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLmJsb2Nrcykge1xuICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIuYmxvY2tzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5ibG9ja3NbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCB8fCBleHRyYS5tb3ouY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgJ2lmJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuZmlsdGVyLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFsgJygnLCBmcmFnbWVudCwgJyknIF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4dHJhLm1vei5jb21wcmVoZW5zaW9uRXhwcmVzc2lvblN0YXJ0c1dpdGhBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmJvZHksIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGV4cHIudHlwZSA9PT0gU3ludGF4LkdlbmVyYXRvckV4cHJlc3Npb24pID8gJyknIDogJ10nKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkJsb2NrOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChleHByLmxlZnQudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZXhwci5sZWZ0LmtpbmQsIG5vRW1wdHlTcGFjZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KGV4cHIubGVmdC5kZWNsYXJhdGlvbnNbMF0sIFNfRkZGRilcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIubGVmdCwgUHJlY2VkZW5jZS5DYWxsLCBFX1RUVCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyYWdtZW50ID0gam9pbihmcmFnbWVudCwgZXhwci5vZiA/ICdvZicgOiAnaW4nKTtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gam9pbihmcmFnbWVudCwgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcblxuICAgICAgICAgICAgcmV0dXJuIFsgJ2ZvcicgKyBzcGFjZSArICcoJywgZnJhZ21lbnQsICcpJyBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIFNwcmVhZEVsZW1lbnQ6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnLi4uJyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGl0ZW1GbGFncyA9IEVfVFRGO1xuICAgICAgICAgICAgaWYgKCEoZmxhZ3MgJiBGX0FMTE9XX0NBTEwpKSB7XG4gICAgICAgICAgICAgICAgaXRlbUZsYWdzID0gRV9URkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudGFnLCBQcmVjZWRlbmNlLkNhbGwsIGl0ZW1GbGFncyksXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5xdWFzaSwgUHJlY2VkZW5jZS5QcmltYXJ5LCBFX0ZGVClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5UYWdnZWRUZW1wbGF0ZSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGVtcGxhdGVFbGVtZW50OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHVzZSBcImNvb2tlZFwiLiBTaW5jZSB0YWdnZWQgdGVtcGxhdGUgY2FuIHVzZSByYXcgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIHJlcHJlc2VudGF0aW9uLiBTbyBpZiB3ZSBkbyBzbywgaXQgYnJlYWtzIHRoZSBzY3JpcHQgc2VtYW50aWNzLlxuICAgICAgICAgICAgcmV0dXJuIGV4cHIudmFsdWUucmF3O1xuICAgICAgICB9LFxuXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpejtcbiAgICAgICAgICAgIHJlc3VsdCA9IFsgJ2AnIF07XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIucXVhc2lzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnF1YXNpc1tpXSwgUHJlY2VkZW5jZS5QcmltYXJ5LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCckeycgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbnNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlICsgJ30nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnYCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTGl0ZXJhbChleHByLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBtZXJnZShDb2RlR2VuZXJhdG9yLnByb3RvdHlwZSwgQ29kZUdlbmVyYXRvci5FeHByZXNzaW9uKTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICB2YXIgcmVzdWx0LCB0eXBlO1xuXG4gICAgICAgIHR5cGUgPSBleHByLnR5cGUgfHwgU3ludGF4LlByb3BlcnR5O1xuXG4gICAgICAgIGlmIChleHRyYS52ZXJiYXRpbSAmJiBleHByLmhhc093blByb3BlcnR5KGV4dHJhLnZlcmJhdGltKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlVmVyYmF0aW0oZXhwciwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSB0aGlzW3R5cGVdKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcblxuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhZGRDb21tZW50cyhleHByLHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0LCBleHByKTtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIGZyYWdtZW50O1xuXG4gICAgICAgIHJlc3VsdCA9IHRoaXNbc3RtdC50eXBlXShzdG10LCBmbGFncyk7XG5cbiAgICAgICAgLy8gQXR0YWNoIGNvbW1lbnRzXG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZENvbW1lbnRzKHN0bXQsIHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguUHJvZ3JhbSAmJiAhc2FmZUNvbmNhdGVuYXRpb24gJiYgbmV3bGluZSA9PT0gJycgJiYgIGZyYWdtZW50LmNoYXJBdChmcmFnbWVudC5sZW5ndGggLSAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZU1hcCA/IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS5yZXBsYWNlUmlnaHQoL1xccyskLywgJycpIDogZnJhZ21lbnQucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQsIHN0bXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUludGVybmFsKG5vZGUpIHtcbiAgICAgICAgdmFyIGNvZGVnZW47XG5cbiAgICAgICAgY29kZWdlbiA9IG5ldyBDb2RlR2VuZXJhdG9yKCk7XG4gICAgICAgIGlmIChpc1N0YXRlbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW4uZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgU19URkZGKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuLmdlbmVyYXRlRXhwcmVzc2lvbihub2RlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlOiAnICsgbm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZShub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCksIHJlc3VsdCwgcGFpcjtcblxuICAgICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPYnNvbGV0ZSBvcHRpb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICBgb3B0aW9ucy5pbmRlbnRgXG4gICAgICAgICAgICAvLyAgIGBvcHRpb25zLmJhc2VgXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiB0aGVtLCB3ZSBjYW4gdXNlIGBvcHRpb24uZm9ybWF0LmluZGVudGAuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuc3R5bGUgPSBvcHRpb25zLmluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSB1cGRhdGVEZWVwbHkoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaW5kZW50ID0gb3B0aW9ucy5mb3JtYXQuaW5kZW50LnN0eWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHN0cmluZ1JlcGVhdChpbmRlbnQsIG9wdGlvbnMuZm9ybWF0LmluZGVudC5iYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIGluZGVudCA9IG9wdGlvbnMuZm9ybWF0LmluZGVudC5zdHlsZTtcbiAgICAgICAgICAgIGJhc2UgPSBzdHJpbmdSZXBlYXQoaW5kZW50LCBvcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IG9wdGlvbnMuZm9ybWF0Lmpzb247XG4gICAgICAgIHJlbnVtYmVyID0gb3B0aW9ucy5mb3JtYXQucmVudW1iZXI7XG4gICAgICAgIGhleGFkZWNpbWFsID0ganNvbiA/IGZhbHNlIDogb3B0aW9ucy5mb3JtYXQuaGV4YWRlY2ltYWw7XG4gICAgICAgIHF1b3RlcyA9IGpzb24gPyAnZG91YmxlJyA6IG9wdGlvbnMuZm9ybWF0LnF1b3RlcztcbiAgICAgICAgZXNjYXBlbGVzcyA9IG9wdGlvbnMuZm9ybWF0LmVzY2FwZWxlc3M7XG4gICAgICAgIG5ld2xpbmUgPSBvcHRpb25zLmZvcm1hdC5uZXdsaW5lO1xuICAgICAgICBzcGFjZSA9IG9wdGlvbnMuZm9ybWF0LnNwYWNlO1xuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQuY29tcGFjdCkge1xuICAgICAgICAgICAgbmV3bGluZSA9IHNwYWNlID0gaW5kZW50ID0gYmFzZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudGhlc2VzID0gb3B0aW9ucy5mb3JtYXQucGFyZW50aGVzZXM7XG4gICAgICAgIHNlbWljb2xvbnMgPSBvcHRpb25zLmZvcm1hdC5zZW1pY29sb25zO1xuICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbiA9IG9wdGlvbnMuZm9ybWF0LnNhZmVDb25jYXRlbmF0aW9uO1xuICAgICAgICBkaXJlY3RpdmUgPSBvcHRpb25zLmRpcmVjdGl2ZTtcbiAgICAgICAgcGFyc2UgPSBqc29uID8gbnVsbCA6IG9wdGlvbnMucGFyc2U7XG4gICAgICAgIHNvdXJjZU1hcCA9IG9wdGlvbnMuc291cmNlTWFwO1xuICAgICAgICBzb3VyY2VDb2RlID0gb3B0aW9ucy5zb3VyY2VDb2RlO1xuICAgICAgICBwcmVzZXJ2ZUJsYW5rTGluZXMgPSBvcHRpb25zLmZvcm1hdC5wcmVzZXJ2ZUJsYW5rTGluZXMgJiYgc291cmNlQ29kZSAhPT0gbnVsbDtcbiAgICAgICAgZXh0cmEgPSBvcHRpb25zO1xuXG4gICAgICAgIGlmIChzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5icm93c2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIGVudmlyb25tZW50IGlzIG5vZGUuanNcbiAgICAgICAgICAgICAgICAvLyBBbmQgcHJldmVudCBmcm9tIGluY2x1ZGluZyBzb3VyY2UtbWFwIGJ5IGJyb3dzZXJpZnlcbiAgICAgICAgICAgICAgICBTb3VyY2VOb2RlID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNvdXJjZU5vZGUgPSBnbG9iYWwuc291cmNlTWFwLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZUludGVybmFsKG5vZGUpO1xuXG4gICAgICAgIGlmICghc291cmNlTWFwKSB7XG4gICAgICAgICAgICBwYWlyID0ge2NvZGU6IHJlc3VsdC50b1N0cmluZygpLCBtYXA6IG51bGx9O1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc291cmNlTWFwV2l0aENvZGUgPyBwYWlyIDogcGFpci5jb2RlO1xuICAgICAgICB9XG5cblxuICAgICAgICBwYWlyID0gcmVzdWx0LnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7XG4gICAgICAgICAgICBmaWxlOiBvcHRpb25zLmZpbGUsXG4gICAgICAgICAgICBzb3VyY2VSb290OiBvcHRpb25zLnNvdXJjZU1hcFJvb3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlQ29udGVudCkge1xuICAgICAgICAgICAgcGFpci5tYXAuc2V0U291cmNlQ29udGVudChvcHRpb25zLnNvdXJjZU1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zb3VyY2VDb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcFdpdGhDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWlyLm1hcC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIEZPUk1BVF9NSU5JRlkgPSB7XG4gICAgICAgIGluZGVudDoge1xuICAgICAgICAgICAgc3R5bGU6ICcnLFxuICAgICAgICAgICAgYmFzZTogMFxuICAgICAgICB9LFxuICAgICAgICByZW51bWJlcjogdHJ1ZSxcbiAgICAgICAgaGV4YWRlY2ltYWw6IHRydWUsXG4gICAgICAgIHF1b3RlczogJ2F1dG8nLFxuICAgICAgICBlc2NhcGVsZXNzOiB0cnVlLFxuICAgICAgICBjb21wYWN0OiB0cnVlLFxuICAgICAgICBwYXJlbnRoZXNlczogZmFsc2UsXG4gICAgICAgIHNlbWljb2xvbnM6IGZhbHNlXG4gICAgfTtcblxuICAgIEZPUk1BVF9ERUZBVUxUUyA9IGdldERlZmF1bHRPcHRpb25zKCkuZm9ybWF0O1xuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICAgIGV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbiAgICBleHBvcnRzLmF0dGFjaENvbW1lbnRzID0gZXN0cmF2ZXJzZS5hdHRhY2hDb21tZW50cztcbiAgICBleHBvcnRzLlByZWNlZGVuY2UgPSB1cGRhdGVEZWVwbHkoe30sIFByZWNlZGVuY2UpO1xuICAgIGV4cG9ydHMuYnJvd3NlciA9IGZhbHNlO1xuICAgIGV4cG9ydHMuRk9STUFUX01JTklGWSA9IEZPUk1BVF9NSU5JRlk7XG4gICAgZXhwb3J0cy5GT1JNQVRfREVGQVVMVFMgPSBGT1JNQVRfREVGQVVMVFM7XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKmpzbGludCB2YXJzOmZhbHNlLCBiaXR3aXNlOnRydWUqL1xuLypqc2hpbnQgaW5kZW50OjQqL1xuLypnbG9iYWwgZXhwb3J0czp0cnVlLCBkZWZpbmU6dHJ1ZSovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsXG4gICAgLy8gYW5kIHBsYWluIGJyb3dzZXIgbG9hZGluZyxcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KChyb290LmVzdHJhdmVyc2UgPSB7fSkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gY2xvbmUoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTeW50YXgsXG4gICAgICAgIGlzQXJyYXksXG4gICAgICAgIFZpc2l0b3JPcHRpb24sXG4gICAgICAgIFZpc2l0b3JLZXlzLFxuICAgICAgICBvYmplY3RDcmVhdGUsXG4gICAgICAgIG9iamVjdEtleXMsXG4gICAgICAgIEJSRUFLLFxuICAgICAgICBTS0lQLFxuICAgICAgICBSRU1PVkU7XG5cbiAgICBmdW5jdGlvbiBpZ25vcmVKU0hpbnRFcnJvcigpIHsgfVxuXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICAgICAgdmFyIHJldCA9IHt9LCBrZXksIHZhbDtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZGVlcENvcHkodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFsbG93Q29weShvYmopIHtcbiAgICAgICAgdmFyIHJldCA9IHt9LCBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpZ25vcmVKU0hpbnRFcnJvcihzaGFsbG93Q29weSk7XG5cbiAgICAvLyBiYXNlZCBvbiBMTFZNIGxpYmMrKyB1cHBlcl9ib3VuZCAvIGxvd2VyX2JvdW5kXG4gICAgLy8gTUlUIExpY2Vuc2VcblxuICAgIGZ1bmN0aW9uIHVwcGVyQm91bmQoYXJyYXksIGZ1bmMpIHtcbiAgICAgICAgdmFyIGRpZmYsIGxlbiwgaSwgY3VycmVudDtcblxuICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgIGRpZmYgPSBsZW4gPj4+IDE7XG4gICAgICAgICAgICBjdXJyZW50ID0gaSArIGRpZmY7XG4gICAgICAgICAgICBpZiAoZnVuYyhhcnJheVtjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBkaWZmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgbGVuIC09IGRpZmYgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvd2VyQm91bmQoYXJyYXksIGZ1bmMpIHtcbiAgICAgICAgdmFyIGRpZmYsIGxlbiwgaSwgY3VycmVudDtcblxuICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgIGRpZmYgPSBsZW4gPj4+IDE7XG4gICAgICAgICAgICBjdXJyZW50ID0gaSArIGRpZmY7XG4gICAgICAgICAgICBpZiAoZnVuYyhhcnJheVtjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgbGVuIC09IGRpZmYgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBpZ25vcmVKU0hpbnRFcnJvcihsb3dlckJvdW5kKTtcblxuICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRigpIHsgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGKCk7XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIga2V5cyA9IFtdLCBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIG8pIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBleHRlbmQodG8sIGZyb20pIHtcbiAgICAgICAgb2JqZWN0S2V5cyhmcm9tKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgU3ludGF4ID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogJ0NvbXByZWhlbnNpb25CbG9jaycsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246ICdDb21wcmVoZW5zaW9uRXhwcmVzc2lvbicsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6ICdEaXJlY3RpdmVTdGF0ZW1lbnQnLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHBvcnRCYXRjaFNwZWNpZmllcjogJ0V4cG9ydEJhdGNoU3BlY2lmaWVyJyxcbiAgICAgICAgRXhwb3J0RGVjbGFyYXRpb246ICdFeHBvcnREZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246ICdHZW5lcmF0b3JFeHByZXNzaW9uJywgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6ICdNb2R1bGVTcGVjaWZpZXInLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXG4gICAgICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiAnVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVGVtcGxhdGVFbGVtZW50OiAnVGVtcGxhdGVFbGVtZW50JyxcbiAgICAgICAgVGVtcGxhdGVMaXRlcmFsOiAnVGVtcGxhdGVMaXRlcmFsJyxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246ICdUaGlzRXhwcmVzc2lvbicsXG4gICAgICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxuICAgICAgICBUcnlTdGF0ZW1lbnQ6ICdUcnlTdGF0ZW1lbnQnLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6ICdXaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6ICdXaXRoU3RhdGVtZW50JyxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiAnWWllbGRFeHByZXNzaW9uJ1xuICAgIH07XG5cbiAgICBWaXNpdG9yS2V5cyA9IHtcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246IFsnZWxlbWVudHMnXSxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBbJ3BhcmFtcycsICdkZWZhdWx0cycsICdyZXN0JywgJ2JvZHknXSxcbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogWydib2R5J10sXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogWydjYWxsZWUnLCAnYXJndW1lbnRzJ10sXG4gICAgICAgIENhdGNoQ2xhdXNlOiBbJ3BhcmFtJywgJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NCb2R5OiBbJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogWydpZCcsICdib2R5JywgJ3N1cGVyQ2xhc3MnXSxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiBbJ2lkJywgJ2JvZHknLCAnc3VwZXJDbGFzcyddLFxuICAgICAgICBDb21wcmVoZW5zaW9uQmxvY2s6IFsnbGVmdCcsICdyaWdodCddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbXByZWhlbnNpb25FeHByZXNzaW9uOiBbJ2Jsb2NrcycsICdmaWx0ZXInLCAnYm9keSddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgICAgIENvbnRpbnVlU3RhdGVtZW50OiBbJ2xhYmVsJ10sXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRGlyZWN0aXZlU3RhdGVtZW50OiBbXSxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogWydib2R5JywgJ3Rlc3QnXSxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBFeHBvcnRCYXRjaFNwZWNpZmllcjogW10sXG4gICAgICAgIEV4cG9ydERlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9uJywgJ3NwZWNpZmllcnMnLCAnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogWydpZCcsICduYW1lJ10sXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6IFsnZXhwcmVzc2lvbiddLFxuICAgICAgICBGb3JTdGF0ZW1lbnQ6IFsnaW5pdCcsICd0ZXN0JywgJ3VwZGF0ZScsICdib2R5J10sXG4gICAgICAgIEZvckluU3RhdGVtZW50OiBbJ2xlZnQnLCAncmlnaHQnLCAnYm9keSddLFxuICAgICAgICBGb3JPZlN0YXRlbWVudDogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogWydpZCcsICdwYXJhbXMnLCAnZGVmYXVsdHMnLCAncmVzdCcsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogWydpZCcsICdwYXJhbXMnLCAnZGVmYXVsdHMnLCAncmVzdCcsICdib2R5J10sXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246IFsnYmxvY2tzJywgJ2ZpbHRlcicsICdib2R5J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogW10sXG4gICAgICAgIElmU3RhdGVtZW50OiBbJ3Rlc3QnLCAnY29uc2VxdWVudCcsICdhbHRlcm5hdGUnXSxcbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IFsnc3BlY2lmaWVycycsICdzb3VyY2UnXSxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogWydpZCddLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFsnaWQnXSxcbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBbJ2lkJywgJ25hbWUnXSxcbiAgICAgICAgTGl0ZXJhbDogW10sXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IFsnbGFiZWwnLCAnYm9keSddLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246IFsnb2JqZWN0JywgJ3Byb3BlcnR5J10sXG4gICAgICAgIE1ldGhvZERlZmluaXRpb246IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogW10sXG4gICAgICAgIE5ld0V4cHJlc3Npb246IFsnY2FsbGVlJywgJ2FyZ3VtZW50cyddLFxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiBbJ3Byb3BlcnRpZXMnXSxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIFByb2dyYW06IFsnYm9keSddLFxuICAgICAgICBQcm9wZXJ0eTogWydrZXknLCAndmFsdWUnXSxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogWydleHByZXNzaW9ucyddLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogWydkaXNjcmltaW5hbnQnLCAnY2FzZXMnXSxcbiAgICAgICAgU3dpdGNoQ2FzZTogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnXSxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBbJ3RhZycsICdxdWFzaSddLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6IFtdLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6IFsncXVhc2lzJywgJ2V4cHJlc3Npb25zJ10sXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiBbXSxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiBbJ2Jsb2NrJywgJ2hhbmRsZXJzJywgJ2hhbmRsZXInLCAnZ3VhcmRlZEhhbmRsZXJzJywgJ2ZpbmFsaXplciddLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogWydhcmd1bWVudCddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9ucyddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IFsnaWQnLCAnaW5pdCddLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogWyd0ZXN0JywgJ2JvZHknXSxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogWydvYmplY3QnLCAnYm9keSddLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246IFsnYXJndW1lbnQnXVxuICAgIH07XG5cbiAgICAvLyB1bmlxdWUgaWRcbiAgICBCUkVBSyA9IHt9O1xuICAgIFNLSVAgPSB7fTtcbiAgICBSRU1PVkUgPSB7fTtcblxuICAgIFZpc2l0b3JPcHRpb24gPSB7XG4gICAgICAgIEJyZWFrOiBCUkVBSyxcbiAgICAgICAgU2tpcDogU0tJUCxcbiAgICAgICAgUmVtb3ZlOiBSRU1PVkVcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlKHBhcmVudCwga2V5KSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG5cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRbdGhpcy5rZXldID0gbm9kZTtcbiAgICB9O1xuXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIGlmIChpc0FycmF5KHRoaXMucGFyZW50KSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuc3BsaWNlKHRoaXMua2V5LCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEVsZW1lbnQobm9kZSwgcGF0aCwgd3JhcCwgcmVmKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMud3JhcCA9IHdyYXA7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnRyb2xsZXIoKSB7IH1cblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gcHJvcGVydHkgcGF0aCBhcnJheSBmcm9tIHJvb3QgdG8gY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIHBhdGgoKSB7XG4gICAgICAgIHZhciBpLCBpeiwgaiwganosIHJlc3VsdCwgZWxlbWVudDtcblxuICAgICAgICBmdW5jdGlvbiBhZGRUb1BhdGgocmVzdWx0LCBwYXRoKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGp6ID0gcGF0aC5sZW5ndGg7IGogPCBqejsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGhbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByb290IG5vZGVcbiAgICAgICAgaWYgKCF0aGlzLl9fY3VycmVudC5wYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcnN0IG5vZGUgaXMgc2VudGluZWwsIHNlY29uZCBub2RlIGlzIHJvb3QgZWxlbWVudFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMiwgaXogPSB0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLl9fbGVhdmVsaXN0W2ldO1xuICAgICAgICAgICAgYWRkVG9QYXRoKHJlc3VsdCwgZWxlbWVudC5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRUb1BhdGgocmVzdWx0LCB0aGlzLl9fY3VycmVudC5wYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiB0eXBlIG9mIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgfHwgdGhpcy5fX2N1cnJlbnQud3JhcDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBhcnJheSBvZiBwYXJlbnQgZWxlbWVudHNcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5wYXJlbnRzID0gZnVuY3Rpb24gcGFyZW50cygpIHtcbiAgICAgICAgdmFyIGksIGl6LCByZXN1bHQ7XG5cbiAgICAgICAgLy8gZmlyc3Qgbm9kZSBpcyBzZW50aW5lbFxuICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMSwgaXogPSB0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuX19sZWF2ZWxpc3RbaV0ubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2N1cnJlbnQubm9kZTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuX19leGVjdXRlID0gZnVuY3Rpb24gX19leGVjdXRlKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBwcmV2aW91cywgcmVzdWx0O1xuXG4gICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBwcmV2aW91cyAgPSB0aGlzLl9fY3VycmVudDtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBudWxsO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrLmNhbGwodGhpcywgZWxlbWVudC5ub2RlLCB0aGlzLl9fbGVhdmVsaXN0W3RoaXMuX19sZWF2ZWxpc3QubGVuZ3RoIC0gMV0ubm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBwcmV2aW91cztcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gbm90aWZ5IGNvbnRyb2wgc2tpcCAvIGJyZWFrXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5KGZsYWcpIHtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gZmxhZztcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHNraXAgY2hpbGQgbm9kZXMgb2YgY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoU0tJUCk7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBicmVhayB0cmF2ZXJzYWxzXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGVbJ2JyZWFrJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KEJSRUFLKTtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJlbW92ZSBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShSRU1PVkUpO1xuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5fX2luaXRpYWxpemUgPSBmdW5jdGlvbihyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHRoaXMudmlzaXRvciA9IHZpc2l0b3I7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuX193b3JrbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9fbGVhdmVsaXN0ID0gW107XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2ZhbGxiYWNrID0gdmlzaXRvci5mYWxsYmFjayA9PT0gJ2l0ZXJhdGlvbic7XG4gICAgICAgIHRoaXMuX19rZXlzID0gVmlzaXRvcktleXM7XG4gICAgICAgIGlmICh2aXNpdG9yLmtleXMpIHtcbiAgICAgICAgICAgIHRoaXMuX19rZXlzID0gZXh0ZW5kKG9iamVjdENyZWF0ZSh0aGlzLl9fa2V5cyksIHZpc2l0b3Iua2V5cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5vZGUudHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQcm9wZXJ0eShub2RlVHlwZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAobm9kZVR5cGUgPT09IFN5bnRheC5PYmplY3RFeHByZXNzaW9uIHx8IG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0UGF0dGVybikgJiYgJ3Byb3BlcnRpZXMnID09PSBrZXk7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWw7XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG51bGwpKTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2gobmV3IEVsZW1lbnQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgcmV0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG5cbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHJldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCByZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGVsZW1lbnQud3JhcCB8fCBub2RlLnR5cGU7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19rZXlzW25vZGVUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IG9iamVjdEtleXMobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlVHlwZSArICcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50IC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FuZGlkYXRlc1tjdXJyZW50XTtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50MiA9IGNhbmRpZGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5KG5vZGVUeXBlLCBjYW5kaWRhdGVzW2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCAnUHJvcGVydHknLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGVbY3VycmVudDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChuZXcgRWxlbWVudChjYW5kaWRhdGUsIGtleSwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWxlbShlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmV4dEVsZW0sXG4gICAgICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5yZWYucmVtb3ZlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSByZWZlcmVuY2UgaXMgYW4gZWxlbWVudCBvZiBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICBrZXkgPSBlbGVtZW50LnJlZi5rZXk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudC5yZWYucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVtb3ZlZCBmcm9tIGFycmF5LCB0aGVuIGRlY3JlYXNlIGZvbGxvd2luZyBpdGVtcycga2V5cy5cbiAgICAgICAgICAgICAgICBpID0gd29ya2xpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsZW0gPSB3b3JrbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtLnJlZiAmJiBuZXh0RWxlbS5yZWYucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICAobmV4dEVsZW0ucmVmLmtleSA8IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLS1uZXh0RWxlbS5yZWYua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtsaXN0LFxuICAgICAgICAgICAgbGVhdmVsaXN0LFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG5vZGVUeXBlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjdXJyZW50MixcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgICBzZW50aW5lbCxcbiAgICAgICAgICAgIG91dGVyLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplKHJvb3QsIHZpc2l0b3IpO1xuXG4gICAgICAgIHNlbnRpbmVsID0ge307XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICAgIHdvcmtsaXN0ID0gdGhpcy5fX3dvcmtsaXN0O1xuICAgICAgICBsZWF2ZWxpc3QgPSB0aGlzLl9fbGVhdmVsaXN0O1xuXG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgb3V0ZXIgPSB7XG4gICAgICAgICAgICByb290OiByb290XG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChyb290LCBudWxsLCBudWxsLCBuZXcgUmVmZXJlbmNlKG91dGVyLCAncm9vdCcpKTtcbiAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgd2hpbGUgKHdvcmtsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHdvcmtsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGVhdmVsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5sZWF2ZSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBiZSByZXBsYWNlZCB3aXRoIG51bGwsXG4gICAgICAgICAgICAgICAgLy8gc28gZGlzdGluZ3Vpc2ggYmV0d2VlbiB1bmRlZmluZWQgYW5kIG51bGwgaW4gdGhpcyBwbGFjZVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCAmJiB0YXJnZXQgIT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVmLnJlcGxhY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBSRU1PVkUgfHwgdGFyZ2V0ID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWxlbShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCB0YXJnZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5lbnRlciwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIHJlcGxhY2VkIHdpdGggbnVsbCxcbiAgICAgICAgICAgIC8vIHNvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdW5kZWZpbmVkIGFuZCBudWxsIGluIHRoaXMgcGxhY2VcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCAmJiB0YXJnZXQgIT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlZi5yZXBsYWNlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ub2RlID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBSRU1PVkUgfHwgdGFyZ2V0ID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHRhcmdldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgbnVsbFxuICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3b3JrbGlzdC5wdXNoKHNlbnRpbmVsKTtcbiAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBTS0lQIHx8IHRhcmdldCA9PT0gU0tJUCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlVHlwZSA9IGVsZW1lbnQud3JhcCB8fCBub2RlLnR5cGU7XG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gdGhpcy5fX2tleXNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gb2JqZWN0S2V5cyhub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlICcgKyBub2RlVHlwZSArICcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGtleSA9IGNhbmRpZGF0ZXNbY3VycmVudF07XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlID0gbm9kZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDIgPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlW2N1cnJlbnQyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHkobm9kZVR5cGUsIGNhbmRpZGF0ZXNbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgJ1Byb3BlcnR5JywgbmV3IFJlZmVyZW5jZShjYW5kaWRhdGUsIGN1cnJlbnQyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGVbY3VycmVudDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sIG51bGwsIG5ldyBSZWZlcmVuY2UoY2FuZGlkYXRlLCBjdXJyZW50MikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2gobmV3IEVsZW1lbnQoY2FuZGlkYXRlLCBrZXksIG51bGwsIG5ldyBSZWZlcmVuY2Uobm9kZSwga2V5KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIudHJhdmVyc2Uocm9vdCwgdmlzaXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIucmVwbGFjZShyb290LCB2aXNpdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmRDb21tZW50UmFuZ2UoY29tbWVudCwgdG9rZW5zKSB7XG4gICAgICAgIHZhciB0YXJnZXQ7XG5cbiAgICAgICAgdGFyZ2V0ID0gdXBwZXJCb3VuZCh0b2tlbnMsIGZ1bmN0aW9uIHNlYXJjaCh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLnJhbmdlWzBdID4gY29tbWVudC5yYW5nZVswXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gW2NvbW1lbnQucmFuZ2VbMF0sIGNvbW1lbnQucmFuZ2VbMV1dO1xuXG4gICAgICAgIGlmICh0YXJnZXQgIT09IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVsxXSA9IHRva2Vuc1t0YXJnZXRdLnJhbmdlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0IC09IDE7XG4gICAgICAgIGlmICh0YXJnZXQgPj0gMCkge1xuICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdID0gdG9rZW5zW3RhcmdldF0ucmFuZ2VbMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhdHRhY2hDb21tZW50cyh0cmVlLCBwcm92aWRlZENvbW1lbnRzLCB0b2tlbnMpIHtcbiAgICAgICAgLy8gQXQgZmlyc3QsIHdlIHNob3VsZCBjYWxjdWxhdGUgZXh0ZW5kZWQgY29tbWVudCByYW5nZXMuXG4gICAgICAgIHZhciBjb21tZW50cyA9IFtdLCBjb21tZW50LCBsZW4sIGksIGN1cnNvcjtcblxuICAgICAgICBpZiAoIXRyZWUucmFuZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0YWNoQ29tbWVudHMgbmVlZHMgcmFuZ2UgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRva2VucyBhcnJheSBpcyBlbXB0eSwgd2UgYXR0YWNoIGNvbW1lbnRzIHRvIHRyZWUgYXMgJ2xlYWRpbmdDb21tZW50cydcbiAgICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAocHJvdmlkZWRDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlID0gWzAsIHRyZWUucmFuZ2VbMF1dO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlLmxlYWRpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm92aWRlZENvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb21tZW50cy5wdXNoKGV4dGVuZENvbW1lbnRSYW5nZShkZWVwQ29weShwcm92aWRlZENvbW1lbnRzW2ldKSwgdG9rZW5zKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGlzIGJhc2VkIG9uIEpvaG4gRnJlZW1hbidzIGltcGxlbWVudGF0aW9uLlxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPiBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPT09IG5vZGUucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjdXJzb3IgPSAwO1xuICAgICAgICB0cmF2ZXJzZSh0cmVlLCB7XG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IgPCBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW2N1cnNvcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdIDwgY29tbWVudC5leHRlbmRlZFJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnJhbmdlWzFdID09PSBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnNwbGljZShjdXJzb3IsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG91dCBvZiBvd25lZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciA9PT0gY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLkJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tjdXJzb3JdLmV4dGVuZGVkUmFuZ2VbMF0gPiBub2RlLnJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSAnMS44LjEtZGV2JztcbiAgICBleHBvcnRzLlN5bnRheCA9IFN5bnRheDtcbiAgICBleHBvcnRzLnRyYXZlcnNlID0gdHJhdmVyc2U7XG4gICAgZXhwb3J0cy5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBleHBvcnRzLmF0dGFjaENvbW1lbnRzID0gYXR0YWNoQ29tbWVudHM7XG4gICAgZXhwb3J0cy5WaXNpdG9yS2V5cyA9IFZpc2l0b3JLZXlzO1xuICAgIGV4cG9ydHMuVmlzaXRvck9wdGlvbiA9IFZpc2l0b3JPcHRpb247XG4gICAgZXhwb3J0cy5Db250cm9sbGVyID0gQ29udHJvbGxlcjtcbiAgICBleHBvcnRzLmNsb25lRW52aXJvbm1lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjbG9uZSh7fSk7IH07XG5cbiAgICByZXR1cm4gZXhwb3J0cztcbn0pKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgJ0FTIElTJ1xuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIGlzRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdDb25kaXRpb25hbEV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnRnVuY3Rpb25FeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgICAgICBjYXNlICdMb2dpY2FsRXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ05ld0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnT2JqZWN0RXhwcmVzc2lvbic6XG4gICAgICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnVGhpc0V4cHJlc3Npb24nOlxuICAgICAgICAgICAgY2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGlvblN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdEb1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvckluU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdXaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0Jsb2NrU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0RlYnVnZ2VyU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRW1wdHlTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnRXhwcmVzc2lvblN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdGb3JJblN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdGb3JTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnTGFiZWxlZFN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdSZXR1cm5TdGF0ZW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnU3dpdGNoU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1Rocm93U3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1RyeVN0YXRlbWVudCc6XG4gICAgICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ1dpdGhTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NvdXJjZUVsZW1lbnQobm9kZSkge1xuICAgICAgcmV0dXJuIGlzU3RhdGVtZW50KG5vZGUpIHx8IG5vZGUgIT0gbnVsbCAmJiBub2RlLnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFpbGluZ1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0lmU3RhdGVtZW50JzpcbiAgICAgICAgICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29uc2VxdWVudDtcblxuICAgICAgICBjYXNlICdMYWJlbGVkU3RhdGVtZW50JzpcbiAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgY2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuICAgICAgICBjYXNlICdXaGlsZVN0YXRlbWVudCc6XG4gICAgICAgIGNhc2UgJ1dpdGhTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuYm9keTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgY3VycmVudDtcblxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gbm9kZS5jb25zZXF1ZW50O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC50eXBlID09PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlID09IG51bGwpICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSB0cmFpbGluZ1N0YXRlbWVudChjdXJyZW50KTtcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudCk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0V4cHJlc3Npb246IGlzRXhwcmVzc2lvbixcbiAgICAgICAgaXNTdGF0ZW1lbnQ6IGlzU3RhdGVtZW50LFxuICAgICAgICBpc0l0ZXJhdGlvblN0YXRlbWVudDogaXNJdGVyYXRpb25TdGF0ZW1lbnQsXG4gICAgICAgIGlzU291cmNlRWxlbWVudDogaXNTb3VyY2VFbGVtZW50LFxuICAgICAgICBpc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQ6IGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudCxcblxuICAgICAgICB0cmFpbGluZ1N0YXRlbWVudDogdHJhaWxpbmdTdGF0ZW1lbnRcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxNCBJdmFuIE5pa3VsaW4gPGlmYWFhbkBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgUmVnZXgsIE5PTl9BU0NJSV9XSElURVNQQUNFUztcblxuICAgIC8vIFNlZSBgdG9vbHMvZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG4gICAgUmVnZXggPSB7XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTBcXHUwOEEyLVxcdTA4QUNcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3RlxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzMzXFx1MEMzNS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGMFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxQ1xcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjk3XFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBNzkzXFx1QTdBMC1cXHVBN0FBXFx1QTdGOC1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE4MC1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJyksXG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTBcXHUwOEEyLVxcdTA4QUNcXHUwOEU0LVxcdTA4RkVcXHUwOTAwLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N0ZcXHUwOTgxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMS1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzMzXFx1MEMzNS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODJcXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAyXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDYwLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjBcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxQ1xcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxRDAwLVxcdTFERTZcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNjk3XFx1QTY5Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBNzkzXFx1QTdBMC1cXHVBN0FBXFx1QTdGOC1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdCXFx1QUE4MC1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyNlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDQ4ICYmIGNoIDw9IDU3KTsgICAvLyAwLi45XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gaXNEZWNpbWFsRGlnaXQoY2gpIHx8ICAgIC8vIDAuLjlcbiAgICAgICAgICAgICg5NyA8PSBjaCAmJiBjaCA8PSAxMDIpIHx8ICAvLyBhLi5mXG4gICAgICAgICAgICAoNjUgPD0gY2ggJiYgY2ggPD0gNzApOyAgICAgLy8gQS4uRlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDQ4ICYmIGNoIDw9IDU1KTsgICAvLyAwLi43XG4gICAgfVxuXG4gICAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgICBOT05fQVNDSUlfV0hJVEVTUEFDRVMgPSBbXG4gICAgICAgIDB4MTY4MCwgMHgxODBFLFxuICAgICAgICAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSxcbiAgICAgICAgMHgyMDJGLCAweDIwNUYsXG4gICAgICAgIDB4MzAwMCxcbiAgICAgICAgMHhGRUZGXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XG4gICAgICAgICAgICAoY2ggPj0gMHgxNjgwICYmIE5PTl9BU0NJSV9XSElURVNQQUNFUy5pbmRleE9mKGNoKSA+PSAwKTtcbiAgICB9XG5cbiAgICAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gICAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XG4gICAgfVxuXG4gICAgLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDk3ICYmIGNoIDw9IDEyMikgfHwgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA+PSA2NSAmJiBjaCA8PSA5MCkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgICAoY2ggPT09IDM2KSB8fCAoY2ggPT09IDk1KSB8fCAgICAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAgIChjaCA9PT0gOTIpIHx8ICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDk3ICYmIGNoIDw9IDEyMikgfHwgICAgIC8vIGEuLnpcbiAgICAgICAgICAgIChjaCA+PSA2NSAmJiBjaCA8PSA5MCkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgICAoY2ggPj0gNDggJiYgY2ggPD0gNTcpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgICAgKGNoID09PSAzNikgfHwgKGNoID09PSA5NSkgfHwgICAgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgICAoY2ggPT09IDkyKSB8fCAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzRGVjaW1hbERpZ2l0OiBpc0RlY2ltYWxEaWdpdCxcbiAgICAgICAgaXNIZXhEaWdpdDogaXNIZXhEaWdpdCxcbiAgICAgICAgaXNPY3RhbERpZ2l0OiBpc09jdGFsRGlnaXQsXG4gICAgICAgIGlzV2hpdGVTcGFjZTogaXNXaGl0ZVNwYWNlLFxuICAgICAgICBpc0xpbmVUZXJtaW5hdG9yOiBpc0xpbmVUZXJtaW5hdG9yLFxuICAgICAgICBpc0lkZW50aWZpZXJTdGFydDogaXNJZGVudGlmaWVyU3RhcnQsXG4gICAgICAgIGlzSWRlbnRpZmllclBhcnQ6IGlzSWRlbnRpZmllclBhcnRcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGNvZGUgPSByZXF1aXJlKCcuL2NvZGUnKTtcblxuICAgIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZEVTNihpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZEVTNShpZCwgc3RyaWN0KSB7XG4gICAgICAgIC8vIHlpZWxkIHNob3VsZCBub3QgYmUgdHJlYXRlZCBhcyBrZXl3b3JkIHVuZGVyIG5vbi1zdHJpY3QgbW9kZS5cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgaWQgPT09ICd5aWVsZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkRVM2KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fCAoaWQgPT09ICd0cnknKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxuICAgICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXNlcnZlZFdvcmRFUzUoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdudWxsJyB8fCBpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnIHx8IGlzS2V5d29yZEVTNShpZCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Jlc2VydmVkV29yZEVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpZCA9PT0gJ251bGwnIHx8IGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScgfHwgaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVzdHJpY3RlZFdvcmQoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUoaWQpIHtcbiAgICAgICAgdmFyIGksIGl6LCBjaDtcblxuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmICghY29kZS5pc0lkZW50aWZpZXJTdGFydChjaCkgfHwgY2ggPT09IDkyKSB7ICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMSwgaXogPSBpZC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoIWNvZGUuaXNJZGVudGlmaWVyUGFydChjaCkgfHwgY2ggPT09IDkyKSB7ICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJFUzUoaWQsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gaXNJZGVudGlmaWVyTmFtZShpZCkgJiYgIWlzUmVzZXJ2ZWRXb3JkRVM1KGlkLCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllckVTNihpZCwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBpc0lkZW50aWZpZXJOYW1lKGlkKSAmJiAhaXNSZXNlcnZlZFdvcmRFUzYoaWQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzS2V5d29yZEVTNTogaXNLZXl3b3JkRVM1LFxuICAgICAgICBpc0tleXdvcmRFUzY6IGlzS2V5d29yZEVTNixcbiAgICAgICAgaXNSZXNlcnZlZFdvcmRFUzU6IGlzUmVzZXJ2ZWRXb3JkRVM1LFxuICAgICAgICBpc1Jlc2VydmVkV29yZEVTNjogaXNSZXNlcnZlZFdvcmRFUzYsXG4gICAgICAgIGlzUmVzdHJpY3RlZFdvcmQ6IGlzUmVzdHJpY3RlZFdvcmQsXG4gICAgICAgIGlzSWRlbnRpZmllck5hbWU6IGlzSWRlbnRpZmllck5hbWUsXG4gICAgICAgIGlzSWRlbnRpZmllckVTNTogaXNJZGVudGlmaWVyRVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJFUzY6IGlzSWRlbnRpZmllckVTNlxuICAgIH07XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGV4cG9ydHMuYXN0ID0gcmVxdWlyZSgnLi9hc3QnKTtcbiAgICBleHBvcnRzLmNvZGUgPSByZXF1aXJlKCcuL2NvZGUnKTtcbiAgICBleHBvcnRzLmtleXdvcmQgPSByZXF1aXJlKCcuL2tleXdvcmQnKTtcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICAgKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAgICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICAgKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gICAqL1xuICBmdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NldCA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICAgKi9cbiAgQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHZhciBpc0R1cGxpY2F0ZSA9IHRoaXMuaGFzKGFTdHIpO1xuICAgIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICAgIH1cbiAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICB0aGlzLl9zZXRbdXRpbC50b1NldFN0cmluZyhhU3RyKV0gPSBpZHg7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC50b1NldFN0cmluZyhhU3RyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gICAgaWYgKHRoaXMuaGFzKGFTdHIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICAgKlxuICAgKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICAgKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICAgKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICAgKi9cbiAgQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xuICB9O1xuXG4gIGV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4gIC8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuICAvLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbiAgLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4gIC8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbiAgLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4gIC8vXG4gIC8vICAgQ29udGludWF0aW9uXG4gIC8vICAgfCAgICBTaWduXG4gIC8vICAgfCAgICB8XG4gIC8vICAgViAgICBWXG4gIC8vICAgMTAxMDExXG5cbiAgdmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuICAvLyBiaW5hcnk6IDEwMDAwMFxuICB2YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4gIC8vIGJpbmFyeTogMDExMTExXG4gIHZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICAgKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICAgKi9cbiAgZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gICAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICAgKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAgICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gICAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gICAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgICAgPyAtc2hpZnRlZFxuICAgICAgOiBzaGlmdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gICAqL1xuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gICAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICAgIHZhciBkaWdpdDtcblxuICAgIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gICAgZG8ge1xuICAgICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgICBpZiAodmxxID4gMCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICAgIH1cbiAgICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gICAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgICByZXR1cm4gZW5jb2RlZDtcbiAgfTtcblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gICAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhT3V0UGFyYW0pIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoaSA+PSBzdHJMZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgICAgfVxuICAgICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckF0KGkrKykpO1xuICAgICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICAgIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gICAgYU91dFBhcmFtLnJlc3QgPSBhU3RyLnNsaWNlKGkpO1xuICB9O1xuXG59KTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGNoYXJUb0ludE1hcCA9IHt9O1xuICB2YXIgaW50VG9DaGFyTWFwID0ge307XG5cbiAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG4gICAgLnNwbGl0KCcnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChjaCwgaW5kZXgpIHtcbiAgICAgIGNoYXJUb0ludE1hcFtjaF0gPSBpbmRleDtcbiAgICAgIGludFRvQ2hhck1hcFtpbmRleF0gPSBjaDtcbiAgICB9KTtcblxuICAvKipcbiAgICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0X2VuY29kZShhTnVtYmVyKSB7XG4gICAgaWYgKGFOdW1iZXIgaW4gaW50VG9DaGFyTWFwKSB7XG4gICAgICByZXR1cm4gaW50VG9DaGFyTWFwW2FOdW1iZXJdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIGFOdW1iZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBkaWdpdCB0byBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZGVjb2RlKGFDaGFyKSB7XG4gICAgaWYgKGFDaGFyIGluIGNoYXJUb0ludE1hcCkge1xuICAgICAgcmV0dXJuIGNoYXJUb0ludE1hcFthQ2hhcl07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgYSB2YWxpZCBiYXNlIDY0IGRpZ2l0OiBcIiArIGFDaGFyKTtcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICAgKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gICAqL1xuICBmdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAvL1xuICAgIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgICAvLyAgICAgIHRoZSBuZXh0IGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIGxlc3MgdGhhbiB0aGF0IGVsZW1lbnQuXG4gICAgLy9cbiAgICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAgIC8vICAgICAgZWxlbWVudCB3aGljaCBpcyBsZXNzIHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2VcbiAgICAvLyAgICAgIHJldHVybiAtMS5cbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIC8vIGFIYXlzdGFja1ttaWRdIGlzIGdyZWF0ZXIgdGhhbiBvdXIgbmVlZGxlLlxuICAgICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGRpZCBub3QgZmluZCBhbiBleGFjdCBtYXRjaCwgcmV0dXJuIHRoZSBuZXh0IGNsb3Nlc3Qgb25lXG4gICAgICAvLyAodGVybWluYXRpb24gY2FzZSAyKS5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gYUhheXN0YWNrW21pZF0gaXMgbGVzcyB0aGFuIG91ciBuZWVkbGUuXG4gICAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDIpIG9yICgzKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gICAqIHRoZSBpbmRleCBvZiBuZXh0IGxvd2VzdCB2YWx1ZSBjaGVja2VkIGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpc1xuICAgKiBiZWNhdXNlIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlXG4gICAqIHBvaW50cywgYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzXG4gICAqIGp1c3QgbWVhbnMgdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICAgKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICAgKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gICAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gICAqL1xuICBleHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlKSB7XG4gICAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSlcbiAgfTtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAgICogcG9zaXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAgIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICAgIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gICAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAgICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gICAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gICAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gICAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAgICpcbiAgICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICAgKi9cbiAgTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICAgIHZhciBtYXBwaW5nO1xuICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gICAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAgICpcbiAgICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gICAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICAgKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICAgKiBjb3B5LlxuICAgKi9cbiAgTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICAgIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcbiAgICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hcnJheTtcbiAgfTtcblxuICBleHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcblxuICAvKipcbiAgICogQSBTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gICAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICAgKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gICAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAgICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAgICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gICAqXG4gICAqICAgICB7XG4gICAqICAgICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICAgKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAgICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICAgKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAgICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gICAqICAgICB9XG4gICAqXG4gICAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gICAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gICAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAgIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gICAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICAgIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gICAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gICAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgc291cmNlcyA9IHNvdXJjZXMubWFwKHV0aWwubm9ybWFsaXplKTtcblxuICAgIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAgIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gICAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMsIHRydWUpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gICAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gICAqIEByZXR1cm5zIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICAgIHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICAgIHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcblxuICAgICAgc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICAgIHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKVxuICAgICAgICAuc29ydCh1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgICAgcmV0dXJuIHNtYztcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbiAgLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbiAgLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuICAvLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbiAgLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4gIC8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbiAgLy9cbiAgLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbiAgLy9cbiAgLy8gICAgIHtcbiAgLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbiAgLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4gIC8vICAgICAgICAgICAgIGNvZGUuXG4gIC8vICAgICB9XG4gIC8vXG4gIC8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbiAgLy8gYG51bGxgLlxuICAvL1xuICAvLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuICAvL1xuICAvLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgfVxuICB9KTtcblxuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX25leHRDaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyKSB7XG4gICAgICB2YXIgYyA9IGFTdHIuY2hhckF0KDApO1xuICAgICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAgICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gICAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHN0ciA9IGFTdHI7XG4gICAgICB2YXIgdGVtcCA9IHt9O1xuICAgICAgdmFyIG1hcHBpbmc7XG5cbiAgICAgIHdoaWxlIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJzsnKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJywnKSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmcgPSB7fTtcbiAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKHN0ciwgdGVtcCk7XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHRlbXAudmFsdWU7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG5cbiAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIXRoaXMuX25leHRDaGFySXNNYXBwaW5nU2VwYXJhdG9yKHN0cikpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoc3RyLCB0ZW1wKTtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5fc291cmNlcy5hdChwcmV2aW91c1NvdXJjZSArIHRlbXAudmFsdWUpO1xuICAgICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IHRoaXMuX25leHRDaGFySXNNYXBwaW5nU2VwYXJhdG9yKHN0cikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShzdHIsIHRlbXApO1xuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHRlbXAudmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDAgfHwgdGhpcy5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3Ioc3RyKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoc3RyLCB0ZW1wKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuICAgICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDAgJiYgIXRoaXMuX25leHRDaGFySXNNYXBwaW5nU2VwYXJhdG9yKHN0cikpIHtcbiAgICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShzdHIsIHRlbXApO1xuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSB0aGlzLl9uYW1lcy5hdChwcmV2aW91c05hbWUgKyB0ZW1wLnZhbHVlKTtcbiAgICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAgICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvcikge1xuICAgICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvcik7XG4gICAgfTtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICAgKiBpbmNsdXNpdmUuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbmVyYXRlZENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnMpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbmFtZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAgICogYXZhaWxpYmxlLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgICB9XG5cbiAgICAgIHZhciB1cmw7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gICAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZVxuICAgKiBhbmQgbGluZSBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byBJbmZpbml0eSwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0XG4gICAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogSW5maW5pdHlcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG5lZWRsZS5vcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWy0taW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXBwaW5ncy5yZXZlcnNlKCk7XG4gICAgfTtcblxuICBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuICBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAgICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICAgKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gICAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAgICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gICAqIEBwYXJhbSBhT3JkZXJcbiAgICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAgICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gICAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICAgIHZhciBtYXBwaW5ncztcbiAgICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH0pLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuICAvKipcbiAgICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICAgKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgICBpZiAoIWFBcmdzKSB7XG4gICAgICBhQXJncyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gICAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gIH1cblxuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICAgKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICAgKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gICAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gICAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICAgKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAgICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAgICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICAgKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAgICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gICAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAgICpcbiAgICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICAgKiAgICAgIHRva2VuLlxuICAgKlxuICAgKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAgICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgICAvLyBDYXNlIDEuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICAgKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbWFwcGluZztcblxuICAgICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUodGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcblxuICAgICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSlcbiAgICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuICAvLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG4gIHZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbiAgLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG4gIHZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuICAvLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4gIC8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4gIC8vIHZlcnNpb25zIVxuICB2YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuICAvKipcbiAgICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICAgKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAgICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gICAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICAgKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICAgKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAgICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICAgIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gICAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICAgKlxuICAgKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gICAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gICAqL1xuICBTb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXksIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluZUNvbnRlbnRzID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKTtcbiAgICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgICB2YXIgbmV3TGluZSA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG4gICAgICB9O1xuXG4gICAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICAgIGlmIChyZW1haW5pbmdMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5qb2luKFwiXCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGFDaHVuaykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gICAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAgICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICAgIHZhciBjaHVuaztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICAgKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAgICpcbiAgICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICAgIHZhciBuZXdDaGlsZHJlbjtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgICAgfVxuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICAgKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAgICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gICAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAgICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzdHIgKz0gY2h1bms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICAgKiBtYXAuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgICBjb2RlOiBcIlwiLFxuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xuICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICAgKiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAgICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICAgKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICAgIH1cbiAgfVxuICBleHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxuICB2YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbiAgdmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG4gIGZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgICBob3N0OiBtYXRjaFszXSxcbiAgICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgICAgcGF0aDogbWF0Y2hbNV1cbiAgICB9O1xuICB9XG4gIGV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuICBmdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gICAgdmFyIHVybCA9ICcnO1xuICAgIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICAgIH1cbiAgICB1cmwgKz0gJy8vJztcbiAgICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICAgIH1cbiAgICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICAgKlxuICAgKiAtIFJlcGxhY2VzIGNvbnNlcXV0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gICAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICAgKlxuICAgKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgICB2YXIgcGF0aCA9IGFQYXRoO1xuICAgIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gICAgaWYgKHVybCkge1xuICAgICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgICByZXR1cm4gYVBhdGg7XG4gICAgICB9XG4gICAgICBwYXRoID0gdXJsLnBhdGg7XG4gICAgfVxuICAgIHZhciBpc0Fic29sdXRlID0gKHBhdGguY2hhckF0KDApID09PSAnLycpO1xuXG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICAgIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICB1cCsrO1xuICAgICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgICAgdXAgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICB1cC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICAgIH1cblxuICAgIGlmICh1cmwpIHtcbiAgICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBleHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuICAvKipcbiAgICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gICAqXG4gICAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAgICpcbiAgICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAgICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gICAqICAgZmlyc3QuXG4gICAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICAgKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAgICogICBpcyByZXR1cm5lZC5cbiAgICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICAgKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gICAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICAgIGFSb290ID0gXCIuXCI7XG4gICAgfVxuICAgIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgICAgYVBhdGggPSBcIi5cIjtcbiAgICB9XG4gICAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgICAgaWYgKGFSb290VXJsKSB7XG4gICAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gICAgfVxuXG4gICAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gICAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgPyBhUGF0aFxuICAgICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gam9pbmVkO1xuICB9XG4gIGV4cG9ydHMuam9pbiA9IGpvaW47XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICAgKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gICAqL1xuICBmdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICAgIGFSb290ID0gXCIuXCI7XG4gICAgfVxuXG4gICAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gICAgLy8gWFhYOiBJdCBpcyBwb3NzaWJsZSB0byByZW1vdmUgdGhpcyBibG9jaywgYW5kIHRoZSB0ZXN0cyBzdGlsbCBwYXNzIVxuICAgIHZhciB1cmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gICAgaWYgKGFQYXRoLmNoYXJBdCgwKSA9PSBcIi9cIiAmJiB1cmwgJiYgdXJsLnBhdGggPT0gXCIvXCIpIHtcbiAgICAgIHJldHVybiBhUGF0aC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgPT09IDBcbiAgICAgID8gYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpXG4gICAgICA6IGFQYXRoO1xuICB9XG4gIGV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxuICAvKipcbiAgICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICAgKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gICAqXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG4gIGV4cG9ydHMudG9TZXRTdHJpbmcgPSB0b1NldFN0cmluZztcblxuICBmdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgICByZXR1cm4gYVN0ci5zdWJzdHIoMSk7XG4gIH1cbiAgZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gZnJvbVNldFN0cmluZztcblxuICBmdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gICAgdmFyIHMxID0gYVN0cjEgfHwgXCJcIjtcbiAgICB2YXIgczIgPSBhU3RyMiB8fCBcIlwiO1xuICAgIHJldHVybiAoczEgPiBzMikgLSAoczEgPCBzMik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAgICpcbiAgICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICAgKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAgICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAgICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHZhciBjbXA7XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICB9O1xuICBleHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlXG4gICAqIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICAgKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICAgKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICB2YXIgY21wO1xuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zO1xuXG59KTtcbiIsIi8qKiB2aW06IGV0OnRzPTQ6c3c9NDpzdHM9NFxuICogQGxpY2Vuc2UgYW1kZWZpbmUgMC4xLjAgQ29weXJpZ2h0IChjKSAyMDExLCBUaGUgRG9qbyBGb3VuZGF0aW9uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBBdmFpbGFibGUgdmlhIHRoZSBNSVQgb3IgbmV3IEJTRCBsaWNlbnNlLlxuICogc2VlOiBodHRwOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL2FtZGVmaW5lIGZvciBkZXRhaWxzXG4gKi9cblxuLypqc2xpbnQgbm9kZTogdHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCBwcm9jZXNzICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlZmluZSBmb3Igbm9kZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgdGhlIFwibW9kdWxlXCIgb2JqZWN0IHRoYXQgaXMgZGVmaW5lZCBieSBOb2RlIGZvciB0aGVcbiAqIGN1cnJlbnQgbW9kdWxlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlcXVpcmVGbl0uIE5vZGUncyByZXF1aXJlIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudCBtb2R1bGUuXG4gKiBJdCBvbmx5IG5lZWRzIHRvIGJlIHBhc3NlZCBpbiBOb2RlIHZlcnNpb25zIGJlZm9yZSAwLjUsIHdoZW4gbW9kdWxlLnJlcXVpcmVcbiAqIGRpZCBub3QgZXhpc3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZGVmaW5lIGZ1bmN0aW9uIHRoYXQgaXMgdXNhYmxlIGZvciB0aGUgY3VycmVudCBub2RlXG4gKiBtb2R1bGUuXG4gKi9cbmZ1bmN0aW9uIGFtZGVmaW5lKG1vZHVsZSwgcmVxdWlyZUZuKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBkZWZpbmVDYWNoZSA9IHt9LFxuICAgICAgICBsb2FkZXJDYWNoZSA9IHt9LFxuICAgICAgICBhbHJlYWR5Q2FsbGVkID0gZmFsc2UsXG4gICAgICAgIHBhdGggPSByZXF1aXJlKCdwYXRoJyksXG4gICAgICAgIG1ha2VSZXF1aXJlLCBzdHJpbmdSZXF1aXJlO1xuXG4gICAgLyoqXG4gICAgICogVHJpbXMgdGhlIC4gYW5kIC4uIGZyb20gYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKiBJdCB3aWxsIGtlZXAgYSBsZWFkaW5nIHBhdGggc2VnbWVudCBpZiBhIC4uIHdpbGwgYmVjb21lXG4gICAgICogdGhlIGZpcnN0IHBhdGggc2VnbWVudCwgdG8gaGVscCB3aXRoIG1vZHVsZSBuYW1lIGxvb2t1cHMsXG4gICAgICogd2hpY2ggYWN0IGxpa2UgcGF0aHMsIGJ1dCBjYW4gYmUgcmVtYXBwZWQuIEJ1dCB0aGUgZW5kIHJlc3VsdCxcbiAgICAgKiBhbGwgcGF0aHMgdGhhdCB1c2UgdGhpcyBmdW5jdGlvbiBzaG91bGQgbG9vayBub3JtYWxpemVkLlxuICAgICAqIE5PVEU6IHRoaXMgbWV0aG9kIE1PRElGSUVTIHRoZSBpbnB1dCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnkgdGhlIGFycmF5IG9mIHBhdGggc2VnbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbURvdHMoYXJ5KSB7XG4gICAgICAgIHZhciBpLCBwYXJ0O1xuICAgICAgICBmb3IgKGkgPSAwOyBhcnlbaV07IGkrPSAxKSB7XG4gICAgICAgICAgICBwYXJ0ID0gYXJ5W2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGFyeS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgKGFyeVsyXSA9PT0gJy4uJyB8fCBhcnlbMF0gPT09ICcuLicpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vRW5kIG9mIHRoZSBsaW5lLiBLZWVwIGF0IGxlYXN0IG9uZSBub24tZG90XG4gICAgICAgICAgICAgICAgICAgIC8vcGF0aCBzZWdtZW50IGF0IHRoZSBmcm9udCBzbyBpdCBjYW4gYmUgbWFwcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vY29ycmVjdGx5IHRvIGRpc2suIE90aGVyd2lzZSwgdGhlcmUgaXMgbGlrZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vbm8gcGF0aCBtYXBwaW5nIGZvciBhIHBhdGggc3RhcnRpbmcgd2l0aCAnLi4nLlxuICAgICAgICAgICAgICAgICAgICAvL1RoaXMgY2FuIHN0aWxsIGZhaWwsIGJ1dCBjYXRjaGVzIHRoZSBtb3N0IHJlYXNvbmFibGVcbiAgICAgICAgICAgICAgICAgICAgLy91c2VzIG9mIC4uXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpIC0gMSwgMik7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemUobmFtZSwgYmFzZU5hbWUpIHtcbiAgICAgICAgdmFyIGJhc2VQYXJ0cztcblxuICAgICAgICAvL0FkanVzdCBhbnkgcmVsYXRpdmUgcGF0aHMuXG4gICAgICAgIGlmIChuYW1lICYmIG5hbWUuY2hhckF0KDApID09PSAnLicpIHtcbiAgICAgICAgICAgIC8vSWYgaGF2ZSBhIGJhc2UgbmFtZSwgdHJ5IHRvIG5vcm1hbGl6ZSBhZ2FpbnN0IGl0LFxuICAgICAgICAgICAgLy9vdGhlcndpc2UsIGFzc3VtZSBpdCBpcyBhIHRvcC1sZXZlbCByZXF1aXJlIHRoYXQgd2lsbFxuICAgICAgICAgICAgLy9iZSByZWxhdGl2ZSB0byBiYXNlVXJsIGluIHRoZSBlbmQuXG4gICAgICAgICAgICBpZiAoYmFzZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlTmFtZS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5zbGljZSgwLCBiYXNlUGFydHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLmNvbmNhdChuYW1lLnNwbGl0KCcvJykpO1xuICAgICAgICAgICAgICAgIHRyaW1Eb3RzKGJhc2VQYXJ0cyk7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGJhc2VQYXJ0cy5qb2luKCcvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIG5vcm1hbGl6ZSgpIGZ1bmN0aW9uIHBhc3NlZCB0byBhIGxvYWRlciBwbHVnaW4nc1xuICAgICAqIG5vcm1hbGl6ZSBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZU5vcm1hbGl6ZShyZWxOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlTG9hZChpZCkge1xuICAgICAgICBmdW5jdGlvbiBsb2FkKHZhbHVlKSB7XG4gICAgICAgICAgICBsb2FkZXJDYWNoZVtpZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWQuZnJvbVRleHQgPSBmdW5jdGlvbiAoaWQsIHRleHQpIHtcbiAgICAgICAgICAgIC8vVGhpcyBvbmUgaXMgZGlmZmljdWx0IGJlY2F1c2UgdGhlIHRleHQgY2FuL3Byb2JhYmx5IHVzZXNcbiAgICAgICAgICAgIC8vZGVmaW5lLCBhbmQgYW55IHJlbGF0aXZlIHBhdGhzIGFuZCByZXF1aXJlcyBzaG91bGQgYmUgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vdG8gdGhhdCBpZCB3YXMgaXQgd291bGQgYmUgZm91bmQgb24gZGlzay4gQnV0IHRoaXMgd291bGQgcmVxdWlyZVxuICAgICAgICAgICAgLy9ib290c3RyYXBwaW5nIGEgbW9kdWxlL3JlcXVpcmUgZmFpcmx5IGRlZXBseSBmcm9tIG5vZGUgY29yZS5cbiAgICAgICAgICAgIC8vTm90IHN1cmUgaG93IGJlc3QgdG8gZ28gYWJvdXQgdGhhdCB5ZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtZGVmaW5lIGRvZXMgbm90IGltcGxlbWVudCBsb2FkLmZyb21UZXh0Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGxvYWQ7XG4gICAgfVxuXG4gICAgbWFrZVJlcXVpcmUgPSBmdW5jdGlvbiAoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCkge1xuICAgICAgICBmdW5jdGlvbiBhbWRSZXF1aXJlKGRlcHMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy9TeW5jaHJvbm91cywgc2luZ2xlIG1vZHVsZSByZXF1aXJlKCcnKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwcywgcmVsSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL0FycmF5IG9mIGRlcGVuZGVuY2llcyB3aXRoIGEgY2FsbGJhY2suXG5cbiAgICAgICAgICAgICAgICAvL0NvbnZlcnQgdGhlIGRlcGVuZGVuY2llcyB0byBtb2R1bGVzLlxuICAgICAgICAgICAgICAgIGRlcHMgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGRlcE5hbWUsIHJlbElkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vV2FpdCBmb3IgbmV4dCB0aWNrIHRvIGNhbGwgYmFjayB0aGUgcmVxdWlyZSBjYWxsLlxuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBkZXBzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFtZFJlcXVpcmUudG9VcmwgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIGlmIChmaWxlUGF0aC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKGZpbGVQYXRoLCBwYXRoLmRpcm5hbWUobW9kdWxlLmZpbGVuYW1lKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYW1kUmVxdWlyZTtcbiAgICB9O1xuXG4gICAgLy9GYXZvciBleHBsaWNpdCB2YWx1ZSwgcGFzc2VkIGluIGlmIHRoZSBtb2R1bGUgd2FudHMgdG8gc3VwcG9ydCBOb2RlIDAuNC5cbiAgICByZXF1aXJlRm4gPSByZXF1aXJlRm4gfHwgZnVuY3Rpb24gcmVxKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLnJlcXVpcmUuYXBwbHkobW9kdWxlLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciByLCBlLCBtLCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBlID0gbG9hZGVyQ2FjaGVbaWRdID0ge307XG4gICAgICAgICAgICBtID0ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB1cmk6IF9fZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vT25seSBzdXBwb3J0IG9uZSBkZWZpbmUgY2FsbCBwZXIgZmlsZVxuICAgICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtZGVmaW5lIHdpdGggbm8gbW9kdWxlIElEIGNhbm5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9Vc2UgdGhlIHJlYWwgdmFyaWFibGVzIGZyb20gbm9kZVxuICAgICAgICAgICAgLy9Vc2UgbW9kdWxlLmV4cG9ydHMgZm9yIGV4cG9ydHMsIHNpbmNlXG4gICAgICAgICAgICAvL3RoZSBleHBvcnRzIGluIGhlcmUgaXMgYW1kZWZpbmUgZXhwb3J0cy5cbiAgICAgICAgICAgIGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgICAgIG0gPSBtb2R1bGU7XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBtb2R1bGUuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzLCB0aGV5IGFyZSBzdHJpbmdzLCBzbyBuZWVkXG4gICAgICAgIC8vdG8gY29udmVydCB0aGVtIHRvIGRlcGVuZGVuY3kgdmFsdWVzLlxuICAgICAgICBpZiAoZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIoZGVwTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQ2FsbCB0aGUgZmFjdG9yeSB3aXRoIHRoZSByaWdodCBkZXBlbmRlbmNpZXMuXG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeS5hcHBseShtLmV4cG9ydHMsIGRlcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gbS5leHBvcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RyaW5nUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGlkLCByZWxJZCkge1xuICAgICAgICAvL1NwbGl0IHRoZSBJRCBieSBhICEgc28gdGhhdFxuICAgICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKCchJyksXG4gICAgICAgICAgICBvcmlnaW5hbElkID0gaWQsXG4gICAgICAgICAgICBwcmVmaXgsIHBsdWdpbjtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuXG4gICAgICAgICAgICAvL1N0cmFpZ2h0IG1vZHVsZSBsb29rdXAuIElmIGl0IGlzIG9uZSBvZiB0aGUgc3BlY2lhbCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICAvL2RlYWwgd2l0aCBpdCwgb3RoZXJ3aXNlLCBkZWxlZ2F0ZSB0byBub2RlLlxuICAgICAgICAgICAgaWYgKGlkID09PSAncmVxdWlyZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnZXhwb3J0cycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9hZGVyQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHN5c3RlbVJlcXVpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbVJlcXVpcmUob3JpZ2luYWxJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb2R1bGUgd2l0aCBJRDogJyArIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1RoZXJlIGlzIGEgcGx1Z2luIGluIHBsYXkuXG4gICAgICAgICAgICBwcmVmaXggPSBpZC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHJpbmcoaW5kZXggKyAxLCBpZC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBwbHVnaW4gPSBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcHJlZml4LCByZWxJZCk7XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4ubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBwbHVnaW4ubm9ybWFsaXplKGlkLCBtYWtlTm9ybWFsaXplKHJlbElkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vTm9ybWFsaXplIHRoZSBJRCBub3JtYWxseS5cbiAgICAgICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLmxvYWQoaWQsIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpLCBtYWtlTG9hZChpZCksIHt9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9DcmVhdGUgYSBkZWZpbmUgZnVuY3Rpb24gc3BlY2lmaWMgdG8gdGhlIG1vZHVsZSBhc2tpbmcgZm9yIGFtZGVmaW5lLlxuICAgIGZ1bmN0aW9uIGRlZmluZShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IGlkO1xuICAgICAgICAgICAgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlcHMgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9TZXQgdXAgcHJvcGVydGllcyBmb3IgdGhpcyBtb2R1bGUuIElmIGFuIElELCB0aGVuIHVzZVxuICAgICAgICAvL2ludGVybmFsIGNhY2hlLiBJZiBubyBJRCwgdGhlbiB1c2UgdGhlIGV4dGVybmFsIHZhcmlhYmxlc1xuICAgICAgICAvL2ZvciB0aGlzIG5vZGUgbW9kdWxlLlxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIC8vUHV0IHRoZSBtb2R1bGUgaW4gZGVlcCBmcmVlemUgdW50aWwgdGhlcmUgaXMgYVxuICAgICAgICAgICAgLy9yZXF1aXJlIGNhbGwgZm9yIGl0LlxuICAgICAgICAgICAgZGVmaW5lQ2FjaGVbaWRdID0gW2lkLCBkZXBzLCBmYWN0b3J5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9kZWZpbmUucmVxdWlyZSwgd2hpY2ggaGFzIGFjY2VzcyB0byBhbGwgdGhlIHZhbHVlcyBpbiB0aGVcbiAgICAvL2NhY2hlLiBVc2VmdWwgZm9yIEFNRCBtb2R1bGVzIHRoYXQgYWxsIGhhdmUgSURzIGluIHRoZSBmaWxlLFxuICAgIC8vYnV0IG5lZWQgdG8gZmluYWxseSBleHBvcnQgYSB2YWx1ZSB0byBub2RlIGJhc2VkIG9uIG9uZSBvZiB0aG9zZVxuICAgIC8vSURzLlxuICAgIGRlZmluZS5yZXF1aXJlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZS5hbWQgPSB7fTtcblxuICAgIHJldHVybiBkZWZpbmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYW1kZWZpbmU7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImVzY29kZWdlblwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiRUNNQVNjcmlwdCBjb2RlIGdlbmVyYXRvclwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vZXN0b29scy9lc2NvZGVnZW5cIixcbiAgXCJtYWluXCI6IFwiZXNjb2RlZ2VuLmpzXCIsXG4gIFwiYmluXCI6IHtcbiAgICBcImVzZ2VuZXJhdGVcIjogXCIuL2Jpbi9lc2dlbmVyYXRlLmpzXCIsXG4gICAgXCJlc2NvZGVnZW5cIjogXCIuL2Jpbi9lc2NvZGVnZW4uanNcIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcIkxJQ0VOU0UuQlNEXCIsXG4gICAgXCJMSUNFTlNFLnNvdXJjZS1tYXBcIixcbiAgICBcIlJFQURNRS5tZFwiLFxuICAgIFwiYmluXCIsXG4gICAgXCJlc2NvZGVnZW4uanNcIixcbiAgICBcInBhY2thZ2UuanNvblwiXG4gIF0sXG4gIFwidmVyc2lvblwiOiBcIjEuNi4xXCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0wLjEwLjBcIlxuICB9LFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJjb25zdGVsbGF0aW9uXCIsXG4gICAgICBcImVtYWlsXCI6IFwidXRhdGFuZS50ZWFAZ21haWwuY29tXCJcbiAgICB9XG4gIF0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJodHRwOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzY29kZWdlbi5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJlc3RyYXZlcnNlXCI6IFwiXjEuOS4xXCIsXG4gICAgXCJlc3V0aWxzXCI6IFwiXjEuMS42XCIsXG4gICAgXCJlc3ByaW1hXCI6IFwiXjEuMi4yXCIsXG4gICAgXCJvcHRpb25hdG9yXCI6IFwiXjAuNS4wXCIsXG4gICAgXCJzb3VyY2UtbWFwXCI6IFwifjAuMS40MFwiXG4gIH0sXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwic291cmNlLW1hcFwiOiBcIn4wLjEuNDBcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJhY29ybi02dG81XCI6IFwiXjAuMTEuMS0yNVwiLFxuICAgIFwiYmx1ZWJpcmRcIjogXCJeMi4zLjExXCIsXG4gICAgXCJib3dlci1yZWdpc3RyeS1jbGllbnRcIjogXCJeMC4yLjFcIixcbiAgICBcImNoYWlcIjogXCJeMS4xMC4wXCIsXG4gICAgXCJjb21tb25qcy1ldmVyeXdoZXJlXCI6IFwiXjAuOS43XCIsXG4gICAgXCJlc3ByaW1hLW1velwiOiBcIipcIixcbiAgICBcImd1bHBcIjogXCJeMy44LjEwXCIsXG4gICAgXCJndWxwLWVzbGludFwiOiBcIl4wLjIuMFwiLFxuICAgIFwiZ3VscC1tb2NoYVwiOiBcIl4yLjAuMFwiLFxuICAgIFwic2VtdmVyXCI6IFwiXjQuMS4wXCJcbiAgfSxcbiAgXCJsaWNlbnNlc1wiOiBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiQlNEXCIsXG4gICAgICBcInVybFwiOiBcImh0dHA6Ly9naXRodWIuY29tL2VzdG9vbHMvZXNjb2RlZ2VuL3Jhdy9tYXN0ZXIvTElDRU5TRS5CU0RcIlxuICAgIH1cbiAgXSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJndWxwIHRyYXZpc1wiLFxuICAgIFwidW5pdC10ZXN0XCI6IFwiZ3VscCB0ZXN0XCIsXG4gICAgXCJsaW50XCI6IFwiZ3VscCBsaW50XCIsXG4gICAgXCJyZWxlYXNlXCI6IFwibm9kZSB0b29scy9yZWxlYXNlLmpzXCIsXG4gICAgXCJidWlsZC1taW5cIjogXCJjanNpZnkgLW1hIHBhdGg6IHRvb2xzL2VudHJ5LXBvaW50LmpzID4gZXNjb2RlZ2VuLmJyb3dzZXIubWluLmpzXCIsXG4gICAgXCJidWlsZFwiOiBcImNqc2lmeSAtYSBwYXRoOiB0b29scy9lbnRyeS1wb2ludC5qcyA+IGVzY29kZWdlbi5icm93c2VyLmpzXCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiMWNhNjY0ZjY4ZGNmMjIwYjc2YzlkYzU2MmIyMzM3YzVlMGI0MjI3ZFwiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2VzdG9vbHMvZXNjb2RlZ2VuL2lzc3Vlc1wiXG4gIH0sXG4gIFwiX2lkXCI6IFwiZXNjb2RlZ2VuQDEuNi4xXCIsXG4gIFwiX3NoYXN1bVwiOiBcIjM2N2RlMTdkODUxMDU0MGQxMmJjNmRjYjhiM2Y5MTgzOTEyNjU4MTVcIixcbiAgXCJfZnJvbVwiOiBcImVzY29kZWdlbkAxLjYuMVwiLFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMi4wLjAtYWxwaGEtNVwiLFxuICBcIl9ucG1Vc2VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJjb25zdGVsbGF0aW9uXCIsXG4gICAgXCJlbWFpbFwiOiBcInV0YXRhbmUudGVhQGdtYWlsLmNvbVwiXG4gIH0sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCIzNjdkZTE3ZDg1MTA1NDBkMTJiYzZkY2I4YjNmOTE4MzkxMjY1ODE1XCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cDovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lc2NvZGVnZW4vLS9lc2NvZGVnZW4tMS42LjEudGd6XCJcbiAgfSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7fSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9lc2NvZGVnZW4vLS9lc2NvZGVnZW4tMS42LjEudGd6XCJcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBkb3Q7XG5cbnZhciBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyk7XG5cbmZ1bmN0aW9uIGRvdChjZmcsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdHZhciBjb3VudGVyID0gb3B0aW9ucy5jb3VudGVyIHx8IDA7XG5cdHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcblx0dmFyIGdlbmVyYXRlU291cmNlID0gIXNvdXJjZSAmJiBvcHRpb25zLmdlbmVyYXRlU291cmNlO1xuXHRcblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgbm9kZXMgPSBjZmdbMl07XG5cblx0Ly8gcHJpbnQgYWxsIHRoZSBub2Rlczpcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBub2RlID0gbm9kZXNbaV07XG5cdFx0dmFyIGxhYmVsID0gbm9kZS5sYWJlbCB8fCBub2RlLnR5cGU7XG5cdFx0aWYgKCFsYWJlbCAmJiBzb3VyY2UgJiYgbm9kZS5hc3ROb2RlLnJhbmdlKSB7XG5cdFx0XHR2YXIgYXN0ID0gbm9kZS5hc3ROb2RlO1xuXHRcdFx0dmFyIHJhbmdlID0gYXN0LnJhbmdlO1xuXHRcdFx0dmFyIGFkZCA9ICcnO1xuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIHNvbWUgc3RhdGVtZW50cyB0byBnZXQgdGhlbSBwcm9wZXJseSBwcmludGVkXG5cdFx0XHRpZiAoYXN0LnR5cGUgPT0gJ1N3aXRjaENhc2UnKSB7XG5cdFx0XHRcdGlmIChhc3QudGVzdCkge1xuXHRcdFx0XHRcdHJhbmdlID0gW3JhbmdlWzBdLCBhc3QudGVzdC5yYW5nZVsxXV07XG5cdFx0XHRcdFx0YWRkID0gJzonO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJhbmdlID0gW3JhbmdlWzBdLCByYW5nZVswXV07XG5cdFx0XHRcdFx0YWRkID0nZGVmYXVsdDonO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGFzdC50eXBlID09ICdGb3JJblN0YXRlbWVudCcpIHtcblx0XHRcdFx0cmFuZ2UgPSBbcmFuZ2VbMF0sIGFzdC5yaWdodC5yYW5nZVsxXV07XG5cdFx0XHRcdGFkZCA9ICcpJztcblx0XHRcdH0gZWxzZSBpZiAoYXN0LnR5cGUgPT0gJ0NhdGNoQ2xhdXNlJykge1xuXHRcdFx0XHRyYW5nZSA9IFtyYW5nZVswXSwgYXN0LnBhcmFtLnJhbmdlWzFdXTtcblx0XHRcdFx0YWRkID0gJyknO1xuXHRcdFx0fVxuXG5cdFx0XHRsYWJlbCA9IHNvdXJjZS5zbGljZShyYW5nZVswXSwgcmFuZ2VbMV0pXG5cdFx0XHRcdC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcblx0XHRcdFx0LnJlcGxhY2UoL1xcdC9nLCAnICAgICcpXG5cdFx0XHRcdC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyBhZGQ7XG5cdFx0fVxuXHRcdGlmICghbGFiZWwgJiYgbm9kZS5hc3ROb2RlKSB7XG5cdFx0XHRsYWJlbCA9IGdlbmVyYXRlU291cmNlID8gY29kZWdlbi5nZW5lcmF0ZShub2RlLmFzdE5vZGUpIDogbm9kZS5hc3ROb2RlLnR5cGU7XG5cdFx0fVxuXHRcdG91dHB1dC5wdXNoKCduJyArIChjb3VudGVyICsgaSkgKyAnIFtsYWJlbD1cIicgKyBsYWJlbCArICdcIicpO1xuXHRcdGlmICh+WydlbnRyeScsICdleGl0J10uaW5kZXhPZihub2RlLnR5cGUpKVxuXHRcdFx0b3V0cHV0LnB1c2goJywgc3R5bGU9XCJyb3VuZGVkXCInKTtcblx0XHRvdXRwdXQucHVzaCgnXVxcbicpO1xuXHR9XG5cblx0Ly8gcHJpbnQgYWxsIHRoZSBlZGdlczpcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBub2RlID0gbm9kZXNbaV07XG5cdFx0Wydub3JtYWwnLCAndHJ1ZScsICdmYWxzZScsICdleGNlcHRpb24nXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0XHR2YXIgbmV4dCA9IG5vZGVbdHlwZV07XG5cdFx0XHRpZiAoIW5leHQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdG91dHB1dC5wdXNoKCduJyArIChjb3VudGVyICsgaSkgKyAnIC0+IG4nICsgKGNvdW50ZXIgKyBub2Rlcy5pbmRleE9mKG5leHQpKSArICcgWycpO1xuXHRcdGlmICh0eXBlID09PSAnZXhjZXB0aW9uJylcblx0XHRcdG91dHB1dC5wdXNoKCdjb2xvcj1cInJlZFwiLCBsYWJlbD1cImV4Y2VwdGlvblwiJylcblx0XHRlbHNlIGlmICh+Wyd0cnVlJywgJ2ZhbHNlJ10uaW5kZXhPZih0eXBlKSlcblx0XHRcdG91dHB1dC5wdXNoKCdsYWJlbD1cIicgKyB0eXBlICsgJ1wiJyk7XG5cdFx0b3V0cHV0LnB1c2goJ11cXG4nKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmIChvcHRpb25zLmNvdW50ZXIgIT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zLmNvdW50ZXIrPSBub2Rlcy5sZW5ndGg7XG5cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn1cblxuIiwiXG52YXIgd2Fsa2VyID0gcmVxdWlyZSgnd2Fsa2VzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJvbEZsb3dHcmFwaDtcbm1vZHVsZS5leHBvcnRzLmRvdCA9IHJlcXVpcmUoJy4vZG90Jyk7XG5cbi8vIEZJWE1FOiBzd2l0Y2gvY2FzZSB3aXRoIGRlZmF1bHQgYmVmb3JlIG90aGVyIGNhc2VzP1xuLy8gRklYTUU6IGNhdGNoIGNyZWF0ZXMgYSBuZXcgc2NvcGUsIHNvIHNob3VsZCBzb21laG93IGJlIGhhbmRsZWQgZGlmZmVyZW50bHlcblxuLy8gVE9ETzogdHJ5L2ZpbmFsbHk6IGZpbmFsbHkgZm9sbG93cyB0cnksIGJ1dCBkb2VzIG5vdCByZXR1cm4gdG8gbm9ybWFsIGZsb3c/XG5cbi8vIFRPRE86IGxhYmVsZWQgYnJlYWsvY29udGludWVcbi8vIFRPRE86IFdpdGhTdGF0ZW1lbnRcblxuLy8gVE9ETzogYXZvaWQgYWRkaW5nIGFuZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGFzdCBub2Rlc1xuXG4vKipcbiAqIFJldHVybnMgW2VudHJ5LCBleGl0XSBgRmxvd05vZGVgcyBmb3IgdGhlIHBhc3NlZCBpbiBBU1RcbiAqL1xuZnVuY3Rpb24gQ29udHJvbEZsb3dHcmFwaChhc3ROb2RlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHBhcmVudFN0YWNrID0gW107XG5cdHZhciBleGl0Tm9kZSA9IG5ldyBGbG93Tm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgJ2V4aXQnKTtcblx0dmFyIGNhdGNoU3RhY2sgPSBbZXhpdE5vZGVdO1xuXHR2YXIgb21pdEV4Y2VwdGlvbnMgPSAhIW9wdGlvbnMub21pdEV4Y2VwdGlvbnM7XG5cblx0Y3JlYXRlTm9kZXMoYXN0Tm9kZSk7XG5cdGxpbmtTaWJsaW5ncyhhc3ROb2RlKTtcblx0XG5cdHdhbGtlcihhc3ROb2RlLCB7XG5cdFx0Q2F0Y2hDbGF1c2U6IGZ1bmN0aW9uIChyZWN1cnNlKSB7XG5cdFx0XHR0aGlzLmNmZy5jb25uZWN0KGdldEVudHJ5KHRoaXMuYm9keSkpO1xuXHRcdFx0cmVjdXJzZSh0aGlzLmJvZHkpO1xuXHRcdH0sXG5cdFx0RG9XaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdG1heVRocm93KHRoaXMudGVzdCk7XG5cdFx0XHR0aGlzLnRlc3QuY2ZnXG5cdFx0XHRcdC5jb25uZWN0KGdldEVudHJ5KHRoaXMuYm9keSksICd0cnVlJylcblx0XHRcdFx0LmNvbm5lY3QoZ2V0U3VjY2Vzc29yKHRoaXMpLCAnZmFsc2UnKTtcblx0XHRcdHJlY3Vyc2UodGhpcy5ib2R5KTtcblx0XHR9LFxuXHRcdEV4cHJlc3Npb25TdGF0ZW1lbnQ6IGNvbm5lY3ROZXh0LFxuXHRcdEZ1bmN0aW9uRGVjbGFyYXRpb246IGZ1bmN0aW9uICgpIHt9LFxuXHRcdEZvclN0YXRlbWVudDogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdGlmICh0aGlzLnRlc3QpIHtcblx0XHRcdFx0bWF5VGhyb3codGhpcy50ZXN0KTtcblx0XHRcdFx0dGhpcy50ZXN0LmNmZ1xuXHRcdFx0XHRcdC5jb25uZWN0KGdldEVudHJ5KHRoaXMuYm9keSksICd0cnVlJylcblx0XHRcdFx0XHQuY29ubmVjdChnZXRTdWNjZXNzb3IodGhpcyksICdmYWxzZScpO1xuXHRcdFx0XHRpZiAodGhpcy51cGRhdGUpXG5cdFx0XHRcdFx0dGhpcy51cGRhdGUuY2ZnLmNvbm5lY3QodGhpcy50ZXN0LmNmZyk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMudXBkYXRlKVxuXHRcdFx0XHR0aGlzLnVwZGF0ZS5jZmcuY29ubmVjdChnZXRFbnRyeSh0aGlzLmJvZHkpKTtcblx0XHRcdGlmICh0aGlzLnVwZGF0ZSlcblx0XHRcdFx0bWF5VGhyb3codGhpcy51cGRhdGUpO1xuXHRcdFx0aWYgKHRoaXMuaW5pdCkge1xuXHRcdFx0XHRtYXlUaHJvdyh0aGlzLmluaXQpO1xuXHRcdFx0XHR0aGlzLmluaXQuY2ZnLmNvbm5lY3QodGhpcy50ZXN0ICYmIHRoaXMudGVzdC5jZmcgfHwgZ2V0RW50cnkodGhpcy5ib2R5KSk7XG5cdFx0XHR9XG5cdFx0XHRyZWN1cnNlKHRoaXMuYm9keSk7XG5cdFx0fSxcblx0XHRGb3JJblN0YXRlbWVudDogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdG1heVRocm93KHRoaXMpXG5cdFx0XHR0aGlzLmNmZ1xuXHRcdFx0XHQuY29ubmVjdChnZXRFbnRyeSh0aGlzLmJvZHkpLCAndHJ1ZScpXG5cdFx0XHRcdC5jb25uZWN0KGdldFN1Y2Nlc3Nvcih0aGlzKSwgJ2ZhbHNlJyk7XG5cdFx0XHRyZWN1cnNlKHRoaXMuYm9keSk7XG5cdFx0fSxcblx0XHRJZlN0YXRlbWVudDogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdHJlY3Vyc2UodGhpcy5jb25zZXF1ZW50KTtcblx0XHRcdG1heVRocm93KHRoaXMudGVzdCk7XG5cdFx0XHR0aGlzLnRlc3QuY2ZnLmNvbm5lY3QoZ2V0RW50cnkodGhpcy5jb25zZXF1ZW50KSwgJ3RydWUnKTtcblx0XHRcdGlmICh0aGlzLmFsdGVybmF0ZSkge1xuXHRcdFx0XHRyZWN1cnNlKHRoaXMuYWx0ZXJuYXRlKTtcblx0XHRcdFx0dGhpcy50ZXN0LmNmZy5jb25uZWN0KGdldEVudHJ5KHRoaXMuYWx0ZXJuYXRlKSwgJ2ZhbHNlJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRlc3QuY2ZnLmNvbm5lY3QoZ2V0U3VjY2Vzc29yKHRoaXMpLCAnZmFsc2UnKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdFJldHVyblN0YXRlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdFx0bWF5VGhyb3codGhpcyk7XG5cdFx0XHR0aGlzLmNmZy5jb25uZWN0KGV4aXROb2RlKTtcblx0XHR9LFxuXHRcdFN3aXRjaENhc2U6IGZ1bmN0aW9uIChyZWN1cnNlKSB7XG5cdFx0XHRpZiAodGhpcy50ZXN0KSB7XG5cdFx0XHRcdC8vIGlmIHRoaXMgaXMgYSByZWFsIGNhc2UsIGNvbm5lY3QgYHRydWVgIHRvIHRoZSBib2R5XG5cdFx0XHRcdC8vIG9yIHRoZSBib2R5IG9mIHRoZSBuZXh0IGNhc2Vcblx0XHRcdFx0dmFyIGNoZWNrID0gdGhpcztcblx0XHRcdFx0d2hpbGUgKCFjaGVjay5jb25zZXF1ZW50Lmxlbmd0aCAmJiBjaGVjay5jZmcubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0Y2hlY2sgPSBjaGVjay5jZmcubmV4dFNpYmxpbmcuYXN0Tm9kZTtcblxuXHRcdFx0XHR0aGlzLmNmZy5jb25uZWN0KGNoZWNrLmNvbnNlcXVlbnQubGVuZ3RoICYmIGdldEVudHJ5KGNoZWNrLmNvbnNlcXVlbnRbMF0pIHx8IGdldFN1Y2Nlc3Nvcih0aGlzLmNmZy5wYXJlbnQpLCAndHJ1ZScpO1xuXG5cdFx0XHRcdC8vIGFuZCBjb25uZWN0IGZhbHNlIHRvIHRoZSBuZXh0IGBjYXNlYFxuXHRcdFx0XHR0aGlzLmNmZy5jb25uZWN0KGdldFN1Y2Nlc3Nvcih0aGlzKSwgJ2ZhbHNlJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB0aGlzIGlzIHRoZSBgZGVmYXVsdGAgY2FzZSwgY29ubmVjdCBpdCB0byB0aGUgYm9keSwgb3IgdGhlXG5cdFx0XHRcdC8vIHN1Y2Nlc3NvciBvZiB0aGUgcGFyZW50XG5cdFx0XHRcdHRoaXMuY2ZnLmNvbm5lY3QodGhpcy5jb25zZXF1ZW50Lmxlbmd0aCAmJiBnZXRFbnRyeSh0aGlzLmNvbnNlcXVlbnRbMF0pIHx8IGdldFN1Y2Nlc3Nvcih0aGlzLmNmZy5wYXJlbnQpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuY29uc2VxdWVudC5mb3JFYWNoKHJlY3Vyc2UpO1xuXHRcdH0sXG5cdFx0U3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbiAocmVjdXJzZSkge1xuXHRcdFx0dGhpcy5jZmcuY29ubmVjdCh0aGlzLmNhc2VzWzBdLmNmZyk7XG5cdFx0XHR0aGlzLmNhc2VzLmZvckVhY2gocmVjdXJzZSk7XG5cdFx0fSxcblx0XHRUaHJvd1N0YXRlbWVudDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5jZmcuY29ubmVjdChnZXRFeGNlcHRpb25UYXJnZXQodGhpcyksICdleGNlcHRpb24nKTtcblx0XHR9LFxuXHRcdFRyeVN0YXRlbWVudDogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1swXSAmJiB0aGlzLmhhbmRsZXJzWzBdLmNmZyB8fCBnZXRFbnRyeSh0aGlzLmZpbmFsaXplcik7XG5cdFx0XHRjYXRjaFN0YWNrLnB1c2goaGFuZGxlcik7XG5cdFx0XHRyZWN1cnNlKHRoaXMuYmxvY2spO1xuXHRcdFx0Y2F0Y2hTdGFjay5wb3AoKTtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuaGFuZGxlcnMubGVuZ3RoKVxuXHRcdFx0XHRyZWN1cnNlKHRoaXMuaGFuZGxlcnNbMF0pO1xuXHRcdFx0aWYgKHRoaXMuZmluYWxpemVyKSB7XG5cdFx0XHRcdC8vdGhpcy5maW5hbGl6ZXIuY2ZnLmNvbm5lY3QoZ2V0U3VjY2Vzc29yKHRoaXMpKTtcblx0XHRcdFx0cmVjdXJzZSh0aGlzLmZpbmFsaXplcik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRWYXJpYWJsZURlY2xhcmF0aW9uOiBjb25uZWN0TmV4dCxcblx0XHRXaGlsZVN0YXRlbWVudDogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdG1heVRocm93KHRoaXMudGVzdCk7XG5cdFx0XHR0aGlzLnRlc3QuY2ZnXG5cdFx0XHRcdC5jb25uZWN0KGdldEVudHJ5KHRoaXMuYm9keSksICd0cnVlJylcblx0XHRcdFx0LmNvbm5lY3QoZ2V0U3VjY2Vzc29yKHRoaXMpLCAnZmFsc2UnKTtcblx0XHRcdHJlY3Vyc2UodGhpcy5ib2R5KTtcblx0XHR9XG5cdH0pO1xuXHRcblx0dmFyIGVudHJ5Tm9kZSA9IG5ldyBGbG93Tm9kZShhc3ROb2RlLCB1bmRlZmluZWQsICdlbnRyeScpO1xuXHRlbnRyeU5vZGUubm9ybWFsID0gZ2V0RW50cnkoYXN0Tm9kZSk7XG5cdHdhbGtlcihhc3ROb2RlLCB7ZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5jZmcpXG5cdFx0XHRyZXR1cm47XG5cdFx0Ly8gRXhwcmVzc2lvblN0YXRlbWVudHMgc2hvdWxkIHJlZmVyIHRvIHRoZWlyIGV4cHJlc3Npb24gZGlyZWN0bHlcblx0XHRpZiAodGhpcy50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcpXG5cdFx0XHR0aGlzLmNmZy5hc3ROb2RlID0gdGhpcy5leHByZXNzaW9uO1xuXHRcdGRlbGV0ZSB0aGlzLmNmZztcblx0XHR3YWxrZXIuY2hlY2tQcm9wcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9fSk7XG5cblx0dmFyIGFsbE5vZGVzID0gW107XG5cdHZhciByZXZlcnNlU3RhY2sgPSBbZW50cnlOb2RlXTtcblx0d2hpbGUgKHJldmVyc2VTdGFjay5sZW5ndGgpIHtcblx0XHR2YXIgY2ZnTm9kZSA9IHJldmVyc2VTdGFjay5wb3AoKTtcblx0XHRhbGxOb2Rlcy5wdXNoKGNmZ05vZGUpO1xuXHRcdGNmZ05vZGUubmV4dCA9IFtdO1xuXHRcdFsnZXhjZXB0aW9uJywgJ2ZhbHNlJywgJ3RydWUnLCAnbm9ybWFsJ10uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuXHRcdFx0dmFyIG5leHQgPSBjZmdOb2RlW3R5cGVdO1xuXHRcdFx0aWYgKCFuZXh0KVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRpZiAoIX5jZmdOb2RlLm5leHQuaW5kZXhPZihuZXh0KSlcblx0XHRcdFx0Y2ZnTm9kZS5uZXh0LnB1c2gobmV4dCk7XG5cdFx0XHRpZiAoIX5uZXh0LnByZXYuaW5kZXhPZihjZmdOb2RlKSlcblx0XHRcdFx0bmV4dC5wcmV2LnB1c2goY2ZnTm9kZSk7XG5cdFx0XHRpZiAoIX5yZXZlcnNlU3RhY2suaW5kZXhPZihuZXh0KSAmJiAhbmV4dC5uZXh0KVxuXHRcdFx0XHRyZXZlcnNlU3RhY2sucHVzaChuZXh0KTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEV4Y2VwdGlvblRhcmdldChhc3ROb2RlKSB7XG5cdFx0cmV0dXJuIGNhdGNoU3RhY2tbY2F0Y2hTdGFjay5sZW5ndGggLSAxXTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1heVRocm93KGFzdE5vZGUpIHtcblx0XHRpZiAoIW9taXRFeGNlcHRpb25zICYmIGV4cHJlc3Npb25UaHJvd3MoYXN0Tm9kZSkpXG5cdFx0XHRhc3ROb2RlLmNmZy5jb25uZWN0KGdldEV4Y2VwdGlvblRhcmdldCh0aGlzKSwgJ2V4Y2VwdGlvbicpO1xuXHR9XG5cdGZ1bmN0aW9uIGV4cHJlc3Npb25UaHJvd3MoYXN0Tm9kZSkge1xuXHRcdGlmICh0eXBlb2YgYXN0Tm9kZSAhPT0gJ29iamVjdCcgfHwgJ0Z1bmN0aW9uRXhwcmVzc2lvbicgPT09IGFzdE5vZGUudHlwZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRpZiAoYXN0Tm9kZS50eXBlICYmIH50aHJvd1R5cGVzLmluZGV4T2YoYXN0Tm9kZS50eXBlKSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdHZhciBzZWxmID0gYXN0Tm9kZTtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXMoc2VsZikuc29tZShmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR2YXIgcHJvcCA9IHNlbGZba2V5XTtcblx0XHRcdGlmIChwcm9wIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0cmV0dXJuIHByb3Auc29tZShleHByZXNzaW9uVGhyb3dzKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHByb3AgPT09ICdvYmplY3QnICYmIHByb3ApXG5cdFx0XHRcdHJldHVybiBleHByZXNzaW9uVGhyb3dzKHByb3ApO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRKdW1wVGFyZ2V0KGFzdE5vZGUsIHR5cGVzKSB7XG5cdFx0dmFyIHBhcmVudCA9IGFzdE5vZGUuY2ZnLnBhcmVudDtcblx0XHR3aGlsZSAoIX50eXBlcy5pbmRleE9mKHBhcmVudC50eXBlKSAmJiBwYXJlbnQuY2ZnLnBhcmVudClcblx0XHRcdHBhcmVudCA9IHBhcmVudC5jZmcucGFyZW50O1xuXHRcdHJldHVybiB+dHlwZXMuaW5kZXhPZihwYXJlbnQudHlwZSkgPyBwYXJlbnQgOiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29ubmVjdE5leHQoKSB7XG5cdFx0bWF5VGhyb3codGhpcyk7XG5cdFx0dGhpcy5jZmcuY29ubmVjdChnZXRTdWNjZXNzb3IodGhpcykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGVudHJ5IG5vZGUgb2YgYSBzdGF0ZW1lbnRcblx0ICovXG5cdGZ1bmN0aW9uIGdldEVudHJ5KGFzdE5vZGUpIHtcblx0XHRzd2l0Y2ggKGFzdE5vZGUudHlwZSkge1xuXHRcdFx0Y2FzZSAnQnJlYWtTdGF0ZW1lbnQnOlxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZ2V0SnVtcFRhcmdldChhc3ROb2RlLCBicmVha1RhcmdldHMpO1xuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0ID8gZ2V0U3VjY2Vzc29yKHRhcmdldCkgOiBleGl0Tm9kZTtcblx0XHRcdGNhc2UgJ0NvbnRpbnVlU3RhdGVtZW50Jzpcblx0XHRcdFx0dmFyIHRhcmdldCA9IGdldEp1bXBUYXJnZXQoYXN0Tm9kZSwgY29udGludWVUYXJnZXRzKTtcblx0XHRcdFx0c3dpdGNoICh0YXJnZXQudHlwZSkge1xuXHRcdFx0XHRcdGNhc2UgJ0ZvclN0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHQvLyBjb250aW51ZSBnb2VzIHRvIHRoZSB1cGRhdGUsIHRlc3Qgb3IgYm9keVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRhcmdldC51cGRhdGUgJiYgdGFyZ2V0LnVwZGF0ZS5jZmcgfHwgdGFyZ2V0LnRlc3QgJiYgdGFyZ2V0LnRlc3QuY2ZnIHx8IGdldEVudHJ5KHRhcmdldC5ib2R5KTtcblx0XHRcdFx0XHRjYXNlICdGb3JJblN0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0LmNmZztcblx0XHRcdFx0XHRjYXNlICdEb1doaWxlU3RhdGVtZW50Jzpcblx0XHRcdFx0XHRjYXNlICdXaGlsZVN0YXRlbWVudCc6XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnRlc3QuY2ZnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVucmVhY2hlZFxuXHRcdFx0Y2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuXHRcdFx0Y2FzZSAnUHJvZ3JhbSc6XG5cdFx0XHRcdHJldHVybiBhc3ROb2RlLmJvZHkubGVuZ3RoICYmIGdldEVudHJ5KGFzdE5vZGUuYm9keVswXSkgfHwgZ2V0U3VjY2Vzc29yKGFzdE5vZGUpO1xuXHRcdFx0Y2FzZSAnRG9XaGlsZVN0YXRlbWVudCc6XG5cdFx0XHRcdHJldHVybiBnZXRFbnRyeShhc3ROb2RlLmJvZHkpO1xuXHRcdFx0Y2FzZSAnRW1wdHlTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gZ2V0U3VjY2Vzc29yKGFzdE5vZGUpO1xuXHRcdFx0Y2FzZSAnRm9yU3RhdGVtZW50Jzpcblx0XHRcdFx0cmV0dXJuIGFzdE5vZGUuaW5pdCAmJiBhc3ROb2RlLmluaXQuY2ZnIHx8IGFzdE5vZGUudGVzdCAmJiBhc3ROb2RlLnRlc3QuY2ZnIHx8IGdldEVudHJ5KGFzdE5vZGUuYm9keSk7XG5cdFx0XHRjYXNlICdGdW5jdGlvbkRlY2xhcmF0aW9uJzpcblx0XHRcdFx0cmV0dXJuIGdldFN1Y2Nlc3Nvcihhc3ROb2RlKTtcblx0XHRcdGNhc2UgJ0lmU3RhdGVtZW50Jzpcblx0XHRcdFx0cmV0dXJuIGFzdE5vZGUudGVzdC5jZmc7XG5cdFx0XHRjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gZ2V0RW50cnkoYXN0Tm9kZS5jYXNlc1swXSk7XG5cdFx0XHRjYXNlICdUcnlTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gZ2V0RW50cnkoYXN0Tm9kZS5ibG9jayk7XG5cdFx0XHRjYXNlICdXaGlsZVN0YXRlbWVudCc6XG5cdFx0XHRcdHJldHVybiBhc3ROb2RlLnRlc3QuY2ZnO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGFzdE5vZGUuY2ZnO1xuXHRcdH1cblx0fVxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3VjY2Vzc29yIG5vZGUgb2YgYSBzdGF0ZW1lbnRcblx0ICovXG5cdGZ1bmN0aW9uIGdldFN1Y2Nlc3Nvcihhc3ROb2RlKSB7XG5cdFx0Ly8gcGFydCBvZiBhIGJsb2NrIC0+IGl0IGFscmVhZHkgaGFzIGEgbmV4dFNpYmxpbmdcblx0XHRpZiAoYXN0Tm9kZS5jZmcubmV4dFNpYmxpbmcpXG5cdFx0XHRyZXR1cm4gYXN0Tm9kZS5jZmcubmV4dFNpYmxpbmc7XG5cdFx0dmFyIHBhcmVudCA9IGFzdE5vZGUuY2ZnLnBhcmVudDtcblx0XHRpZiAoIXBhcmVudCkgLy8gaXQgaGFzIG5vIHBhcmVudCAtPiBleGl0Tm9kZVxuXHRcdFx0cmV0dXJuIGV4aXROb2RlO1xuXHRcdHN3aXRjaCAocGFyZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gcGFyZW50LnRlc3QuY2ZnO1xuXHRcdFx0Y2FzZSAnRm9yU3RhdGVtZW50Jzpcblx0XHRcdFx0cmV0dXJuIHBhcmVudC51cGRhdGUgJiYgcGFyZW50LnVwZGF0ZS5jZmcgfHwgcGFyZW50LnRlc3QgJiYgcGFyZW50LnRlc3QuY2ZnIHx8IGdldEVudHJ5KHBhcmVudC5ib2R5KTtcblx0XHRcdGNhc2UgJ0ZvckluU3RhdGVtZW50Jzpcblx0XHRcdFx0cmV0dXJuIHBhcmVudC5jZmc7XG5cdFx0XHRjYXNlICdUcnlTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gcGFyZW50LmZpbmFsaXplciAmJiBhc3ROb2RlICE9PSBwYXJlbnQuZmluYWxpemVyICYmIGdldEVudHJ5KHBhcmVudC5maW5hbGl6ZXIpIHx8IGdldFN1Y2Nlc3NvcihwYXJlbnQpO1xuXHRcdFx0Y2FzZSAnU3dpdGNoQ2FzZSc6XG5cdFx0XHRcdC8vIHRoZSBzdWNlc3NvciBvZiBhIHN0YXRlbWVudCBhdCB0aGUgZW5kIG9mIGEgY2FzZSBibG9jayBpc1xuXHRcdFx0XHQvLyB0aGUgZW50cnkgb2YgdGhlIG5leHQgY2FzZXMgY29uc2VxdWVudFxuXHRcdFx0XHRpZiAoIXBhcmVudC5jZmcubmV4dFNpYmxpbmcpXG5cdFx0XHRcdFx0cmV0dXJuIGdldFN1Y2Nlc3NvcihwYXJlbnQpO1xuXHRcdFx0XHR2YXIgY2hlY2sgPSBwYXJlbnQuY2ZnLm5leHRTaWJsaW5nLmFzdE5vZGU7XG5cdFx0XHRcdHdoaWxlICghY2hlY2suY29uc2VxdWVudC5sZW5ndGggJiYgY2hlY2suY2ZnLm5leHRTaWJsaW5nKVxuXHRcdFx0XHRcdGNoZWNrID0gY2hlY2suY2ZnLm5leHRTaWJsaW5nLmFzdE5vZGU7XG5cdFx0XHRcdC8vIG9yIHRoZSBuZXh0IHN0YXRlbWVudCBhZnRlciB0aGUgc3dpdGNoLCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjYXNlc1xuXHRcdFx0XHRyZXR1cm4gY2hlY2suY29uc2VxdWVudC5sZW5ndGggJiYgZ2V0RW50cnkoY2hlY2suY29uc2VxdWVudFswXSkgfHwgZ2V0U3VjY2Vzc29yKHBhcmVudC5wYXJlbnQpO1xuXHRcdFx0Y2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuXHRcdFx0XHRyZXR1cm4gcGFyZW50LnRlc3QuY2ZnO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGdldFN1Y2Nlc3NvcihwYXJlbnQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgRmxvd05vZGUgZm9yIGV2ZXJ5IEFTVCBub2RlXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVOb2Rlcyhhc3ROb2RlKSB7XG5cdFx0d2Fsa2VyKGFzdE5vZGUsIHsgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHBhcmVudFN0YWNrLmxlbmd0aCA/IHBhcmVudFN0YWNrW3BhcmVudFN0YWNrLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXHRcdFx0Y3JlYXRlTm9kZSh0aGlzLCBwYXJlbnQpO1xuXHRcdFx0Ly8gZG8gbm90IHJlY3Vyc2UgZm9yIEZ1bmN0aW9uRGVjbGFyYXRpb24gb3IgYW55IHN1Yi1leHByZXNzaW9uXG5cdFx0XHRpZiAodGhpcy50eXBlID09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyB8fCB+dGhpcy50eXBlLmluZGV4T2YoJ0V4cHJlc3Npb24nKSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0cGFyZW50U3RhY2sucHVzaCh0aGlzKTtcblx0XHRcdHdhbGtlci5jaGVja1Byb3BzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRwYXJlbnRTdGFjay5wb3AoKTtcblx0XHR9fSk7XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlTm9kZShhc3ROb2RlLCBwYXJlbnQpIHtcblx0XHRpZiAoIWFzdE5vZGUuY2ZnKVxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFzdE5vZGUsICdjZmcnLCB7dmFsdWU6IG5ldyBGbG93Tm9kZShhc3ROb2RlLCBwYXJlbnQpLCBjb25maWd1cmFibGU6IHRydWV9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaW5rcyBpbiB0aGUgbmV4dCBzaWJsaW5nIGZvciBub2RlcyBpbnNpZGUgYSBibG9ja1xuXHQgKi9cblx0ZnVuY3Rpb24gbGlua1NpYmxpbmdzKGFzdE5vZGUpIHtcblx0XHRmdW5jdGlvbiBiYWNrVG9Gcm9udChsaXN0LCByZWN1cnNlKSB7XG5cdFx0XHQvLyBsaW5rIGFsbCB0aGUgY2hpbGRyZW4gdG8gdGhlIG5leHQgc2libGluZyBmcm9tIGJhY2sgdG8gZnJvbnQsXG5cdFx0XHQvLyBzbyB0aGUgbm9kZXMgYWxyZWFkeSBoYXZlIC5uZXh0U2libGluZ1xuXHRcdFx0Ly8gc2V0IHdoZW4gdGhlaXIgZ2V0RW50cnkgaXMgY2FsbGVkXG5cdFx0XHRmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBsaXN0W2ldO1xuXHRcdFx0XHRpZiAoaSA8IGxpc3QubGVuZ3RoIC0gMSlcblx0XHRcdFx0XHRjaGlsZC5jZmcubmV4dFNpYmxpbmcgPSBnZXRFbnRyeShsaXN0W2kgKyAxXSk7XG5cdFx0XHRcdHJlY3Vyc2UoY2hpbGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmdW5jdGlvbiBCbG9ja09yUHJvZ3JhbShyZWN1cnNlKSB7XG5cdFx0XHRiYWNrVG9Gcm9udCh0aGlzLmJvZHksIHJlY3Vyc2UpO1xuXHRcdH1cblx0XHR3YWxrZXIoYXN0Tm9kZSwge1xuXHRcdFx0QmxvY2tTdGF0ZW1lbnQ6IEJsb2NrT3JQcm9ncmFtLFxuXHRcdFx0UHJvZ3JhbTogQmxvY2tPclByb2dyYW0sXG5cdFx0XHRGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbiAoKSB7fSxcblx0XHRcdEZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkge30sXG5cdFx0XHRTd2l0Y2hDYXNlOiBmdW5jdGlvbiAocmVjdXJzZSkge1xuXHRcdFx0XHRiYWNrVG9Gcm9udCh0aGlzLmNvbnNlcXVlbnQsIHJlY3Vyc2UpO1xuXHRcdFx0fSxcblx0XHRcdFN3aXRjaFN0YXRlbWVudDogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcblx0XHRcdFx0YmFja1RvRnJvbnQodGhpcy5jYXNlcywgcmVjdXJzZSk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBbZW50cnlOb2RlLCBleGl0Tm9kZSwgYWxsTm9kZXNdO1xufTtcblxuZnVuY3Rpb24gRmxvd05vZGUoYXN0Tm9kZSwgcGFyZW50LCB0eXBlKSB7XG5cdHRoaXMuYXN0Tm9kZSA9IGFzdE5vZGU7XG5cdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXHR0aGlzLnR5cGUgPSB0eXBlO1xuXHR0aGlzLnByZXYgPSBbXTtcbn1cbkZsb3dOb2RlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG5leHQsIHR5cGUpIHtcblx0dGhpc1t0eXBlIHx8ICdub3JtYWwnXSA9IG5leHQ7XG5cdHJldHVybiB0aGlzO1xufTtcblxudmFyIGNvbnRpbnVlVGFyZ2V0cyA9IFtcblx0J0ZvclN0YXRlbWVudCcsXG5cdCdGb3JJblN0YXRlbWVudCcsXG5cdCdEb1doaWxlU3RhdGVtZW50Jyxcblx0J1doaWxlU3RhdGVtZW50J107XG52YXIgYnJlYWtUYXJnZXRzID0gY29udGludWVUYXJnZXRzLmNvbmNhdChbJ1N3aXRjaFN0YXRlbWVudCddKTtcbnZhciB0aHJvd1R5cGVzID0gW1xuXHQnQXNzaWdubWVudEV4cHJlc3Npb24nLCAvLyBhc3NpZ25pbmcgdG8gdW5kZWYgb3Igbm9uLXdyaXRhYmxlIHByb3Bcblx0J0JpbmFyeUV4cHJlc3Npb24nLCAvLyBpbnN0YW5jZW9mIGFuZCBpbiBvbiBub24tb2JqZWN0c1xuXHQnQ2FsbEV4cHJlc3Npb24nLCAvLyBvYnZpb3VzbHlcblx0J01lbWJlckV4cHJlc3Npb24nLCAvLyBnZXR0ZXJzIG1heSB0aHJvd1xuXHQnTmV3RXhwcmVzc2lvbicsIC8vIG9idmlvdXNseVxuXHQnVW5hcnlFeHByZXNzaW9uJyAvLyBkZWxldGUgbm9uLWRlbGV0YWJsZSBwcm9wXG5dO1xuXG4iLCIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTItMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1pY2hhZWwgRmljYXJyYSA8ZXNjb2RlZ2VuLmNvcHlyaWdodEBtaWNoYWVsLmZpY2FycmEubWU+XG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMyBJcmFrbGkgR296YWxpc2h2aWxpIDxyZm9iaWNAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgUm9iZXJ0IEd1c3QtQmFyZG9uIDxkb25hdGVAcm9iZXJ0Lmd1c3QtYmFyZG9uLm9yZz5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvaG4gRnJlZW1hbiA8amZyZWVtYW4wOEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMS0yMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgZ2VuZXJhdGVTdGF0ZW1lbnQ6dHJ1ZSwgZ2VuZXJhdGVFeHByZXNzaW9uOnRydWUsIHJlcXVpcmU6dHJ1ZSwgZ2xvYmFsOnRydWUqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgU3ludGF4LFxuICAgICAgICBQcmVjZWRlbmNlLFxuICAgICAgICBCaW5hcnlQcmVjZWRlbmNlLFxuICAgICAgICBSZWdleCxcbiAgICAgICAgU291cmNlTm9kZSxcbiAgICAgICAgZXN0cmF2ZXJzZSxcbiAgICAgICAgaXNBcnJheSxcbiAgICAgICAgYmFzZSxcbiAgICAgICAgaW5kZW50LFxuICAgICAgICBqc29uLFxuICAgICAgICByZW51bWJlcixcbiAgICAgICAgaGV4YWRlY2ltYWwsXG4gICAgICAgIHF1b3RlcyxcbiAgICAgICAgZXNjYXBlbGVzcyxcbiAgICAgICAgbmV3bGluZSxcbiAgICAgICAgc3BhY2UsXG4gICAgICAgIHBhcmVudGhlc2VzLFxuICAgICAgICBzZW1pY29sb25zLFxuICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbixcbiAgICAgICAgZGlyZWN0aXZlLFxuICAgICAgICBleHRyYSxcbiAgICAgICAgcGFyc2UsXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgRk9STUFUX01JTklGWSxcbiAgICAgICAgRk9STUFUX0RFRkFVTFRTO1xuXG4gICAgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcblxuICAgIFN5bnRheCA9IHtcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICAgIEFycmF5UGF0dGVybjogJ0FycmF5UGF0dGVybicsXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDb21wcmVoZW5zaW9uQmxvY2s6ICdDb21wcmVoZW5zaW9uQmxvY2snLFxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogJ0NvbXByZWhlbnNpb25FeHByZXNzaW9uJyxcbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogJ0RpcmVjdGl2ZVN0YXRlbWVudCcsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXG4gICAgICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgSWZTdGF0ZW1lbnQ6ICdJZlN0YXRlbWVudCcsXG4gICAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXG4gICAgICAgIFlpZWxkRXhwcmVzc2lvbjogJ1lpZWxkRXhwcmVzc2lvbidcblxuICAgIH07XG5cbiAgICBQcmVjZWRlbmNlID0ge1xuICAgICAgICBTZXF1ZW5jZTogMCxcbiAgICAgICAgQXNzaWdubWVudDogMSxcbiAgICAgICAgQ29uZGl0aW9uYWw6IDIsXG4gICAgICAgIEFycm93RnVuY3Rpb246IDIsXG4gICAgICAgIExvZ2ljYWxPUjogMyxcbiAgICAgICAgTG9naWNhbEFORDogNCxcbiAgICAgICAgQml0d2lzZU9SOiA1LFxuICAgICAgICBCaXR3aXNlWE9SOiA2LFxuICAgICAgICBCaXR3aXNlQU5EOiA3LFxuICAgICAgICBFcXVhbGl0eTogOCxcbiAgICAgICAgUmVsYXRpb25hbDogOSxcbiAgICAgICAgQml0d2lzZVNISUZUOiAxMCxcbiAgICAgICAgQWRkaXRpdmU6IDExLFxuICAgICAgICBNdWx0aXBsaWNhdGl2ZTogMTIsXG4gICAgICAgIFVuYXJ5OiAxMyxcbiAgICAgICAgUG9zdGZpeDogMTQsXG4gICAgICAgIENhbGw6IDE1LFxuICAgICAgICBOZXc6IDE2LFxuICAgICAgICBNZW1iZXI6IDE3LFxuICAgICAgICBQcmltYXJ5OiAxOFxuICAgIH07XG5cbiAgICBCaW5hcnlQcmVjZWRlbmNlID0ge1xuICAgICAgICAnfHwnOiBQcmVjZWRlbmNlLkxvZ2ljYWxPUixcbiAgICAgICAgJyYmJzogUHJlY2VkZW5jZS5Mb2dpY2FsQU5ELFxuICAgICAgICAnfCc6IFByZWNlZGVuY2UuQml0d2lzZU9SLFxuICAgICAgICAnXic6IFByZWNlZGVuY2UuQml0d2lzZVhPUixcbiAgICAgICAgJyYnOiBQcmVjZWRlbmNlLkJpdHdpc2VBTkQsXG4gICAgICAgICc9PSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICchPSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICc9PT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnIT09JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJ2lzJzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJ2lzbnQnOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnPCc6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJz4nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc8PSc6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJz49JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnaW4nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICdpbnN0YW5jZW9mJzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPDwnOiBQcmVjZWRlbmNlLkJpdHdpc2VTSElGVCxcbiAgICAgICAgJz4+JzogUHJlY2VkZW5jZS5CaXR3aXNlU0hJRlQsXG4gICAgICAgICc+Pj4nOiBQcmVjZWRlbmNlLkJpdHdpc2VTSElGVCxcbiAgICAgICAgJysnOiBQcmVjZWRlbmNlLkFkZGl0aXZlLFxuICAgICAgICAnLSc6IFByZWNlZGVuY2UuQWRkaXRpdmUsXG4gICAgICAgICcqJzogUHJlY2VkZW5jZS5NdWx0aXBsaWNhdGl2ZSxcbiAgICAgICAgJyUnOiBQcmVjZWRlbmNlLk11bHRpcGxpY2F0aXZlLFxuICAgICAgICAnLyc6IFByZWNlZGVuY2UuTXVsdGlwbGljYXRpdmVcbiAgICB9O1xuXG4gICAgUmVnZXggPSB7XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NjlcXHUwNjZlLVxcdTA2ZDNcXHUwNmQ1LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZThcXHUwNmVhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMC1cXHUwNzRhXFx1MDc0ZC1cXHUwN2IxXFx1MDdjMC1cXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgyZFxcdTA4NDAtXFx1MDg1YlxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTgxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJjLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZVxcdTA5ZDdcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllM1xcdTA5ZTYtXFx1MDlmMVxcdTBhMDEtXFx1MGEwM1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTY2LVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmMtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZDBcXHUwYWUwLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzYy1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI3MVxcdTBiODJcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDBcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZC1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzU4XFx1MGM1OVxcdTBjNjAtXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiYy1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2RlXFx1MGNlMC1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGNmMVxcdTBjZjJcXHUwZDAyXFx1MGQwM1xcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2QtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZVxcdTBkNTdcXHUwZDYwLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDdhLVxcdTBkN2ZcXHUwZDgyXFx1MGQ4M1xcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUwMS1cXHUwZTNhXFx1MGU0MC1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjlcXHUwZWJiLVxcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZS1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5ZFxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzVkLVxcdTEzNWZcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdkM1xcdTE3ZDdcXHUxN2RjXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExYlxcdTFhMjAtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYTdcXHUxYjAwLVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiZjNcXHUxYzAwLVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzRkLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZjZcXHUxZDAwLVxcdTFkZTZcXHUxZGZjLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ3Zi1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmRlMC1cXHUyZGZmXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyZlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlhXFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjJiXFx1YTY0MC1cXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY3Zi1cXHVhNjk3XFx1YTY5Zi1cXHVhNmYxXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODI3XFx1YTg0MC1cXHVhODczXFx1YTg4MC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGY3XFx1YThmYlxcdWE5MDAtXFx1YTkyZFxcdWE5MzAtXFx1YTk1M1xcdWE5NjAtXFx1YTk3Y1xcdWE5ODAtXFx1YTljMFxcdWE5Y2YtXFx1YTlkOVxcdWFhMDAtXFx1YWEzNlxcdWFhNDAtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdiXFx1YWE4MC1cXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVmXFx1YWFmMi1cXHVhYWY2XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYxMC1cXHVmZjE5XFx1ZmYyMS1cXHVmZjNhXFx1ZmYzZlxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY10nKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0T3B0aW9ucygpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRlbnQ6IG51bGwsXG4gICAgICAgICAgICBiYXNlOiBudWxsLFxuICAgICAgICAgICAgcGFyc2U6IG51bGwsXG4gICAgICAgICAgICBjb21tZW50OiBmYWxzZSxcbiAgICAgICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgICAgIGluZGVudDoge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJyAgICAnLFxuICAgICAgICAgICAgICAgICAgICBiYXNlOiAwLFxuICAgICAgICAgICAgICAgICAgICBhZGp1c3RNdWx0aWxpbmVDb21tZW50OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV3bGluZTogJ1xcbicsXG4gICAgICAgICAgICAgICAgc3BhY2U6ICcgJyxcbiAgICAgICAgICAgICAgICBqc29uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZW51bWJlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgaGV4YWRlY2ltYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1b3RlczogJ3NpbmdsZScsXG4gICAgICAgICAgICAgICAgZXNjYXBlbGVzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyZW50aGVzZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbjogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3o6IHtcbiAgICAgICAgICAgICAgICBzdGFybGVzc0dlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcGFyZW50aGVzaXplZENvbXByZWhlbnNpb25CbG9jazogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IG51bGwsXG4gICAgICAgICAgICBzb3VyY2VNYXBSb290OiBudWxsLFxuICAgICAgICAgICAgc291cmNlTWFwV2l0aENvZGU6IGZhbHNlLFxuICAgICAgICAgICAgZGlyZWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHZlcmJhdGltOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1JlcGVhdChzdHIsIG51bSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgZm9yIChudW0gfD0gMDsgbnVtID4gMDsgbnVtID4+Pj0gMSwgc3RyICs9IHN0cikge1xuICAgICAgICAgICAgaWYgKG51bSAmIDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciB0aGUgbm9uIFNvdXJjZU1hcCBlbnZpcm9ubWVudFxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVNb2NrKGxpbmUsIGNvbHVtbiwgZmlsZW5hbWUsIGNodW5rKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBmbGF0dGVuKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGlucHV0Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlbihpbnB1dFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIFNvdXJjZU5vZGVNb2NrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnICYmIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmxhdHRlbihjaHVuayk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXN1bHQ7XG4gICAgfVxuXG4gICAgU291cmNlTm9kZU1vY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHZhciByZXMgPSAnJywgaSwgaXosIG5vZGU7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgU291cmNlTm9kZU1vY2spIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gbm9kZS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICBTb3VyY2VOb2RlTW9jay5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gcmVwbGFjZVJpZ2h0KHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIFNvdXJjZU5vZGVNb2NrKSB7XG4gICAgICAgICAgICBsYXN0LnJlcGxhY2VSaWdodChwYXR0ZXJuLCByZXBsYWNlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0LnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU291cmNlTm9kZU1vY2sucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHNlcCkge1xuICAgICAgICB2YXIgaSwgaXosIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGl6ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmIChpeiA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6IC09IDE7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZHJlbltpXSwgc2VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRyZW5baXpdKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGhhc0xpbmVUZXJtaW5hdG9yKHN0cikge1xuICAgICAgICByZXR1cm4gKC9bXFxyXFxuXS9nKS50ZXN0KHN0cik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kc1dpdGhMaW5lVGVybWluYXRvcihzdHIpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBjaCAmJiBpc0xpbmVUZXJtaW5hdG9yKGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVEZWVwbHkodGFyZ2V0LCBvdmVycmlkZSkge1xuICAgICAgICB2YXIga2V5LCB2YWw7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNIYXNoT2JqZWN0KHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHRhcmdldCBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGtleSBpbiBvdmVycmlkZSkge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvdmVycmlkZVtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChpc0hhc2hPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIYXNoT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGVlcGx5KHRhcmdldFtrZXldLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB1cGRhdGVEZWVwbHkoe30sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZU51bWJlcih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0LCBwb2ludCwgdGVtcCwgZXhwb25lbnQsIHBvcztcblxuICAgICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWVyaWMgbGl0ZXJhbCB3aG9zZSB2YWx1ZSBpcyBOYU4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1lcmljIGxpdGVyYWwgd2hvc2UgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMSAvIDApIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uID8gJ251bGwnIDogcmVudW1iZXIgPyAnMWU0MDAnIDogJzFlKzQwMCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSAnJyArIHZhbHVlO1xuICAgICAgICBpZiAoIXJlbnVtYmVyIHx8IHJlc3VsdC5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcG9pbnQgPSByZXN1bHQuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoIWpzb24gJiYgcmVzdWx0LmNoYXJBdCgwKSA9PT0gJzAnICYmIHBvaW50ID09PSAxKSB7XG4gICAgICAgICAgICBwb2ludCA9IDA7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoJ2UrJywgJ2UnKTtcbiAgICAgICAgZXhwb25lbnQgPSAwO1xuICAgICAgICBpZiAoKHBvcyA9IHRlbXAuaW5kZXhPZignZScpKSA+IDApIHtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gK3RlbXAuc2xpY2UocG9zICsgMSk7XG4gICAgICAgICAgICB0ZW1wID0gdGVtcC5zbGljZSgwLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludCA+PSAwKSB7XG4gICAgICAgICAgICBleHBvbmVudCAtPSB0ZW1wLmxlbmd0aCAtIHBvaW50IC0gMTtcbiAgICAgICAgICAgIHRlbXAgPSArKHRlbXAuc2xpY2UoMCwgcG9pbnQpICsgdGVtcC5zbGljZShwb2ludCArIDEpKSArICcnO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IDA7XG4gICAgICAgIHdoaWxlICh0ZW1wLmNoYXJBdCh0ZW1wLmxlbmd0aCArIHBvcyAtIDEpID09PSAnMCcpIHtcbiAgICAgICAgICAgIHBvcyAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgIT09IDApIHtcbiAgICAgICAgICAgIGV4cG9uZW50IC09IHBvcztcbiAgICAgICAgICAgIHRlbXAgPSB0ZW1wLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9uZW50ICE9PSAwKSB7XG4gICAgICAgICAgICB0ZW1wICs9ICdlJyArIGV4cG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGVtcC5sZW5ndGggPCByZXN1bHQubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIChoZXhhZGVjaW1hbCAmJiB2YWx1ZSA+IDFlMTIgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlICYmICh0ZW1wID0gJzB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KSkubGVuZ3RoIDwgcmVzdWx0Lmxlbmd0aCkpICYmXG4gICAgICAgICAgICAgICAgK3RlbXAgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSB2YWxpZCBSZWdFeHAgZXhwcmVzc2lvbi5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2l2IEVuZ2luZVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcmFjdGVyKGNoLCBwcmV2aW91c0lzQmFja3NsYXNoKSB7XG4gICAgICAgIC8vIG5vdCBoYW5kbGluZyAnXFwnIGFuZCBoYW5kbGluZyBcXHUyMDI4IG9yIFxcdTIwMjkgdG8gdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKChjaCAmIH4xKSA9PT0gMHgyMDI4KSB7XG4gICAgICAgICAgICByZXR1cm4gKHByZXZpb3VzSXNCYWNrc2xhc2ggPyAndScgOiAnXFxcXHUnKSArICgoY2ggPT09IDB4MjAyOCkgPyAnMjAyOCcgOiAnMjAyOScpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gMTMpIHsgIC8vIFxcbiwgXFxyXG4gICAgICAgICAgICByZXR1cm4gKHByZXZpb3VzSXNCYWNrc2xhc2ggPyAnJyA6ICdcXFxcJykgKyAoKGNoID09PSAxMCkgPyAnbicgOiAncicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVJlZ0V4cChyZWcpIHtcbiAgICAgICAgdmFyIG1hdGNoLCByZXN1bHQsIGZsYWdzLCBpLCBpeiwgY2gsIGNoYXJhY3RlckluQnJhY2ssIHByZXZpb3VzSXNCYWNrc2xhc2g7XG5cbiAgICAgICAgcmVzdWx0ID0gcmVnLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHJlZy5zb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIGV4dHJhY3QgZmxhZyBmcm9tIHRvU3RyaW5nIHJlc3VsdFxuICAgICAgICAgICAgbWF0Y2ggPSByZXN1bHQubWF0Y2goL1xcLyhbXi9dKikkLyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxhZ3MgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgICAgICBjaGFyYWN0ZXJJbkJyYWNrID0gZmFsc2U7XG4gICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHJlZy5zb3VyY2UubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIGNoID0gcmVnLnNvdXJjZS5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c0lzQmFja3NsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJJbkJyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDkzKSB7ICAvLyBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVySW5CcmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0NykgeyAgLy8gL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSA5MSkgeyAgLy8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckluQnJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVSZWdFeHBDaGFyYWN0ZXIoY2gsIHByZXZpb3VzSXNCYWNrc2xhc2gpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gY2ggPT09IDkyOyAgLy8gXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBuZXcgUmVnRXhwKFwiXFxcXFxcbicpIGlzIHByb3ZpZGVkLCBjcmVhdGUgL1xcbi9cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcihjaCwgcHJldmlvdXNJc0JhY2tzbGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbGlrZSAvXFxcXFsvXS9cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNJc0JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICcvJyArIHJlc3VsdCArICcvJyArIGZsYWdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVBbGxvd2VkQ2hhcmFjdGVyKGNoLCBuZXh0KSB7XG4gICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKSwgaGV4ID0gY29kZS50b1N0cmluZygxNiksIHJlc3VsdCA9ICdcXFxcJztcblxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgJ1xcYic6XG4gICAgICAgICAgICByZXN1bHQgKz0gJ2InO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1xcZic6XG4gICAgICAgICAgICByZXN1bHQgKz0gJ2YnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gJ3QnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoanNvbiB8fCBjb2RlID4gMHhmZikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAndScgKyAnMDAwMCcuc2xpY2UoaGV4Lmxlbmd0aCkgKyBoZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFx1MDAwMCcgJiYgJzAxMjM0NTY3ODknLmluZGV4T2YobmV4dCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcwJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXHgwQicpIHsgLy8gJ1xcdidcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3gwQic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAneCcgKyAnMDAnLnNsaWNlKGhleC5sZW5ndGgpICsgaGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZURpc2FsbG93ZWRDaGFyYWN0ZXIoY2gpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdcXFxcJztcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAnbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAncic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXFx1MjAyOCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gJ3UyMDI4JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdcXHUyMDI5JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAndTIwMjknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdGx5IGNsYXNzaWZpZWQgY2hhcmFjdGVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZURpcmVjdGl2ZShzdHIpIHtcbiAgICAgICAgdmFyIGksIGl6LCBjaCwgYnVmLCBxdW90ZTtcblxuICAgICAgICBidWYgPSBzdHI7XG4gICAgICAgIGlmICh0eXBlb2YgYnVmWzBdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYnVmID0gc3RyaW5nVG9BcnJheShidWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcXVvdGUgPSBxdW90ZXMgPT09ICdkb3VibGUnID8gJ1wiJyA6ICdcXCcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGJ1Zi5sZW5ndGg7IGkgPCBpejsgaSArPSAxKSB7XG4gICAgICAgICAgICBjaCA9IGJ1ZltpXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAgICAgICBxdW90ZSA9ICdcIic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnXFwnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdW90ZSArIHN0ciArIHF1b3RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLCBpLCBsZW4sIGNoLCBzaW5nbGVRdW90ZXMgPSAwLCBkb3VibGVRdW90ZXMgPSAwLCBzaW5nbGU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdHJbMF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHJpbmdUb0FycmF5KHN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNoID0gc3RyW2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFwnJykge1xuICAgICAgICAgICAgICAgIHNpbmdsZVF1b3RlcyArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIGRvdWJsZVF1b3RlcyArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy8nICYmIGpzb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5Jy5pbmRleE9mKGNoKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZURpc2FsbG93ZWRDaGFyYWN0ZXIoY2gpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoanNvbiAmJiBjaCA8ICcgJykgfHwgIShqc29uIHx8IGVzY2FwZWxlc3MgfHwgKGNoID49ICcgJyAmJiBjaCA8PSAnficpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVBbGxvd2VkQ2hhcmFjdGVyKGNoLCBzdHJbaSArIDFdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpbmdsZSA9ICEocXVvdGVzID09PSAnZG91YmxlJyB8fCAocXVvdGVzID09PSAnYXV0bycgJiYgZG91YmxlUXVvdGVzIDwgc2luZ2xlUXVvdGVzKSk7XG4gICAgICAgIHN0ciA9IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gc2luZ2xlID8gJ1xcJycgOiAnXCInO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc3RyWzBdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3RyID0gc3RyaW5nVG9BcnJheShzdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjaCA9IHN0cltpXTtcbiAgICAgICAgICAgIGlmICgoY2ggPT09ICdcXCcnICYmIHNpbmdsZSkgfHwgKGNoID09PSAnXCInICYmICFzaW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQgKyAoc2luZ2xlID8gJ1xcJycgOiAnXCInKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgICAgLy8gVXNlIGBcXHgwQmAgaW5zdGVhZCBvZiBgXFx2YCBmb3IgSUUgPCA5IGNvbXBhdGliaWxpdHlcbiAgICAgICAgcmV0dXJuICdcXHRcXHgwQlxcZiBcXHhhMCcuaW5kZXhPZihjaCkgPj0gMCB8fCAoY2guY2hhckNvZGVBdCgwKSA+PSAweDE2ODAgJiYgJ1xcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmJy5pbmRleE9mKGNoKSA+PSAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxyXFx1MjAyOFxcdTIwMjknLmluZGV4T2YoY2gpID49IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnJCcpIHx8IChjaCA9PT0gJ18nKSB8fCAoY2ggPT09ICdcXFxcJykgfHxcbiAgICAgICAgICAgIChjaCA+PSAnYScgJiYgY2ggPD0gJ3onKSB8fCAoY2ggPj0gJ0EnICYmIGNoIDw9ICdaJykgfHxcbiAgICAgICAgICAgICgoY2ggPj0gJzAnKSAmJiAoY2ggPD0gJzknKSkgfHxcbiAgICAgICAgICAgICgoY2guY2hhckNvZGVBdCgwKSA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoY2gpKTtcbiAgICB9XG5cbiAgICAvLyB0YWtlcyBjaGFyIGNvZGVcbiAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gKGNoID49IDQ4ICYmIGNoIDw9IDU3KTsgICAvLyAwLi45XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2VOb2RlKGdlbmVyYXRlZCwgbm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5sb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKG51bGwsIG51bGwsIHNvdXJjZU1hcCwgZ2VuZXJhdGVkLCBub2RlLm5hbWUgfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKG5vZGUubG9jLnN0YXJ0LmxpbmUsIG5vZGUubG9jLnN0YXJ0LmNvbHVtbiwgKHNvdXJjZU1hcCA9PT0gdHJ1ZSA/IG5vZGUubG9jLnNvdXJjZSB8fCBudWxsIDogc291cmNlTWFwKSwgZ2VuZXJhdGVkLCBub2RlLm5hbWUgfHwgbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9FbXB0eVNwYWNlKCkge1xuICAgICAgICByZXR1cm4gKHNwYWNlKSA/IHNwYWNlIDogJyAnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGpvaW4obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIGxlZnRTb3VyY2UgPSB0b1NvdXJjZU5vZGUobGVmdCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHJpZ2h0U291cmNlID0gdG9Tb3VyY2VOb2RlKHJpZ2h0KS50b1N0cmluZygpLFxuICAgICAgICAgICAgbGVmdENoYXIgPSBsZWZ0U291cmNlLmNoYXJBdChsZWZ0U291cmNlLmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgcmlnaHRDaGFyID0gcmlnaHRTb3VyY2UuY2hhckF0KDApO1xuXG4gICAgICAgIGlmICgobGVmdENoYXIgPT09ICcrJyB8fCBsZWZ0Q2hhciA9PT0gJy0nKSAmJiBsZWZ0Q2hhciA9PT0gcmlnaHRDaGFyIHx8XG4gICAgICAgIGlzSWRlbnRpZmllclBhcnQobGVmdENoYXIpICYmIGlzSWRlbnRpZmllclBhcnQocmlnaHRDaGFyKSB8fFxuICAgICAgICBsZWZ0Q2hhciA9PT0gJy8nICYmIHJpZ2h0Q2hhciA9PT0gJ2knKSB7IC8vIGluZml4IHdvcmQgb3BlcmF0b3JzIGFsbCBzdGFydCB3aXRoIGBpYFxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCBub0VtcHR5U3BhY2UoKSwgcmlnaHRdO1xuICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVTcGFjZShsZWZ0Q2hhcikgfHwgaXNMaW5lVGVybWluYXRvcihsZWZ0Q2hhcikgfHwgaXNXaGl0ZVNwYWNlKHJpZ2h0Q2hhcikgfHwgaXNMaW5lVGVybWluYXRvcihyaWdodENoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2xlZnQsIHNwYWNlLCByaWdodF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkSW5kZW50KHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIFtiYXNlLCBzdG10XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aXRoSW5kZW50KGZuKSB7XG4gICAgICAgIHZhciBwcmV2aW91c0Jhc2UsIHJlc3VsdDtcbiAgICAgICAgcHJldmlvdXNCYXNlID0gYmFzZTtcbiAgICAgICAgYmFzZSArPSBpbmRlbnQ7XG4gICAgICAgIHJlc3VsdCA9IGZuLmNhbGwodGhpcywgYmFzZSk7XG4gICAgICAgIGJhc2UgPSBwcmV2aW91c0Jhc2U7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2VzKHN0cikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihzdHIuY2hhckF0KGkpKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc3RyLmxlbmd0aCAtIDEpIC0gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGp1c3RNdWx0aWxpbmVDb21tZW50KHZhbHVlLCBzcGVjaWFsQmFzZSkge1xuICAgICAgICB2YXIgYXJyYXksIGksIGxlbiwgbGluZSwgaiwgc3BhY2VzLCBwcmV2aW91c0Jhc2U7XG5cbiAgICAgICAgYXJyYXkgPSB2YWx1ZS5zcGxpdCgvXFxyXFxufFtcXHJcXG5dLyk7XG4gICAgICAgIHNwYWNlcyA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgLy8gZmlyc3QgbGluZSBkb2Vzbid0IGhhdmUgaW5kZW50YXRpb25cbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxpbmUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBsaW5lLmxlbmd0aCAmJiBpc1doaXRlU3BhY2UobGluZVtqXSkpIHtcbiAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BhY2VzID4gaikge1xuICAgICAgICAgICAgICAgIHNwYWNlcyA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNwZWNpYWxCYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gcGF0dGVybiBsaWtlXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgIHZhciB0ID0gMjA7ICAvKlxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICogdGhpcyBpcyBjb21tZW50XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmFzZSA9IGJhc2U7XG4gICAgICAgICAgICBpZiAoYXJyYXlbMV1bc3BhY2VzXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEJhc2UgKz0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZSA9IHNwZWNpYWxCYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNwYWNlcyAmIDEpIHtcbiAgICAgICAgICAgICAgICAvLyAvKlxuICAgICAgICAgICAgICAgIC8vICAqXG4gICAgICAgICAgICAgICAgLy8gICovXG4gICAgICAgICAgICAgICAgLy8gSWYgc3BhY2VzIGFyZSBvZGQgbnVtYmVyLCBhYm92ZSBwYXR0ZXJuIGlzIGNvbnNpZGVyZWQuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FzdGUgMSBzcGFjZS5cbiAgICAgICAgICAgICAgICBzcGFjZXMgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzQmFzZSA9IGJhc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSB0b1NvdXJjZU5vZGUoYWRkSW5kZW50KGFycmF5W2ldLnNsaWNlKHNwYWNlcykpKS5qb2luKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2UgPSBwcmV2aW91c0Jhc2U7XG5cbiAgICAgICAgcmV0dXJuIGFycmF5LmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ29tbWVudChjb21tZW50LCBzcGVjaWFsQmFzZSkge1xuICAgICAgICBpZiAoY29tbWVudC50eXBlID09PSAnTGluZScpIHtcbiAgICAgICAgICAgIGlmIChlbmRzV2l0aExpbmVUZXJtaW5hdG9yKGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcvLycgKyBjb21tZW50LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXNlIExpbmVUZXJtaW5hdG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuICcvLycgKyBjb21tZW50LnZhbHVlICsgJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhLmZvcm1hdC5pbmRlbnQuYWRqdXN0TXVsdGlsaW5lQ29tbWVudCAmJiAvW1xcblxccl0vLnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGp1c3RNdWx0aWxpbmVDb21tZW50KCcvKicgKyBjb21tZW50LnZhbHVlICsgJyovJywgc3BlY2lhbEJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLyonICsgY29tbWVudC52YWx1ZSArICcqLyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQ29tbWVudHNUb1N0YXRlbWVudChzdG10LCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgY29tbWVudCwgc2F2ZSwgdGFpbGluZ1RvU3RhdGVtZW50LCBzcGVjaWFsQmFzZSwgZnJhZ21lbnQ7XG5cbiAgICAgICAgaWYgKHN0bXQubGVhZGluZ0NvbW1lbnRzICYmIHN0bXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNhdmUgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LmxlYWRpbmdDb21tZW50c1swXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYgKHNhZmVDb25jYXRlbmF0aW9uICYmIHN0bXQudHlwZSA9PT0gU3ludGF4LlByb2dyYW0gJiYgc3RtdC5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlQ29tbWVudChjb21tZW50KSk7XG4gICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHN0bXQubGVhZGluZ0NvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQubGVhZGluZ0NvbW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gW2dlbmVyYXRlQ29tbWVudChjb21tZW50KV07XG4gICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudChmcmFnbWVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoc2F2ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0bXQudHJhaWxpbmdDb21tZW50cykge1xuICAgICAgICAgICAgdGFpbGluZ1RvU3RhdGVtZW50ID0gIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzcGVjaWFsQmFzZSA9IHN0cmluZ1JlcGVhdCgnICcsIGNhbGN1bGF0ZVNwYWNlcyh0b1NvdXJjZU5vZGUoW2Jhc2UsIHJlc3VsdCwgaW5kZW50XSkudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RtdC50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQudHJhaWxpbmdDb21tZW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodGFpbGluZ1RvU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0YXJnZXQgbGlrZSBmb2xsb3dpbmcgc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciB0ID0gMjA7ICAvKipcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAqIFRoaXMgaXMgY29tbWVudCBvZiB0XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIGluZGVudF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCBzcGVjaWFsQmFzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQsIHNwZWNpYWxCYXNlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgYWRkSW5kZW50KGdlbmVyYXRlQ29tbWVudChjb21tZW50KSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gbGVuIC0gMSAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGUocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCAnXFxuJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRoZXNpemUodGV4dCwgY3VycmVudCwgc2hvdWxkKSB7XG4gICAgICAgIGlmIChjdXJyZW50IDwgc2hvdWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gWycoJywgdGV4dCwgJyknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXliZUJsb2NrKHN0bXQsIHNlbWljb2xvbk9wdGlvbmFsLCBmdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgbm9MZWFkaW5nQ29tbWVudDtcblxuICAgICAgICBub0xlYWRpbmdDb21tZW50ID0gIWV4dHJhLmNvbW1lbnQgfHwgIXN0bXQubGVhZGluZ0NvbW1lbnRzO1xuXG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCAmJiBub0xlYWRpbmdDb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NwYWNlLCBnZW5lcmF0ZVN0YXRlbWVudChzdG10LCB7IGZ1bmN0aW9uQm9keTogZnVuY3Rpb25Cb2R5IH0pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5FbXB0eVN0YXRlbWVudCAmJiBub0xlYWRpbmdDb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJzsnO1xuICAgICAgICB9XG5cbiAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbbmV3bGluZSwgYWRkSW5kZW50KGdlbmVyYXRlU3RhdGVtZW50KHN0bXQsIHsgc2VtaWNvbG9uT3B0aW9uYWw6IHNlbWljb2xvbk9wdGlvbmFsLCBmdW5jdGlvbkJvZHk6IGZ1bmN0aW9uQm9keSB9KSldO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heWJlQmxvY2tTdWZmaXgoc3RtdCwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBlbmRzID0gZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGUocmVzdWx0KS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKHN0bXQudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50ICYmICghZXh0cmEuY29tbWVudCB8fCAhc3RtdC5sZWFkaW5nQ29tbWVudHMpICYmICFlbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgc3BhY2VdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgYmFzZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyZXN1bHQsIG5ld2xpbmUsIGJhc2VdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlVmVyYmF0aW0oZXhwciwgb3B0aW9uKSB7XG4gICAgICAgIHZhciBpLCByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IGV4cHJbZXh0cmEudmVyYmF0aW1dLnNwbGl0KC9cXHJcXG58XFxuLyk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IG5ld2xpbmUgKyBiYXNlICsgcmVzdWx0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgb3B0aW9uLnByZWNlZGVuY2UpO1xuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlKHJlc3VsdCwgZXhwcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZShub2RlLm5hbWUsIG5vZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRnVuY3Rpb25Cb2R5KG5vZGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgaSwgbGVuLCBleHByLCBhcnJvdztcblxuICAgICAgICBhcnJvdyA9IG5vZGUudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuXG4gICAgICAgIGlmIChhcnJvdyAmJiBub2RlLnBhcmFtcy5sZW5ndGggPT09IDEgJiYgbm9kZS5wYXJhbXNbMF0udHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIGFyZyA9PiB7IH0gY2FzZVxuICAgICAgICAgICAgcmVzdWx0ID0gW2dlbmVyYXRlSWRlbnRpZmllcihub2RlLnBhcmFtc1swXSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gWycoJ107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLnBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlSWRlbnRpZmllcihub2RlLnBhcmFtc1tpXSkpO1xuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJvdykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UsICc9PicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgZXhwciA9IGdlbmVyYXRlRXhwcmVzc2lvbihub2RlLmJvZHksIHtcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGV4cHIudG9TdHJpbmcoKS5jaGFyQXQoMCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBbJygnLCBleHByLCAnKSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZXhwcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChtYXliZUJsb2NrKG5vZGUuYm9keSwgZmFsc2UsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLCBvcHRpb24pIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIHByZWNlZGVuY2UsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY3VycmVudFByZWNlZGVuY2UsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuLFxuICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgZnJhZ21lbnQsXG4gICAgICAgICAgICBtdWx0aWxpbmUsXG4gICAgICAgICAgICBsZWZ0Q2hhcixcbiAgICAgICAgICAgIGxlZnRTb3VyY2UsXG4gICAgICAgICAgICByaWdodENoYXIsXG4gICAgICAgICAgICBhbGxvd0luLFxuICAgICAgICAgICAgYWxsb3dDYWxsLFxuICAgICAgICAgICAgYWxsb3dVbnBhcmVudGhlc2l6ZWROZXcsXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBwcmVjZWRlbmNlID0gb3B0aW9uLnByZWNlZGVuY2U7XG4gICAgICAgIGFsbG93SW4gPSBvcHRpb24uYWxsb3dJbjtcbiAgICAgICAgYWxsb3dDYWxsID0gb3B0aW9uLmFsbG93Q2FsbDtcbiAgICAgICAgdHlwZSA9IGV4cHIudHlwZSB8fCBvcHRpb24udHlwZTtcblxuICAgICAgICBpZiAoZXh0cmEudmVyYmF0aW0gJiYgZXhwci5oYXNPd25Qcm9wZXJ0eShleHRyYS52ZXJiYXRpbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVZlcmJhdGltKGV4cHIsIG9wdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uOlxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBhbGxvd0luIHw9IChQcmVjZWRlbmNlLlNlcXVlbmNlIDwgcHJlY2VkZW5jZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHByLmV4cHJlc3Npb25zLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbnNbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxuICAgICAgICAgICAgYWxsb3dJbiB8PSAoUHJlY2VkZW5jZS5Bc3NpZ25tZW50IDwgcHJlY2VkZW5jZSk7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkNhbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSArIGV4cHIub3BlcmF0b3IgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IGFsbG93SW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246XG4gICAgICAgICAgICBhbGxvd0luIHw9IChQcmVjZWRlbmNlLkFycm93RnVuY3Rpb24gPCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShnZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByKSwgUHJlY2VkZW5jZS5BcnJvd0Z1bmN0aW9uLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGFsbG93SW4gfD0gKFByZWNlZGVuY2UuQ29uZGl0aW9uYWwgPCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLnRlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuTG9naWNhbE9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgKyAnPycgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuY29uc2VxdWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UgKyAnOicgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYWx0ZXJuYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBQcmVjZWRlbmNlLkNvbmRpdGlvbmFsLFxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbjpcbiAgICAgICAgY2FzZSBTeW50YXguQmluYXJ5RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGN1cnJlbnRQcmVjZWRlbmNlID0gQmluYXJ5UHJlY2VkZW5jZVtleHByLm9wZXJhdG9yXTtcblxuICAgICAgICAgICAgYWxsb3dJbiB8PSAoY3VycmVudFByZWNlZGVuY2UgPCBwcmVjZWRlbmNlKTtcblxuICAgICAgICAgICAgZnJhZ21lbnQgPSBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogY3VycmVudFByZWNlZGVuY2UsXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJbixcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWZ0U291cmNlID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgaWYgKGxlZnRTb3VyY2UuY2hhckF0KGxlZnRTb3VyY2UubGVuZ3RoIC0gMSkgPT09ICcvJyAmJiBpc0lkZW50aWZpZXJQYXJ0KGV4cHIub3BlcmF0b3IuY2hhckF0KDApKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtmcmFnbWVudCwgbm9FbXB0eVNwYWNlKCksIGV4cHIub3BlcmF0b3JdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKGZyYWdtZW50LCBleHByLm9wZXJhdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhZ21lbnQgPSBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCwge1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IGN1cnJlbnRQcmVjZWRlbmNlICsgMSxcbiAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luLFxuICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChleHByLm9wZXJhdG9yID09PSAnLycgJiYgZnJhZ21lbnQudG9TdHJpbmcoKS5jaGFyQXQoMCkgPT09ICcvJyB8fFxuICAgICAgICAgICAgZXhwci5vcGVyYXRvci5zbGljZSgtMSkgPT09ICc8JyAmJiBmcmFnbWVudC50b1N0cmluZygpLnNsaWNlKDAsIDMpID09PSAnIS0tJykge1xuICAgICAgICAgICAgICAgIC8vIElmICcvJyBjb25jYXRzIHdpdGggJy8nIG9yIGA8YCBjb25jYXRzIHdpdGggYCEtLWAsIGl0IGlzIGludGVycHJldGVkIGFzIGNvbW1lbnQgc3RhcnRcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvciA9PT0gJ2luJyAmJiAhYWxsb3dJbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnKCcsIHJlc3VsdCwgJyknXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgY3VycmVudFByZWNlZGVuY2UsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5DYWxsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJlc3VsdCA9IFtnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5jYWxsZWUsIHtcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkNhbGwsXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWUsXG4gICAgICAgICAgICAgICAgYWxsb3dVbnBhcmVudGhlc2l6ZWROZXc6IGZhbHNlXG4gICAgICAgICAgICB9KV07XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcoJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHByWydhcmd1bWVudHMnXS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlRXhwcmVzc2lvbihleHByWydhcmd1bWVudHMnXVtpXSwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcpJyk7XG5cbiAgICAgICAgICAgIGlmICghYWxsb3dDYWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWycoJywgcmVzdWx0LCAnKSddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLkNhbGwsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguTmV3RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGxlbiA9IGV4cHJbJ2FyZ3VtZW50cyddLmxlbmd0aDtcbiAgICAgICAgICAgIGFsbG93VW5wYXJlbnRoZXNpemVkTmV3ID0gb3B0aW9uLmFsbG93VW5wYXJlbnRoZXNpemVkTmV3ID09PSB1bmRlZmluZWQgfHwgb3B0aW9uLmFsbG93VW5wYXJlbnRoZXNpemVkTmV3O1xuXG4gICAgICAgICAgICByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgICduZXcnLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmNhbGxlZSwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLk5ldyxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dVbnBhcmVudGhlc2l6ZWROZXc6IGFsbG93VW5wYXJlbnRoZXNpemVkTmV3ICYmICFwYXJlbnRoZXNlcyAmJiBsZW4gPT09IDBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCFhbGxvd1VucGFyZW50aGVzaXplZE5ldyB8fCBwYXJlbnRoZXNlcyB8fCBsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJygnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHJbJ2FyZ3VtZW50cyddW2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5OZXcsIHByZWNlZGVuY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJlc3VsdCA9IFtnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5vYmplY3QsIHtcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkNhbGwsXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IGFsbG93Q2FsbCxcbiAgICAgICAgICAgICAgICBhbGxvd1VucGFyZW50aGVzaXplZE5ldzogZmFsc2VcbiAgICAgICAgICAgIH0pXTtcblxuICAgICAgICAgICAgaWYgKGV4cHIuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnWycsIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnR5LCB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogYWxsb3dDYWxsXG4gICAgICAgICAgICAgICAgfSksICddJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHByLm9iamVjdC50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiB0eXBlb2YgZXhwci5vYmplY3QudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGFsbCB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDEuIE5vIGZsb2F0aW5nIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vICAgMi4gRG9uJ3QgaGF2ZSBleHBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAzLiBUaGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBkZWNpbWFsIGRpZ2l0XG4gICAgICAgICAgICAgICAgICAgIC8vICAgNC4gTm90IGhleGFkZWNpbWFsIE9SIG9jdGFsIG51bWJlciBsaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhZGQgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmluZGV4T2YoJy4nKSA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhL1tlRXhYXS8udGVzdChmcmFnbWVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RlY2ltYWxEaWdpdChmcmFnbWVudC5jaGFyQ29kZUF0KGZyYWdtZW50Lmxlbmd0aCAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoZnJhZ21lbnQubGVuZ3RoID49IDIgJiYgZnJhZ21lbnQuY2hhckNvZGVBdCgwKSA9PT0gNDgpICAvLyAnMCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJy4nLCBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5wcm9wZXJ0eSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk1lbWJlciwgcHJlY2VkZW5jZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5VbmFyeUV4cHJlc3Npb246XG4gICAgICAgICAgICBmcmFnbWVudCA9IGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCB7XG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5VbmFyeSxcbiAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzcGFjZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKGV4cHIub3BlcmF0b3IsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW2V4cHIub3BlcmF0b3JdO1xuICAgICAgICAgICAgICAgIGlmIChleHByLm9wZXJhdG9yLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlLCB2b2lkLCB0eXBlb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGB0eXBlb2YgW11gLCBub3QgYHR5cGVvZltdYFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgaW5zZXJ0aW5nIHNwYWNlcyBiZXR3ZWVuIG9wZXJhdG9yIGFuZCBhcmd1bWVudCBpZiBpdCBpcyB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICAvLyBsaWtlLCBgIWNvbmRgXG4gICAgICAgICAgICAgICAgICAgIGxlZnRTb3VyY2UgPSB0b1NvdXJjZU5vZGUocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2hhciA9IGxlZnRTb3VyY2UuY2hhckF0KGxlZnRTb3VyY2UubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2hhciA9IGZyYWdtZW50LnRvU3RyaW5nKCkuY2hhckF0KDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKGxlZnRDaGFyID09PSAnKycgfHwgbGVmdENoYXIgPT09ICctJykgJiYgbGVmdENoYXIgPT09IHJpZ2h0Q2hhcikgfHwgKGlzSWRlbnRpZmllclBhcnQobGVmdENoYXIpICYmIGlzSWRlbnRpZmllclBhcnQocmlnaHRDaGFyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vRW1wdHlTcGFjZSgpLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLlVuYXJ5LCBwcmVjZWRlbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LllpZWxkRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGlmIChleHByLmRlbGVnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJ3lpZWxkKic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd5aWVsZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5hcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguVXBkYXRlRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGlmIChleHByLnByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwci5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5VbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgUHJlY2VkZW5jZS5VbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlBvc3RmaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwci5vcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBQcmVjZWRlbmNlLlBvc3RmaXgsXG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxuICAgICAgICAgICAgcmVzdWx0ID0gJ2Z1bmN0aW9uJztcblxuICAgICAgICAgICAgaWYgKGV4cHIuaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCBub0VtcHR5U3BhY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIuaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQgKyBzcGFjZSwgZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwcildO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5BcnJheVBhdHRlcm46XG4gICAgICAgIGNhc2UgU3ludGF4LkFycmF5RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGlmICghZXhwci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnW10nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZXhwci5lbGVtZW50cy5sZW5ndGggPiAxO1xuICAgICAgICAgICAgcmVzdWx0ID0gWydbJywgbXVsdGlsaW5lID8gbmV3bGluZSA6ICcnXTtcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKGluZGVudCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHByLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG11bHRpbGluZSA/IGluZGVudCA6ICcnLCBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5lbGVtZW50c1tpXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgKG11bHRpbGluZSA/IG5ld2xpbmUgOiBzcGFjZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobXVsdGlsaW5lICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBiYXNlIDogJycsICddJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Qcm9wZXJ0eTpcbiAgICAgICAgICAgIGlmIChleHByLmtpbmQgPT09ICdnZXQnIHx8IGV4cHIua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGV4cHIua2luZCwgbm9FbXB0eVNwYWNlKCksXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIuc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHByLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIudmFsdWUuZ2VuZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSksIGdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5rZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGlmICghZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd7fSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aWxpbmUgPSBleHByLnByb3BlcnRpZXMubGVuZ3RoID4gMTtcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0aWVzWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb3BlcnR5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBpc3N1ZXMgNFxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmFuc2Zvcm0gZnJvbVxuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe1xuICAgICAgICAgICAgICAgIC8vICAgICAgIG1ldGhvZDI6IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgICAvLyB0b1xuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe21ldGhvZDI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICB9fSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGUoZnJhZ21lbnQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsgJ3snLCBzcGFjZSwgZnJhZ21lbnQsIHNwYWNlLCAnfScgXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbICd7JywgbmV3bGluZSwgaW5kZW50LCBmcmFnbWVudCBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQsIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnRpZXNbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Qcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgbmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXNlLCAnfScpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguT2JqZWN0UGF0dGVybjpcbiAgICAgICAgICAgIGlmICghZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd7fSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG11bHRpbGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV4cHIucHJvcGVydGllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IGV4cHIucHJvcGVydGllc1swXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkudmFsdWUudHlwZSAhPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IGV4cHIucHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eS5zaG9ydGhhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IFsneycsIG11bHRpbGluZSA/IG5ld2xpbmUgOiAnJyBdO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHByLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycsIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnRpZXNbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG11bHRpbGluZSAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGUocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gYmFzZSA6ICcnLCAnfScpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguVGhpc0V4cHJlc3Npb246XG4gICAgICAgICAgICByZXN1bHQgPSAndGhpcyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyOlxuICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguTGl0ZXJhbDpcbiAgICAgICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KCdyYXcnKSAmJiBwYXJzZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJhdyA9IHBhcnNlKGV4cHIucmF3KS5ib2R5WzBdLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXcudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXcudmFsdWUgPT09IGV4cHIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBleHByLnJhdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHVzZSByYXcgcHJvcGVydHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJ251bGwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXNjYXBlU3RyaW5nKGV4cHIudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVOdW1iZXIoZXhwci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhwci52YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVnRXhwKGV4cHIudmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246XG4gICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgJ1snLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgaWYgKGV4cHIuYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZXhwci5ibG9ja3MubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5ibG9ja3NbaV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICdpZicgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5maWx0ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhLm1vei5wYXJlbnRoZXNpemVkQ29tcHJlaGVuc2lvbkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbICcoJywgZnJhZ21lbnQsICcpJyBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCddJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Db21wcmVoZW5zaW9uQmxvY2s6XG4gICAgICAgICAgICBpZiAoZXhwci5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGV4cHIubGVmdC5raW5kLCBub0VtcHR5U3BhY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVTdGF0ZW1lbnQoZXhwci5sZWZ0LmRlY2xhcmF0aW9uc1swXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGdlbmVyYXRlRXhwcmVzc2lvbihleHByLmxlZnQsIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5DYWxsLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhZ21lbnQgPSBqb2luKGZyYWdtZW50LCBleHByLm9mID8gJ29mJyA6ICdpbicpO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBqb2luKGZyYWdtZW50LCBnZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCwge1xuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgaWYgKGV4dHJhLm1vei5wYXJlbnRoZXNpemVkQ29tcHJlaGVuc2lvbkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWyAnZm9yJyArIHNwYWNlICsgJygnLCBmcmFnbWVudCwgJyknIF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oJ2ZvcicgKyBzcGFjZSwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBleHByZXNzaW9uIHR5cGU6ICcgKyBleHByLnR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZShyZXN1bHQsIGV4cHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3RhdGVtZW50KHN0bXQsIG9wdGlvbikge1xuICAgICAgICB2YXIgaSwgbGVuLCByZXN1bHQsIG5vZGUsIGFsbG93SW4sIGZ1bmN0aW9uQm9keSwgZGlyZWN0aXZlQ29udGV4dCwgZnJhZ21lbnQsIHNlbWljb2xvbjtcblxuICAgICAgICBhbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgc2VtaWNvbG9uID0gJzsnO1xuICAgICAgICBmdW5jdGlvbkJvZHkgPSBmYWxzZTtcbiAgICAgICAgZGlyZWN0aXZlQ29udGV4dCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICBhbGxvd0luID0gb3B0aW9uLmFsbG93SW4gPT09IHVuZGVmaW5lZCB8fCBvcHRpb24uYWxsb3dJbjtcbiAgICAgICAgICAgIGlmICghc2VtaWNvbG9ucyAmJiBvcHRpb24uc2VtaWNvbG9uT3B0aW9uYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZW1pY29sb24gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uQm9keSA9IG9wdGlvbi5mdW5jdGlvbkJvZHk7XG4gICAgICAgICAgICBkaXJlY3RpdmVDb250ZXh0ID0gb3B0aW9uLmRpcmVjdGl2ZUNvbnRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHN0bXQudHlwZSkge1xuICAgICAgICBjYXNlIFN5bnRheC5CbG9ja1N0YXRlbWVudDpcbiAgICAgICAgICAgIHJlc3VsdCA9IFsneycsIG5ld2xpbmVdO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdG10LmJvZHkubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQoZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW1pY29sb25PcHRpb25hbDogaSA9PT0gbGVuIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZUNvbnRleHQ6IGZ1bmN0aW9uQm9keVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCgnfScpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkJyZWFrU3RhdGVtZW50OlxuICAgICAgICAgICAgaWYgKHN0bXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnYnJlYWsgJyArIHN0bXQubGFiZWwubmFtZSArIHNlbWljb2xvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJ2JyZWFrJyArIHNlbWljb2xvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50OlxuICAgICAgICAgICAgaWYgKHN0bXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnY29udGludWUgJyArIHN0bXQubGFiZWwubmFtZSArIHNlbWljb2xvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJ2NvbnRpbnVlJyArIHNlbWljb2xvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LkRpcmVjdGl2ZVN0YXRlbWVudDpcbiAgICAgICAgICAgIGlmIChzdG10LnJhdykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0bXQucmF3ICsgc2VtaWNvbG9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBlc2NhcGVEaXJlY3RpdmUoc3RtdC5kaXJlY3RpdmUpICsgc2VtaWNvbG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguRG9XaGlsZVN0YXRlbWVudDpcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgYGRvIDQyIHdoaWxlIChjb25kKWAgaXMgU3ludGF4IEVycm9yLiBXZSBuZWVkIHNlbWljb2xvbi5cbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oJ2RvJywgbWF5YmVCbG9jayhzdG10LmJvZHkpKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1heWJlQmxvY2tTdWZmaXgoc3RtdC5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAnd2hpbGUnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAnKScgKyBzZW1pY29sb25cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguQ2F0Y2hDbGF1c2U6XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICdjYXRjaCcgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQucGFyYW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChtYXliZUJsb2NrKHN0bXQuYm9keSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguRGVidWdnZXJTdGF0ZW1lbnQ6XG4gICAgICAgICAgICByZXN1bHQgPSAnZGVidWdnZXInICsgc2VtaWNvbG9uO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguRW1wdHlTdGF0ZW1lbnQ6XG4gICAgICAgICAgICByZXN1bHQgPSAnOyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50OlxuICAgICAgICAgICAgcmVzdWx0ID0gW2dlbmVyYXRlRXhwcmVzc2lvbihzdG10LmV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAvLyAxMi40ICd7JywgJ2Z1bmN0aW9uJyBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHBvc2l0aW9uLlxuICAgICAgICAgICAgLy8gd3JhcCBleHByZXNzaW9uIHdpdGggcGFyZW50aGVzZXNcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdG9Tb3VyY2VOb2RlKHJlc3VsdCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGFyQXQoMCkgPT09ICd7JyB8fCAoZnJhZ21lbnQuc2xpY2UoMCwgOCkgPT09ICdmdW5jdGlvbicgJiYgJyAoJy5pbmRleE9mKGZyYWdtZW50LmNoYXJBdCg4KSkgPj0gMCkgfHwgKGRpcmVjdGl2ZSAmJiBkaXJlY3RpdmVDb250ZXh0ICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiB0eXBlb2Ygc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbJygnLCByZXN1bHQsICcpJyArIHNlbWljb2xvbl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbWljb2xvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I6XG4gICAgICAgICAgICBpZiAoc3RtdC5pbml0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5pZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICc9JyxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmluaXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuQXNzaWdubWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IGFsbG93SW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZUlkZW50aWZpZXIoc3RtdC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uOlxuICAgICAgICAgICAgcmVzdWx0ID0gW3N0bXQua2luZF07XG4gICAgICAgICAgICAvLyBzcGVjaWFsIHBhdGggZm9yXG4gICAgICAgICAgICAvLyB2YXIgeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIH07XG4gICAgICAgICAgICBpZiAoc3RtdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIHN0bXQuZGVjbGFyYXRpb25zWzBdLmluaXQgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RtdC5kZWNsYXJhdGlvbnNbMF0uaW5pdC50eXBlID09PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCksIGdlbmVyYXRlU3RhdGVtZW50KHN0bXQuZGVjbGFyYXRpb25zWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93SW46IGFsbG93SW5cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlRGVjbGFyYXRvciBpcyB0eXBlZCBhcyBTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGpvaW5lZCB3aXRoIGNvbW1hIChub3QgTGluZVRlcm1pbmF0b3IpLlxuICAgICAgICAgICAgICAgIC8vIFNvIGlmIGNvbW1lbnQgaXMgYXR0YWNoZWQgdG8gdGFyZ2V0IG5vZGUsIHdlIHNob3VsZCBzcGVjaWFsaXplLlxuICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gc3RtdC5kZWNsYXJhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5jb21tZW50ICYmIG5vZGUubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJywgYWRkSW5kZW50KGdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCksIGdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBzdG10LmRlY2xhcmF0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHN0bXQuZGVjbGFyYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lLCBhZGRJbmRlbnQoZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBhbGxvd0luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UsIGdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogYWxsb3dJblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VtaWNvbG9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LlRocm93U3RhdGVtZW50OlxuICAgICAgICAgICAgcmVzdWx0ID0gW2pvaW4oXG4gICAgICAgICAgICAgICAgJ3Rocm93JyxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5hcmd1bWVudCwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSwgc2VtaWNvbG9uXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LlRyeVN0YXRlbWVudDpcbiAgICAgICAgICAgIHJlc3VsdCA9IFsndHJ5JywgbWF5YmVCbG9jayhzdG10LmJsb2NrKV07XG4gICAgICAgICAgICByZXN1bHQgPSBtYXliZUJsb2NrU3VmZml4KHN0bXQuYmxvY2ssIHJlc3VsdCk7XG4gICAgICAgICAgICBpZiAoc3RtdC5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIC8vIG9sZCBpbnRlcmZhY2VcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdG10LmhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBnZW5lcmF0ZVN0YXRlbWVudChzdG10LmhhbmRsZXJzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplciB8fCBpICsgMSAhPT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXliZUJsb2NrU3VmZml4KHN0bXQuaGFuZGxlcnNbaV0uYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbmV3IGludGVyZmFjZVxuICAgICAgICAgICAgICAgIGlmIChzdG10LmhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaGFuZGxlcikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIgfHwgc3RtdC5ndWFyZGVkSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF5YmVCbG9ja1N1ZmZpeChzdG10LmhhbmRsZXIuYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0bXQuZ3VhcmRlZEhhbmRsZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBnZW5lcmF0ZVN0YXRlbWVudChzdG10Lmd1YXJkZWRIYW5kbGVyc1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIgfHwgaSArIDEgIT09IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF5YmVCbG9ja1N1ZmZpeChzdG10Lmd1YXJkZWRIYW5kbGVyc1tpXS5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFsnZmluYWxseScsIG1heWJlQmxvY2soc3RtdC5maW5hbGl6ZXIpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Td2l0Y2hTdGF0ZW1lbnQ6XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICdzd2l0Y2gnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmRpc2NyaW1pbmFudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICcpJyArIHNwYWNlICsgJ3snICsgbmV3bGluZVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzdG10LmNhc2VzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RtdC5jYXNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGFkZEluZGVudChnZW5lcmF0ZVN0YXRlbWVudChzdG10LmNhc2VzW2ldLCB7c2VtaWNvbG9uT3B0aW9uYWw6IGkgPT09IGxlbiAtIDF9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KCd9JykpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguU3dpdGNoQ2FzZTpcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG10LnRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgam9pbignY2FzZScsIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnOidcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ2RlZmF1bHQ6J107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgbGVuID0gc3RtdC5jb25zZXF1ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGVuICYmIHN0bXQuY29uc2VxdWVudFswXS50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBtYXliZUJsb2NrKHN0bXQuY29uc2VxdWVudFswXSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGxlbiAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGUocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gYWRkSW5kZW50KGdlbmVyYXRlU3RhdGVtZW50KHN0bXQuY29uc2VxdWVudFtpXSwge3NlbWljb2xvbk9wdGlvbmFsOiBpID09PSBsZW4gLSAxICYmIHNlbWljb2xvbiA9PT0gJyd9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxICE9PSBsZW4gJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LklmU3RhdGVtZW50OlxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnaWYnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc3RtdC5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXliZUJsb2NrKHN0bXQuY29uc2VxdWVudCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1heWJlQmxvY2tTdWZmaXgoc3RtdC5jb25zZXF1ZW50LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChzdG10LmFsdGVybmF0ZS50eXBlID09PSBTeW50YXguSWZTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFsnZWxzZSAnLCBnZW5lcmF0ZVN0YXRlbWVudChzdG10LmFsdGVybmF0ZSwge3NlbWljb2xvbk9wdGlvbmFsOiBzZW1pY29sb24gPT09ICcnfSldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgam9pbignZWxzZScsIG1heWJlQmxvY2soc3RtdC5hbHRlcm5hdGUsIHNlbWljb2xvbiA9PT0gJycpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXliZUJsb2NrKHN0bXQuY29uc2VxdWVudCwgc2VtaWNvbG9uID09PSAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguRm9yU3RhdGVtZW50OlxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWydmb3InICsgc3BhY2UgKyAnKCddO1xuICAgICAgICAgICAgICAgIGlmIChzdG10LmluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuaW5pdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5pbml0LCB7YWxsb3dJbjogZmFsc2V9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5pbml0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAnOycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJzsnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC50ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlLCBnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSwgJzsnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG10LnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSwgZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudXBkYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSwgJyknKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXN1bHQucHVzaChtYXliZUJsb2NrKHN0bXQuYm9keSwgc2VtaWNvbG9uID09PSAnJykpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguRm9ySW5TdGF0ZW1lbnQ6XG4gICAgICAgICAgICByZXN1bHQgPSBbJ2ZvcicgKyBzcGFjZSArICcoJ107XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RtdC5sZWZ0LmtpbmQgKyBub0VtcHR5U3BhY2UoKSwgZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5sZWZ0LmRlY2xhcmF0aW9uc1swXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmxlZnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuQ2FsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCAnaW4nKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbam9pbihcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5yaWdodCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0NhbGw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApLCAnKSddO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChtYXliZUJsb2NrKHN0bXQuYm9keSwgc2VtaWNvbG9uID09PSAnJykpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguTGFiZWxlZFN0YXRlbWVudDpcbiAgICAgICAgICAgIHJlc3VsdCA9IFtzdG10LmxhYmVsLm5hbWUgKyAnOicsIG1heWJlQmxvY2soc3RtdC5ib2R5LCBzZW1pY29sb24gPT09ICcnKV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5Qcm9ncmFtOlxuICAgICAgICAgICAgbGVuID0gc3RtdC5ib2R5Lmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtzYWZlQ29uY2F0ZW5hdGlvbiAmJiBsZW4gPiAwID8gJ1xcbicgOiAnJ107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGFkZEluZGVudChcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW1pY29sb25PcHRpb25hbDogIXNhZmVDb25jYXRlbmF0aW9uICYmIGkgPT09IGxlbiAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVDb250ZXh0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGVuICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZShmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIHJlc3VsdCA9IFsoc3RtdC5nZW5lcmF0b3IgJiYgIWV4dHJhLm1vei5zdGFybGVzc0dlbmVyYXRvciA/ICdmdW5jdGlvbiogJyA6ICdmdW5jdGlvbiAnKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUlkZW50aWZpZXIoc3RtdC5pZCksXG4gICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGdW5jdGlvbkJvZHkoc3RtdCldO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguUmV0dXJuU3RhdGVtZW50OlxuICAgICAgICAgICAgaWYgKHN0bXQuYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbam9pbihcbiAgICAgICAgICAgICAgICAgICAgJ3JldHVybicsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmFyZ3VtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICksIHNlbWljb2xvbl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsncmV0dXJuJyArIHNlbWljb2xvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN5bnRheC5XaGlsZVN0YXRlbWVudDpcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ3doaWxlJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiBQcmVjZWRlbmNlLlNlcXVlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWF5YmVCbG9jayhzdG10LmJvZHksIHNlbWljb2xvbiA9PT0gJycpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3ludGF4LldpdGhTdGF0ZW1lbnQ6XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICd3aXRoJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5vYmplY3QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IFByZWNlZGVuY2UuU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dDYWxsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChtYXliZUJsb2NrKHN0bXQuYm9keSwgc2VtaWNvbG9uID09PSAnJykpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzdGF0ZW1lbnQgdHlwZTogJyArIHN0bXQudHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdHRhY2ggY29tbWVudHNcblxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYWRkQ29tbWVudHNUb1N0YXRlbWVudChzdG10LCByZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnJhZ21lbnQgPSB0b1NvdXJjZU5vZGUocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguUHJvZ3JhbSAmJiAhc2FmZUNvbmNhdGVuYXRpb24gJiYgbmV3bGluZSA9PT0gJycgJiYgIGZyYWdtZW50LmNoYXJBdChmcmFnbWVudC5sZW5ndGggLSAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRvU291cmNlTm9kZShyZXN1bHQpLnJlcGxhY2VSaWdodCgvXFxzKyQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlKHJlc3VsdCwgc3RtdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUobm9kZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBnZXREZWZhdWx0T3B0aW9ucygpLCByZXN1bHQsIHBhaXI7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gT2Jzb2xldGUgb3B0aW9uc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgYG9wdGlvbnMuaW5kZW50YFxuICAgICAgICAgICAgLy8gICBgb3B0aW9ucy5iYXNlYFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgdGhlbSwgd2UgY2FuIHVzZSBgb3B0aW9uLmZvcm1hdC5pbmRlbnRgLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmluZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9ucy5mb3JtYXQuaW5kZW50LnN0eWxlID0gb3B0aW9ucy5pbmRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYmFzZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9ucy5mb3JtYXQuaW5kZW50LmJhc2UgPSBvcHRpb25zLmJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gdXBkYXRlRGVlcGx5KGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGluZGVudCA9IG9wdGlvbnMuZm9ybWF0LmluZGVudC5zdHlsZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBvcHRpb25zLmJhc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBzdHJpbmdSZXBlYXQoaW5kZW50LCBvcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgICAgICBpbmRlbnQgPSBvcHRpb25zLmZvcm1hdC5pbmRlbnQuc3R5bGU7XG4gICAgICAgICAgICBiYXNlID0gc3RyaW5nUmVwZWF0KGluZGVudCwgb3B0aW9ucy5mb3JtYXQuaW5kZW50LmJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGpzb24gPSBvcHRpb25zLmZvcm1hdC5qc29uO1xuICAgICAgICByZW51bWJlciA9IG9wdGlvbnMuZm9ybWF0LnJlbnVtYmVyO1xuICAgICAgICBoZXhhZGVjaW1hbCA9IGpzb24gPyBmYWxzZSA6IG9wdGlvbnMuZm9ybWF0LmhleGFkZWNpbWFsO1xuICAgICAgICBxdW90ZXMgPSBqc29uID8gJ2RvdWJsZScgOiBvcHRpb25zLmZvcm1hdC5xdW90ZXM7XG4gICAgICAgIGVzY2FwZWxlc3MgPSBvcHRpb25zLmZvcm1hdC5lc2NhcGVsZXNzO1xuICAgICAgICBuZXdsaW5lID0gb3B0aW9ucy5mb3JtYXQubmV3bGluZTtcbiAgICAgICAgc3BhY2UgPSBvcHRpb25zLmZvcm1hdC5zcGFjZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0LmNvbXBhY3QpIHtcbiAgICAgICAgICAgIG5ld2xpbmUgPSBzcGFjZSA9IGluZGVudCA9IGJhc2UgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRoZXNlcyA9IG9wdGlvbnMuZm9ybWF0LnBhcmVudGhlc2VzO1xuICAgICAgICBzZW1pY29sb25zID0gb3B0aW9ucy5mb3JtYXQuc2VtaWNvbG9ucztcbiAgICAgICAgc2FmZUNvbmNhdGVuYXRpb24gPSBvcHRpb25zLmZvcm1hdC5zYWZlQ29uY2F0ZW5hdGlvbjtcbiAgICAgICAgZGlyZWN0aXZlID0gb3B0aW9ucy5kaXJlY3RpdmU7XG4gICAgICAgIHBhcnNlID0ganNvbiA/IG51bGwgOiBvcHRpb25zLnBhcnNlO1xuICAgICAgICBzb3VyY2VNYXAgPSBvcHRpb25zLnNvdXJjZU1hcDtcbiAgICAgICAgZXh0cmEgPSBvcHRpb25zO1xuXG4gICAgICAgIGlmIChzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5icm93c2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIGVudmlyb25tZW50IGlzIG5vZGUuanNcbiAgICAgICAgICAgICAgICAvLyBBbmQgcHJldmVudCBmcm9tIGluY2x1ZGluZyBzb3VyY2UtbWFwIGJ5IGJyb3dzZXJpZnlcbiAgICAgICAgICAgICAgICBTb3VyY2VOb2RlID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNvdXJjZU5vZGUgPSBnbG9iYWwuc291cmNlTWFwLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBTb3VyY2VOb2RlID0gU291cmNlTm9kZU1vY2s7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFN5bnRheC5CbG9ja1N0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguQnJlYWtTdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LkNhdGNoQ2xhdXNlOlxuICAgICAgICBjYXNlIFN5bnRheC5Db250aW51ZVN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguRGlyZWN0aXZlU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5Eb1doaWxlU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5EZWJ1Z2dlclN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguRW1wdHlTdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LkZvclN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguRm9ySW5TdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgIGNhc2UgU3ludGF4LklmU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5MYWJlbGVkU3RhdGVtZW50OlxuICAgICAgICBjYXNlIFN5bnRheC5Qcm9ncmFtOlxuICAgICAgICBjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LlN3aXRjaFN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguU3dpdGNoQ2FzZTpcbiAgICAgICAgY2FzZSBTeW50YXguVGhyb3dTdGF0ZW1lbnQ6XG4gICAgICAgIGNhc2UgU3ludGF4LlRyeVN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjpcbiAgICAgICAgY2FzZSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yOlxuICAgICAgICBjYXNlIFN5bnRheC5XaGlsZVN0YXRlbWVudDpcbiAgICAgICAgY2FzZSBTeW50YXguV2l0aFN0YXRlbWVudDpcbiAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LkFycmF5RXhwcmVzc2lvbjpcbiAgICAgICAgY2FzZSBTeW50YXguQXJyYXlQYXR0ZXJuOlxuICAgICAgICBjYXNlIFN5bnRheC5CaW5hcnlFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5DYWxsRXhwcmVzc2lvbjpcbiAgICAgICAgY2FzZSBTeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb246XG4gICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XG4gICAgICAgIGNhc2UgU3ludGF4LkxpdGVyYWw6XG4gICAgICAgIGNhc2UgU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5OZXdFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5PYmplY3RFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5PYmplY3RQYXR0ZXJuOlxuICAgICAgICBjYXNlIFN5bnRheC5Qcm9wZXJ0eTpcbiAgICAgICAgY2FzZSBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5UaGlzRXhwcmVzc2lvbjpcbiAgICAgICAgY2FzZSBTeW50YXguVW5hcnlFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5VcGRhdGVFeHByZXNzaW9uOlxuICAgICAgICBjYXNlIFN5bnRheC5ZaWVsZEV4cHJlc3Npb246XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlRXhwcmVzc2lvbihub2RlLCB7XG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogUHJlY2VkZW5jZS5TZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFsbG93Q2FsbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZTogJyArIG5vZGUudHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNvdXJjZU1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFpciA9IHJlc3VsdC50b1N0cmluZ1dpdGhTb3VyY2VNYXAoe1xuICAgICAgICAgICAgZmlsZTogb3B0aW9ucy5maWxlLFxuICAgICAgICAgICAgc291cmNlUm9vdDogb3B0aW9ucy5zb3VyY2VNYXBSb290XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcFdpdGhDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFpcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFpci5tYXAudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBGT1JNQVRfTUlOSUZZID0ge1xuICAgICAgICBpbmRlbnQ6IHtcbiAgICAgICAgICAgIHN0eWxlOiAnJyxcbiAgICAgICAgICAgIGJhc2U6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcmVudW1iZXI6IHRydWUsXG4gICAgICAgIGhleGFkZWNpbWFsOiB0cnVlLFxuICAgICAgICBxdW90ZXM6ICdhdXRvJyxcbiAgICAgICAgZXNjYXBlbGVzczogdHJ1ZSxcbiAgICAgICAgY29tcGFjdDogdHJ1ZSxcbiAgICAgICAgcGFyZW50aGVzZXM6IGZhbHNlLFxuICAgICAgICBzZW1pY29sb25zOiBmYWxzZVxuICAgIH07XG5cbiAgICBGT1JNQVRfREVGQVVMVFMgPSBnZXREZWZhdWx0T3B0aW9ucygpLmZvcm1hdDtcblxuICAgIGV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoJy4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiAgICBleHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG4gICAgZXhwb3J0cy5hdHRhY2hDb21tZW50cyA9IGVzdHJhdmVyc2UuYXR0YWNoQ29tbWVudHM7XG4gICAgZXhwb3J0cy5icm93c2VyID0gZmFsc2U7XG4gICAgZXhwb3J0cy5GT1JNQVRfTUlOSUZZID0gRk9STUFUX01JTklGWTtcbiAgICBleHBvcnRzLkZPUk1BVF9ERUZBVUxUUyA9IEZPUk1BVF9ERUZBVUxUUztcbn0oKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG4gIHZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIFNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gICAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICAgKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gICAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAgICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gICAqXG4gICAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICAgKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICAgKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAgICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gICAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqXG4gICAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gICAqXG4gICAqICAgICB7XG4gICAqICAgICAgIHZlcnNpb24gOiAzLFxuICAgKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICAgKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAgICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICAgKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAgICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gICAqICAgICB9XG4gICAqXG4gICAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICAgKi9cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gICAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gICAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICAgIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gICAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICAgIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICAgIH1cblxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICBzb3VyY2VzID0gc291cmNlcy5tYXAodXRpbC5ub3JtYWxpemUpO1xuXG4gICAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAgIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcywgdHJ1ZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICAgIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gICAgdGhpcy5maWxlID0gZmlsZTtcbiAgfVxuXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICAgKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgICBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgICBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgICAgc21jLnNvdXJjZXNDb250ZW50ID0gYVNvdXJjZU1hcC5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChzbWMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG5cbiAgICAgIHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgICBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKClcbiAgICAgICAgLnNvcnQodXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICAgIHJldHVybiBzbWM7XG4gICAgfTtcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCAhPSBudWxsID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBzdHIgPSBhU3RyO1xuICAgICAgdmFyIHRlbXAgPSB7fTtcbiAgICAgIHZhciBtYXBwaW5nO1xuXG4gICAgICB3aGlsZSAoc3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICc7Jykge1xuICAgICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcsJykge1xuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtYXBwaW5nID0ge307XG4gICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShzdHIsIHRlbXApO1xuICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyB0ZW1wLnZhbHVlO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgc3RyID0gdGVtcC5yZXN0O1xuXG4gICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwICYmICF0aGlzLl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihzdHIpKSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKHN0ciwgdGVtcCk7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQocHJldmlvdXNTb3VyY2UgKyB0ZW1wLnZhbHVlKTtcbiAgICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihzdHIpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoc3RyLCB0ZW1wKTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IHRoaXMuX25leHRDaGFySXNNYXBwaW5nU2VwYXJhdG9yKHN0cikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKHN0ciwgdGVtcCk7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHRlbXAudmFsdWU7XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcbiAgICAgICAgICAgIHN0ciA9IHRlbXAucmVzdDtcblxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwICYmICF0aGlzLl9uZXh0Q2hhcklzTWFwcGluZ1NlcGFyYXRvcihzdHIpKSB7XG4gICAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoc3RyLCB0ZW1wKTtcbiAgICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gdGhpcy5fbmFtZXMuYXQocHJldmlvdXNOYW1lICsgdGVtcC52YWx1ZSk7XG4gICAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgICBzdHIgPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcbiAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnNvcnQodXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gICAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvcikge1xuICAgICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvcik7XG4gICAgfTtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICAgKiBpbmNsdXNpdmUuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiB0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIG5hbWU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsaWJsZS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgICB9XG5cbiAgICAgIHZhciB1cmw7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAvKipcbiAgICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gICAqXG4gICAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICAgKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnIG9yXG4gICAqICAgICAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgLy9cbiAgICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIC8vXG4gICAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAgIC8vICAgICAgdGhlIG5leHQgY2xvc2VzdCBlbGVtZW50LlxuICAgIC8vXG4gICAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgICAvLyAgICAgIGVsZW1lbnQgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZSByZXR1cm4gLTEuXG4gICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gICAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMTtcbiAgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDI7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICAgKiB0aGUgaW5kZXggb2YgbmV4dCBoaWdoZXN0IHZhbHVlIGNoZWNrZWQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzXG4gICAqIGJlY2F1c2UgbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGVcbiAgICogcG9pbnRzLCBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3NcbiAgICoganVzdCBtZWFucyB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gICAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gICAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gICAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAgICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIGFCaWFzIEVpdGhlciAnZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCcgb3JcbiAgICogICAgICdleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLiBEZWZhdWx0cyB0b1xuICAgKiAgICAgJ2V4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQnLlxuICAgKi9cbiAgZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgICB2YXIgYUJpYXMgPSBhQmlhcyB8fCBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EO1xuXG4gICAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpXG4gIH07XG5cbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG4gIHZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuICB2YXIgQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vYmFzaWMtc291cmNlLW1hcC1jb25zdW1lcicpLkJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIEFuIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2hcbiAgICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAgICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gICAqIGlucHV0LlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAgICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICAgKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gICAqXG4gICAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAgICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gICAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gICAqICAgICAgIGZpZWxkLlxuICAgKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAgICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAgICpcbiAgICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gICAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gICAqIHVuc3VwcG9ydGVkLlxuICAgKlxuICAgKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICAgKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICAgKlxuICAgKiAge1xuICAgKiAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgZmlsZTogXCJhcHAuanNcIixcbiAgICogICAgc2VjdGlvbnM6IFt7XG4gICAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gICAqICAgICAgbWFwOiB7XG4gICAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICAgKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICAgKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gICAqICAgICAgfVxuICAgKiAgICB9XSxcbiAgICogIH1cbiAgICpcbiAgICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICAgKi9cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICAgIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICAgIGxpbmU6IC0xLFxuICAgICAgY29sdW1uOiAwXG4gICAgfTtcbiAgICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgaWYgKHMudXJsKSB7XG4gICAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgICAgfVxuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgICAgfSxcbiAgICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJykpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNvdXJjZXM7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgICB9O1xuXG4gICAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAgIHZhciBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgfSwgYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgOiAwKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gICAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAgICogYXZhaWxhYmxlLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgICAgOiAwKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICAgIHZhciBzZWN0aW9uTWFwcGluZ3MgPSBzZWN0aW9uLmNvbnN1bWVyLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tpXTtcblxuICAgICAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICB2YXIgc291cmNlUm9vdCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdDtcblxuICAgICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5jb2x1bW4gK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lKVxuICAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9ucyk7XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuICBleHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbn0pO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIC8vIFdlIGRvIGxhdGUgcmVxdWlyZXMgYmVjYXVzZSB0aGUgc3ViY2xhc3NlcyByZXF1aXJlKCkgdGhpcyBmaWxlLlxuICAgIGlmIChzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgdmFyIGluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vaW5kZXhlZC1zb3VyY2UtbWFwLWNvbnN1bWVyJyk7XG4gICAgICByZXR1cm4gbmV3IGluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2Jhc2ljLXNvdXJjZS1tYXAtY29uc3VtZXInKTtcbiAgICAgIHJldHVybiBuZXcgYmFzaWNTb3VyY2VNYXBDb25zdW1lci5CYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCk7XG4gICAgfVxuICB9XG5cbiAgU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgYmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vYmFzaWMtc291cmNlLW1hcC1jb25zdW1lcicpO1xuICAgIHJldHVybiBiYXNpY1NvdXJjZU1hcENvbnN1bWVyLkJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAgICAgICAgICAgIC5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgIH1cbiAgfSk7XG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fbmV4dENoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX25leHRDaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIpIHtcbiAgICAgIHZhciBjID0gYVN0ci5jaGFyQXQoMCk7XG4gICAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gICAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuICBTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMjtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICAgKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gICAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAgICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICAgKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAgICogQHBhcmFtIGFPcmRlclxuICAgKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICAgKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAgICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgICAgdmFyIG1hcHBpbmdzO1xuICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZVxuICAgICAgICB9O1xuICAgICAgfSkuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAgICogYW5kIGxpbmUgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZS4gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpc1xuICAgICAgICAvLyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvciB0aGUgbGluZSB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG5lZWRsZS5vcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXBwaW5ncztcbiAgICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxufSk7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuICAvKipcbiAgICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICAgKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqL1xuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgICBpZiAoIWFBcmdzKSB7XG4gICAgICBhQXJncyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gICAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICAgIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gIH1cblxuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICAgIH0pO1xuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICAgKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICAgKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gICAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICAgKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gICAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gICAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICAgKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAgICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAgICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICAgKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAgICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gICAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgICAgfVxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgIH1cbiAgICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgfSwgdGhpcyk7XG4gICAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAgICpcbiAgICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gICAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICAgKiAgICAgIHRva2VuLlxuICAgKlxuICAgKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAgICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgICAvLyBDYXNlIDEuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICAgKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbWFwcGluZztcblxuICAgICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUodGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcblxuICAgICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSlcbiAgICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cbn0pO1xuIiwiLyoqIHZpbTogZXQ6dHM9NDpzdz00OnN0cz00XG4gKiBAbGljZW5zZSBhbWRlZmluZSAwLjEuMCBDb3B5cmlnaHQgKGMpIDIwMTEsIFRoZSBEb2pvIEZvdW5kYXRpb24gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIEF2YWlsYWJsZSB2aWEgdGhlIE1JVCBvciBuZXcgQlNEIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2pyYnVya2UvYW1kZWZpbmUgZm9yIGRldGFpbHNcbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHByb2Nlc3MgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVmaW5lIGZvciBub2RlLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgXCJtb2R1bGVcIiBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGJ5IE5vZGUgZm9yIHRoZVxuICogY3VycmVudCBtb2R1bGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVxdWlyZUZuXS4gTm9kZSdzIHJlcXVpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1vZHVsZS5cbiAqIEl0IG9ubHkgbmVlZHMgdG8gYmUgcGFzc2VkIGluIE5vZGUgdmVyc2lvbnMgYmVmb3JlIDAuNSwgd2hlbiBtb2R1bGUucmVxdWlyZVxuICogZGlkIG5vdCBleGlzdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBkZWZpbmUgZnVuY3Rpb24gdGhhdCBpcyB1c2FibGUgZm9yIHRoZSBjdXJyZW50IG5vZGVcbiAqIG1vZHVsZS5cbiAqL1xuZnVuY3Rpb24gYW1kZWZpbmUobW9kdWxlLCByZXF1aXJlRm4pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRlZmluZUNhY2hlID0ge30sXG4gICAgICAgIGxvYWRlckNhY2hlID0ge30sXG4gICAgICAgIGFscmVhZHlDYWxsZWQgPSBmYWxzZSxcbiAgICAgICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICAgICAgbWFrZVJlcXVpcmUsIHN0cmluZ1JlcXVpcmU7XG5cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgLiBhbmQgLi4gZnJvbSBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqIEl0IHdpbGwga2VlcCBhIGxlYWRpbmcgcGF0aCBzZWdtZW50IGlmIGEgLi4gd2lsbCBiZWNvbWVcbiAgICAgKiB0aGUgZmlyc3QgcGF0aCBzZWdtZW50LCB0byBoZWxwIHdpdGggbW9kdWxlIG5hbWUgbG9va3VwcyxcbiAgICAgKiB3aGljaCBhY3QgbGlrZSBwYXRocywgYnV0IGNhbiBiZSByZW1hcHBlZC4gQnV0IHRoZSBlbmQgcmVzdWx0LFxuICAgICAqIGFsbCBwYXRocyB0aGF0IHVzZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsb29rIG5vcm1hbGl6ZWQuXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgTU9ESUZJRVMgdGhlIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyeSB0aGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRG90cyhhcnkpIHtcbiAgICAgICAgdmFyIGksIHBhcnQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGFyeVtpXTsgaSs9IDEpIHtcbiAgICAgICAgICAgIHBhcnQgPSBhcnlbaV07XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiAoYXJ5WzJdID09PSAnLi4nIHx8IGFyeVswXSA9PT0gJy4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcbiAgICAgICAgICAgICAgICAgICAgLy9wYXRoIHNlZ21lbnQgYXQgdGhlIGZyb250IHNvIGl0IGNhbiBiZSBtYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0bHkgdG8gZGlzay4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBsaWtlbHlcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoICcuLicuXG4gICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjYW4gc3RpbGwgZmFpbCwgYnV0IGNhdGNoZXMgdGhlIG1vc3QgcmVhc29uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvL3VzZXMgb2YgLi5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xuICAgICAgICB2YXIgYmFzZVBhcnRzO1xuXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgLy9JZiBoYXZlIGEgYmFzZSBuYW1lLCB0cnkgdG8gbm9ybWFsaXplIGFnYWluc3QgaXQsXG4gICAgICAgICAgICAvL290aGVyd2lzZSwgYXNzdW1lIGl0IGlzIGEgdG9wLWxldmVsIHJlcXVpcmUgdGhhdCB3aWxsXG4gICAgICAgICAgICAvL2JlIHJlbGF0aXZlIHRvIGJhc2VVcmwgaW4gdGhlIGVuZC5cbiAgICAgICAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuY29uY2F0KG5hbWUuc3BsaXQoJy8nKSk7XG4gICAgICAgICAgICAgICAgdHJpbURvdHMoYmFzZVBhcnRzKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gYmFzZVBhcnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgbm9ybWFsaXplKCkgZnVuY3Rpb24gcGFzc2VkIHRvIGEgbG9hZGVyIHBsdWdpbidzXG4gICAgICogbm9ybWFsaXplIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGlkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWQodmFsdWUpIHtcbiAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZC5mcm9tVGV4dCA9IGZ1bmN0aW9uIChpZCwgdGV4dCkge1xuICAgICAgICAgICAgLy9UaGlzIG9uZSBpcyBkaWZmaWN1bHQgYmVjYXVzZSB0aGUgdGV4dCBjYW4vcHJvYmFibHkgdXNlc1xuICAgICAgICAgICAgLy9kZWZpbmUsIGFuZCBhbnkgcmVsYXRpdmUgcGF0aHMgYW5kIHJlcXVpcmVzIHNob3VsZCBiZSByZWxhdGl2ZVxuICAgICAgICAgICAgLy90byB0aGF0IGlkIHdhcyBpdCB3b3VsZCBiZSBmb3VuZCBvbiBkaXNrLiBCdXQgdGhpcyB3b3VsZCByZXF1aXJlXG4gICAgICAgICAgICAvL2Jvb3RzdHJhcHBpbmcgYSBtb2R1bGUvcmVxdWlyZSBmYWlybHkgZGVlcGx5IGZyb20gbm9kZSBjb3JlLlxuICAgICAgICAgICAgLy9Ob3Qgc3VyZSBob3cgYmVzdCB0byBnbyBhYm91dCB0aGF0IHlldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgZG9lcyBub3QgaW1wbGVtZW50IGxvYWQuZnJvbVRleHQnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbG9hZDtcbiAgICB9XG5cbiAgICBtYWtlUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFtZFJlcXVpcmUoZGVwcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL1N5bmNocm9ub3VzLCBzaW5nbGUgbW9kdWxlIHJlcXVpcmUoJycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBzLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vQXJyYXkgb2YgZGVwZW5kZW5jaWVzIHdpdGggYSBjYWxsYmFjay5cblxuICAgICAgICAgICAgICAgIC8vQ29udmVydCB0aGUgZGVwZW5kZW5jaWVzIHRvIG1vZHVsZXMuXG4gICAgICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwTmFtZSwgcmVsSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9XYWl0IGZvciBuZXh0IHRpY2sgdG8gY2FsbCBiYWNrIHRoZSByZXF1aXJlIGNhbGwuXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGRlcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYW1kUmVxdWlyZS50b1VybCA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICAgICAgaWYgKGZpbGVQYXRoLmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUoZmlsZVBhdGgsIHBhdGguZGlybmFtZShtb2R1bGUuZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBhbWRSZXF1aXJlO1xuICAgIH07XG5cbiAgICAvL0Zhdm9yIGV4cGxpY2l0IHZhbHVlLCBwYXNzZWQgaW4gaWYgdGhlIG1vZHVsZSB3YW50cyB0byBzdXBwb3J0IE5vZGUgMC40LlxuICAgIHJlcXVpcmVGbiA9IHJlcXVpcmVGbiB8fCBmdW5jdGlvbiByZXEoKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUucmVxdWlyZS5hcHBseShtb2R1bGUsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIHIsIGUsIG0sIHJlc3VsdDtcblxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGUgPSBsb2FkZXJDYWNoZVtpZF0gPSB7fTtcbiAgICAgICAgICAgIG0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHVyaTogX19maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgciA9IG1ha2VSZXF1aXJlKHJlcXVpcmVGbiwgZSwgbSwgaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9Pbmx5IHN1cHBvcnQgb25lIGRlZmluZSBjYWxsIHBlciBmaWxlXG4gICAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgd2l0aCBubyBtb2R1bGUgSUQgY2Fubm90IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBwZXIgZmlsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL1VzZSB0aGUgcmVhbCB2YXJpYWJsZXMgZnJvbSBub2RlXG4gICAgICAgICAgICAvL1VzZSBtb2R1bGUuZXhwb3J0cyBmb3IgZXhwb3J0cywgc2luY2VcbiAgICAgICAgICAgIC8vdGhlIGV4cG9ydHMgaW4gaGVyZSBpcyBhbWRlZmluZSBleHBvcnRzLlxuICAgICAgICAgICAgZSA9IG1vZHVsZS5leHBvcnRzO1xuICAgICAgICAgICAgbSA9IG1vZHVsZTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIG1vZHVsZS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0lmIHRoZXJlIGFyZSBkZXBlbmRlbmNpZXMsIHRoZXkgYXJlIHN0cmluZ3MsIHNvIG5lZWRcbiAgICAgICAgLy90byBjb252ZXJ0IHRoZW0gdG8gZGVwZW5kZW5jeSB2YWx1ZXMuXG4gICAgICAgIGlmIChkZXBzKSB7XG4gICAgICAgICAgICBkZXBzID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcE5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcihkZXBOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9DYWxsIHRoZSBmYWN0b3J5IHdpdGggdGhlIHJpZ2h0IGRlcGVuZGVuY2llcy5cbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3J5LmFwcGx5KG0uZXhwb3J0cywgZGVwcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWN0b3J5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtLmV4cG9ydHMgPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBsb2FkZXJDYWNoZVtpZF0gPSBtLmV4cG9ydHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdHJpbmdSZXF1aXJlID0gZnVuY3Rpb24gKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgaWQsIHJlbElkKSB7XG4gICAgICAgIC8vU3BsaXQgdGhlIElEIGJ5IGEgISBzbyB0aGF0XG4gICAgICAgIHZhciBpbmRleCA9IGlkLmluZGV4T2YoJyEnKSxcbiAgICAgICAgICAgIG9yaWdpbmFsSWQgPSBpZCxcbiAgICAgICAgICAgIHByZWZpeCwgcGx1Z2luO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlkID0gbm9ybWFsaXplKGlkLCByZWxJZCk7XG5cbiAgICAgICAgICAgIC8vU3RyYWlnaHQgbW9kdWxlIGxvb2t1cC4gSWYgaXQgaXMgb25lIG9mIHRoZSBzcGVjaWFsIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIC8vZGVhbCB3aXRoIGl0LCBvdGhlcndpc2UsIGRlbGVnYXRlIHRvIG5vZGUuXG4gICAgICAgICAgICBpZiAoaWQgPT09ICdyZXF1aXJlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlUmVxdWlyZShzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdleHBvcnRzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2FkZXJDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZpbmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYoc3lzdGVtUmVxdWlyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3lzdGVtUmVxdWlyZShvcmlnaW5hbElkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1vZHVsZSB3aXRoIElEOiAnICsgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vVGhlcmUgaXMgYSBwbHVnaW4gaW4gcGxheS5cbiAgICAgICAgICAgIHByZWZpeCA9IGlkLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICBpZCA9IGlkLnN1YnN0cmluZyhpbmRleCArIDEsIGlkLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHBsdWdpbiA9IHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBwcmVmaXgsIHJlbElkKTtcblxuICAgICAgICAgICAgaWYgKHBsdWdpbi5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHBsdWdpbi5ub3JtYWxpemUoaWQsIG1ha2VOb3JtYWxpemUocmVsSWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9Ob3JtYWxpemUgdGhlIElEIG5vcm1hbGx5LlxuICAgICAgICAgICAgICAgIGlkID0gbm9ybWFsaXplKGlkLCByZWxJZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4ubG9hZChpZCwgbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCksIG1ha2VMb2FkKGlkKSwge30pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL0NyZWF0ZSBhIGRlZmluZSBmdW5jdGlvbiBzcGVjaWZpYyB0byB0aGUgbW9kdWxlIGFza2luZyBmb3IgYW1kZWZpbmUuXG4gICAgZnVuY3Rpb24gZGVmaW5lKGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGlkKSkge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGRlcHM7XG4gICAgICAgICAgICBkZXBzID0gaWQ7XG4gICAgICAgICAgICBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRlcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVwcyAmJiAhQXJyYXkuaXNBcnJheShkZXBzKSkge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGRlcHM7XG4gICAgICAgICAgICBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZXBzKSB7XG4gICAgICAgICAgICBkZXBzID0gWydyZXF1aXJlJywgJ2V4cG9ydHMnLCAnbW9kdWxlJ107XG4gICAgICAgIH1cblxuICAgICAgICAvL1NldCB1cCBwcm9wZXJ0aWVzIGZvciB0aGlzIG1vZHVsZS4gSWYgYW4gSUQsIHRoZW4gdXNlXG4gICAgICAgIC8vaW50ZXJuYWwgY2FjaGUuIElmIG5vIElELCB0aGVuIHVzZSB0aGUgZXh0ZXJuYWwgdmFyaWFibGVzXG4gICAgICAgIC8vZm9yIHRoaXMgbm9kZSBtb2R1bGUuXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgLy9QdXQgdGhlIG1vZHVsZSBpbiBkZWVwIGZyZWV6ZSB1bnRpbCB0aGVyZSBpcyBhXG4gICAgICAgICAgICAvL3JlcXVpcmUgY2FsbCBmb3IgaXQuXG4gICAgICAgICAgICBkZWZpbmVDYWNoZVtpZF0gPSBbaWQsIGRlcHMsIGZhY3RvcnldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnVuRmFjdG9yeShpZCwgZGVwcywgZmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2RlZmluZS5yZXF1aXJlLCB3aGljaCBoYXMgYWNjZXNzIHRvIGFsbCB0aGUgdmFsdWVzIGluIHRoZVxuICAgIC8vY2FjaGUuIFVzZWZ1bCBmb3IgQU1EIG1vZHVsZXMgdGhhdCBhbGwgaGF2ZSBJRHMgaW4gdGhlIGZpbGUsXG4gICAgLy9idXQgbmVlZCB0byBmaW5hbGx5IGV4cG9ydCBhIHZhbHVlIHRvIG5vZGUgYmFzZWQgb24gb25lIG9mIHRob3NlXG4gICAgLy9JRHMuXG4gICAgZGVmaW5lLnJlcXVpcmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGxvYWRlckNhY2hlW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkuYXBwbHkobnVsbCwgZGVmaW5lQ2FjaGVbaWRdKTtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lLmFtZCA9IHt9O1xuXG4gICAgcmV0dXJuIGRlZmluZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhbWRlZmluZTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiZXNjb2RlZ2VuXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJFQ01BU2NyaXB0IGNvZGUgZ2VuZXJhdG9yXCIsXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwOi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2VzY29kZWdlbi5odG1sXCIsXG4gIFwibWFpblwiOiBcImVzY29kZWdlbi5qc1wiLFxuICBcImJpblwiOiB7XG4gICAgXCJlc2dlbmVyYXRlXCI6IFwiLi9iaW4vZXNnZW5lcmF0ZS5qc1wiLFxuICAgIFwiZXNjb2RlZ2VuXCI6IFwiLi9iaW4vZXNjb2RlZ2VuLmpzXCJcbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4wLjI4XCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0wLjQuMFwiXG4gIH0sXG4gIFwibWFpbnRhaW5lcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIll1c3VrZSBTdXp1a2lcIixcbiAgICAgIFwiZW1haWxcIjogXCJ1dGF0YW5lLnRlYUBnbWFpbC5jb21cIixcbiAgICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvblwiXG4gICAgfVxuICBdLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvbi9lc2NvZGVnZW4uZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiZXNwcmltYVwiOiBcIn4xLjAuMlwiLFxuICAgIFwiZXN0cmF2ZXJzZVwiOiBcIn4xLjMuMFwiLFxuICAgIFwic291cmNlLW1hcFwiOiBcIj49IDAuMS4yXCJcbiAgfSxcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJzb3VyY2UtbWFwXCI6IFwiPj0gMC4xLjJcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJlc3ByaW1hLW1velwiOiBcIipcIixcbiAgICBcImNvbW1vbmpzLWV2ZXJ5d2hlcmVcIjogXCJ+MC44LjBcIixcbiAgICBcInFcIjogXCIqXCIsXG4gICAgXCJib3dlclwiOiBcIipcIixcbiAgICBcInNlbXZlclwiOiBcIipcIixcbiAgICBcImNoYWlcIjogXCJ+MS43LjJcIixcbiAgICBcImdydW50LWNvbnRyaWItanNoaW50XCI6IFwifjAuNS4wXCIsXG4gICAgXCJncnVudC1jbGlcIjogXCJ+MC4xLjlcIixcbiAgICBcImdydW50XCI6IFwifjAuNC4xXCIsXG4gICAgXCJncnVudC1tb2NoYS10ZXN0XCI6IFwifjAuNi4yXCJcbiAgfSxcbiAgXCJsaWNlbnNlc1wiOiBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiQlNEXCIsXG4gICAgICBcInVybFwiOiBcImh0dHA6Ly9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24vZXNjb2RlZ2VuL3Jhdy9tYXN0ZXIvTElDRU5TRS5CU0RcIlxuICAgIH1cbiAgXSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJncnVudCB0cmF2aXNcIixcbiAgICBcInVuaXQtdGVzdFwiOiBcImdydW50IHRlc3RcIixcbiAgICBcImxpbnRcIjogXCJncnVudCBsaW50XCIsXG4gICAgXCJyZWxlYXNlXCI6IFwibm9kZSB0b29scy9yZWxlYXNlLmpzXCIsXG4gICAgXCJidWlsZC1taW5cIjogXCJjanNpZnkgLW1hIHBhdGg6IHRvb2xzL2VudHJ5LXBvaW50LmpzID4gZXNjb2RlZ2VuLmJyb3dzZXIubWluLmpzXCIsXG4gICAgXCJidWlsZFwiOiBcImNqc2lmeSAtYSBwYXRoOiB0b29scy9lbnRyeS1wb2ludC5qcyA+IGVzY29kZWdlbi5icm93c2VyLmpzXCJcbiAgfSxcbiAgXCJyZWFkbWVcIjogXCJcXG4jIyMgRXNjb2RlZ2VuIFshW0J1aWxkIFN0YXR1c10oaHR0cHM6Ly9zZWN1cmUudHJhdmlzLWNpLm9yZy9Db25zdGVsbGF0aW9uL2VzY29kZWdlbi5wbmcpXShodHRwOi8vdHJhdmlzLWNpLm9yZy9Db25zdGVsbGF0aW9uL2VzY29kZWdlbikgWyFbQnVpbGQgU3RhdHVzXShodHRwczovL2Ryb25lLmlvL2dpdGh1Yi5jb20vQ29uc3RlbGxhdGlvbi9lc2NvZGVnZW4vc3RhdHVzLnBuZyldKGh0dHBzOi8vZHJvbmUuaW8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2VzY29kZWdlbi9sYXRlc3QpXFxuXFxuRXNjb2RlZ2VuIChbZXNjb2RlZ2VuXShodHRwOi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2VzY29kZWdlbikpIGlzXFxuW0VDTUFTY3JpcHRdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvc3RhbmRhcmRzL0VjbWEtMjYyLmh0bSlcXG4oYWxzbyBwb3B1bGFybHkga25vd24gYXMgW0phdmFTY3JpcHRdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmF2YVNjcmlwdD5KYXZhU2NyaXB0KSlcXG5jb2RlIGdlbmVyYXRvciBmcm9tIFtQYXJzZXIgQVBJXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9TcGlkZXJNb25rZXkvUGFyc2VyX0FQSSkgQVNULlxcblNlZSBbb25saW5lIGdlbmVyYXRvciBkZW1vXShodHRwOi8vY29uc3RlbGxhdGlvbi5naXRodWIuY29tL2VzY29kZWdlbi9kZW1vL2luZGV4Lmh0bWwpLlxcblxcblxcbiMjIyBJbnN0YWxsXFxuXFxuRXNjb2RlZ2VuIGNhbiBiZSB1c2VkIGluIGEgd2ViIGJyb3dzZXI6XFxuXFxuICAgIDxzY3JpcHQgc3JjPVxcXCJlc2NvZGVnZW4uYnJvd3Nlci5qc1xcXCI+PC9zY3JpcHQ+XFxuXFxuZXNjb2RlZ2VuLmJyb3dzZXIuanMgaXMgZm91bmQgaW4gdGFnZ2VkLXJldmlzaW9uLiBTZWUgVGFncyBvbiBHaXRIdWIuXFxuXFxuT3IgaW4gYSBOb2RlLmpzIGFwcGxpY2F0aW9uIHZpYSB0aGUgcGFja2FnZSBtYW5hZ2VyOlxcblxcbiAgICBucG0gaW5zdGFsbCBlc2NvZGVnZW5cXG5cXG4jIyMgVXNhZ2VcXG5cXG5BIHNpbXBsZSBleGFtcGxlOiB0aGUgcHJvZ3JhbVxcblxcbiAgICBlc2NvZGVnZW4uZ2VuZXJhdGUoe1xcbiAgICAgICAgdHlwZTogJ0JpbmFyeUV4cHJlc3Npb24nLFxcbiAgICAgICAgb3BlcmF0b3I6ICcrJyxcXG4gICAgICAgIGxlZnQ6IHsgdHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogNDAgfSxcXG4gICAgICAgIHJpZ2h0OiB7IHR5cGU6ICdMaXRlcmFsJywgdmFsdWU6IDIgfVxcbiAgICB9KTtcXG5cXG5wcm9kdWNlcyB0aGUgc3RyaW5nIGAnNDAgKyAyJ2BcXG5cXG5TZWUgdGhlIFtBUEkgcGFnZV0oaHR0cHM6Ly9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24vZXNjb2RlZ2VuL3dpa2kvQVBJKSBmb3JcXG5vcHRpb25zLiBUbyBydW4gdGhlIHRlc3RzLCBleGVjdXRlIGBucG0gdGVzdGAgaW4gdGhlIHJvb3QgZGlyZWN0b3J5LlxcblxcbiMjIyBMaWNlbnNlXFxuXFxuIyMjIyBFc2NvZGVnZW5cXG5cXG5Db3B5cmlnaHQgKEMpIDIwMTIgW1l1c3VrZSBTdXp1a2ldKGh0dHA6Ly9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24pXFxuICh0d2l0dGVyOiBbQENvbnN0ZWxsYXRpb25dKGh0dHA6Ly90d2l0dGVyLmNvbS9Db25zdGVsbGF0aW9uKSkgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy5cXG5cXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcXG5tb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcXG5cXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcXG4gICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxcbiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXFxuICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXFxuXFxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcXFwiQVMgSVNcXFwiXFxuQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxcbklNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXFxuQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxcbkRJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXFxuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxcbk9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXFxuVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG5cXG4jIyMjIHNvdXJjZS1tYXBcXG5cXG5Tb3VyY2VOb2RlTW9ja3MgaGFzIGEgbGltaXRlZCBpbnRlcmZhY2Ugb2YgbW96aWxsYS9zb3VyY2UtbWFwIFNvdXJjZU5vZGUgaW1wbGVtZW50YXRpb25zLlxcblxcbkNvcHlyaWdodCAoYykgMjAwOS0yMDExLCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xcbkFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuXFxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XFxubW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XFxuXFxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcXG4gIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblxcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxcbiAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxcbiAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXFxuXFxuKiBOZWl0aGVyIHRoZSBuYW1lcyBvZiB0aGUgTW96aWxsYSBGb3VuZGF0aW9uIG5vciB0aGUgbmFtZXMgb2YgcHJvamVjdFxcbiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpc1xcbiAgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcXFwiQVMgSVNcXFwiIEFORFxcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEVcXG5GT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxcbkRBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXFxuU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVJcXG5DQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLFxcbk9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXFxuT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG5cIixcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL0NvbnN0ZWxsYXRpb24vZXNjb2RlZ2VuL2lzc3Vlc1wiXG4gIH0sXG4gIFwiX2lkXCI6IFwiZXNjb2RlZ2VuQDAuMC4yOFwiLFxuICBcIl9mcm9tXCI6IFwiZXNjb2RlZ2VuQH4gMC4wLjI3XCJcbn1cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMSBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vKmpzbGludCBiaXR3aXNlOnRydWUgcGx1c3BsdXM6dHJ1ZSAqL1xuLypnbG9iYWwgZXNwcmltYTp0cnVlLCBkZWZpbmU6dHJ1ZSwgZXhwb3J0czp0cnVlLCB3aW5kb3c6IHRydWUsXG50aHJvd0Vycm9yOiB0cnVlLCBjcmVhdGVMaXRlcmFsOiB0cnVlLCBnZW5lcmF0ZVN0YXRlbWVudDogdHJ1ZSxcbnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb246IHRydWUsIHBhcnNlQmxvY2s6IHRydWUsIHBhcnNlRXhwcmVzc2lvbjogdHJ1ZSxcbnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbjogdHJ1ZSwgcGFyc2VGdW5jdGlvbkV4cHJlc3Npb246IHRydWUsXG5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHM6IHRydWUsIHBhcnNlVmFyaWFibGVJZGVudGlmaWVyOiB0cnVlLFxucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uOiB0cnVlLFxucGFyc2VTdGF0ZW1lbnQ6IHRydWUsIHBhcnNlU291cmNlRWxlbWVudDogdHJ1ZSAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsXG4gICAgLy8gUmhpbm8sIGFuZCBwbGFpbiBicm93c2VyIGxvYWRpbmcuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeSgocm9vdC5lc3ByaW1hID0ge30pKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFRva2VuLFxuICAgICAgICBUb2tlbk5hbWUsXG4gICAgICAgIFN5bnRheCxcbiAgICAgICAgUHJvcGVydHlLaW5kLFxuICAgICAgICBNZXNzYWdlcyxcbiAgICAgICAgUmVnZXgsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGV4dHJhO1xuXG4gICAgVG9rZW4gPSB7XG4gICAgICAgIEJvb2xlYW5MaXRlcmFsOiAxLFxuICAgICAgICBFT0Y6IDIsXG4gICAgICAgIElkZW50aWZpZXI6IDMsXG4gICAgICAgIEtleXdvcmQ6IDQsXG4gICAgICAgIE51bGxMaXRlcmFsOiA1LFxuICAgICAgICBOdW1lcmljTGl0ZXJhbDogNixcbiAgICAgICAgUHVuY3R1YXRvcjogNyxcbiAgICAgICAgU3RyaW5nTGl0ZXJhbDogOFxuICAgIH07XG5cbiAgICBUb2tlbk5hbWUgPSB7fTtcbiAgICBUb2tlbk5hbWVbVG9rZW4uQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuICAgIFRva2VuTmFtZVtUb2tlbi5FT0ZdID0gJzxlbmQ+JztcbiAgICBUb2tlbk5hbWVbVG9rZW4uSWRlbnRpZmllcl0gPSAnSWRlbnRpZmllcic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLktleXdvcmRdID0gJ0tleXdvcmQnO1xuICAgIFRva2VuTmFtZVtUb2tlbi5OdWxsTGl0ZXJhbF0gPSAnTnVsbCc7XG4gICAgVG9rZW5OYW1lW1Rva2VuLk51bWVyaWNMaXRlcmFsXSA9ICdOdW1lcmljJztcbiAgICBUb2tlbk5hbWVbVG9rZW4uUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG4gICAgVG9rZW5OYW1lW1Rva2VuLlN0cmluZ0xpdGVyYWxdID0gJ1N0cmluZyc7XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcbiAgICAgICAgRG9XaGlsZVN0YXRlbWVudDogJ0RvV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogJ0RlYnVnZ2VyU3RhdGVtZW50JyxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcbiAgICAgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXG4gICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCdcbiAgICB9O1xuXG4gICAgUHJvcGVydHlLaW5kID0ge1xuICAgICAgICBEYXRhOiAxLFxuICAgICAgICBHZXQ6IDIsXG4gICAgICAgIFNldDogNFxuICAgIH07XG5cbiAgICAvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxuICAgIE1lc3NhZ2VzID0ge1xuICAgICAgICBVbmV4cGVjdGVkVG9rZW46ICAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXG4gICAgICAgIFVuZXhwZWN0ZWROdW1iZXI6ICAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgICBVbmV4cGVjdGVkU3RyaW5nOiAgJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcbiAgICAgICAgVW5leHBlY3RlZElkZW50aWZpZXI6ICAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcbiAgICAgICAgVW5leHBlY3RlZFJlc2VydmVkOiAgJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICAgIFVuZXhwZWN0ZWRFT1M6ICAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxuICAgICAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogICdJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cnLFxuICAgICAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgICBVbnRlcm1pbmF0ZWRSZWdFeHA6ICAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLycsXG4gICAgICAgIEludmFsaWRMSFNJbkFzc2lnbm1lbnQ6ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcbiAgICAgICAgSW52YWxpZExIU0luRm9ySW46ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItaW4nLFxuICAgICAgICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6ICdNb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGluIHN3aXRjaCBzdGF0ZW1lbnQnLFxuICAgICAgICBOb0NhdGNoT3JGaW5hbGx5OiAgJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxuICAgICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXG4gICAgICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcbiAgICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcbiAgICAgICAgU3RyaWN0TW9kZVdpdGg6ICAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXG4gICAgICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdFZhck5hbWU6ICAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1OYW1lOiAgJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICAnRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0T2N0YWxMaXRlcmFsOiAgJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgICBTdHJpY3REZWxldGU6ICAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgICAgU3RyaWN0RHVwbGljYXRlUHJvcGVydHk6ICAnRHVwbGljYXRlIGRhdGEgcHJvcGVydHkgaW4gb2JqZWN0IGxpdGVyYWwgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgICBBY2Nlc3NvckRhdGFQcm9wZXJ0eTogICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgZGF0YSBhbmQgYWNjZXNzb3IgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgICAgQWNjZXNzb3JHZXRTZXQ6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIG11bHRpcGxlIGdldC9zZXQgYWNjZXNzb3JzIHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICAgIFN0cmljdExIU1Bvc3RmaXg6ICAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0TEhTUHJlZml4OiAgJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAgJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZSdcbiAgICB9O1xuXG4gICAgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5weS5cbiAgICBSZWdleCA9IHtcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY10nKSxcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogbmV3IFJlZ0V4cCgnW1xceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MTAtXFx1MDYxYVxcdTA2MjAtXFx1MDY2OVxcdTA2NmUtXFx1MDZkM1xcdTA2ZDUtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlOFxcdTA2ZWEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwLVxcdTA3NGFcXHUwNzRkLVxcdTA3YjFcXHUwN2MwLVxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODJkXFx1MDg0MC1cXHUwODViXFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmMtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNlXFx1MDlkN1xcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUzXFx1MDllNi1cXHUwOWYxXFx1MGEwMS1cXHUwYTAzXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNjYtXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiYy1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFkMFxcdTBhZTAtXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNjLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjcxXFx1MGI4MlxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkMFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkLVxcdTBjNDRcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNThcXHUwYzU5XFx1MGM2MC1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JjLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZGVcXHUwY2UwLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwY2YxXFx1MGNmMlxcdTBkMDJcXHUwZDAzXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZC1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRlXFx1MGQ1N1xcdTBkNjAtXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkN2EtXFx1MGQ3ZlxcdTBkODJcXHUwZDgzXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTAxLVxcdTBlM2FcXHUwZTQwLVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViOVxcdTBlYmItXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlkXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzNWQtXFx1MTM1ZlxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN2QzXFx1MTdkN1xcdTE3ZGNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk0Ni1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTFiXFx1MWEyMC1cXHUxYTVlXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWFhN1xcdTFiMDAtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWJmM1xcdTFjMDAtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNGQtXFx1MWM3ZFxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNmNlxcdTFkMDAtXFx1MWRlNlxcdTFkZmMtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDdmLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZGUwLVxcdTJkZmZcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJmXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOWFcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MmJcXHVhNjQwLVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjdmLVxcdWE2OTdcXHVhNjlmLVxcdWE2ZjFcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MjdcXHVhODQwLVxcdWE4NzNcXHVhODgwLVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjdcXHVhOGZiXFx1YTkwMC1cXHVhOTJkXFx1YTkzMC1cXHVhOTUzXFx1YTk2MC1cXHVhOTdjXFx1YTk4MC1cXHVhOWMwXFx1YTljZi1cXHVhOWQ5XFx1YWEwMC1cXHVhYTM2XFx1YWE0MC1cXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2JcXHVhYTgwLVxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWZcXHVhYWYyLVxcdWFhZjZcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWQtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjEwLVxcdWZmMTlcXHVmZjIxLVxcdWZmM2FcXHVmZjNmXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXScpXG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICAvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbiAgICAvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cbiAgICAvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNsaWNlU291cmNlKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoZnJvbSwgdG8pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgJ2VzcHJpbWEnWzBdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzbGljZVNvdXJjZSA9IGZ1bmN0aW9uIHNsaWNlQXJyYXlTb3VyY2UoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoZnJvbSwgdG8pLmpvaW4oJycpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAnMDEyMzQ1Njc4OScuaW5kZXhPZihjaCkgPj0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICAgIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRicuaW5kZXhPZihjaCkgPj0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCkgPj0gMDtcbiAgICB9XG5cblxuICAgIC8vIDcuMiBXaGl0ZSBTcGFjZVxuXG4gICAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09ICcgJykgfHwgKGNoID09PSAnXFx1MDAwOScpIHx8IChjaCA9PT0gJ1xcdTAwMEInKSB8fFxuICAgICAgICAgICAgKGNoID09PSAnXFx1MDAwQycpIHx8IChjaCA9PT0gJ1xcdTAwQTAnKSB8fFxuICAgICAgICAgICAgKGNoLmNoYXJDb2RlQXQoMCkgPj0gMHgxNjgwICYmXG4gICAgICAgICAgICAgJ1xcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGJy5pbmRleE9mKGNoKSA+PSAwKTtcbiAgICB9XG5cbiAgICAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gICAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgICByZXR1cm4gKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xccicgfHwgY2ggPT09ICdcXHUyMDI4JyB8fCBjaCA9PT0gJ1xcdTIwMjknKTtcbiAgICB9XG5cbiAgICAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09ICckJykgfHwgKGNoID09PSAnXycpIHx8IChjaCA9PT0gJ1xcXFwnKSB8fFxuICAgICAgICAgICAgKGNoID49ICdhJyAmJiBjaCA8PSAneicpIHx8IChjaCA+PSAnQScgJiYgY2ggPD0gJ1onKSB8fFxuICAgICAgICAgICAgKChjaC5jaGFyQ29kZUF0KDApID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoY2gpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICAgIHJldHVybiAoY2ggPT09ICckJykgfHwgKGNoID09PSAnXycpIHx8IChjaCA9PT0gJ1xcXFwnKSB8fFxuICAgICAgICAgICAgKGNoID49ICdhJyAmJiBjaCA8PSAneicpIHx8IChjaCA+PSAnQScgJiYgY2ggPD0gJ1onKSB8fFxuICAgICAgICAgICAgKChjaCA+PSAnMCcpICYmIChjaCA8PSAnOScpKSB8fFxuICAgICAgICAgICAgKChjaC5jaGFyQ29kZUF0KDApID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChjaCkpO1xuICAgIH1cblxuICAgIC8vIDcuNi4xLjIgRnV0dXJlIFJlc2VydmVkIFdvcmRzXG5cbiAgICBmdW5jdGlvbiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgICBzd2l0Y2ggKGlkKSB7XG5cbiAgICAgICAgLy8gRnV0dXJlIHJlc2VydmVkIHdvcmRzLlxuICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgICBjYXNlICdleHRlbmRzJzpcbiAgICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgY2FzZSAnc3VwZXInOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICAgIHN3aXRjaCAoaWQpIHtcblxuICAgICAgICAvLyBTdHJpY3QgTW9kZSByZXNlcnZlZCB3b3Jkcy5cbiAgICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XG4gICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgICBjYXNlICdwcml2YXRlJzpcbiAgICAgICAgY2FzZSAncHJvdGVjdGVkJzpcbiAgICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgICAgY2FzZSAnc3RhdGljJzpcbiAgICAgICAgY2FzZSAneWllbGQnOlxuICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXN0cmljdGVkV29yZChpZCkge1xuICAgICAgICByZXR1cm4gaWQgPT09ICdldmFsJyB8fCBpZCA9PT0gJ2FyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICAgIHZhciBrZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBrZXl3b3JkID0gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHwgKGlkID09PSAndHJ5Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAga2V5d29yZCA9IChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8IChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAga2V5d29yZCA9IChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8IChpZCA9PT0gJ3Rocm93Jyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAga2V5d29yZCA9IChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8IChpZCA9PT0gJ3N3aXRjaCcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGtleXdvcmQgPSAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAga2V5d29yZCA9IChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICAvLyBGdXR1cmUgcmVzZXJ2ZWQgd29yZHMuXG4gICAgICAgIC8vICdjb25zdCcgaXMgc3BlY2lhbGl6ZWQgYXMgS2V5d29yZCBpbiBWOC5cbiAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gRm9yIGNvbXBhdGlibGl0eSB0byBTcGlkZXJNb25rZXkgYW5kIEVTLm5leHRcbiAgICAgICAgY2FzZSAneWllbGQnOlxuICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKGlkKTtcbiAgICB9XG5cbiAgICAvLyA3LjQgQ29tbWVudHNcblxuICAgIGZ1bmN0aW9uIHNraXBDb21tZW50KCkge1xuICAgICAgICB2YXIgY2gsIGJsb2NrQ29tbWVudCwgbGluZUNvbW1lbnQ7XG5cbiAgICAgICAgYmxvY2tDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIGxpbmVDb21tZW50ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChsaW5lQ29tbWVudCkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChibG9ja0NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXggKyAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgICBsaW5lQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkhleEVzY2FwZShwcmVmaXgpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgY2gsIGNvZGUgPSAwO1xuXG4gICAgICAgIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgY2gsIHN0YXJ0LCBpZCwgcmVzdG9yZTtcblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdICE9PSAndScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWQgPSBjaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgIGlkID0gJ3UnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSAhPT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlkICs9IGNoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgaWQgKz0gJ3UnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWQgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxuICAgICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXG4gICAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNLZXl3b3JkKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5LZXl3b3JkLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDcuOC4xIE51bGwgTGl0ZXJhbHNcblxuICAgICAgICBpZiAoaWQgPT09ICdudWxsJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5OdWxsTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyA3LjguMiBCb29sZWFuIExpdGVyYWxzXG5cbiAgICAgICAgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uQm9vbGVhbkxpdGVyYWwsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFRva2VuLklkZW50aWZpZXIsXG4gICAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyA3LjcgUHVuY3R1YXRvcnNcblxuICAgIGZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBpbmRleCxcbiAgICAgICAgICAgIGNoMSA9IHNvdXJjZVtpbmRleF0sXG4gICAgICAgICAgICBjaDIsXG4gICAgICAgICAgICBjaDMsXG4gICAgICAgICAgICBjaDQ7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJzsnIHx8IGNoMSA9PT0gJ3snIHx8IGNoMSA9PT0gJ30nKSB7XG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjaDEsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gxID09PSAnLCcgfHwgY2gxID09PSAnKCcgfHwgY2gxID09PSAnKScpIHtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoMSxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvdCAoLikgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cblxuICAgICAgICBjaDIgPSBzb3VyY2VbaW5kZXggKyAxXTtcbiAgICAgICAgaWYgKGNoMSA9PT0gJy4nICYmICFpc0RlY2ltYWxEaWdpdChjaDIpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZVtpbmRleCsrXSxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBlZWsgbW9yZSBjaGFyYWN0ZXJzLlxuXG4gICAgICAgIGNoMyA9IHNvdXJjZVtpbmRleCArIDJdO1xuICAgICAgICBjaDQgPSBzb3VyY2VbaW5kZXggKyAzXTtcblxuICAgICAgICAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yOiA+Pj49XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJz4nICYmIGNoMiA9PT0gJz4nICYmIGNoMyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBpZiAoY2g0ID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnPj4+PScsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ID09PSAhPT0gPj4+IDw8PSA+Pj1cblxuICAgICAgICBpZiAoY2gxID09PSAnPScgJiYgY2gyID09PSAnPScgJiYgY2gzID09PSAnPScpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc9PT0nLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJyEnICYmIGNoMiA9PT0gJz0nICYmIGNoMyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnIT09JyxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaDEgPT09ICc+JyAmJiBjaDIgPT09ICc+JyAmJiBjaDMgPT09ICc+Jykge1xuICAgICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICB2YWx1ZTogJz4+PicsXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gxID09PSAnPCcgJiYgY2gyID09PSAnPCcgJiYgY2gzID09PSAnPScpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc8PD0nLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoMSA9PT0gJz4nICYmIGNoMiA9PT0gJz4nICYmIGNoMyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnPj49JyxcbiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbc3RhcnQsIGluZGV4XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA8PSA+PSA9PSAhPSArKyAtLSA8PCA+PiAmJiB8fFxuICAgICAgICAvLyArPSAtPSAqPSAlPSAmPSB8PSBePSAvPVxuXG4gICAgICAgIGlmIChjaDIgPT09ICc9Jykge1xuICAgICAgICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2gxICsgY2gyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaDEgPT09IGNoMiAmJiAoJystPD4mfCcuaW5kZXhPZihjaDEpID49IDApKSB7XG4gICAgICAgICAgICBpZiAoJystPD4mfCcuaW5kZXhPZihjaDIpID49IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaDEgKyBjaDIsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlbWFpbmluZyAxLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cblxuICAgICAgICBpZiAoJ1tdPD4rLSolJnxeIX4/Oj0vJy5pbmRleE9mKGNoMSkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2VbaW5kZXgrK10sXG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA3LjguMyBOdW1lcmljIExpdGVyYWxzXG5cbiAgICBmdW5jdGlvbiBzY2FuTnVtZXJpY0xpdGVyYWwoKSB7XG4gICAgICAgIHZhciBudW1iZXIsIHN0YXJ0LCBjaDtcblxuICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgIGFzc2VydChpc0RlY2ltYWxEaWdpdChjaCkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICAgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIG51bWJlciA9ICcnO1xuICAgICAgICBpZiAoY2ggIT09ICcuJykge1xuICAgICAgICAgICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xuICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IDB4XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bWJlciwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtYmVyLCA4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnIHN1Y2ggYXMgJzA5JyBpcyBpbGxlZ2FsLlxuICAgICAgICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaCA9ICdjaGFyYWN0ZXIgJyArIGNoO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSAnPGVuZD4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgcmFuZ2U6IFtzdGFydCwgaW5kZXhdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNy44LjQgU3RyaW5nIExpdGVyYWxzXG5cbiAgICBmdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnLCBxdW90ZSwgc3RhcnQsIGNoLCBjb2RlLCB1bmVzY2FwZWQsIHJlc3RvcmUsIG9jdGFsID0gZmFsc2U7XG5cbiAgICAgICAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksXG4gICAgICAgICAgICAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgKytpbmRleDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmICghaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocXVvdGUgIT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogVG9rZW4uU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgICBvY3RhbDogb2N0YWwsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xuICAgICAgICB2YXIgc3RyLCBjaCwgc3RhcnQsIHBhdHRlcm4sIGZsYWdzLCB2YWx1ZSwgY2xhc3NNYXJrZXIgPSBmYWxzZSwgcmVzdG9yZSwgdGVybWluYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBFQ01BLTI2MiA3LjguNVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgcGF0dGVybiA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuXG4gICAgICAgIGZsYWdzID0gJyc7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IHJlc3RvcmUgPCBpbmRleDsgKytyZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNvdXJjZVtyZXN0b3JlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaXRlcmFsOiBzdHIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBpbmRleF1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkIHx8XG4gICAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCB8fFxuICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICAgICAgdmFyIGNoLCB0b2tlbjtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uRU9GLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtpbmRleCwgaW5kZXhdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4gPSBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ1xcJycgfHwgY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoID09PSAnLicgfHwgaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2tlbiA9IHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW47XG5cbiAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgaW5kZXggPSBidWZmZXIucmFuZ2VbMV07XG4gICAgICAgICAgICBsaW5lTnVtYmVyID0gYnVmZmVyLmxpbmVOdW1iZXI7XG4gICAgICAgICAgICBsaW5lU3RhcnQgPSBidWZmZXIubGluZVN0YXJ0O1xuICAgICAgICAgICAgdG9rZW4gPSBidWZmZXI7XG4gICAgICAgICAgICBidWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGFkdmFuY2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29rYWhlYWQoKSB7XG4gICAgICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0O1xuXG4gICAgICAgIGlmIChidWZmZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgPSBpbmRleDtcbiAgICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBidWZmZXIgPSBhZHZhbmNlKCk7XG4gICAgICAgIGluZGV4ID0gcG9zO1xuICAgICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhIGxpbmUgdGVybWluYXRvciBiZWZvcmUgdGhlIG5leHQgdG9rZW4uXG5cbiAgICBmdW5jdGlvbiBwZWVrTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0LCBmb3VuZDtcblxuICAgICAgICBwb3MgPSBpbmRleDtcbiAgICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBmb3VuZCA9IGxpbmVOdW1iZXIgIT09IGxpbmU7XG4gICAgICAgIGluZGV4ID0gcG9zO1xuICAgICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvblxuXG4gICAgZnVuY3Rpb24gdGhyb3dFcnJvcih0b2tlbiwgbWVzc2FnZUZvcm1hdCkge1xuICAgICAgICB2YXIgZXJyb3IsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAgICAgICAvJShcXGQpL2csXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHdob2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpbmRleF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgdG9rZW4ubGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgICAgZXJyb3IuaW5kZXggPSB0b2tlbi5yYW5nZVswXTtcbiAgICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgICAgICAgZXJyb3IuY29sdW1uID0gdG9rZW4ucmFuZ2VbMF0gLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIGxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICAgIGVycm9yLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRocm93RXJyb3JUb2xlcmFudCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93RXJyb3IuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXG5cbiAgICBmdW5jdGlvbiB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZEVPUyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgICBpZiAoaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCb29sZWFuTGl0ZXJhbCwgTnVsbExpdGVyYWwsIG9yIFB1bmN0dWF0b3IuXG4gICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG4gICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cbiAgICBmdW5jdGlvbiBleHBlY3QodmFsdWUpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXG4gICAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cbiAgICBmdW5jdGlvbiBleHBlY3RLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5LZXl3b3JkIHx8IHRva2VuLnZhbHVlICE9PSBrZXl3b3JkKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG5cbiAgICBmdW5jdGlvbiBtYXRjaCh2YWx1ZSkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udmFsdWUgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXG5cbiAgICBmdW5jdGlvbiBtYXRjaEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgJiYgdG9rZW4udmFsdWUgPT09IGtleXdvcmQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gaXMgYW4gYXNzaWdubWVudCBvcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gbWF0Y2hBc3NpZ24oKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZCgpLFxuICAgICAgICAgICAgb3AgPSB0b2tlbi52YWx1ZTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcCA9PT0gJz0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJyo9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICcvPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnJT0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJys9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICctPScgfHxcbiAgICAgICAgICAgIG9wID09PSAnPDw9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICc+Pj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJz4+Pj0nIHx8XG4gICAgICAgICAgICBvcCA9PT0gJyY9JyB8fFxuICAgICAgICAgICAgb3AgPT09ICdePScgfHxcbiAgICAgICAgICAgIG9wID09PSAnfD0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnN1bWVTZW1pY29sb24oKSB7XG4gICAgICAgIHZhciB0b2tlbiwgbGluZTtcblxuICAgICAgICAvLyBDYXRjaCB0aGUgdmVyeSBjb21tb24gY2FzZSBmaXJzdC5cbiAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICc7Jykge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgIT09IGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5FT0YgJiYgIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBwcm92aWRlZCBleHByZXNzaW9uIGlzIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cblxuICAgIGZ1bmN0aW9uIGlzTGVmdEhhbmRTaWRlKGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgfHwgZXhwci50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICAvLyAxMS4xLjQgQXJyYXkgSW5pdGlhbGlzZXJcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ10nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkFycmF5RXhwcmVzc2lvbixcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDExLjEuNSBPYmplY3QgSW5pdGlhbGlzZXJcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHlGdW5jdGlvbihwYXJhbSwgZmlyc3QpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzU3RyaWN0LCBib2R5O1xuXG4gICAgICAgIHByZXZpb3VzU3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBib2R5ID0gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChmaXJzdCAmJiBzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChwYXJhbVswXS5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGZpcnN0LCBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmljdCA9IHByZXZpb3VzU3RyaWN0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uLFxuICAgICAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtLFxuICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgICAgICBnZW5lcmF0b3I6IGZhbHNlLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IGZyb20gcGFyc2VPYmplY3RQcm9wZXJ0eSgpLCB3aGVyZVxuICAgICAgICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMaXRlcmFsKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgIG5hbWU6IHRva2VuLnZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eSgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBrZXksIGlkLCBwYXJhbTtcblxuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG5cbiAgICAgICAgICAgIGlkID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSBBc3NpZ25tZW50OiBHZXR0ZXIgYW5kIFNldHRlci5cblxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnZ2V0JyAmJiAhbWF0Y2goJzonKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJygnKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoJyknKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uKFtdKSxcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ2dldCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSA9PT0gJ3NldCcgJiYgIW1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcoJyk7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbSA9IFsgcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKSBdO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnKScpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZVByb3BlcnR5RnVuY3Rpb24ocGFyYW0sIHRva2VuKSxcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ3NldCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGtleTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdpbml0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAga2luZDogJ2luaXQnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXSwgcHJvcGVydHksIG5hbWUsIGtpbmQsIG1hcCA9IHt9LCB0b1N0cmluZyA9IFN0cmluZztcblxuICAgICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eSgpO1xuXG4gICAgICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHByb3BlcnR5LmtleS5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtpbmQgPSAocHJvcGVydHkua2luZCA9PT0gJ2luaXQnKSA/IFByb3BlcnR5S2luZC5EYXRhIDogKHByb3BlcnR5LmtpbmQgPT09ICdnZXQnKSA/IFByb3BlcnR5S2luZC5HZXQgOiBQcm9wZXJ0eUtpbmQuU2V0O1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcFtuYW1lXSA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCAhPT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXBbbmFtZV0gJiBraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yR2V0U2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBbbmFtZV0gfD0ga2luZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwW25hbWVdID0ga2luZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk9iamVjdEV4cHJlc3Npb24sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTEuMS42IFRoZSBHcm91cGluZyBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VHcm91cEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIC8vIDExLjEgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkKCksXG4gICAgICAgICAgICB0eXBlID0gdG9rZW4udHlwZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBuYW1lOiBsZXgoKS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWwobGV4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ3RoaXMnKSkge1xuICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UaGlzRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMaXRlcmFsKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbCkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTGl0ZXJhbCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXBFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWwoc2NhblJlZ0V4cCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgIH1cblxuICAgIC8vIDExLjIgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICBpZiAoIWlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgICBleHBlY3QoJy4nKTtcblxuICAgICAgICByZXR1cm4gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb21wdXRlZE1lbWJlcigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTmV3RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnbmV3Jyk7XG5cbiAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxuICAgICAgICAgICAgY2FsbGVlOiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICdhcmd1bWVudHMnOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICBleHByWydhcmd1bWVudHMnXSA9IHBhcnNlQXJndW1lbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICAgIHZhciBleHByO1xuXG4gICAgICAgIGV4cHIgPSBtYXRjaEtleXdvcmQoJ25ldycpID8gcGFyc2VOZXdFeHByZXNzaW9uKCkgOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCcuJykgfHwgbWF0Y2goJ1snKSB8fCBtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBleHByLFxuICAgICAgICAgICAgICAgICAgICAnYXJndW1lbnRzJzogcGFyc2VBcmd1bWVudHMoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHI7XG5cbiAgICAgICAgZXhwciA9IG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24oKSA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJy4nKSB8fCBtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VDb21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VOb25Db21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSwgdG9rZW47XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkgJiYgIXBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICAvLyAxMS4zLjEsIDExLjMuMlxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0TEhTUG9zdGZpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNMZWZ0SGFuZFNpZGUoZXhwcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVXBkYXRlRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjQgVW5hcnkgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIC8vIDExLjQuNCwgMTEuNC41XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgJiYgaXNSZXN0cmljdGVkV29yZChleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RMSFNQcmVmaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGV4cHIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZExIU0luQXNzaWdubWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlVwZGF0ZUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IHRva2VuLnZhbHVlLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBleHByLFxuICAgICAgICAgICAgICAgIHByZWZpeDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IHBhcnNlVW5hcnlFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IHBhcnNlVW5hcnlFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGV4cHIub3BlcmF0b3IgPT09ICdkZWxldGUnICYmIGV4cHIuYXJndW1lbnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdERlbGV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgfVxuXG4gICAgLy8gMTEuNSBNdWx0aXBsaWNhdGl2ZSBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCcqJykgfHwgbWF0Y2goJy8nKSB8fCBtYXRjaCgnJScpKSB7XG4gICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBsZXgoKS52YWx1ZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuNiBBZGRpdGl2ZSBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlQWRkaXRpdmVFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjcgQml0d2lzZSBTaGlmdCBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlU2hpZnRFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlQWRkaXRpdmVFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCc8PCcpIHx8IG1hdGNoKCc+PicpIHx8IG1hdGNoKCc+Pj4nKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VBZGRpdGl2ZUV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICAvLyAxMS44IFJlbGF0aW9uYWwgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZVJlbGF0aW9uYWxFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciwgcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZVNoaWZ0RXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnPCcpIHx8IG1hdGNoKCc+JykgfHwgbWF0Y2goJzw9JykgfHwgbWF0Y2goJz49JykgfHwgKHByZXZpb3VzQWxsb3dJbiAmJiBtYXRjaEtleXdvcmQoJ2luJykpIHx8IG1hdGNoS2V5d29yZCgnaW5zdGFuY2VvZicpKSB7XG4gICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBsZXgoKS52YWx1ZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZVNoaWZ0RXhwcmVzc2lvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuOSBFcXVhbGl0eSBPcGVyYXRvcnNcblxuICAgIGZ1bmN0aW9uIHBhcnNlRXF1YWxpdHlFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJz09JykgfHwgbWF0Y2goJyE9JykgfHwgbWF0Y2goJz09PScpIHx8IG1hdGNoKCchPT0nKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogbGV4KCkudmFsdWUsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuMTAgQmluYXJ5IEJpdHdpc2UgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUJpdHdpc2VBTkRFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlRXF1YWxpdHlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCcmJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJyYnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlRXF1YWxpdHlFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJpdHdpc2VYT1JFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlQml0d2lzZUFOREV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJ14nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnXicsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VCaXR3aXNlQU5ERXhwcmVzc2lvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlQml0d2lzZVhPUkV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJ3wnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnfCcsXG4gICAgICAgICAgICAgICAgbGVmdDogZXhwcixcbiAgICAgICAgICAgICAgICByaWdodDogcGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbigpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvZ2ljYWxBTkRFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlQml0d2lzZU9SRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIHdoaWxlIChtYXRjaCgnJiYnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJyYmJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZUJpdHdpc2VPUkV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTG9naWNhbE9SRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBwYXJzZUxvZ2ljYWxBTkRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCd8fCcpKSB7XG4gICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnfHwnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGV4cHIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHBhcnNlTG9naWNhbEFOREV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudDtcblxuICAgICAgICBleHByID0gcGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc/JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuICAgICAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG4gICAgICAgICAgICBleHBlY3QoJzonKTtcblxuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIHRlc3Q6IGV4cHIsXG4gICAgICAgICAgICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudCxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGU6IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDExLjEzIEFzc2lnbm1lbnQgT3BlcmF0b3JzXG5cbiAgICBmdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4sIGV4cHI7XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgZXhwciA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoQXNzaWduKCkpIHtcbiAgICAgICAgICAgIC8vIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cbiAgICAgICAgICAgIGlmICghaXNMZWZ0SGFuZFNpZGUoZXhwcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Bc3NpZ25tZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gMTEuMTMuMVxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0TEhTQXNzaWdubWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBsZXgoKS52YWx1ZSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBleHByLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgZXhwciA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBbIGV4cHIgXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICBleHByLmV4cHJlc3Npb25zLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIC8vIDEyLjEgQmxvY2tcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50TGlzdCgpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXSxcbiAgICAgICAgICAgIHN0YXRlbWVudDtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgICAgICB2YXIgYmxvY2s7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgYmxvY2sgPSBwYXJzZVN0YXRlbWVudExpc3QoKTtcblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxuICAgICAgICAgICAgYm9keTogYmxvY2tcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4yIFZhcmlhYmxlIFN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxuICAgICAgICAgICAgbmFtZTogdG9rZW4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24oa2luZCkge1xuICAgICAgICB2YXIgaWQgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcigpLFxuICAgICAgICAgICAgaW5pdCA9IG51bGw7XG5cbiAgICAgICAgLy8gMTIuMi4xXG4gICAgICAgIGlmIChzdHJpY3QgJiYgaXNSZXN0cmljdGVkV29yZChpZC5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3RWYXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChraW5kID09PSAnY29uc3QnKSB7XG4gICAgICAgICAgICBleHBlY3QoJz0nKTtcbiAgICAgICAgICAgIGluaXQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJz0nKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBpbml0ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpbml0OiBpbml0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChraW5kKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2gocGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKGtpbmQpKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVZhcmlhYmxlU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25zO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3ZhcicpO1xuXG4gICAgICAgIGRlY2xhcmF0aW9ucyA9IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBkZWNsYXJhdGlvbnMsXG4gICAgICAgICAgICBraW5kOiAndmFyJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGtpbmQgbWF5IGJlIGBjb25zdGAgb3IgYGxldGBcbiAgICAvLyBCb3RoIGFyZSBleHBlcmltZW50YWwgYW5kIG5vdCBpbiB0aGUgc3BlY2lmaWNhdGlvbiB5ZXQuXG4gICAgLy8gc2VlIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6Y29uc3RcbiAgICAvLyBhbmQgaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTpsZXRcbiAgICBmdW5jdGlvbiBwYXJzZUNvbnN0TGV0RGVjbGFyYXRpb24oa2luZCkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25zO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoa2luZCk7XG5cbiAgICAgICAgZGVjbGFyYXRpb25zID0gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uTGlzdChraW5kKTtcblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBkZWNsYXJhdGlvbnMsXG4gICAgICAgICAgICBraW5kOiBraW5kXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuMyBFbXB0eSBTdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlRW1wdHlTdGF0ZW1lbnQoKSB7XG4gICAgICAgIGV4cGVjdCgnOycpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRW1wdHlTdGF0ZW1lbnRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi40IEV4cHJlc3Npb24gU3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi41IElmIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VJZlN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdpZicpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBjb25zZXF1ZW50ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBpZiAobWF0Y2hLZXl3b3JkKCdlbHNlJykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgYWx0ZXJuYXRlID0gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LklmU3RhdGVtZW50LFxuICAgICAgICAgICAgdGVzdDogdGVzdCxcbiAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQsXG4gICAgICAgICAgICBhbHRlcm5hdGU6IGFsdGVybmF0ZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjYgSXRlcmF0aW9uIFN0YXRlbWVudHNcblxuICAgIGZ1bmN0aW9uIHBhcnNlRG9XaGlsZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGJvZHksIHRlc3QsIG9sZEluSXRlcmF0aW9uO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2RvJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Eb1doaWxlU3RhdGVtZW50LFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHRlc3Q6IHRlc3RcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdoaWxlU3RhdGVtZW50KCkge1xuICAgICAgICB2YXIgdGVzdCwgYm9keSwgb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnd2hpbGUnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5XaGlsZVN0YXRlbWVudCxcbiAgICAgICAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IHBhcnNlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoKSxcbiAgICAgICAgICAgIGtpbmQ6IHRva2VuLnZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGb3JTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBpbml0LCB0ZXN0LCB1cGRhdGUsIGxlZnQsIHJpZ2h0LCBib2R5LCBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBpbml0ID0gdGVzdCA9IHVwZGF0ZSA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZm9yJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1hdGNoS2V5d29yZCgndmFyJykgfHwgbWF0Y2hLZXl3b3JkKCdsZXQnKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpbml0ID0gcGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIG1hdGNoS2V5d29yZCgnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGluaXQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTGVmdEhhbmRTaWRlKGluaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkTEhTSW5Gb3JJbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGV4cGVjdCgnOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgICAgICBpZiAoIW1hdGNoKCc7JykpIHtcbiAgICAgICAgICAgICAgICB0ZXN0ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoJzsnKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBvbGRJbkl0ZXJhdGlvbiA9IHN0YXRlLmluSXRlcmF0aW9uO1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgc3RhdGUuaW5JdGVyYXRpb24gPSBvbGRJbkl0ZXJhdGlvbjtcblxuICAgICAgICBpZiAodHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Gb3JTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgaW5pdDogaW5pdCxcbiAgICAgICAgICAgICAgICB0ZXN0OiB0ZXN0LFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkZvckluU3RhdGVtZW50LFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBlYWNoOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIDEyLjcgVGhlIGNvbnRpbnVlIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb250aW51ZVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIHRva2VuLCBsYWJlbCA9IG51bGw7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnY29udGludWUnKTtcblxuICAgICAgICAvLyBPcHRpbWl6ZSB0aGUgbW9zdCBjb21tb24gZm9ybTogJ2NvbnRpbnVlOycuXG4gICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAnOycpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoIXN0YXRlLmluSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIGlmICghc3RhdGUuaW5JdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbGxlZ2FsQ29udGludWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Db250aW51ZVN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBsYWJlbDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBsYWJlbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVua25vd25MYWJlbCwgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgaWYgKGxhYmVsID09PSBudWxsICYmICFzdGF0ZS5pbkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbENvbnRpbnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ29udGludWVTdGF0ZW1lbnQsXG4gICAgICAgICAgICBsYWJlbDogbGFiZWxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi44IFRoZSBicmVhayBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQnJlYWtTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgbGFiZWwgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ2JyZWFrJyk7XG5cbiAgICAgICAgLy8gT3B0aW1pemUgdGhlIG1vc3QgY29tbW9uIGZvcm06ICdicmVhazsnLlxuICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJzsnKSB7XG4gICAgICAgICAgICBsZXgoKTtcblxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuaW5JdGVyYXRpb24gfHwgc3RhdGUuaW5Td2l0Y2gpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSWxsZWdhbEJyZWFrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQnJlYWtTdGF0ZW1lbnQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgIGlmICghKHN0YXRlLmluSXRlcmF0aW9uIHx8IHN0YXRlLmluU3dpdGNoKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJyZWFrU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxhYmVsID0gcGFyc2VWYXJpYWJsZUlkZW50aWZpZXIoKTtcblxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubGFiZWxTZXQsIGxhYmVsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5rbm93bkxhYmVsLCBsYWJlbC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IG51bGwgJiYgIShzdGF0ZS5pbkl0ZXJhdGlvbiB8fCBzdGF0ZS5pblN3aXRjaCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLklsbGVnYWxCcmVhayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJyZWFrU3RhdGVtZW50LFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuOSBUaGUgcmV0dXJuIHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VSZXR1cm5TdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiwgYXJndW1lbnQgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3JldHVybicpO1xuXG4gICAgICAgIGlmICghc3RhdGUuaW5GdW5jdGlvbkJvZHkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuSWxsZWdhbFJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAncmV0dXJuJyBmb2xsb3dlZCBieSBhIHNwYWNlIGFuZCBhbiBpZGVudGlmaWVyIGlzIHZlcnkgY29tbW9uLlxuICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlW2luZGV4ICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlJldHVyblN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguUmV0dXJuU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnOycpKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCgnfScpICYmIHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQsXG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgd2l0aCBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2l0aFN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIG9iamVjdCwgYm9keTtcblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdE1vZGVXaXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3dpdGgnKTtcblxuICAgICAgICBleHBlY3QoJygnKTtcblxuICAgICAgICBvYmplY3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LldpdGhTdGF0ZW1lbnQsXG4gICAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4xMCBUaGUgc3dpdGggc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciB0ZXN0LFxuICAgICAgICAgICAgY29uc2VxdWVudCA9IFtdLFxuICAgICAgICAgICAgc3RhdGVtZW50O1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICB0ZXN0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGVjdEtleXdvcmQoJ2Nhc2UnKTtcbiAgICAgICAgICAgIHRlc3QgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoJzonKTtcblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnfScpIHx8IG1hdGNoS2V5d29yZCgnZGVmYXVsdCcpIHx8IG1hdGNoS2V5d29yZCgnY2FzZScpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zZXF1ZW50LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguU3dpdGNoQ2FzZSxcbiAgICAgICAgICAgIHRlc3Q6IHRlc3QsXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTd2l0Y2hTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBkaXNjcmltaW5hbnQsIGNhc2VzLCBjbGF1c2UsIG9sZEluU3dpdGNoLCBkZWZhdWx0Rm91bmQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnc3dpdGNoJyk7XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgZGlzY3JpbWluYW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguU3dpdGNoU3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIGRpc2NyaW1pbmFudDogZGlzY3JpbWluYW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2FzZXMgPSBbXTtcblxuICAgICAgICBvbGRJblN3aXRjaCA9IHN0YXRlLmluU3dpdGNoO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IHRydWU7XG4gICAgICAgIGRlZmF1bHRGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXVzZSA9IHBhcnNlU3dpdGNoQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGNsYXVzZS50ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZXMucHVzaChjbGF1c2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaW5Td2l0Y2ggPSBvbGRJblN3aXRjaDtcblxuICAgICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LlN3aXRjaFN0YXRlbWVudCxcbiAgICAgICAgICAgIGRpc2NyaW1pbmFudDogZGlzY3JpbWluYW50LFxuICAgICAgICAgICAgY2FzZXM6IGNhc2VzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuMTMgVGhlIHRocm93IHN0YXRlbWVudFxuXG4gICAgZnVuY3Rpb24gcGFyc2VUaHJvd1N0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50O1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3Rocm93Jyk7XG5cbiAgICAgICAgaWYgKHBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5OZXdsaW5lQWZ0ZXJUaHJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LlRocm93U3RhdGVtZW50LFxuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIuMTQgVGhlIHRyeSBzdGF0ZW1lbnRcblxuICAgIGZ1bmN0aW9uIHBhcnNlQ2F0Y2hDbGF1c2UoKSB7XG4gICAgICAgIHZhciBwYXJhbTtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdjYXRjaCcpO1xuXG4gICAgICAgIGV4cGVjdCgnKCcpO1xuICAgICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgIHBhcmFtID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICAvLyAxMi4xNC4xXG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIHBhcmFtLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIGlzUmVzdHJpY3RlZFdvcmQocGFyYW0ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdENhdGNoVmFyaWFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ2F0Y2hDbGF1c2UsXG4gICAgICAgICAgICBwYXJhbTogcGFyYW0sXG4gICAgICAgICAgICBib2R5OiBwYXJzZUJsb2NrKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRyeVN0YXRlbWVudCgpIHtcbiAgICAgICAgdmFyIGJsb2NrLCBoYW5kbGVycyA9IFtdLCBmaW5hbGl6ZXIgPSBudWxsO1xuXG4gICAgICAgIGV4cGVjdEtleXdvcmQoJ3RyeScpO1xuXG4gICAgICAgIGJsb2NrID0gcGFyc2VCbG9jaygpO1xuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2NhdGNoJykpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocGFyc2VDYXRjaENsYXVzZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaEtleXdvcmQoJ2ZpbmFsbHknKSkge1xuICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICBmaW5hbGl6ZXIgPSBwYXJzZUJsb2NrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwICYmICFmaW5hbGl6ZXIpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLk5vQ2F0Y2hPckZpbmFsbHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5UcnlTdGF0ZW1lbnQsXG4gICAgICAgICAgICBibG9jazogYmxvY2ssXG4gICAgICAgICAgICBndWFyZGVkSGFuZGxlcnM6IFtdLFxuICAgICAgICAgICAgaGFuZGxlcnM6IGhhbmRsZXJzLFxuICAgICAgICAgICAgZmluYWxpemVyOiBmaW5hbGl6ZXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAxMi4xNSBUaGUgZGVidWdnZXIgc3RhdGVtZW50XG5cbiAgICBmdW5jdGlvbiBwYXJzZURlYnVnZ2VyU3RhdGVtZW50KCkge1xuICAgICAgICBleHBlY3RLZXl3b3JkKCdkZWJ1Z2dlcicpO1xuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkRlYnVnZ2VyU3RhdGVtZW50XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTIgU3RhdGVtZW50c1xuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZCgpLFxuICAgICAgICAgICAgZXhwcixcbiAgICAgICAgICAgIGxhYmVsZWRCb2R5O1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRW1wdHlTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUJsb2NrKCk7XG4gICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JyZWFrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VCcmVha1N0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnY29udGludWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUNvbnRpbnVlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdkZWJ1Z2dlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VEb1doaWxlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdmb3InOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZvclN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICAgICAgICAgIGNhc2UgJ2lmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJZlN0YXRlbWVudCgpO1xuICAgICAgICAgICAgY2FzZSAncmV0dXJuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VSZXR1cm5TdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3N3aXRjaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3dpdGNoU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICd0aHJvdyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVGhyb3dTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3RyeSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlVHJ5U3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICd2YXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVZhcmlhYmxlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBjYXNlICd3aGlsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2hpbGVTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ3dpdGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVdpdGhTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgLy8gMTIuMTIgTGFiZWxsZWQgU3RhdGVtZW50c1xuICAgICAgICBpZiAoKGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpICYmIG1hdGNoKCc6JykpIHtcbiAgICAgICAgICAgIGxleCgpO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmxhYmVsU2V0LCBleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuUmVkZWNsYXJhdGlvbiwgJ0xhYmVsJywgZXhwci5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubGFiZWxTZXRbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICBsYWJlbGVkQm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubGFiZWxTZXRbZXhwci5uYW1lXTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTGFiZWxlZFN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICBsYWJlbDogZXhwcixcbiAgICAgICAgICAgICAgICBib2R5OiBsYWJlbGVkQm9keVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTMgRnVuY3Rpb24gRGVmaW5pdGlvblxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzKCkge1xuICAgICAgICB2YXIgc291cmNlRWxlbWVudCwgc291cmNlRWxlbWVudHMgPSBbXSwgdG9rZW4sIGRpcmVjdGl2ZSwgZmlyc3RSZXN0cmljdGVkLFxuICAgICAgICAgICAgb2xkTGFiZWxTZXQsIG9sZEluSXRlcmF0aW9uLCBvbGRJblN3aXRjaCwgb2xkSW5GdW5jdGlvbkJvZHk7XG5cbiAgICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZSA9IHNsaWNlU291cmNlKHRva2VuLnJhbmdlWzBdICsgMSwgdG9rZW4ucmFuZ2VbMV0gLSAxKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2xkTGFiZWxTZXQgPSBzdGF0ZS5sYWJlbFNldDtcbiAgICAgICAgb2xkSW5JdGVyYXRpb24gPSBzdGF0ZS5pbkl0ZXJhdGlvbjtcbiAgICAgICAgb2xkSW5Td2l0Y2ggPSBzdGF0ZS5pblN3aXRjaDtcbiAgICAgICAgb2xkSW5GdW5jdGlvbkJvZHkgPSBzdGF0ZS5pbkZ1bmN0aW9uQm9keTtcblxuICAgICAgICBzdGF0ZS5sYWJlbFNldCA9IHt9O1xuICAgICAgICBzdGF0ZS5pbkl0ZXJhdGlvbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pblN3aXRjaCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbkZ1bmN0aW9uQm9keSA9IHRydWU7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICAgIHN0YXRlLmxhYmVsU2V0ID0gb2xkTGFiZWxTZXQ7XG4gICAgICAgIHN0YXRlLmluSXRlcmF0aW9uID0gb2xkSW5JdGVyYXRpb247XG4gICAgICAgIHN0YXRlLmluU3dpdGNoID0gb2xkSW5Td2l0Y2g7XG4gICAgICAgIHN0YXRlLmluRnVuY3Rpb25Cb2R5ID0gb2xkSW5GdW5jdGlvbkJvZHk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CbG9ja1N0YXRlbWVudCxcbiAgICAgICAgICAgIGJvZHk6IHNvdXJjZUVsZW1lbnRzXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCkge1xuICAgICAgICB2YXIgaWQsIHBhcmFtLCBwYXJhbXMgPSBbXSwgYm9keSwgdG9rZW4sIHN0cmljdGVkLCBmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UsIHByZXZpb3VzU3RyaWN0LCBwYXJhbVNldDtcblxuICAgICAgICBleHBlY3RLZXl3b3JkKCdmdW5jdGlvbicpO1xuICAgICAgICB0b2tlbiA9IGxvb2thaGVhZCgpO1xuICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RGdW5jdGlvbk5hbWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICBwYXJhbVNldCA9IHt9O1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgICAgICAgICBwYXJhbSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1TZXQsIHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbVNldCwgdG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIHBhcmFtU2V0W3BhcmFtLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBkZWZhdWx0czogW10sXG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgICAgIGdlbmVyYXRvcjogZmFsc2UsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgdG9rZW4sIGlkID0gbnVsbCwgc3RyaWN0ZWQsIGZpcnN0UmVzdHJpY3RlZCwgbWVzc2FnZSwgcGFyYW0sIHBhcmFtcyA9IFtdLCBib2R5LCBwcmV2aW91c1N0cmljdCwgcGFyYW1TZXQ7XG5cbiAgICAgICAgZXhwZWN0S2V5d29yZCgnZnVuY3Rpb24nKTtcblxuICAgICAgICBpZiAoIW1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkKCk7XG4gICAgICAgICAgICBpZCA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0RnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RyaWN0ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IE1lc3NhZ2VzLlN0cmljdEZ1bmN0aW9uTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICBwYXJhbVNldCA9IHt9O1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgICAgICAgICBwYXJhbSA9IHBhcnNlVmFyaWFibGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UGFyYW1OYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1TZXQsIHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbVNldCwgdG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBNZXNzYWdlcy5TdHJpY3RQYXJhbUR1cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgIHBhcmFtU2V0W3BhcmFtLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBwcmV2aW91c1N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgYm9keSA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cygpO1xuICAgICAgICBpZiAoc3RyaWN0ICYmIGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihmaXJzdFJlc3RyaWN0ZWQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpY3QgJiYgc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChzdHJpY3RlZCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaWN0ID0gcHJldmlvdXNTdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb24sXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGRlZmF1bHRzOiBbXSxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAgICAgZ2VuZXJhdG9yOiBmYWxzZSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMTQgUHJvZ3JhbVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBsb29rYWhlYWQoKTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VDb25zdExldERlY2xhcmF0aW9uKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnRzKCkge1xuICAgICAgICB2YXIgc291cmNlRWxlbWVudCwgc291cmNlRWxlbWVudHMgPSBbXSwgdG9rZW4sIGRpcmVjdGl2ZSwgZmlyc3RSZXN0cmljdGVkO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc291cmNlRWxlbWVudC5leHByZXNzaW9uLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgZGlyZWN0aXZlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXJlY3RpdmUgPSBzbGljZVNvdXJjZSh0b2tlbi5yYW5nZVswXSArIDEsIHRva2VuLnJhbmdlWzFdIC0gMSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlRWxlbWVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQcm9ncmFtKCkge1xuICAgICAgICB2YXIgcHJvZ3JhbTtcbiAgICAgICAgc3RyaWN0ID0gZmFsc2U7XG4gICAgICAgIHByb2dyYW0gPSB7XG4gICAgICAgICAgICB0eXBlOiBTeW50YXguUHJvZ3JhbSxcbiAgICAgICAgICAgIGJvZHk6IHBhcnNlU291cmNlRWxlbWVudHMoKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgbmVlZGVkIG9ubHkgd2hlbiB0aGUgb3B0aW9uIHRvIHByZXNlcnZlXG4gICAgLy8gdGhlIGNvbW1lbnRzIGlzIGFjdGl2ZS5cblxuICAgIGZ1bmN0aW9uIGFkZENvbW1lbnQodHlwZSwgdmFsdWUsIHN0YXJ0LCBlbmQsIGxvYykge1xuICAgICAgICBhc3NlcnQodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJywgJ0NvbW1lbnQgbXVzdCBoYXZlIHZhbGlkIHBvc2l0aW9uJyk7XG5cbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgd2F5IHRoZSBhY3R1YWwgdG9rZW4gaXMgc2Nhbm5lZCwgb2Z0ZW4gdGhlIGNvbW1lbnRzXG4gICAgICAgIC8vIChpZiBhbnkpIGFyZSBza2lwcGVkIHR3aWNlIGR1cmluZyB0aGUgbGV4aWNhbCBhbmFseXNpcy5cbiAgICAgICAgLy8gVGh1cywgd2UgbmVlZCB0byBza2lwIGFkZGluZyBhIGNvbW1lbnQgaWYgdGhlIGNvbW1lbnQgYXJyYXkgYWxyZWFkeVxuICAgICAgICAvLyBoYW5kbGVkIGl0LlxuICAgICAgICBpZiAoZXh0cmEuY29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnRzW2V4dHJhLmNvbW1lbnRzLmxlbmd0aCAtIDFdLnJhbmdlWzFdID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRyYS5jb21tZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0LCBlbmRdLFxuICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkNvbW1lbnQoKSB7XG4gICAgICAgIHZhciBjb21tZW50LCBjaCwgbG9jLCBzdGFydCwgYmxvY2tDb21tZW50LCBsaW5lQ29tbWVudDtcblxuICAgICAgICBjb21tZW50ID0gJyc7XG4gICAgICAgIGJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICBsaW5lQ29tbWVudCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAobGluZUNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IC0gMVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBsaW5lQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50KCdMaW5lJywgY29tbWVudCwgc3RhcnQsIGluZGV4IC0gMSwgbG9jKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGxlbmd0aCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50KCdMaW5lJywgY29tbWVudCwgc3RhcnQsIGxlbmd0aCwgbG9jKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2tDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2luZGV4ICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSAnXFxyXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY29tbWVudC5zdWJzdHIoMCwgY29tbWVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbW1lbnQoJ0Jsb2NrJywgY29tbWVudCwgc3RhcnQsIGluZGV4LCBsb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVDb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDb21tZW50KCdMaW5lJywgY29tbWVudCwgc3RhcnQsIGluZGV4LCBsb2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0IC0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAgJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlckNvbW1lbnRMb2NhdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGVudHJ5LCBjb21tZW50LCBjb21tZW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBleHRyYS5jb21tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZW50cnkgPSBleHRyYS5jb21tZW50c1tpXTtcbiAgICAgICAgICAgIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50cnkudHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50LnJhbmdlID0gZW50cnkucmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudC5sb2MgPSBlbnRyeS5sb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXh0cmEuY29tbWVudHMgPSBjb21tZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0VG9rZW4oKSB7XG4gICAgICAgIHZhciBzdGFydCwgbG9jLCB0b2tlbiwgcmFuZ2UsIHZhbHVlO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIGxvYyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdG9rZW4gPSBleHRyYS5hZHZhbmNlKCk7XG4gICAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIHJhbmdlID0gW3Rva2VuLnJhbmdlWzBdLCB0b2tlbi5yYW5nZVsxXV07XG4gICAgICAgICAgICB2YWx1ZSA9IHNsaWNlU291cmNlKHRva2VuLnJhbmdlWzBdLCB0b2tlbi5yYW5nZVsxXSk7XG4gICAgICAgICAgICBleHRyYS50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RSZWdleCgpIHtcbiAgICAgICAgdmFyIHBvcywgbG9jLCByZWdleCwgdG9rZW47XG5cbiAgICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgICBwb3MgPSBpbmRleDtcbiAgICAgICAgbG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZWdleCA9IGV4dHJhLnNjYW5SZWdFeHAoKTtcbiAgICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXG4gICAgICAgIGlmIChleHRyYS50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLycgfHwgdG9rZW4udmFsdWUgPT09ICcvPScpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSZWd1bGFyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICB2YWx1ZTogcmVnZXgubGl0ZXJhbCxcbiAgICAgICAgICAgIHJhbmdlOiBbcG9zLCBpbmRleF0sXG4gICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyVG9rZW5Mb2NhdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGVudHJ5LCB0b2tlbiwgdG9rZW5zID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4dHJhLnRva2Vucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZW50cnkgPSBleHRyYS50b2tlbnNbaV07XG4gICAgICAgICAgICB0b2tlbiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBlbnRyeS50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIHRva2VuLnJhbmdlID0gZW50cnkucmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4ubG9jID0gZW50cnkubG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXh0cmEudG9rZW5zID0gdG9rZW5zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpdGVyYWwodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5MaXRlcmFsLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmF3TGl0ZXJhbCh0b2tlbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUsXG4gICAgICAgICAgICByYXc6IHNsaWNlU291cmNlKHRva2VuLnJhbmdlWzBdLCB0b2tlbi5yYW5nZVsxXSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbk1hcmtlcigpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IHt9O1xuXG4gICAgICAgIG1hcmtlci5yYW5nZSA9IFtpbmRleCwgaW5kZXhdO1xuICAgICAgICBtYXJrZXIubG9jID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBtYXJrZXIuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5yYW5nZVsxXSA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5sb2MuZW5kLmxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5sb2MuZW5kLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0O1xuICAgICAgICB9O1xuXG4gICAgICAgIG1hcmtlci5hcHBseUdyb3VwID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuZ3JvdXBSYW5nZSA9IFt0aGlzLnJhbmdlWzBdLCB0aGlzLnJhbmdlWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgICBub2RlLmdyb3VwTG9jID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5sb2Muc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sb2Muc3RhcnQuY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5sb2MuZW5kLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMubG9jLmVuZC5jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbWFya2VyLmFwcGx5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmFuZ2UgPSBbdGhpcy5yYW5nZVswXSwgdGhpcy5yYW5nZVsxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxvYy5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmxvYy5zdGFydC5jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxvYy5lbmQubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5sb2MuZW5kLmNvbHVtblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNrR3JvdXBFeHByZXNzaW9uKCkge1xuICAgICAgICB2YXIgbWFya2VyLCBleHByO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG4gICAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBleHBlY3QoJyknKTtcblxuICAgICAgICBtYXJrZXIuZW5kKCk7XG4gICAgICAgIG1hcmtlci5hcHBseUdyb3VwKGV4cHIpO1xuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNrTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdmFyIG1hcmtlciwgZXhwcjtcblxuICAgICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgICBtYXJrZXIgPSBjcmVhdGVMb2NhdGlvbk1hcmtlcigpO1xuXG4gICAgICAgIGV4cHIgPSBtYXRjaEtleXdvcmQoJ25ldycpID8gcGFyc2VOZXdFeHByZXNzaW9uKCkgOiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgd2hpbGUgKG1hdGNoKCcuJykgfHwgbWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgICBleHByID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWFya2VyLmVuZCgpO1xuICAgICAgICAgICAgICAgIG1hcmtlci5hcHBseShleHByKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBleHByLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcGFyc2VOb25Db21wdXRlZE1lbWJlcigpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgbWFya2VyLmFwcGx5KGV4cHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2tMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICAgICAgICB2YXIgbWFya2VyLCBleHByO1xuXG4gICAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICAgIG1hcmtlciA9IGNyZWF0ZUxvY2F0aW9uTWFya2VyKCk7XG5cbiAgICAgICAgZXhwciA9IG1hdGNoS2V5d29yZCgnbmV3JykgPyBwYXJzZU5ld0V4cHJlc3Npb24oKSA6IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgICB3aGlsZSAobWF0Y2goJy4nKSB8fCBtYXRjaCgnWycpIHx8IG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IGV4cHIsXG4gICAgICAgICAgICAgICAgICAgICdhcmd1bWVudHMnOiBwYXJzZUFyZ3VtZW50cygpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuZW5kKCk7XG4gICAgICAgICAgICAgICAgbWFya2VyLmFwcGx5KGV4cHIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgICAgZXhwciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGV4cHIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwYXJzZUNvbXB1dGVkTWVtYmVyKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1hcmtlci5lbmQoKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuYXBwbHkoZXhwcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWFya2VyLmVuZCgpO1xuICAgICAgICAgICAgICAgIG1hcmtlci5hcHBseShleHByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlckdyb3VwKG5vZGUpIHtcbiAgICAgICAgdmFyIG4sIGksIGVudHJ5O1xuXG4gICAgICAgIG4gPSAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShub2RlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykgPyBbXSA6IHt9O1xuICAgICAgICBmb3IgKGkgaW4gbm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJ2dyb3VwUmFuZ2UnICYmIGkgIT09ICdncm91cExvYycpIHtcbiAgICAgICAgICAgICAgICBlbnRyeSA9IG5vZGVbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5ID09PSBudWxsIHx8IHR5cGVvZiBlbnRyeSAhPT0gJ29iamVjdCcgfHwgZW50cnkgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgbltpXSA9IGVudHJ5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5baV0gPSBmaWx0ZXJHcm91cChlbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyYXBUcmFja2luZ0Z1bmN0aW9uKHJhbmdlLCBsb2MpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBhcnNlRnVuY3Rpb24pIHtcblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNCaW5hcnkobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiB8fFxuICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgPT09IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB2aXNpdChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNCaW5hcnkobm9kZS5sZWZ0KSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpdChub2RlLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNCaW5hcnkobm9kZS5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXQobm9kZS5yaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnQuZ3JvdXBSYW5nZSB8fCBub2RlLnJpZ2h0Lmdyb3VwUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbm9kZS5sZWZ0Lmdyb3VwUmFuZ2UgPyBub2RlLmxlZnQuZ3JvdXBSYW5nZVswXSA6IG5vZGUubGVmdC5yYW5nZVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IG5vZGUucmlnaHQuZ3JvdXBSYW5nZSA/IG5vZGUucmlnaHQuZ3JvdXBSYW5nZVsxXSA6IG5vZGUucmlnaHQucmFuZ2VbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJhbmdlID0gW3N0YXJ0LCBlbmRdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlLnJhbmdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBub2RlLmxlZnQucmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBub2RlLnJpZ2h0LnJhbmdlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yYW5nZSA9IFtzdGFydCwgZW5kXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnQuZ3JvdXBMb2MgfHwgbm9kZS5yaWdodC5ncm91cExvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBub2RlLmxlZnQuZ3JvdXBMb2MgPyBub2RlLmxlZnQuZ3JvdXBMb2Muc3RhcnQgOiBub2RlLmxlZnQubG9jLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gbm9kZS5yaWdodC5ncm91cExvYyA/IG5vZGUucmlnaHQuZ3JvdXBMb2MuZW5kIDogbm9kZS5yaWdodC5sb2MuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlLmxvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubG9jID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLmxlZnQubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbm9kZS5yaWdodC5sb2MuZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrZXIsIG5vZGU7XG5cbiAgICAgICAgICAgICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgbWFya2VyID0gY3JlYXRlTG9jYXRpb25NYXJrZXIoKTtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VGdW5jdGlvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIG1hcmtlci5lbmQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChyYW5nZSAmJiB0eXBlb2Ygbm9kZS5yYW5nZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmFwcGx5KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb2MgJiYgdHlwZW9mIG5vZGUubG9jID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuYXBwbHkobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzQmluYXJ5KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0KG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXRjaCgpIHtcblxuICAgICAgICB2YXIgd3JhcFRyYWNraW5nO1xuXG4gICAgICAgIGlmIChleHRyYS5jb21tZW50cykge1xuICAgICAgICAgICAgZXh0cmEuc2tpcENvbW1lbnQgPSBza2lwQ29tbWVudDtcbiAgICAgICAgICAgIHNraXBDb21tZW50ID0gc2NhbkNvbW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEucmF3KSB7XG4gICAgICAgICAgICBleHRyYS5jcmVhdGVMaXRlcmFsID0gY3JlYXRlTGl0ZXJhbDtcbiAgICAgICAgICAgIGNyZWF0ZUxpdGVyYWwgPSBjcmVhdGVSYXdMaXRlcmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhLnJhbmdlIHx8IGV4dHJhLmxvYykge1xuXG4gICAgICAgICAgICBleHRyYS5wYXJzZUdyb3VwRXhwcmVzc2lvbiA9IHBhcnNlR3JvdXBFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsO1xuICAgICAgICAgICAgcGFyc2VHcm91cEV4cHJlc3Npb24gPSB0cmFja0dyb3VwRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9IHRyYWNrTGVmdEhhbmRTaWRlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCA9IHRyYWNrTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbDtcblxuICAgICAgICAgICAgd3JhcFRyYWNraW5nID0gd3JhcFRyYWNraW5nRnVuY3Rpb24oZXh0cmEucmFuZ2UsIGV4dHJhLmxvYyk7XG5cbiAgICAgICAgICAgIGV4dHJhLnBhcnNlQWRkaXRpdmVFeHByZXNzaW9uID0gcGFyc2VBZGRpdGl2ZUV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlQml0d2lzZUFOREV4cHJlc3Npb24gPSBwYXJzZUJpdHdpc2VBTkRFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uID0gcGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbiA9IHBhcnNlQml0d2lzZVhPUkV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUJsb2NrID0gcGFyc2VCbG9jaztcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyA9IHBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cztcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlQ2F0Y2hDbGF1c2UgPSBwYXJzZUNhdGNoQ2xhdXNlO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VDb21wdXRlZE1lbWJlciA9IHBhcnNlQ29tcHV0ZWRNZW1iZXI7XG4gICAgICAgICAgICBleHRyYS5wYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VDb25zdExldERlY2xhcmF0aW9uID0gcGFyc2VDb25zdExldERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VFcXVhbGl0eUV4cHJlc3Npb24gPSBwYXJzZUVxdWFsaXR5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlRXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbiA9IHBhcnNlRm9yVmFyaWFibGVEZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uID0gcGFyc2VGdW5jdGlvbkV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZUxvZ2ljYWxBTkRFeHByZXNzaW9uID0gcGFyc2VMb2dpY2FsQU5ERXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlTG9naWNhbE9SRXhwcmVzc2lvbiA9IHBhcnNlTG9naWNhbE9SRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uID0gcGFyc2VNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZU5ld0V4cHJlc3Npb24gPSBwYXJzZU5ld0V4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHk7XG4gICAgICAgICAgICBleHRyYS5wYXJzZU9iamVjdFByb3BlcnR5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eTtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlT2JqZWN0UHJvcGVydHlLZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5O1xuICAgICAgICAgICAgZXh0cmEucGFyc2VQb3N0Zml4RXhwcmVzc2lvbiA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZVByaW1hcnlFeHByZXNzaW9uID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlUHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbTtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlUHJvcGVydHlGdW5jdGlvbiA9IHBhcnNlUHJvcGVydHlGdW5jdGlvbjtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb24gPSBwYXJzZVJlbGF0aW9uYWxFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VTdGF0ZW1lbnQgPSBwYXJzZVN0YXRlbWVudDtcbiAgICAgICAgICAgIGV4dHJhLnBhcnNlU2hpZnRFeHByZXNzaW9uID0gcGFyc2VTaGlmdEV4cHJlc3Npb247XG4gICAgICAgICAgICBleHRyYS5wYXJzZVN3aXRjaENhc2UgPSBwYXJzZVN3aXRjaENhc2U7XG4gICAgICAgICAgICBleHRyYS5wYXJzZVVuYXJ5RXhwcmVzc2lvbiA9IHBhcnNlVW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uID0gcGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uO1xuICAgICAgICAgICAgZXh0cmEucGFyc2VWYXJpYWJsZUlkZW50aWZpZXIgPSBwYXJzZVZhcmlhYmxlSWRlbnRpZmllcjtcblxuICAgICAgICAgICAgcGFyc2VBZGRpdGl2ZUV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VBZGRpdGl2ZUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlQml0d2lzZUFOREV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VCaXR3aXNlQU5ERXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUJpdHdpc2VPUkV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VCaXR3aXNlT1JFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlQml0d2lzZVhPUkV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VCaXR3aXNlWE9SRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUJsb2NrID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlQmxvY2spO1xuICAgICAgICAgICAgcGFyc2VGdW5jdGlvblNvdXJjZUVsZW1lbnRzID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlRnVuY3Rpb25Tb3VyY2VFbGVtZW50cyk7XG4gICAgICAgICAgICBwYXJzZUNhdGNoQ2xhdXNlID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlQ2F0Y2hDbGF1c2UpO1xuICAgICAgICAgICAgcGFyc2VDb21wdXRlZE1lbWJlciA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUNvbXB1dGVkTWVtYmVyKTtcbiAgICAgICAgICAgIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlQ29uc3RMZXREZWNsYXJhdGlvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUNvbnN0TGV0RGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgcGFyc2VFcXVhbGl0eUV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VFcXVhbGl0eUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUZvclZhcmlhYmxlRGVjbGFyYXRpb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VGb3JWYXJpYWJsZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgIHBhcnNlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgcGFyc2VGdW5jdGlvbkV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VGdW5jdGlvbkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZUxvZ2ljYWxBTkRFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlTG9naWNhbEFOREV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlTG9naWNhbE9SRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZU5ld0V4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VOZXdFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkpO1xuICAgICAgICAgICAgcGFyc2VPYmplY3RQcm9wZXJ0eSA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZU9iamVjdFByb3BlcnR5KTtcbiAgICAgICAgICAgIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VPYmplY3RQcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICBwYXJzZVBvc3RmaXhFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlUG9zdGZpeEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VQcmltYXJ5RXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZVByaW1hcnlFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHBhcnNlUHJvZ3JhbSA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZVByb2dyYW0pO1xuICAgICAgICAgICAgcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlUHJvcGVydHlGdW5jdGlvbik7XG4gICAgICAgICAgICBwYXJzZVJlbGF0aW9uYWxFeHByZXNzaW9uID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VTdGF0ZW1lbnQgPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VTdGF0ZW1lbnQpO1xuICAgICAgICAgICAgcGFyc2VTaGlmdEV4cHJlc3Npb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VTaGlmdEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcGFyc2VTd2l0Y2hDYXNlID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlU3dpdGNoQ2FzZSk7XG4gICAgICAgICAgICBwYXJzZVVuYXJ5RXhwcmVzc2lvbiA9IHdyYXBUcmFja2luZyhleHRyYS5wYXJzZVVuYXJ5RXhwcmVzc2lvbik7XG4gICAgICAgICAgICBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24gPSB3cmFwVHJhY2tpbmcoZXh0cmEucGFyc2VWYXJpYWJsZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICAgIHBhcnNlVmFyaWFibGVJZGVudGlmaWVyID0gd3JhcFRyYWNraW5nKGV4dHJhLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZXh0cmEuYWR2YW5jZSA9IGFkdmFuY2U7XG4gICAgICAgICAgICBleHRyYS5zY2FuUmVnRXhwID0gc2NhblJlZ0V4cDtcblxuICAgICAgICAgICAgYWR2YW5jZSA9IGNvbGxlY3RUb2tlbjtcbiAgICAgICAgICAgIHNjYW5SZWdFeHAgPSBjb2xsZWN0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnBhdGNoKCkge1xuICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnNraXBDb21tZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBza2lwQ29tbWVudCA9IGV4dHJhLnNraXBDb21tZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhLnJhdykge1xuICAgICAgICAgICAgY3JlYXRlTGl0ZXJhbCA9IGV4dHJhLmNyZWF0ZUxpdGVyYWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEucmFuZ2UgfHwgZXh0cmEubG9jKSB7XG4gICAgICAgICAgICBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlQWRkaXRpdmVFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUJpdHdpc2VBTkRFeHByZXNzaW9uID0gZXh0cmEucGFyc2VCaXR3aXNlQU5ERXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlQml0d2lzZU9SRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlQml0d2lzZU9SRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlQml0d2lzZVhPUkV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUJpdHdpc2VYT1JFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VCbG9jayA9IGV4dHJhLnBhcnNlQmxvY2s7XG4gICAgICAgICAgICBwYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHMgPSBleHRyYS5wYXJzZUZ1bmN0aW9uU291cmNlRWxlbWVudHM7XG4gICAgICAgICAgICBwYXJzZUNhdGNoQ2xhdXNlID0gZXh0cmEucGFyc2VDYXRjaENsYXVzZTtcbiAgICAgICAgICAgIHBhcnNlQ29tcHV0ZWRNZW1iZXIgPSBleHRyYS5wYXJzZUNvbXB1dGVkTWVtYmVyO1xuICAgICAgICAgICAgcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlQ29uc3RMZXREZWNsYXJhdGlvbiA9IGV4dHJhLnBhcnNlQ29uc3RMZXREZWNsYXJhdGlvbjtcbiAgICAgICAgICAgIHBhcnNlRXF1YWxpdHlFeHByZXNzaW9uID0gZXh0cmEucGFyc2VFcXVhbGl0eUV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZUZvclZhcmlhYmxlRGVjbGFyYXRpb24gPSBleHRyYS5wYXJzZUZvclZhcmlhYmxlRGVjbGFyYXRpb247XG4gICAgICAgICAgICBwYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSBleHRyYS5wYXJzZUZ1bmN0aW9uRGVjbGFyYXRpb247XG4gICAgICAgICAgICBwYXJzZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VHcm91cEV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUdyb3VwRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCA9IGV4dHJhLnBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbDtcbiAgICAgICAgICAgIHBhcnNlTG9naWNhbEFOREV4cHJlc3Npb24gPSBleHRyYS5wYXJzZUxvZ2ljYWxBTkRFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uID0gZXh0cmEucGFyc2VMb2dpY2FsT1JFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24gPSBleHRyYS5wYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlTmV3RXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlTmV3RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSA9IGV4dHJhLnBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eTtcbiAgICAgICAgICAgIHBhcnNlT2JqZWN0UHJvcGVydHkgPSBleHRyYS5wYXJzZU9iamVjdFByb3BlcnR5O1xuICAgICAgICAgICAgcGFyc2VPYmplY3RQcm9wZXJ0eUtleSA9IGV4dHJhLnBhcnNlT2JqZWN0UHJvcGVydHlLZXk7XG4gICAgICAgICAgICBwYXJzZVByaW1hcnlFeHByZXNzaW9uID0gZXh0cmEucGFyc2VQcmltYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24gPSBleHRyYS5wYXJzZVBvc3RmaXhFeHByZXNzaW9uO1xuICAgICAgICAgICAgcGFyc2VQcm9ncmFtID0gZXh0cmEucGFyc2VQcm9ncmFtO1xuICAgICAgICAgICAgcGFyc2VQcm9wZXJ0eUZ1bmN0aW9uID0gZXh0cmEucGFyc2VQcm9wZXJ0eUZ1bmN0aW9uO1xuICAgICAgICAgICAgcGFyc2VSZWxhdGlvbmFsRXhwcmVzc2lvbiA9IGV4dHJhLnBhcnNlUmVsYXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZVN0YXRlbWVudCA9IGV4dHJhLnBhcnNlU3RhdGVtZW50O1xuICAgICAgICAgICAgcGFyc2VTaGlmdEV4cHJlc3Npb24gPSBleHRyYS5wYXJzZVNoaWZ0RXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHBhcnNlU3dpdGNoQ2FzZSA9IGV4dHJhLnBhcnNlU3dpdGNoQ2FzZTtcbiAgICAgICAgICAgIHBhcnNlVW5hcnlFeHByZXNzaW9uID0gZXh0cmEucGFyc2VVbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgICBwYXJzZVZhcmlhYmxlRGVjbGFyYXRpb24gPSBleHRyYS5wYXJzZVZhcmlhYmxlRGVjbGFyYXRpb247XG4gICAgICAgICAgICBwYXJzZVZhcmlhYmxlSWRlbnRpZmllciA9IGV4dHJhLnBhcnNlVmFyaWFibGVJZGVudGlmaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5zY2FuUmVnRXhwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhZHZhbmNlID0gZXh0cmEuYWR2YW5jZTtcbiAgICAgICAgICAgIHNjYW5SZWdFeHAgPSBleHRyYS5zY2FuUmVnRXhwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0sIHRvU3RyaW5nO1xuXG4gICAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG4gICAgICAgICAgICBleHRyYS5yYXcgPSAodHlwZW9mIG9wdGlvbnMucmF3ID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmF3O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRva2VucyA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGV4dHJhLmNvbW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRvbGVyYW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbMF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IGZpcnN0IHRvIGNvbnZlcnQgdG8gYSBzdHJpbmcuIFRoaXMgaXMgZ29vZCBhcyBmYXN0IHBhdGhcbiAgICAgICAgICAgICAgICAvLyBmb3Igb2xkIElFIHdoaWNoIHVuZGVyc3RhbmRzIHN0cmluZyBpbmRleGluZyBmb3Igc3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMgb25seSBhbmQgbm90IGZvciBzdHJpbmcgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGlmIChjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IGNvZGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGFjY2Vzc2luZyB0aGUgY2hhcmFjdGVycyB2aWEgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbMF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHN0cmluZ1RvQXJyYXkoY29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcGF0Y2goKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb2dyYW0gPSBwYXJzZVByb2dyYW0oKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuY29tbWVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyQ29tbWVudExvY2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5jb21tZW50cyA9IGV4dHJhLmNvbW1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgICAgICAgIHByb2dyYW0udG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UgfHwgZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3JhbS5ib2R5ID0gZmlsdGVyR3JvdXAocHJvZ3JhbS5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHVucGF0Y2goKTtcbiAgICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG5cbiAgICAvLyBTeW5jIHdpdGggcGFja2FnZS5qc29uLlxuICAgIGV4cG9ydHMudmVyc2lvbiA9ICcxLjAuMic7XG5cbiAgICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG5cbiAgICAvLyBEZWVwIGNvcHkuXG4gICAgZXhwb3J0cy5TeW50YXggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZSwgdHlwZXMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHR5cGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobmFtZSBpbiBTeW50YXgpIHtcbiAgICAgICAgICAgIGlmIChTeW50YXguaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0eXBlc1tuYW1lXSA9IFN5bnRheFtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmZyZWV6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0eXBlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgfSgpKTtcblxufSkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiIsIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKmpzbGludCB2YXJzOmZhbHNlLCBiaXR3aXNlOnRydWUqL1xuLypqc2hpbnQgaW5kZW50OjQqL1xuLypnbG9iYWwgZXhwb3J0czp0cnVlLCBkZWZpbmU6dHJ1ZSovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsXG4gICAgLy8gYW5kIHBsYWluIGJyb3dzZXIgbG9hZGluZyxcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5KChyb290LmVzdHJhdmVyc2UgPSB7fSkpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgU3ludGF4LFxuICAgICAgICBpc0FycmF5LFxuICAgICAgICBWaXNpdG9yT3B0aW9uLFxuICAgICAgICBWaXNpdG9yS2V5cyxcbiAgICAgICAgQlJFQUssXG4gICAgICAgIFNLSVA7XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6ICdCbG9ja1N0YXRlbWVudCcsXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6ICdCcmVha1N0YXRlbWVudCcsXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgICBDYXRjaENsYXVzZTogJ0NhdGNoQ2xhdXNlJyxcbiAgICAgICAgQ2xhc3NCb2R5OiAnQ2xhc3NCb2R5JyxcbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogJ0NsYXNzRGVjbGFyYXRpb24nLFxuICAgICAgICBDbGFzc0V4cHJlc3Npb246ICdDbGFzc0V4cHJlc3Npb24nLFxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogJ0RpcmVjdGl2ZVN0YXRlbWVudCcsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246ICdGdW5jdGlvbkRlY2xhcmF0aW9uJyxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiAnRnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcbiAgICAgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiAnTGFiZWxlZFN0YXRlbWVudCcsXG4gICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICAgIE1ldGhvZERlZmluaXRpb246ICdNZXRob2REZWZpbml0aW9uJyxcbiAgICAgICAgTmV3RXhwcmVzc2lvbjogJ05ld0V4cHJlc3Npb24nLFxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICAgIFByb2dyYW06ICdQcm9ncmFtJyxcbiAgICAgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXG4gICAgICAgIFJldHVyblN0YXRlbWVudDogJ1JldHVyblN0YXRlbWVudCcsXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogJ1NlcXVlbmNlRXhwcmVzc2lvbicsXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogJ1N3aXRjaFN0YXRlbWVudCcsXG4gICAgICAgIFN3aXRjaENhc2U6ICdTd2l0Y2hDYXNlJyxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246ICdUaGlzRXhwcmVzc2lvbicsXG4gICAgICAgIFRocm93U3RhdGVtZW50OiAnVGhyb3dTdGF0ZW1lbnQnLFxuICAgICAgICBUcnlTdGF0ZW1lbnQ6ICdUcnlTdGF0ZW1lbnQnLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246ICdWYXJpYWJsZURlY2xhcmF0aW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiAnVmFyaWFibGVEZWNsYXJhdG9yJyxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6ICdXaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6ICdXaXRoU3RhdGVtZW50JyxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiAnWWllbGRFeHByZXNzaW9uJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpZ25vcmVKU0hpbnRFcnJvcigpIHsgfVxuXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICAgICAgdmFyIHJldCA9IHt9LCBrZXksIHZhbDtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZGVlcENvcHkodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFsbG93Q29weShvYmopIHtcbiAgICAgICAgdmFyIHJldCA9IHt9LCBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpZ25vcmVKU0hpbnRFcnJvcihzaGFsbG93Q29weSk7XG5cbiAgICAvLyBiYXNlZCBvbiBMTFZNIGxpYmMrKyB1cHBlcl9ib3VuZCAvIGxvd2VyX2JvdW5kXG4gICAgLy8gTUlUIExpY2Vuc2VcblxuICAgIGZ1bmN0aW9uIHVwcGVyQm91bmQoYXJyYXksIGZ1bmMpIHtcbiAgICAgICAgdmFyIGRpZmYsIGxlbiwgaSwgY3VycmVudDtcblxuICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgIGRpZmYgPSBsZW4gPj4+IDE7XG4gICAgICAgICAgICBjdXJyZW50ID0gaSArIGRpZmY7XG4gICAgICAgICAgICBpZiAoZnVuYyhhcnJheVtjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBkaWZmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgbGVuIC09IGRpZmYgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvd2VyQm91bmQoYXJyYXksIGZ1bmMpIHtcbiAgICAgICAgdmFyIGRpZmYsIGxlbiwgaSwgY3VycmVudDtcblxuICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgIGRpZmYgPSBsZW4gPj4+IDE7XG4gICAgICAgICAgICBjdXJyZW50ID0gaSArIGRpZmY7XG4gICAgICAgICAgICBpZiAoZnVuYyhhcnJheVtjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgbGVuIC09IGRpZmYgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBpZ25vcmVKU0hpbnRFcnJvcihsb3dlckJvdW5kKTtcblxuICAgIFZpc2l0b3JLZXlzID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogWydlbGVtZW50cyddLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogWydwYXJhbXMnLCAnYm9keSddLFxuICAgICAgICBCbG9ja1N0YXRlbWVudDogWydib2R5J10sXG4gICAgICAgIEJpbmFyeUV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogWydjYWxsZWUnLCAnYXJndW1lbnRzJ10sXG4gICAgICAgIENhdGNoQ2xhdXNlOiBbJ3BhcmFtJywgJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NCb2R5OiBbJ2JvZHknXSxcbiAgICAgICAgQ2xhc3NEZWNsYXJhdGlvbjogWydpZCcsICdib2R5JywgJ3N1cGVyQ2xhc3MnXSxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiBbJ2lkJywgJ2JvZHknLCAnc3VwZXJDbGFzcyddLFxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IFsndGVzdCcsICdjb25zZXF1ZW50JywgJ2FsdGVybmF0ZSddLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogW10sXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogW10sXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6IFsnYm9keScsICd0ZXN0J10sXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiBbXSxcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogWydleHByZXNzaW9uJ10sXG4gICAgICAgIEZvclN0YXRlbWVudDogWydpbml0JywgJ3Rlc3QnLCAndXBkYXRlJywgJ2JvZHknXSxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6IFsnbGVmdCcsICdyaWdodCcsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IFsnaWQnLCAncGFyYW1zJywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiBbJ2lkJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIElkZW50aWZpZXI6IFtdLFxuICAgICAgICBJZlN0YXRlbWVudDogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgICAgIExpdGVyYWw6IFtdLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBbJ2xhYmVsJywgJ2JvZHknXSxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBbJ29iamVjdCcsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiBbJ2NhbGxlZScsICdhcmd1bWVudHMnXSxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIFByb2dyYW06IFsnYm9keSddLFxuICAgICAgICBQcm9wZXJ0eTogWydrZXknLCAndmFsdWUnXSxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogWydleHByZXNzaW9ucyddLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6IFsnZGlzY3JpbWluYW50JywgJ2Nhc2VzJ10sXG4gICAgICAgIFN3aXRjaENhc2U6IFsndGVzdCcsICdjb25zZXF1ZW50J10sXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiBbXSxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiBbJ2Jsb2NrJywgJ2hhbmRsZXJzJywgJ2hhbmRsZXInLCAnZ3VhcmRlZEhhbmRsZXJzJywgJ2ZpbmFsaXplciddLFxuICAgICAgICBVbmFyeUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogWydhcmd1bWVudCddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9ucyddLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IFsnaWQnLCAnaW5pdCddLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogWyd0ZXN0JywgJ2JvZHknXSxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogWydvYmplY3QnLCAnYm9keSddLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246IFsnYXJndW1lbnQnXVxuICAgIH07XG5cbiAgICAvLyB1bmlxdWUgaWRcbiAgICBCUkVBSyA9IHt9O1xuICAgIFNLSVAgPSB7fTtcblxuICAgIFZpc2l0b3JPcHRpb24gPSB7XG4gICAgICAgIEJyZWFrOiBCUkVBSyxcbiAgICAgICAgU2tpcDogU0tJUFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBSZWZlcmVuY2UocGFyZW50LCBrZXkpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cblxuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uobm9kZSkge1xuICAgICAgICB0aGlzLnBhcmVudFt0aGlzLmtleV0gPSBub2RlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBFbGVtZW50KG5vZGUsIHBhdGgsIHdyYXAsIHJlZikge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLndyYXAgPSB3cmFwO1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb250cm9sbGVyKCkgeyB9XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIHByb3BlcnR5IHBhdGggYXJyYXkgZnJvbSByb290IHRvIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiBwYXRoKCkge1xuICAgICAgICB2YXIgaSwgaXosIGosIGp6LCByZXN1bHQsIGVsZW1lbnQ7XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkVG9QYXRoKHJlc3VsdCwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqeiA9IHBhdGgubGVuZ3RoOyBqIDwgano7ICsraikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm9vdCBub2RlXG4gICAgICAgIGlmICghdGhpcy5fX2N1cnJlbnQucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCBub2RlIGlzIHNlbnRpbmVsLCBzZWNvbmQgbm9kZSBpcyByb290IGVsZW1lbnRcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDIsIGl6ID0gdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5fX2xlYXZlbGlzdFtpXTtcbiAgICAgICAgICAgIGFkZFRvUGF0aChyZXN1bHQsIGVsZW1lbnQucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkVG9QYXRoKHJlc3VsdCwgdGhpcy5fX2N1cnJlbnQucGF0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gYXJyYXkgb2YgcGFyZW50IGVsZW1lbnRzXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucGFyZW50cyA9IGZ1bmN0aW9uIHBhcmVudHMoKSB7XG4gICAgICAgIHZhciBpLCBpeiwgcmVzdWx0O1xuXG4gICAgICAgIC8vIGZpcnN0IG5vZGUgaXMgc2VudGluZWxcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDEsIGl6ID0gdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9fbGVhdmVsaXN0W2ldLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jdXJyZW50Lm5vZGU7XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLl9fZXhlY3V0ZSA9IGZ1bmN0aW9uIF9fZXhlY3V0ZShjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgICB2YXIgcHJldmlvdXMsIHJlc3VsdDtcblxuICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcHJldmlvdXMgID0gdGhpcy5fX2N1cnJlbnQ7XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjay5jYWxsKHRoaXMsIGVsZW1lbnQubm9kZSwgdGhpcy5fX2xlYXZlbGlzdFt0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aCAtIDFdLm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gcHJldmlvdXM7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIG5vdGlmeSBjb250cm9sIHNraXAgLyBicmVha1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeShmbGFnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IGZsYWc7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBza2lwIGNoaWxkIG5vZGVzIG9mIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KFNLSVApO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gYnJlYWsgdHJhdmVyc2Fsc1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlWydicmVhayddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShCUkVBSyk7XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLl9faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdGhpcy52aXNpdG9yID0gdmlzaXRvcjtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5fX3dvcmtsaXN0ID0gW107XG4gICAgICAgIHRoaXMuX19sZWF2ZWxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBudWxsO1xuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS50cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdmFyIHdvcmtsaXN0LFxuICAgICAgICAgICAgbGVhdmVsaXN0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBub2RlVHlwZSxcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjdXJyZW50MixcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgICBzZW50aW5lbDtcblxuICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZShyb290LCB2aXNpdG9yKTtcblxuICAgICAgICBzZW50aW5lbCA9IHt9O1xuXG4gICAgICAgIC8vIHJlZmVyZW5jZVxuICAgICAgICB3b3JrbGlzdCA9IHRoaXMuX193b3JrbGlzdDtcbiAgICAgICAgbGVhdmVsaXN0ID0gdGhpcy5fX2xlYXZlbGlzdDtcblxuICAgICAgICAvLyBpbml0aWFsaXplXG4gICAgICAgIHdvcmtsaXN0LnB1c2gobmV3IEVsZW1lbnQocm9vdCwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuICAgICAgICBsZWF2ZWxpc3QucHVzaChuZXcgRWxlbWVudChudWxsLCBudWxsLCBudWxsLCBudWxsKSk7XG5cbiAgICAgICAgd2hpbGUgKHdvcmtsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHdvcmtsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGVhdmVsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5sZWF2ZSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCByZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGUpIHtcblxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IuZW50ZXIsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgcmV0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd29ya2xpc3QucHVzaChzZW50aW5lbCk7XG4gICAgICAgICAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBTS0lQIHx8IHJldCA9PT0gU0tJUCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gZWxlbWVudC53cmFwIHx8IG5vZGUudHlwZTtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gVmlzaXRvcktleXNbbm9kZVR5cGVdO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudCAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGNhbmRpZGF0ZXNbY3VycmVudF07XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2gobmV3IEVsZW1lbnQoY2FuZGlkYXRlLCBrZXksIG51bGwsIG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudDIgPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQyIC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlW2N1cnJlbnQyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbiAmJiAncHJvcGVydGllcycgPT09IGNhbmRpZGF0ZXNbY3VycmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCAnUHJvcGVydHknLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KGNhbmRpZGF0ZVtjdXJyZW50Ml0sIFtrZXksIGN1cnJlbnQyXSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdmFyIHdvcmtsaXN0LFxuICAgICAgICAgICAgbGVhdmVsaXN0LFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIG5vZGVUeXBlLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjdXJyZW50MixcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBjYW5kaWRhdGUsXG4gICAgICAgICAgICBzZW50aW5lbCxcbiAgICAgICAgICAgIG91dGVyLFxuICAgICAgICAgICAga2V5O1xuXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplKHJvb3QsIHZpc2l0b3IpO1xuXG4gICAgICAgIHNlbnRpbmVsID0ge307XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICAgIHdvcmtsaXN0ID0gdGhpcy5fX3dvcmtsaXN0O1xuICAgICAgICBsZWF2ZWxpc3QgPSB0aGlzLl9fbGVhdmVsaXN0O1xuXG4gICAgICAgIC8vIGluaXRpYWxpemVcbiAgICAgICAgb3V0ZXIgPSB7XG4gICAgICAgICAgICByb290OiByb290XG4gICAgICAgIH07XG4gICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChyb290LCBudWxsLCBudWxsLCBuZXcgUmVmZXJlbmNlKG91dGVyLCAncm9vdCcpKTtcbiAgICAgICAgd29ya2xpc3QucHVzaChlbGVtZW50KTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgd2hpbGUgKHdvcmtsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHdvcmtsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gbGVhdmVsaXN0LnBvcCgpO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5sZWF2ZSwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBub2RlIG1heSBiZSByZXBsYWNlZCB3aXRoIG51bGwsXG4gICAgICAgICAgICAgICAgLy8gc28gZGlzdGluZ3Vpc2ggYmV0d2VlbiB1bmRlZmluZWQgYW5kIG51bGwgaW4gdGhpcyBwbGFjZVxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVmLnJlcGxhY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCB0YXJnZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5fX2V4ZWN1dGUodmlzaXRvci5lbnRlciwgZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIHJlcGxhY2VkIHdpdGggbnVsbCxcbiAgICAgICAgICAgIC8vIHNvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdW5kZWZpbmVkIGFuZCBudWxsIGluIHRoaXMgcGxhY2VcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IEJSRUFLICYmIHRhcmdldCAhPT0gU0tJUCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlZi5yZXBsYWNlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ub2RlID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3N0YXRlID09PSBCUkVBSyB8fCB0YXJnZXQgPT09IEJSRUFLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyLnJvb3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIG51bGxcbiAgICAgICAgICAgIG5vZGUgPSBlbGVtZW50Lm5vZGU7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd29ya2xpc3QucHVzaChzZW50aW5lbCk7XG4gICAgICAgICAgICBsZWF2ZWxpc3QucHVzaChlbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCB0YXJnZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZVR5cGUgPSBlbGVtZW50LndyYXAgfHwgbm9kZS50eXBlO1xuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IFZpc2l0b3JLZXlzW25vZGVUeXBlXTtcblxuICAgICAgICAgICAgY3VycmVudCA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50IC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGVzW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KGNhbmRpZGF0ZSwga2V5LCBudWxsLCBuZXcgUmVmZXJlbmNlKG5vZGUsIGtleSkpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudDIgPSBjYW5kaWRhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudDIgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb24gJiYgJ3Byb3BlcnRpZXMnID09PSBjYW5kaWRhdGVzW2N1cnJlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCAnUHJvcGVydHknLCBuZXcgUmVmZXJlbmNlKGNhbmRpZGF0ZSwgY3VycmVudDIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sIG51bGwsIG5ldyBSZWZlcmVuY2UoY2FuZGlkYXRlLCBjdXJyZW50MikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dGVyLnJvb3Q7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRyYXZlcnNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcigpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci50cmF2ZXJzZShyb290LCB2aXNpdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlcigpO1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5yZXBsYWNlKHJvb3QsIHZpc2l0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZENvbW1lbnRSYW5nZShjb21tZW50LCB0b2tlbnMpIHtcbiAgICAgICAgdmFyIHRhcmdldDtcblxuICAgICAgICB0YXJnZXQgPSB1cHBlckJvdW5kKHRva2VucywgZnVuY3Rpb24gc2VhcmNoKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ucmFuZ2VbMF0gPiBjb21tZW50LnJhbmdlWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2UgPSBbY29tbWVudC5yYW5nZVswXSwgY29tbWVudC5yYW5nZVsxXV07XG5cbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID0gdG9rZW5zW3RhcmdldF0ucmFuZ2VbMF07XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgLT0gMTtcbiAgICAgICAgaWYgKHRhcmdldCA+PSAwKSB7XG4gICAgICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMF0gPSB0b2tlbnNbdGFyZ2V0XS5yYW5nZVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0dGFjaENvbW1lbnRzKHRyZWUsIHByb3ZpZGVkQ29tbWVudHMsIHRva2Vucykge1xuICAgICAgICAvLyBBdCBmaXJzdCwgd2Ugc2hvdWxkIGNhbGN1bGF0ZSBleHRlbmRlZCBjb21tZW50IHJhbmdlcy5cbiAgICAgICAgdmFyIGNvbW1lbnRzID0gW10sIGNvbW1lbnQsIGxlbiwgaSwgY3Vyc29yO1xuXG4gICAgICAgIGlmICghdHJlZS5yYW5nZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRhY2hDb21tZW50cyBuZWVkcyByYW5nZSBpbmZvcm1hdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9rZW5zIGFycmF5IGlzIGVtcHR5LCB3ZSBhdHRhY2ggY29tbWVudHMgdG8gdHJlZSBhcyAnbGVhZGluZ0NvbW1lbnRzJ1xuICAgICAgICBpZiAoIXRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChwcm92aWRlZENvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb3ZpZGVkQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGRlZXBDb3B5KHByb3ZpZGVkQ29tbWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2UgPSBbMCwgdHJlZS5yYW5nZVswXV07XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyZWUubGVhZGluZ0NvbW1lbnRzID0gY29tbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb3ZpZGVkQ29tbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goZXh0ZW5kQ29tbWVudFJhbmdlKGRlZXBDb3B5KHByb3ZpZGVkQ29tbWVudHNbaV0pLCB0b2tlbnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgYmFzZWQgb24gSm9obiBGcmVlbWFuJ3MgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIGN1cnNvciA9IDA7XG4gICAgICAgIHRyYXZlcnNlKHRyZWUsIHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb21tZW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvciA8IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY29tbWVudHNbY3Vyc29yXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVsxXSA+IG5vZGUucmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVsxXSA9PT0gbm9kZS5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxlYWRpbmdDb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMuc3BsaWNlKGN1cnNvciwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgb3V0IG9mIG93bmVkIG5vZGVcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yID09PSBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uQnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2N1cnNvcl0uZXh0ZW5kZWRSYW5nZVswXSA+IG5vZGUucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uU2tpcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN1cnNvciA9IDA7XG4gICAgICAgIHRyYXZlcnNlKHRyZWUsIHtcbiAgICAgICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb21tZW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvciA8IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY29tbWVudHNbY3Vyc29yXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucmFuZ2VbMV0gPCBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucmFuZ2VbMV0gPT09IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnRyYWlsaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudHMuc3BsaWNlKGN1cnNvciwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgb3V0IG9mIG93bmVkIG5vZGVcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yID09PSBjb21tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uQnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRzW2N1cnNvcl0uZXh0ZW5kZWRSYW5nZVswXSA+IG5vZGUucmFuZ2VbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uU2tpcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cblxuICAgIGV4cG9ydHMudmVyc2lvbiA9ICcxLjMuMic7XG4gICAgZXhwb3J0cy5TeW50YXggPSBTeW50YXg7XG4gICAgZXhwb3J0cy50cmF2ZXJzZSA9IHRyYXZlcnNlO1xuICAgIGV4cG9ydHMucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgZXhwb3J0cy5hdHRhY2hDb21tZW50cyA9IGF0dGFjaENvbW1lbnRzO1xuICAgIGV4cG9ydHMuVmlzaXRvcktleXMgPSBWaXNpdG9yS2V5cztcbiAgICBleHBvcnRzLlZpc2l0b3JPcHRpb24gPSBWaXNpdG9yT3B0aW9uO1xuICAgIGV4cG9ydHMuQ29udHJvbGxlciA9IENvbnRyb2xsZXI7XG59KSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIiwiLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHdoZW4gdXNlZCBpbiBub2RlLCB0aGlzIHdpbGwgYWN0dWFsbHkgbG9hZCB0aGUgdXRpbCBtb2R1bGUgd2UgZGVwZW5kIG9uXG4vLyB2ZXJzdXMgbG9hZGluZyB0aGUgYnVpbHRpbiB1dGlsIG1vZHVsZSBhcyBoYXBwZW5zIG90aGVyd2lzZVxuLy8gdGhpcyBpcyBhIGJ1ZyBpbiBub2RlIG1vZHVsZSBsb2FkaW5nIGFzIGZhciBhcyBJIGFtIGNvbmNlcm5lZFxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuXG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IHN0YWNrU3RhcnRGdW5jdGlvbi5uYW1lO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodXRpbC5pc051bWJlcih2YWx1ZSkgJiYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmICh1dGlsLmlzRnVuY3Rpb24odmFsdWUpIHx8IHV0aWwuaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHMpKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5hY3R1YWwsIHJlcGxhY2VyKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihhY3R1YWwpICYmIHV0aWwuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNPYmplY3QoYWN0dWFsKSAmJiAhdXRpbC5pc09iamVjdChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYSkgfHwgdXRpbC5pc051bGxPclVuZGVmaW5lZChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGV4cGVjdGVkKSkge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gd2Fsa2VyO1xuXG5mdW5jdGlvbiB3YWxrZXIoYXN0Tm9kZSwgZnVuY3Rpb25UYWJsZSwgb2Zmc2V0KSB7XG5cdGZ1bmN0aW9uIHN0b3AoKSB7IHRocm93IHN0b3A7IH1cblx0dmFyIHJlY3Vyc2UgPSBmdW5jdGlvbiAoYXN0Tm9kZSkge1xuXHRcdGlmICghYXN0Tm9kZSB8fCB0eXBlb2YgYXN0Tm9kZSAhPT0gJ29iamVjdCcgfHwgIWFzdE5vZGUudHlwZSlcblx0XHRcdHJldHVybiBhc3ROb2RlO1xuXHRcdC8vIHJhbmdlIGJhc2VkIHJlY3Vyc2lvbjogb25seSByZWN1cnNlIHdoZW4gdGhlIGFzdE5vZGUgaXMgaW4gcmFuZ2Vcblx0XHRpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgYXN0Tm9kZS5yYW5nZSAmJlxuXHRcdCAgICAoYXN0Tm9kZS5yYW5nZVswXSA+IG9mZnNldCB8fCBhc3ROb2RlLnJhbmdlWzFdIDwgb2Zmc2V0KSlcblx0XHRcdHJldHVybiBhc3ROb2RlO1xuXHRcdFxuXHRcdHZhciBmbiA9IGZ1bmN0aW9uVGFibGVbYXN0Tm9kZS50eXBlXSB8fCBmdW5jdGlvblRhYmxlLmRlZmF1bHQgfHwgY2hlY2tQcm9wcztcblx0XHRyZXR1cm4gZm4uY2FsbChhc3ROb2RlLCByZWN1cnNlLCBzdG9wKTtcblx0fVxuXHR2YXIgcmV0O1xuXHR0cnkge1xuXHRcdHJldCA9IHJlY3Vyc2UoYXN0Tm9kZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoZSAhPT0gc3RvcClcblx0XHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wcyhyZWN1cnNlKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIG1hcHBlZCA9IHt9O1xuXHRPYmplY3Qua2V5cyhzZWxmKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgcHJvcCA9IHNlbGZba2V5XTtcblx0XHR2YXIgcmV0ID0gcHJvcDtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShwcm9wKSlcblx0XHRcdHJldCA9IHByb3AubWFwKHJlY3Vyc2UpO1xuXHRcdGVsc2Vcblx0XHRcdHJldCA9IHJlY3Vyc2UocHJvcCk7XG5cdFx0bWFwcGVkW2tleV0gPSByZXQ7XG5cdH0pO1xuXHRyZXR1cm4gbWFwcGVkO1xufVxuXG53YWxrZXIuY2hlY2tQcm9wcyA9IGNoZWNrUHJvcHM7XG4iLCIoZnVuY3Rpb24obW9kdWxlKXtcclxuXHJcbiAgICAvLyBEZXBlbmRlbmNpZXNcclxuICAgIHZhciBDb250ZXh0ID0gcmVxdWlyZShcIi4uL2Jhc2UvY29udGV4dC5qc1wiKTtcclxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vYmFzZS9jb21tb24uanNcIik7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlL2luZGV4LmpzXCIpO1xyXG4gICAgdmFyIEFubm90YXRpb25zID0gcmVxdWlyZShcIi4vLi4vYmFzZS9hbm5vdGF0aW9uLmpzXCIpO1xyXG4gICAgdmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xyXG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XHJcbiAgICB2YXIgSW5mZXJlbmNlU2NvcGUgPSByZXF1aXJlKFwiLi90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L1wiKS5JbmZlcmVuY2VTY29wZTtcclxuICAgIHZhciBTeXN0ZW0gPSByZXF1aXJlKFwiLi90eXBlaW5mZXJlbmNlL3JlZ2lzdHJ5L3N5c3RlbS5qc1wiKTtcclxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2VzLmpzXCIpO1xyXG4gICAgICAgIHZhciBjb2RlZ2VuID0gcmVxdWlyZShcImVzY29kZWdlblwiKTtcclxuXHJcblxyXG4gICAgLy8gU2hvcnRjdXRzXHJcbiAgICB2YXIgTWFwID0gY29tbW9uLk1hcCxcclxuICAgICAgICBTeW50YXggPSBjb21tb24uU3ludGF4LFxyXG4gICAgICAgIEZ1bmN0aW9uQW5ub3RhdGlvbiA9IEFubm90YXRpb25zLkZ1bmN0aW9uQW5ub3RhdGlvbixcclxuICAgICAgICBBTk5PID0gQW5ub3RhdGlvbnMuQU5OTztcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHByb2dyYW1cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGFuYWx5c2lzXHJcbiAgICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcclxuICAgICAqIEBleHRlbmRzIHtDb250ZXh0fVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBBbmFseXNpc0NvbnRleHQgPSBmdW5jdGlvbihwcm9ncmFtLCBhbmFseXNpcywgb3B0aW9ucykge1xyXG4gICAgICAgIENvbnRleHQuY2FsbCh0aGlzLCBwcm9ncmFtLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHByb2dyYW0udHlwZSwgU3ludGF4LlByb2dyYW0pO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsYmFjayB0aGF0IGNvbnRpbnVlcyBhbmFseXNpcyBpbiB0aGUgc2FtZSBjb250ZXh0XHJcbiAgICAgICAgICogQHNlZSB7QW5hbHlzaXNDb250ZXh0LmFuYWx5emV9XHJcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYW5hbHlzaXMgPSBhbmFseXNpcztcclxuXHJcbiAgICAgICAgdGhpcy5yb290Lmdsb2JhbFBhcmFtZXRlcnMgPSB7fTtcclxuXHJcblxyXG4gICAgICAgIHZhciBzY29wZSA9IGNyZWF0ZUdsb2JhbFNjb3BlKHByb2dyYW0pO1xyXG4gICAgICAgIHJlZ2lzdGVyU3lzdGVtSW5mb3JtYXRpb24oc2NvcGUsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMucHVzaFNjb3BlKHNjb3BlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFwIG9mIChnbG9iYWwpIGZ1bmN0aW9uIG5hbWUgdG8gdW50eXBlZCBmdW5jdGlvbnMgdGhhdFxyXG4gICAgICAgICAqIHNlcnZlIGFzIGEgdGVtcGxhdGUgZm9yIGNhbGxzIHRoYXQgbWlnaHQgY29tZSB3aXRoXHJcbiAgICAgICAgICogZGlmZmVyZW50IHNpZ25hdHVyZXNcclxuICAgICAgICAgKiBAdHlwZSB7TWFwfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnVuY3Rpb25NYXAgPSBleHRyYWN0QWxsRnVuY3Rpb25zKHByb2dyYW0sIHRoaXMpO1xyXG5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FjaGUgb2YgZnVuY3Rpb25zIHRoYXQgdHlwZXMgaGFzIGFscmVhZHkgYmVlbiBkZXJpdmVkLlxyXG4gICAgICAgICAqIE1hcHMgZnJvbSBzaWduYXR1cmUgdG8gYW5ub3RhdGVkIGFzdFxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZXJpdmVkRnVuY3Rpb25zID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuY29uc3RhbnRzID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgQmFzZS5jcmVhdGVDbGFzcyhBbmFseXNpc0NvbnRleHQsIENvbnRleHQsIHtcclxuICAgICAgICBhbmFseXNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHlzaXMuY2FsbCh0aGlzLCB0aGlzLnJvb3QsIHRoaXMub3B0aW9ucyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRUeXBlSW5mbzogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbi5nZXRUeXBlSW5mbyhub2RlLCB0aGlzLmdldFNjb3BlKCksIHRoaXMuY29uc3RhbnRzLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtudWxsfFNldH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRDb25zdGFudHM6IGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25zdGFudHMgPSBjO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2FsbEZ1bmN0aW9uOiBmdW5jdGlvbiAobmFtZSwgYXJncywgb3B0KSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLmNyZWF0ZVNpZ25hdHVyZUZyb21OYW1lQW5kQXJndW1lbnRzKG5hbWUsIGFyZ3MpO1xyXG4gICAgICAgICAgICB2YXIgaW5mbyA9IHRoaXMuZ2V0RnVuY3Rpb25JbmZvcm1hdGlvbkJ5U2lnbmF0dXJlKHNpZ25hdHVyZSk7XHJcbiAgICAgICAgICAgIGlmIChpbmZvKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm87XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGdW5jdGlvbkluZm9ybWF0aW9uRm9yKG5hbWUsIGFyZ3MsIG9wdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjcmVhdGVTaWduYXR1cmVGcm9tTmFtZUFuZEFyZ3VtZW50czogZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChzdHIsIGFyZykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0ciArIGFyZy5nZXRUeXBlU3RyaW5nKClcclxuICAgICAgICAgICAgfSwgbmFtZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRGdW5jdGlvbkluZm9ybWF0aW9uQnlTaWduYXR1cmU6IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVyaXZlZEZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShzaWduYXR1cmUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVyaXZlZEZ1bmN0aW9uID0gdGhpcy5kZXJpdmVkRnVuY3Rpb25zW3NpZ25hdHVyZV07XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmV1c2VcIiwgc2lnbmF0dXJlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZXJpdmVkRnVuY3Rpb24uaW5mbztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyZWF0ZUZ1bmN0aW9uSW5mb3JtYXRpb25Gb3I6IGZ1bmN0aW9uIChuYW1lLCBhcmdzLCBvcHQpIHtcclxuICAgICAgICAgICAgdmFyIGFzdCwgZGVyaXZlZCwgZ2xvYmFsTmFtZTtcclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25NYXAuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBhc3QgPSB0aGlzLmZ1bmN0aW9uTWFwLmdldChuYW1lKTtcclxuICAgICAgICAgICAgICAgIGdsb2JhbE5hbWUgPSBvcHQubmFtZSB8fCB0aGlzLmdldFNhZmVVbmlxdWVOYW1lKG5hbWUucmVwbGFjZSgvXFwuL2csICdfJykpO1xyXG4gICAgICAgICAgICAgICAgZGVyaXZlZCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZGVyaXZlZC5hc3QgPSB0aGlzLmFuYWx5c2VGdW5jdGlvbihKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFzdCkpLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGRlcml2ZWQuaW5mbyA9IGRlcml2ZWQuYXN0LmV4dHJhLnJldHVybkluZm87XHJcbiAgICAgICAgICAgICAgICBkZXJpdmVkLmluZm8ubmV3TmFtZSA9IGRlcml2ZWQuYXN0LmlkLm5hbWUgPSBnbG9iYWxOYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZXJpdmVkRnVuY3Rpb25zW3RoaXMuY3JlYXRlU2lnbmF0dXJlRnJvbU5hbWVBbmRBcmd1bWVudHMobmFtZSwgYXJncyldID0gZGVyaXZlZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZXJpdmVkLmluZm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgZnVuY3Rpb24gXCIgKyBuYW1lKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFuYWx5c2VGdW5jdGlvbjogZnVuY3Rpb24oZnVuY0RlY2wsIHBhcmFtcykge1xyXG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25TY29wZSA9IG5ldyBJbmZlcmVuY2VTY29wZShmdW5jRGVjbCwgdGhpcy5nZXRTY29wZSgpLCB7bmFtZTogZnVuY0RlY2wuaWQubmFtZSB9KTtcclxuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQW5ub3RhdGlvbiA9IG5ldyBGdW5jdGlvbkFubm90YXRpb24oZnVuY0RlY2wpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmVycm9yKFwiYW5hbHlzZUZ1bmN0aW9uOlwiLCBmdW5jdGlvblNjb3BlLnN0cigpKTtcclxuXHJcbiAgICAgICAgICAgIHNldFBhcmFtZXRlclR5cGVzKGZ1bmNEZWNsLnBhcmFtcywgcGFyYW1zKTtcclxuICAgICAgICAgICAgZnVuY3Rpb25TY29wZS5kZWNsYXJlUGFyYW1ldGVycyhmdW5jRGVjbC5wYXJhbXMpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wdXNoU2NvcGUoZnVuY3Rpb25TY29wZSk7XHJcbiAgICAgICAgICAgIGZ1bmNEZWNsLmJvZHkgPSB0aGlzLmFuYWx5c2lzLmNhbGwodGhpcywgZnVuY0RlY2wuYm9keSwgdGhpcy5vcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFubm90YXRlIEZ1bmN0aW9uIFJldHVybiB0eXBlIGZyb20gU2NvcGVcclxuICAgICAgICAgICAgZnVuY3Rpb25Bbm5vdGF0aW9uLnNldFJldHVybkluZm8oZnVuY3Rpb25TY29wZS5nZXRSZXR1cm5JbmZvKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnBvcFNjb3BlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jRGVjbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFJlc3VsdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIChSZS0pYWRkIGRlcml2ZWQgZnVuY3Rpb24gdG8gdGhlIHByb2dyYW1cclxuICAgICAgICAgICAgYWRkRGVyaXZlZE1ldGhvZHModGhpcy5yb290LCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlY2xhcmVWYXJpYWJsZXM6IGZ1bmN0aW9uIChhc3QsIGluRGVjbGFyYXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5nZXRTY29wZSgpLCBjb250ZXh0ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGFzdC50eXBlID09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gYXN0LmRlY2xhcmF0aW9ucztcclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBBTk5PKGRlY2xhcmF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLmlkLnR5cGUgIT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHluYW1pYyB2YXJpYWJsZSBuYW1lcyBhcmUgbm90IHlldCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZU5hbWUgPSBkZWNsYXJhdGlvbi5pZC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmRlY2xhcmVWYXJpYWJsZSh2YXJpYWJsZU5hbWUsIHRydWUsIHJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi5pbml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gQU5OTyhkZWNsYXJhdGlvbi5pbml0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlVHlwZUluZm8odmFyaWFibGVOYW1lLCBpbml0LCBkZWNsYXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi5pbml0LnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRlY2xhcmVWYXJpYWJsZXMoZGVjbGFyYXRpb24uaW5pdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShTaGFkZS5UWVBFUy5VTkRFRklORUQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXN0LnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIGluRGVjbGFyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IEFOTk8oYXN0LnJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYXN0LmxlZnQudHlwZSAhPSBTeW50YXguSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgdmFyaWFibGUgbmFtZXMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlTmFtZSA9IGFzdC5sZWZ0Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICBzY29wZS5kZWNsYXJlVmFyaWFibGUodmFyaWFibGVOYW1lLCB0cnVlLCBBTk5PKGFzdCkpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlVHlwZUluZm8odmFyaWFibGVOYW1lLCB0eXBlSW5mbywgYXN0KTtcclxuICAgICAgICAgICAgICAgIGlmIChhc3QucmlnaHQudHlwZSA9PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRlY2xhcmVWYXJpYWJsZXMoYXN0LnJpZ2h0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluamVjdENhbGw6IGZ1bmN0aW9uKG5hbWUsIGVudHJ5UGFyYW1zKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZ1bmN0aW9uTWFwLmhhcyhuYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgcGFyYW1ldGVyIGlzIHNldCBhcyBnbG9iYWwgX2VudiBvYmplY3QgdG8gYmUgYWNjZXNzaWJsZSBmb3JtIEJSREZzXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgYmlnIGhhY2ssIG5lZWQgYmV0dGVyIGluamVjdGlvbiBtZWNoYW5pc21cclxuICAgICAgICAgICAgICAgIHZhciBlbnZPYmplY3QgPSBlbnRyeVBhcmFtc1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChlbnZPYmplY3QgJiYgZW52T2JqZWN0LmV4dHJhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudkFubm90YXRpb24gPSBuZXcgQW5ub3RhdGlvbnMuQW5ub3RhdGlvbih7fSwgZW52T2JqZWN0LmV4dHJhKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFNjb3BlKCkudXBkYXRlVHlwZUluZm8oXCJfZW52XCIsIGVudkFubm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvdmVycmlkZU5hbWUgPSBuYW1lLnN1YnN0cihuYW1lLmluZGV4T2YoXCIuXCIpKzEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5nbG9iYWxQYXJhbWV0ZXJzW25hbWVdID0gZW50cnlQYXJhbXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxGdW5jdGlvbihuYW1lLCBlbnRyeVBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFOTk8ocGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgfSksIHsgbmFtZTogb3ZlcnJpZGVOYW1lfSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByZ1xyXG4gICAgICogQHBhcmFtIHtBbmFseXNpc0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqIEByZXR1cm5zIHtNYXB9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGV4dHJhY3RBbGxGdW5jdGlvbnMocHJnLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICAgICAgcmVzdWx0LnNldChcImdsb2JhbFwiLCBwcmcpO1xyXG5cclxuICAgICAgICB3YWxrLnJlcGxhY2UocHJnLCB7XHJcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbE5hbWUgPSBub2RlLmlkLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFNjb3BlID0gY29udGV4dC5nZXRTY29wZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbm5vID0gbmV3IEZ1bmN0aW9uQW5ub3RhdGlvbihub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTY29wZS5kZWNsYXJlVmFyaWFibGUobG9jYWxOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTY29wZS51cGRhdGVUeXBlSW5mbyhsb2NhbE5hbWUsIGFubm8pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2NvcGUgPSBuZXcgSW5mZXJlbmNlU2NvcGUobm9kZSwgcGFyZW50U2NvcGUsIHtuYW1lOiBsb2NhbE5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChuZXdTY29wZS5zdHIoKSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wdXNoU2NvcGUobmV3U2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucG9wU2NvcGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlID0geyB0eXBlOiBTeW50YXguRW1wdHlTdGF0ZW1lbnQgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJnLmJvZHkgPSBwcmcuYm9keS5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEudHlwZSAhPSBTeW50YXguRW1wdHlTdGF0ZW1lbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZERlcml2ZWRNZXRob2RzKHByb2dyYW0sIGNvbnRleHQpIHtcclxuICAgICAgICBmb3IodmFyIGZ1bmMgaW4gY29udGV4dC5kZXJpdmVkRnVuY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHByb2dyYW0uYm9keS5wdXNoKGNvbnRleHQuZGVyaXZlZEZ1bmN0aW9uc1tmdW5jXS5hc3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2Fsay50cmF2ZXJzZShwcm9ncmFtLCB7XHJcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLnR5cGUgPT0gU3ludGF4LkNhbGxFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5leHRyYSAmJiBub2RlLmV4dHJhLm5ld05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jYWxsZWUubmFtZSA9IG5vZGUuZXh0cmEubmV3TmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gcGFyYW1zXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSB0eXBlc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRQYXJhbWV0ZXJUeXBlcyhwYXJhbXMsIHR5cGVzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGZ1bmNQYXJhbSA9IEFOTk8ocGFyYW1zW2ldKTtcclxuICAgICAgICAgICAgaWYgKGkgPCB0eXBlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmNQYXJhbS5zZXRGcm9tRXh0cmEodHlwZXNbaV0uZ2V0RXh0cmEoKSk7XHJcbiAgICAgICAgICAgICAgICBmdW5jUGFyYW0uc2V0RHluYW1pY1ZhbHVlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jUGFyYW0uc2V0VHlwZShTaGFkZS5UWVBFUy5VTkRFRklORUQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUdsb2JhbFNjb3BlKGFzdCkge1xyXG4gICAgICAgIHZhciBnbG9iYWxTY29wZSA9IG5ldyBJbmZlcmVuY2VTY29wZShhc3QsIG51bGwsIHtuYW1lOiBcImdsb2JhbFwifSk7XHJcbiAgICAgICAgZ2xvYmFsU2NvcGUucmVnaXN0ZXJHbG9iYWxzKCk7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbFNjb3BlO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZWdpc3RlclN5c3RlbUluZm9ybWF0aW9uKHNjb3BlLCBvcHQpIHtcclxuICAgICAgICB2YXIgdGhpc0luZm8gPSAob3B0LmluamVjdCAmJiBvcHQuaW5qZWN0LnRoaXMpIHx8IG51bGw7XHJcbiAgICAgICAgc2NvcGUuZGVjbGFyZVZhcmlhYmxlKFwidGhpc1wiKTtcclxuICAgICAgICBzY29wZS51cGRhdGVUeXBlSW5mbyhcInRoaXNcIiwgU3lzdGVtLmdldFRoaXNUeXBlSW5mbyh0aGlzSW5mbykpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5hbHlzaXNDb250ZXh0O1xyXG5cclxuXHJcbn0obW9kdWxlKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICAvLyBEZXBlbmRlbmNpZXNcclxuICAgIHZhciBzYW5pdGl6ZXIgPSByZXF1aXJlKFwiLi9zYW5pdGl6ZXIvc2FuaXRpemVyLmpzXCIpLFxyXG4gICAgICAgIHJlc29sdmVyID0gIHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmUuanNcIiksXHJcbiAgICAgICAgc3RhdGljVHJhbnNmb3JtZXIgPSByZXF1aXJlKFwiLi9jb25zdGFudHMvc3RhdGljVHJhbnNmb3JtZXIuanNcIiksXHJcbiAgICAgICAgdW5pZm9ybUFuYWx5c2lzID0gcmVxdWlyZShcIi4vdW5pZm9ybUV4cHJlc3Npb25zL3VuaWZvcm1BbmFseXNpcy5qc1wiKSxcclxuICAgICAgICB2YWxpZGF0b3IgPSByZXF1aXJlKFwiLi92YWxpZGF0b3IuanNcIiksXHJcbiAgICAgICAgc2VtYW50aWNzID0gcmVxdWlyZShcIi4vc2VtYW50aWNzL3NlbWFudGljcy5qc1wiKSxcclxuICAgICAgICBBbmFseXNpc0NvbnRleHQgPSByZXF1aXJlKFwiLi9hbmFseXNpc2NvbnRleHQuanNcIiksXHJcbiAgICAgICAgaW5mZXJlbmNlID0gcmVxdWlyZShcIi4vdHlwZWluZmVyZW5jZS90eXBlaW5mZXJlbmNlLmpzXCIpLFxyXG4gICAgICAgIHNwYWNlVHJhbnNmb3JtZXIgPSByZXF1aXJlKFwiLi4vZ2VuZXJhdGUvc3BhY2UvdHJhbnNmb3JtLmpzXCIpLlNwYWNlVHJhbnNmb3JtZXIsXHJcbiAgICAgICAgQW5ub3RhdGlvbnMgPSByZXF1aXJlKFwiLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIiksXHJcbiAgICAgICAgY29kZWdlbiA9IHJlcXVpcmUoXCJlc2NvZGVnZW5cIik7XHJcblxyXG5cclxuICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgdmFyIEFOTk8gPSBBbm5vdGF0aW9ucy5BTk5PO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyB0aGUgbWFpbiBhbmFseXNpc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFzdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R8bnVsbH0gb3B0XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICB2YXIgYW5hbHl6ZSA9IGZ1bmN0aW9uIChhc3QsIHByb2Nlc3NpbmdEYXRhLCBvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgcHJvY2Vzc2luZ0RhdGEgPSBwcm9jZXNzaW5nRGF0YSB8fCB7fTtcclxuXHJcbiAgICAgICAgdmFyIGVycm9yO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBSZXNvbHZlIEJSREYgY2xvc3VyZXNcclxuICAgICAgICAgICAgYXN0ID0gb3B0LmltcGxlbWVudGF0aW9uID8gcmVzb2x2ZXIucmVzb2x2ZUNsb3N1cmVzUHJlVHlwZUluZmVyZW5jZShhc3QsIG9wdC5pbXBsZW1lbnRhdGlvbiwgcHJvY2Vzc2luZ0RhdGEsIG9wdCkgOiBhc3Q7XHJcblxyXG4gICAgICAgICAgICAvLyBTYW5pdGl6ZSBzdHJhbmdlIGV4cHJlc3Npb25zIGludG8gc29tZXRoaW5nXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgYmV0dGVyIGFuYWx5c2FibGVcclxuICAgICAgICAgICAgYXN0ID0gb3B0LnNhbml0aXplID8gc2FuaXRpemVyLnNhbml0aXplKGFzdCwgb3B0KSA6IGFzdDtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJBbmFseXplXCIsIGNvZGVnZW4uZ2VuZXJhdGUoYXN0KSwgYXN0LnR5cGUsIG9wdC5zYW5pdGl6ZSk7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IEFuYWx5c2lzQ29udGV4dChhc3QsIGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0eXBlcyBhbmQgc3RhdGljIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIGFzdCA9IGluZmVyZW5jZS5pbmZlcihhc3QsIHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUvUmVwbGFjZSBkZWFkIGNvZGUgYW5kIHN0YXRpYyBleHByZXNzaW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGFzdCA9IHN0YXRpY1RyYW5zZm9ybWVyLnRyYW5zZm9ybShhc3QsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhc3QgPSBvcHQuZXh0cmFjdFVuaWZvcm1FeHByZXNzaW9ucyA/IHVuaWZvcm1BbmFseXNpcy5leHRyYWN0KGFzdCwgb3B0KSA6IGFzdDtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKG9wdC51bmlmb3JtRXhwcmVzc2lvbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhc3QgPSBvcHQuc2VtYW50aWNBbmFseXNpcyA/ICBzZW1hbnRpY3MoYXN0LCBvcHQpIDogYXN0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXN0O1xyXG5cclxuICAgICAgICAgICAgfSwgb3B0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRleHQuYW5hbHlzZSgpO1xyXG4gICAgICAgICAgICBpZiAob3B0LmVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmluamVjdENhbGwob3B0LmVudHJ5LCAob3B0LmluamVjdCAmJiAgb3B0LmluamVjdFtvcHQuZW50cnldKSB8fCBbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXN0ID0gY29udGV4dC5nZXRSZXN1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGFzdCA9IG9wdC5pbXBsZW1lbnRhdGlvbiA/IHJlc29sdmVyLnJlc29sdmVDbG9zdXJlc1Bvc3RUeXBlSW5mZXJlbmNlKGFzdCwgb3B0LmltcGxlbWVudGF0aW9uLCBwcm9jZXNzaW5nRGF0YSwgb3B0KSA6IGFzdDtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciByZW1haW5pbmcgY29kZSB0aGUgY29tcGxldGVuZXNzIG9mIGFubm90YXRpb25zXHJcbiAgICAgICAgICAgIGFzdCA9IG9wdC52YWxpZGF0ZSA/IHZhbGlkYXRvci52YWxpZGF0ZShhc3QpIDogYXN0O1xyXG5cclxuICAgICAgICAgICAgaWYob3B0LnRyYW5zZm9ybVNwYWNlcylcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdEYXRhLnNwYWNlSW5mbyA9IHNwYWNlVHJhbnNmb3JtZXIudHJhbnNmb3JtQWFzdChhc3QsIG9wdCk7XHJcblxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYob3B0LnRocm93T25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlcnJvciA9IGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhc3Q6IGFzdCxcclxuICAgICAgICAgICAgZXJyb3I6IGVycm9yXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIG5zLmFuYWx5emUgPSBhbmFseXplO1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcblxyXG4gICAgdmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKS5TeW50YXgsXHJcbiAgICAgICAgQU5OTyA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTyxcclxuICAgICAgICBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xyXG5cclxuXHJcbiAgICB2YXIgVW5hcnlGdW5jdGlvbnMgPSB7XHJcbiAgICAgICAgXCIhXCI6IGZ1bmN0aW9uKGEpIHsgcmV0dXJuICFhOyB9LFxyXG4gICAgICAgIFwiLVwiOiBmdW5jdGlvbihhKSB7IHJldHVybiAtYTsgfSxcclxuICAgICAgICBcIitcIjogZnVuY3Rpb24oYSkgeyByZXR1cm4gK2E7IH0sXHJcbiAgICAgICAgXCJ0eXBlb2ZcIjogZnVuY3Rpb24oYSkgeyByZXR1cm4gdHlwZW9mIGE7IH0sXHJcbiAgICAgICAgXCJ2b2lkXCI6IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIHZvaWQgYTsgfSxcclxuICAgICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbihhKSB7IHJldHVybiB0cnVlOyB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgQmluYXJ5RnVuY3Rpb25zID0ge1xyXG4gICAgICAgIFwiK1wiIDogZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhICsgYjsgfSxcclxuICAgICAgICBcIi1cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSAtIGI7IH0sXHJcbiAgICAgICAgXCIvXCIgOiBmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEgLyBiOyB9LFxyXG4gICAgICAgIFwiKlwiIDogZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhICogYjsgfSxcclxuICAgICAgICBcIiVcIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSAlIGI7IH0sXHJcblxyXG4gICAgICAgIFwiPT1cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSA9PSBiOyB9LFxyXG4gICAgICAgIFwiIT1cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSAhPSBiOyB9LFxyXG4gICAgICAgIFwiPT09XCIgOiBmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEgPT09IGI7IH0sXHJcbiAgICAgICAgXCIhPT1cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSAhPT0gYjsgfSxcclxuICAgICAgICBcIjxcIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSA8IGI7IH0sXHJcbiAgICAgICAgXCI8PVwiIDogZnVuY3Rpb24oYSxiKSB7IHJldHVybiBhIDw9IGI7IH0sXHJcbiAgICAgICAgXCI+XCIgOiBmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEgPiBiOyB9LFxyXG4gICAgICAgIFwiPj1cIiA6IGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYSA+PSBiOyB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbm9kZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRTdGF0aWNWYWx1ZShub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkxpdGVyYWwpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5yYXcgIT09IHVuZGVmaW5lZCA/IG5vZGUucmF3IDogbm9kZS52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIG51bWJlciA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKG51bWJlcikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgIHN3aXRjaCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRydWVcIjogcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjogcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm51bGxcIjogcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiB8fCBub2RlLnR5cGUgPT0gU3ludGF4LkNhbGxFeHByZXNzaW9uICB8fCBub2RlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgfHwgbm9kZS50eXBlID09IFN5bnRheC5OZXdFeHByZXNzaW9uIHx8IG5vZGUudHlwZSA9PSBTeW50YXguTG9naWNhbEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFOTk8obm9kZSkuZ2V0U3RhdGljVmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LlVuYXJ5RXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5vcGVyYXRvciA9PSBcInR5cGVvZlwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQU5OTyhub2RlKS5nZXRTdGF0aWNWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKFVuYXJ5RnVuY3Rpb25zLmhhc093blByb3BlcnR5KG5vZGUub3BlcmF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVW5hcnlGdW5jdGlvbnNbbm9kZS5vcGVyYXRvcl0oZ2V0U3RhdGljVmFsdWUobm9kZS5hcmd1bWVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJVbmtub3duIHVuYXJ5IG9wZXJhdG9yOiBcIiArIG5vZGUub3BlcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQmluYXJ5RXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICBpZihCaW5hcnlGdW5jdGlvbnMuaGFzT3duUHJvcGVydHkobm9kZS5vcGVyYXRvcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBCaW5hcnlGdW5jdGlvbnNbbm9kZS5vcGVyYXRvcl0oZ2V0U3RhdGljVmFsdWUobm9kZS5sZWZ0KSwgZ2V0U3RhdGljVmFsdWUobm9kZS5yaWdodCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJVbmtub3duIGJpbmFyeSBvcGVyYXRvcjogXCIgKyBub2RlLm9wZXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2hhZGUudGhyb3dFcnJvcihub2RlLCBcIkV2YWx1YXRpbmcgc3RhdGljIHZhbHVlIGZvciBub2RlIHR5cGU6IFwiICsgbm9kZS50eXBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFN0YXRpY1RydXRoVmFsdWUobm9kZSkge1xyXG4gICAgICAgIHZhciBhTm9kZSA9IEFOTk8obm9kZSk7XHJcblxyXG4gICAgICAgIC8vICEhdW5kZWZpbmVkID09IGZhbHNlO1xyXG4gICAgICAgIGlmIChhTm9kZS5pc051bGxPclVuZGVmaW5lZCgpKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gISF7fSA9PSB0cnVlXHJcbiAgICAgICAgaWYgKGFOb2RlLmlzT2JqZWN0KCkgfHwgdGhpcy5pc0Z1bmN0aW9uKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIC8vIEluIGFsbCBvdGhlciBjYXNlcywgaXQgZGVwZW5kcyBvbiB0aGUgdmFsdWUsXHJcbiAgICAgICAgLy8gdGh1cyB3ZSBjYW4gb25seSBldmFsdWF0ZSB0aGlzIGZvciBzdGF0aWMgb2JqZWN0c1xyXG4gICAgICAgIGlmIChhTm9kZS5oYXNTdGF0aWNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIWFOb2RlLmdldFN0YXRpY1ZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0cy5nZXRTdGF0aWNWYWx1ZSA9IGdldFN0YXRpY1ZhbHVlO1xyXG4gICAgZXhwb3J0cy5nZXRTdGF0aWNUcnV0aFZhbHVlID0gZ2V0U3RhdGljVHJ1dGhWYWx1ZTtcclxuXHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxyXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxyXG4gICAgICAgIGVzdHJhdmVyc2UgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XHJcblxyXG4gICAgLy8gdmFyIGNvZGVnZW4gPSByZXF1aXJlKCdlc2NvZGVnZW4nKTtcclxuXHJcbiAgICB2YXIgU3ludGF4ID0gY29tbW9uLlN5bnRheCxcclxuICAgICAgICBUWVBFUyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEFOTk8gPSBjb21tb24uQU5OTztcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gQVNUOiBFbGltaW5hdGUgYnJhbmNoZXMgZHVlIHRvIHN0YXRpYyBjb25kaXRpb25zXHJcbiAgICAgKiBhbmQgcGVyZm9ybXMgY29uc3RhbnQgZm9sZGluZ1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFzdFxyXG4gICAgICogQHJldHVybnMgT2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHZhciB0cmFuc2Zvcm0gPSBucy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoYXN0LCBvcHQpIHtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtZXIob3B0KTtcclxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIudHJhbnNmb3JtKGFzdCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFRyYW5zZm9ybWVyID0gZnVuY3Rpb24ob3B0KSB7XHJcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG5cclxuICAgICAgICB0aGlzLmZvbGRDb25zdGFudHMgPSBvcHQuZm9sZENvbnN0YW50cyAhPT0gdW5kZWZpbmVkID8gb3B0LmZvbGRDb25zdGFudHMgOiB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgZXN0cmF2ZXJzZS5Db250cm9sbGVyKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFRyYW5zZm9ybWVyLnByb3RvdHlwZSA9IHtcclxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChhc3QpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyLnJlcGxhY2UoYXN0LCB7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IEFOTk8obm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlSW5mby5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguSWZTdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5oYW5kbGVJZlN0YXRlbWVudChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaGFuZGxlQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmhhbmRsZUxvZ2ljYWxFeHByZXNzaW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmhhbmRsZUFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5oYW5kbGVWYXJpYWJsZURlY2xhcmF0b3Iobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4Lk5ld0V4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Nhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuaGFuZGxlTmV3RXhwcmVzc2lvbihub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmhhbmRsZVZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhhdC5mb2xkQ29uc3RhbnRzICYmIGlzRXhwcmVzc2lvbihub2RlLnR5cGUsIHBhcmVudC50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5mb2xkQ29uc3RhbnRFeHByZXNzaW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIGhhbmRsZUlmU3RhdGVtZW50OiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgdGVzdCA9IEFOTk8obm9kZS50ZXN0KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0ZXN0Lmhhc1N0YXRpY1ZhbHVlKCkgfHwgdGVzdC5jYW5PYmplY3QoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLnNraXAoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0aWNWYWx1ZSA9IHRlc3QuZ2V0U3RhdGljVHJ1dGhWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1ZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybShub2RlLmNvbnNlcXVlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1ZhbHVlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmFsdGVybmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obm9kZS5hbHRlcm5hdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRW1wdHlTdGF0ZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgaGFuZGxlQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgdGVzdCA9IEFOTk8obm9kZS50ZXN0KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0ZXN0Lmhhc1N0YXRpY1ZhbHVlKCkgfHwgdGVzdC5jYW5PYmplY3QoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLnNraXAoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0aWNWYWx1ZSA9IHRlc3QuZ2V0U3RhdGljVHJ1dGhWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1ZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG5vZGUuY29uc2VxdWVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShub2RlLmFsdGVybmF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoYW5kbGVMb2dpY2FsRXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBBTk5PKG5vZGUubGVmdCk7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IEFOTk8obm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0Qm9vbCA9IGxlZnQuZ2V0U3RhdGljVHJ1dGhWYWx1ZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRCb29sID0gcmlnaHQuZ2V0U3RhdGljVHJ1dGhWYWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwifHxcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRCb29sID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRCb29sID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIExlZnQgaXMgZHluYW1pYywgbGV0J3MgY2hlY2sgcmlnaHRcclxuICAgICAgICAgICAgICAgIGlmIChyaWdodEJvb2wgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm9wZXJhdG9yID09PSBcIiYmXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0Qm9vbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRCb29sID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0IGlzIGR5bmFtaWMsIGxldCdzIGNoZWNrIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRCb29sID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IHRoZSByZXN1bHQgdHlwZSBpcyBhbHdheXMgdGhlIG9uZSBvZiB0aGUgbGVmdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRCb29sID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyB0aGUgcmVzdWx0IG11c3QgYmUgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiZmFsc2VcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHsgdHlwZTogXCJib29sZWFuXCJ9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhhbmRsZUFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBub2RlLnJpZ2h0ID0gdGhpcy5mb2xkQ29uc3RhbnRFeHByZXNzaW9uKG5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhbmRsZU5ld0V4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gbm9kZS5hcmd1bWVudHMsIG5ld0FyZ3MgPSBbXTtcclxuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IEFOTk8oYXJnKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1NpbXBsZVN0YXRpYyh0eXBlSW5mbykpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdBcmdzLnB1c2goZ2VuZXJhdGVMaXRlcmFsRnJvbVR5cGVJbmZvKHR5cGVJbmZvKSlcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJncy5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBub2RlLmFyZ3VtZW50cyA9IG5ld0FyZ3M7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhhbmRsZVZhcmlhYmxlRGVjbGFyYXRpb246IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSBub2RlLmRlY2xhcmF0aW9ucywgbmV3RGVjbGFyYXRpb25zID0gW10sIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjbGFyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IEFOTk8oZGVjbGFyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlSW5mby5pc1VuZGVmaW5lZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbm9kZS5kZWNsYXJhdGlvbnMgPSBuZXdEZWNsYXJhdGlvbnM7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFuZGxlVmFyaWFibGVEZWNsYXJhdG9yOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5pbml0KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmluaXQgPSB0aGlzLmZvbGRDb25zdGFudEV4cHJlc3Npb24obm9kZS5pbml0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb2xkQ29uc3RhbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgYW5ubyA9IEFOTk8obm9kZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvbGRDb25zdGFudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1NpbXBsZVN0YXRpYyhhbm5vKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUxpdGVyYWxGcm9tVHlwZUluZm8oYW5ubyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RhdGljT2JqZWN0KGFubm8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlQ29uc3RydWN0b3JGcm9tVHlwZUluZm8oYW5ubyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzU2ltcGxlU3RhdGljKHR5cGVJbmZvKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVJbmZvLmhhc1N0YXRpY1ZhbHVlKCkgJiYgISh0eXBlSW5mby5pc09iamVjdCgpIHx8IHR5cGVJbmZvLmlzTnVsbE9yVW5kZWZpbmVkKCkpO1xyXG4gICAgfVxyXG5cclxuICAgICBmdW5jdGlvbiBpc1N0YXRpY09iamVjdCh0eXBlSW5mbykge1xyXG4gICAgICAgIHJldHVybiB0eXBlSW5mby5oYXNTdGF0aWNWYWx1ZSgpICYmIHR5cGVJbmZvLmlzVmVjdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNfZXhwcmVzc2lvbnMgPSBbU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sIFN5bnRheC5VbmFyeUV4cHJlc3Npb24sIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uXTtcclxuICAgIHZhciBjX3BhcmVudExpdGVyYWxFeHByZXNzaW9ucyA9IFtTeW50YXguQmluYXJ5RXhwcmVzc2lvbiwgU3ludGF4LlJldHVyblN0YXRlbWVudCwgU3ludGF4LkNhbGxFeHByZXNzaW9uXTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gaXNFeHByZXNzaW9uKHR5cGUsIHBhcmVudFR5cGUpIHtcclxuICAgICAgICBpZih0eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICByZXR1cm4gY19wYXJlbnRMaXRlcmFsRXhwcmVzc2lvbnMuaW5kZXhPZihwYXJlbnRUeXBlKSAhPT0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjX2V4cHJlc3Npb25zLmluZGV4T2YodHlwZSkgIT09IC0xO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDb25zdHJ1Y3RvckZyb21UeXBlSW5mbyh0eXBlSW5mbykge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVJbmZvLmdldFN0YXRpY1ZhbHVlKCksIHNpemUsIG5hbWUsIGFyZ3VtZW50cyA9IFtdO1xyXG4gICAgICAgIHN3aXRjaCh0eXBlSW5mby5nZXRLaW5kKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBTaGFkZS5PQkpFQ1RfS0lORFMuRkxPQVQyOiBzaXplID0gMjsgbmFtZSA9IFwiVmVjMlwiOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTaGFkZS5PQkpFQ1RfS0lORFMuRkxPQVQzOiBzaXplID0gMzsgbmFtZSA9IFwiVmVjM1wiOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTaGFkZS5PQkpFQ1RfS0lORFMuRkxPQVQ0OiBzaXplID0gNDsgbmFtZSA9IFwiVmVjNFwiOyBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yIGluIHN0YXRpYyB0cmFuc2Zvcm1hdGlvbi4gVW5rbm93biBraW5kOiBcIiArIHR5cGVJbmZvLmdldEtpbmQoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2FtZSA9IHRydWU7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgKGkgPCBzaXplLTEpICYmIHNhbWU7ICsraSkge1xyXG4gICAgICAgICAgICBzYW1lID0gc2FtZSAmJiB2YWx1ZVtpXSA9PSB2YWx1ZVtpKzFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2l6ZSA9IHNhbWUgPyAxIDogc2l6ZTtcclxuXHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XHJcbiAgICAgICAgICAgIGFyZ3VtZW50cy5wdXNoKGdlbmVyYXRlRmxvYXRMaXRlcmFsRnJvbVZhbHVlKHZhbHVlW2ldKSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk5ld0V4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIGNhbGxlZToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzXHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFOTk8ocmVzdWx0KS5jb3B5KHR5cGVJbmZvKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRmxvYXRMaXRlcmFsRnJvbVZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG5lZWRzU2lnbiA9IHZhbHVlIDwgMDtcclxuXHJcbiAgICAgICAgdmFyIGxpdGVyYWwgPSB7IHR5cGU6IFN5bnRheC5MaXRlcmFsLCB2YWx1ZTogbmVlZHNTaWduID8gLXZhbHVlIDogdmFsdWUgfTtcclxuICAgICAgICBBTk5PKGxpdGVyYWwpLnNldFR5cGUoU2hhZGUuVFlQRVMuTlVNQkVSKTtcclxuXHJcbiAgICAgICAgaWYgKCFuZWVkc1NpZ24pXHJcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xyXG5cclxuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5VbmFyeUV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCItXCIsXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogbGl0ZXJhbFxyXG4gICAgICAgIH1cclxuICAgICAgICBBTk5PKGV4cHJlc3Npb24pLnNldFR5cGUoU2hhZGUuVFlQRVMuTlVNQkVSKTtcclxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUxpdGVyYWxGcm9tVHlwZUluZm8odHlwZUluZm8pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0eXBlSW5mby5nZXRTdGF0aWNWYWx1ZSgpO1xyXG4gICAgICAgIHZhciBpc05lZ2F0aXZlID0gdmFsdWUgPCAwO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguTGl0ZXJhbCxcclxuICAgICAgICAgICAgdmFsdWU6IGlzTmVnYXRpdmUgPyAtdmFsdWUgOiB2YWx1ZSxcclxuICAgICAgICAgICAgZXh0cmE6IHt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEJhc2UuZXh0ZW5kKHJlc3VsdC5leHRyYSwgdHlwZUluZm8uZ2V0RXh0cmEoKSk7XHJcblxyXG4gICAgICAgIGlmKGlzTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmV4dHJhLnN0YXRpY1ZhbHVlID0gLXZhbHVlO1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVW5hcnlFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiLVwiLFxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IHJlc3VsdCxcclxuICAgICAgICAgICAgICAgIGV4dHJhOiB7fVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEJhc2UuZXh0ZW5kKHJlc3VsdC5leHRyYSwgdHlwZUluZm8uZ2V0RXh0cmEoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyksXHJcbiAgICAgICAgU2NvcGUgPSByZXF1aXJlKFwiLi8uLi9iYXNlL3Njb3BlLmpzXCIpLFxyXG4gICAgICAgIHJlc29sdmVyID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2ZS5qc1wiKSxcclxuICAgICAgICBTeW50YXggPSB3YWxrLlN5bnRheDtcclxuXHJcbiAgICB2YXIgZGVyaXZlZFN5c3RlbVBhcmFtZXRlcnMgPSB7XHJcbiAgICAgICAgbm9ybWFsaXplZENvb3JkczogW1wiY29vcmRzXCJdLFxyXG4gICAgICAgIGhlaWdodDogW1wiY29vcmRzXCJdLFxyXG4gICAgICAgIHdpZHRoOiBbXCJjb29yZHNcIl1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7e3NoYWRlclBhcmFtZXRlcnM6IEFycmF5LCBzeXN0ZW1QYXJhbWV0ZXJzOiBBcnJheX19IHJlc3VsdFxyXG4gICAgICogQHBhcmFtIHt7c2hhZGVyUGFyYW1ldGVyczogQXJyYXksIHN5c3RlbVBhcmFtZXRlcnM6IEFycmF5fX0gb3RoZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWVyZ2UocmVzdWx0LCBvdGhlcikge1xyXG4gICAgICAgIHZhciBpLCBwYXJhbTtcclxuICAgICAgICBmb3IgKHZhciBjb250YWluZXIgaW4gcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG90aGVyW2NvbnRhaW5lcl0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtID0gb3RoZXJbY29udGFpbmVyXVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbY29udGFpbmVyXS5pbmRleE9mKHBhcmFtKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjb250YWluZXJdLnB1c2gocGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFN5c3RlbVBhcmFtZXRlcihwYXJhbWV0ZXJOYW1lLCBjb250YWluZXIsIHBhcmFtZXRlck1hcCkge1xyXG4gICAgICAgIC8vIElzIHBhcmFtZXRlciBhbHJlYWR5IGluIGNvbnRhaW5lcj9cclxuICAgICAgICBpZiAoY29udGFpbmVyLmluZGV4T2YocGFyYW1ldGVyTmFtZSkgIT0gLTEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKHBhcmFtZXRlck1hcCAmJiBwYXJhbWV0ZXJNYXAuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyTmFtZSkpIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVpcmVkUGFyYW1ldGVycyA9IHBhcmFtZXRlck1hcFtwYXJhbWV0ZXJOYW1lXTtcclxuICAgICAgICAgICAgcmVxdWlyZWRQYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRTeXN0ZW1QYXJhbWV0ZXIocGFyYW0sIGNvbnRhaW5lciwgcGFyYW1ldGVyTWFwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGFpbmVyLnB1c2gocGFyYW1ldGVyTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lIEdsb2JhbCBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBhbmFseXplXHJcbiAgICAgKiBAcGFyYW0geyp9IHByb2dyYW0gQVNUIG9mIHRoZSBwcm9ncmFtXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW52aXJvbm1lbnRPYmplY3RQb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBhbmFseXplZENhbGxzXHJcbiAgICAgKiBAcmV0dXJucyB7e3NoYWRlclBhcmFtZXRlcnM6IEFycmF5LCBzeXN0ZW1QYXJhbWV0ZXJzOiBBcnJheX19XHJcbiAgICAgKi9cclxuICAgIHZhciBmaW5kUGFyYW1ldGVyc0luRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lLCBwcm9ncmFtLCBlbnZpcm9ubWVudE9iamVjdFBvc2l0aW9uLCBhbmFseXplZENhbGxzKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgU2NvcGUocHJvZ3JhbSwgbnVsbCwge25hbWU6IFwiZ2xvYmFsXCJ9KTtcclxuICAgICAgICB2YXIgY29udGV4dFN0YWNrID0gW2NvbnRleHRdO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0geyBzaGFkZXJQYXJhbWV0ZXJzOiBbXSwgc3lzdGVtUGFyYW1ldGVyczogW10gfTtcclxuICAgICAgICBhbmFseXplZENhbGxzID0gYW5hbHl6ZWRDYWxscyB8fCB7fTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkxvb2tpbmcgZm9yOiBcIiwgZnVuY3Rpb25OYW1lLCBlbnZpcm9ubWVudE9iamVjdFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdmFyIGFjdGl2ZVBhcmFtID0gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgd2Fsay5Db250cm9sbGVyKCk7XHJcbiAgICAgICAgY29udHJvbGxlci50cmF2ZXJzZShwcm9ncmFtLCB7XHJcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgcmV0VmFsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDb250ZXh0ID0gY29udGV4dFN0YWNrW2NvbnRleHRTdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29udGV4dC5kZWNsYXJlVmFyaWFibGUobm9kZS5pZC5uYW1lLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgU2NvcGUobm9kZSwgcGFyZW50Q29udGV4dCwge25hbWU6IG5vZGUuaWQubmFtZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFN0YWNrLnB1c2goY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN0cigpID09IGZ1bmN0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50T2JqZWN0UG9zaXRpb24gIT0gLTEgJiYgbm9kZS5wYXJhbXMubGVuZ3RoID4gZW52aXJvbm1lbnRPYmplY3RQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVBhcmFtID0gbm9kZS5wYXJhbXNbZW52aXJvbm1lbnRPYmplY3RQb3NpdGlvbl0ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuc2tpcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gbm9kZS5hcmd1bWVudHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnIubmFtZSAmJiBjdXJyLm5hbWUgPT0gYWN0aXZlUGFyYW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHRTdGFja1tjb250ZXh0U3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGNvbnRleHQuZ2V0VmFyaWFibGVJZGVudGlmaWVyKG5vZGUuY2FsbGVlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWQgJiYgIWFuYWx5emVkQ2FsbHNbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmFseXplZENhbGxzW2lkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZShyZXN1bHQsIGZpbmRQYXJhbWV0ZXJzSW5GdW5jdGlvbihpZCwgcHJvZ3JhbSwgcG9zLCBhbmFseXplZENhbGxzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUGFyYW0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyTmFtZSA9IG5vZGUucHJvcGVydHkubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gYSBzcGVjaWZpYyBwYXJhbWV0ZXIgb2YgdGhlIGN1cnJlbnQgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVQYXJhbSAmJiBub2RlLm9iamVjdC5uYW1lID09IGFjdGl2ZVBhcmFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTeXN0ZW1QYXJhbWV0ZXIocGFyYW1ldGVyTmFtZSwgcmVzdWx0LnNoYWRlclBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIEluICd0aGlzJyBpcyBhIHN5c3RlbSBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5vYmplY3QudHlwZSA9PSBTeW50YXguVGhpc0V4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFN5c3RlbVBhcmFtZXRlcihwYXJhbWV0ZXJOYW1lLCByZXN1bHQuc3lzdGVtUGFyYW1ldGVycywgZGVyaXZlZFN5c3RlbVBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIEluIGdsb2JhbCB2YXJpYWJsZSAnX2VudidcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5vYmplY3QubmFtZSA9PSBcIl9lbnZcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3lzdGVtUGFyYW1ldGVyKHBhcmFtZXRlck5hbWUsIHJlc3VsdC5zaGFkZXJQYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0IX0gcHJvZ3JhbVxyXG4gICAgICogQHBhcmFtIHtvYmplY3Q/fSBvcHRcclxuICAgICAqIEByZXR1cm5zIHt7c2hhZGVyUGFyYW1ldGVyczogQXJyYXksIHN5c3RlbVBhcmFtZXRlcnM6IEFycmF5fX1cclxuICAgICAqL1xyXG4gICAgbnMuZXh0cmFjdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocHJvZ3JhbSwgb3B0KSB7XHJcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBvcHQuY29udGV4dCB8fCBcImdsb2JhbC5zaGFkZVwiO1xyXG4gICAgICAgIHZhciBwYXJhbWV0ZXJQb3NpdGlvbiA9IG9wdC5wYXJhbSB8fCAwO1xyXG5cclxuICAgICAgICBpZihvcHQuaW1wbGVtZW50YXRpb24pIHtcclxuICAgICAgICAgICAgcHJvZ3JhbSA9IHJlc29sdmVyLnJlc29sdmVDbG9zdXJlc1ByZVR5cGVJbmZlcmVuY2UocHJvZ3JhbSwgb3B0LmltcGxlbWVudGF0aW9uLCBvcHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmluZFBhcmFtZXRlcnNJbkZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcHJvZ3JhbSwgcGFyYW1ldGVyUG9zaXRpb24pO1xyXG4gICAgfTtcclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciB3YWxrID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxyXG4gICAgICAgIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIiksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxyXG4gICAgICAgIGNvbW1vbiA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxyXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIgPSByZXF1aXJlKFwiLi9zdGF0ZW1lbnQtc3BsaXQtdHJhdmVyc2VyXCIpO1xyXG5cclxuICAgIHZhciBTeW50YXggPSB3YWxrLlN5bnRheDtcclxuICAgIHZhciBWaXNpdG9yT3B0aW9uID0gd2Fsay5WaXNpdG9yT3B0aW9uO1xyXG5cclxuXHJcbiAgICB2YXIgRGVjbGFyYXRpb25TaW1wbGlmaWVyID0gZnVuY3Rpb24gKG9wdCkge1xyXG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25TdGFjayA9IFtdO1xyXG4gICAgfTtcclxuICAgIEJhc2UuZXh0ZW5kKERlY2xhcmF0aW9uU2ltcGxpZmllci5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHJvb3QpIHtcclxuICAgICAgICAgICAgd2Fsay5yZXBsYWNlKHJvb3QsIHtcclxuICAgICAgICAgICAgICAgIGVudGVyOiB0aGlzLmVudGVyTm9kZS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgbGVhdmU6IHRoaXMuZXhpdE5vZGUuYmluZCh0aGlzKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZW50ZXJOb2RlOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaChub2RlLnR5cGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlByb2dyYW06XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvblN0YWNrLnB1c2goW10pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRGVjbGFyZWRJZGVudGlmaWVyKG5vZGUuaWQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBleGl0Tm9kZTogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Qcm9ncmFtOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFRvcERlY2xhcmF0aW9uKG5vZGUsIHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZU1pZENvZGVEZWNsYXJhdGlvbihub2RlLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVtb3ZlTWlkQ29kZURlY2xhcmF0aW9uOiBmdW5jdGlvbihub2RlLCBwYXJlbnQpe1xyXG4gICAgICAgICAgICB2YXIgbmV3Tm9kZTtcclxuICAgICAgICAgICAgdmFyIGlzRm9ySW5pdCA9IChwYXJlbnQudHlwZSA9PSBTeW50YXguRm9yU3RhdGVtZW50ICYmIHBhcmVudC5pbml0ID09IG5vZGUpO1xyXG4gICAgICAgICAgICBpZihpc0ZvckluaXQpe1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguU2VxdWVuY2VFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBsb2M6IG5vZGUubG9jXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvYzogbm9kZS5sb2NcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IG5vZGUuZGVjbGFyYXRpb25zO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKGRlY2xhcmF0aW9uLmluaXQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZGVjbGFyYXRpb24uaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBkZWNsYXJhdGlvbi5pbml0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2M6IGRlY2xhcmF0aW9uLmxvY1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNGb3JJbml0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogZGVjbGFyYXRpb24ubG9jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5ib2R5LnB1c2goc3RhdGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoaXNGb3JJbml0ICYmIG5ld05vZGUuZXhwcmVzc2lvbnMubGVuZ3RoID09IDEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld05vZGUuZXhwcmVzc2lvbnNbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWRkVG9wRGVjbGFyYXRpb246IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XHJcbiAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSB0aGlzLmRlY2xhcmF0aW9uU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIGlmKGRlY2xhcmF0aW9ucy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNsYXJhdGlvblN0YXRlbWVudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidmFyXCJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGVjbGFyYXRpb25zLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvblN0YXRlbWVudC5kZWNsYXJhdGlvbnNbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBkZWNsYXJhdGlvbnNbaV0gfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdDogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKG5vZGUudHlwZSA9PSBTeW50YXguUHJvZ3JhbSlcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmJvZHkudW5zaGlmdChkZWNsYXJhdGlvblN0YXRlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKG5vZGUuYm9keS5ib2R5KVxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYm9keS5ib2R5LnVuc2hpZnQoZGVjbGFyYXRpb25TdGF0ZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZERlY2xhcmVkSWRlbnRpZmllcjogZnVuY3Rpb24obmFtZSl7XHJcbiAgICAgICAgICAgIHZhciB0b3BTdGFjayA9IHRoaXMuZGVjbGFyYXRpb25TdGFja1t0aGlzLmRlY2xhcmF0aW9uU3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIGlmKHRvcFN0YWNrLmluZGV4T2YobmFtZSkgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICB0b3BTdGFjay5wdXNoKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgdmFyIFN0YXRlbWVudFNpbXBsaWZpZXIgPSBmdW5jdGlvbiAob3B0KSB7XHJcbiAgICAgICAgU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIuY2FsbCh0aGlzLCBvcHQpO1xyXG4gICAgICAgIHRoaXMuc2tpcEV4dHJhY3Rpb24uZm9ySW5pdFVwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuc3RhdGVtZW50SWRlbnRpZmllckluZm8gPSB7fTtcclxuICAgIH07XHJcblxyXG4gICAgQmFzZS5jcmVhdGVDbGFzcyhTdGF0ZW1lbnRTaW1wbGlmaWVyLCBTdGF0ZW1lbnRTcGxpdFRyYXZlcnNlciwge1xyXG4gICAgICAgIG9uR2F0aGVyU3BsaXRJbmZvOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudElkZW50aWZpZXJJbmZvID0ge307XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGF0ZW1lbnRTcGxpdEVudGVyOiBmdW5jdGlvbihub2RlLCBwYXJlbnQpe1xyXG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pZGVudGlmaWVyRW50ZXIobm9kZSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVXBkYXRlRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hc3NpZ25tZW50RW50ZXIobm9kZSwgcGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN0YXRlbWVudFNwbGl0RXhpdDogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVXBkYXRlRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hc3NpZ25tZW50RXhpdChub2RlLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaWRlbnRpZmllckVudGVyOiBmdW5jdGlvbihub2RlLCBwYXJlbnQpe1xyXG4gICAgICAgICAgICBpZihwYXJlbnQudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbilcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYocGFyZW50LnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHBhcmVudC5sZWZ0ID09IG5vZGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xyXG4gICAgICAgICAgICBpZighdGhpcy5zdGF0ZW1lbnRJZGVudGlmaWVySW5mb1tuYW1lXSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50SWRlbnRpZmllckluZm9bbmFtZV0gPSB7IHJlYWRzOiBbXSwgbGFzdFdyaXRlOiBudWxsIH07XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50SWRlbnRpZmllckluZm9bbmFtZV0ucmVhZHMucHVzaChub2RlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhc3NpZ25tZW50RW50ZXI6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XHJcbiAgICAgICAgICAgIGlmKHBhcmVudC50eXBlID09IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZigobm9kZS5sZWZ0IHx8IG5vZGUuYXJndW1lbnQpLnR5cGUgIT0gU3ludGF4LklkZW50aWZpZXIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiV2Ugb25seSBzdXBwb3J0IG5lc3RlZCBhc3NpZ25tZW50cyBmb3Igc2ltcGxlIGlkZW50aWZpZXJzLCBub3Qgb2JqZWN0cyBvciBhcnJheXMuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uKXtcclxuICAgICAgICAgICAgICAgIHZhciB1c2VQcmV2VmFsdWUgPSAhbm9kZS5wcmVmaXg7XHJcbiAgICAgICAgICAgICAgICBub2RlID0geyB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBub2RlLmFyZ3VtZW50Lm5hbWUsIGxvYzogbm9kZS5hcmd1bWVudC5sb2N9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogeyB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IG5vZGUub3BlcmF0b3IgPT0gXCIrK1wiID8gXCIrXCIgOiBcIi1cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogIHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogbm9kZS5hcmd1bWVudC5uYW1lICwgbG9jOiBub2RlLmFyZ3VtZW50LmxvY30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB7dHlwZTogU3ludGF4LkxpdGVyYWwsIHZhbHVlOiAxfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2M6IG5vZGUubG9jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdXNlUHJldlZhbHVlOiB1c2VQcmV2VmFsdWVcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYobm9kZS50eXBlID09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiAmJiBub2RlLm9wZXJhdG9yICE9IFwiPVwiKXtcclxuICAgICAgICAgICAgICAgIHZhciBiaW5hcnlPcGVyYXRvciA9IG5vZGUub3BlcmF0b3Iuc3Vic3RyKDAsIG5vZGUub3BlcmF0b3IubGVuZ3RoLTEpO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5vcGVyYXRvciA9IFwiPVwiO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IHsgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogYmluYXJ5T3BlcmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IG5vZGUubGVmdC5uYW1lLCBsb2M6IG5vZGUucmlnaHQubG9jIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogbm9kZS5yaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogbm9kZS5yaWdodC5sb2N9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5sZWZ0Lm5hbWU7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuc3RhdGVtZW50SWRlbnRpZmllckluZm9bbmFtZV07XHJcbiAgICAgICAgICAgIGlmKGVudHJ5ICYmIGVudHJ5LnJlYWRzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICBub2RlLl9wcmVJZGVudGlmaWVyV3JpdGVyID0gZW50cnkubGFzdFdyaXRlO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhc3NpZ25tZW50RXhpdDogZnVuY3Rpb24obm9kZSwgcGFyZW50KXtcclxuICAgICAgICAgICAgaWYocGFyZW50LnR5cGUgPT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVhZE9sZFZhbHVlID0gbm9kZS5fdXNlUHJldlZhbHVlO1xyXG4gICAgICAgICAgICBkZWxldGUgbm9kZS5fdXNlUHJldlZhbHVlO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9sZE5hbWUgPSBub2RlLmxlZnQubmFtZTtcclxuICAgICAgICAgICAgaWYoIXRoaXMuc3RhdGVtZW50SWRlbnRpZmllckluZm9bb2xkTmFtZV0pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnRJZGVudGlmaWVySW5mb1tvbGROYW1lXSA9IHsgcmVhZHM6IFtdLCBsYXN0V3JpdGU6IG51bGwgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5zdGF0ZW1lbnRJZGVudGlmaWVySW5mb1tvbGROYW1lXTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZWFkUmVwbGFjZSA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogb2xkTmFtZSxcclxuICAgICAgICAgICAgICAgIGxvYzogbm9kZS5sb2NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYocmVhZE9sZFZhbHVlIHx8IChub2RlLl9wcmVJZGVudGlmaWVyV3JpdGVyICE9PSB1bmRlZmluZWQgJiYgbm9kZS5fcHJlSWRlbnRpZmllcldyaXRlciA9PSBlbnRyeS5sYXN0V3JpdGUpKXtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdOYW1lID0gdGhpcy5nZXRGcmVlTmFtZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYoIWVudHJ5Lmxhc3RXcml0ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcHlBc3NpZ25tZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHsgdHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IG5ld05hbWUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogb2xkTmFtZX0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIlxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50c1RvQmVQcmVwZW5kZWQudW5zaGlmdChjb3B5QXNzaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5sYXN0V3JpdGUubGVmdC5uYW1lID0gbmV3TmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbnRyeS5yZWFkcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cnkucmVhZHNbaV0ubmFtZSA9IG5ld05hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW50cnkucmVhZHMgPSBbXTtcclxuICAgICAgICAgICAgZGVsZXRlIG5vZGUuX3ByZUlkZW50aWZpZXJXcml0ZXI7XHJcbiAgICAgICAgICAgIGVudHJ5Lmxhc3RXcml0ZSA9IG5vZGU7XHJcblxyXG4gICAgICAgICAgICBpZihyZWFkT2xkVmFsdWUpXHJcbiAgICAgICAgICAgICAgICByZWFkUmVwbGFjZS5uYW1lID0gbmV3TmFtZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnRJZGVudGlmaWVySW5mb1tvbGROYW1lXS5yZWFkcy5wdXNoKHJlYWRSZXBsYWNlKTtcclxuXHJcblxyXG4gICAgICAgICAgICB0aGlzLmFzc2lnbm1lbnRzVG9CZVByZXBlbmRlZC5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZFJlcGxhY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIG5zLnNhbml0aXplID0gZnVuY3Rpb24gKGFzdCwgb3B0KSB7XHJcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uU2ltcGxpZmllciA9IG5ldyBEZWNsYXJhdGlvblNpbXBsaWZpZXIob3B0KTtcclxuICAgICAgICB2YXIgc3RhdGVtZW50U2ltcGxpZmllciA9IG5ldyBTdGF0ZW1lbnRTaW1wbGlmaWVyKG9wdCk7XHJcbiAgICAgICAgYXN0ID0gZGVjbGFyYXRpb25TaW1wbGlmaWVyLmV4ZWN1dGUoYXN0KTtcclxuICAgICAgICBhc3QgPSBzdGF0ZW1lbnRTaW1wbGlmaWVyLmV4ZWN1dGUoYXN0KTtcclxuICAgICAgICByZXR1cm4gYXN0O1xyXG4gICAgfTtcclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciB3YWxrID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxyXG4gICAgICAgIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIiksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxyXG4gICAgICAgIGNvbW1vbiA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxyXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVHlwZUluZm8gPSByZXF1aXJlKFwiLi4vLi4vYmFzZS90eXBlaW5mby5qc1wiKS5UeXBlSW5mbyxcclxuICAgICAgICBBTk5PID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYW5ub3RhdGlvbi5qc1wiKS5BTk5PLFxyXG4gICAgICAgIFR5cGVzID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS2luZHMgPSBTaGFkZS5PQkpFQ1RfS0lORFM7XHJcblxyXG4gICAgdmFyIFN5bnRheCA9IHdhbGsuU3ludGF4O1xyXG5cclxuICAgIHZhciBTdGF0ZW1lbnRTcGxpdFRyYXZlcnNlciA9IGZ1bmN0aW9uIChvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByb290IG9mIHRoZSBwcm9ncmFtIEFTVFxyXG4gICAgICAgICAqIEB0eXBlIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2NvcGVzID0gW107XHJcbiAgICAgICAgdGhpcy5wcmVDb250aW51ZVN0YXRlbWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkID0gW107XHJcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50c1RvQmVQcmVwZW5kZWQgPSBbXTtcclxuXHJcbiAgICAgICAgdGhpcy5za2lwRXh0cmFjdGlvbiA9IHtcclxuICAgICAgICAgICAgZm9ySW5pdFVwZGF0ZTogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEJhc2UuZXh0ZW5kKFN0YXRlbWVudFNwbGl0VHJhdmVyc2VyLnByb3RvdHlwZSwge1xyXG5cclxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAocm9vdCkge1xyXG4gICAgICAgICAgICB3YWxrLnJlcGxhY2Uocm9vdCwge1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IHRoaXMuZW50ZXJOb2RlLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgICAgICBsZWF2ZTogdGhpcy5leGl0Tm9kZS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgZ2F0aGVyU3RhdG1lbnRTcGxpdEluZm86IGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYXNzaWdubWVudHNUb0JlUHJlcGVuZGVkID0gW107XHJcbiAgICAgICAgICAgIHRoaXMub25HYXRoZXJTcGxpdEluZm8oKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdhbGsucmVwbGFjZShub2RlLCB7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogdGhpcy5zdGF0ZW1lbnRTcGxpdEVudGVyLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgICAgICBsZWF2ZTogdGhpcy5zdGF0ZW1lbnRTcGxpdEV4aXQuYmluZCh0aGlzKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0YXRlbWVudFNwbGl0RW50ZXI6IGZ1bmN0aW9uKG5vZGVQYXJlbnQpe1xyXG4gICAgICAgICAgICAvLyBJbXBsZW1lbnRlZCBieSBzdWJjbGFzc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhdGVtZW50U3BsaXRFeGl0OiBmdW5jdGlvbihub2RlUGFyZW50KXtcclxuICAgICAgICAgICAgLy8gSW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uR2F0aGVyU3BsaXRJbmZvOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAvLyBJbXBsZW1lbnRlZCBieSBzdWJjbGFzc1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzUmVkdW5kYW50OiBmdW5jdGlvbihub2RlKXtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHdhbGsudHJhdmVyc2Uobm9kZSwge1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChub2RlLnR5cGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVXBkYXRlRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5DYWxsRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5icmVhaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcHVzaFNjb3BlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB2YXIgbmV3U2NvcGUgPSB7XHJcbiAgICAgICAgICAgICAgICBkZWNsYXJlZDogW10sXHJcbiAgICAgICAgICAgICAgICB0bXBEZWNsYXJlZDogW10sXHJcbiAgICAgICAgICAgICAgICB0bXBEZWNsYXJlZFR5cGVzOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNjb3Blcy5wdXNoKG5ld1Njb3BlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcG9wU2NvcGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3Blcy5wb3AoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFNjb3BlOiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29wZXNbdGhpcy5zY29wZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRQcmVDb250aW51ZVN0YXRlbWVudHM6IGZ1bmN0aW9uKHN0YXRlbWVudHMpe1xyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMucHJlQ29udGludWVTdGF0ZW1lbnRzW3RoaXMucHJlQ29udGludWVTdGF0ZW1lbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBsYXN0LnB1c2guYXBwbHkobGFzdCwgc3RhdGVtZW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRQcmVDb250aW51ZVN0YXRlbWVudHM6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZUNvbnRpbnVlU3RhdGVtZW50c1t0aGlzLnByZUNvbnRpbnVlU3RhdGVtZW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbnRlck5vZGU6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguUHJvZ3JhbTpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2NvcGU9IHRoaXMucHVzaFNjb3BlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5wYXJhbXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZS5wYXJhbXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUuZGVjbGFyZWQucHVzaChub2RlLnBhcmFtc1tpXS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERlY2xhcmVkSWRlbnRpZmllcihub2RlLmlkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQ29udGludWVTdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kQ29udGludWVTdGF0ZW1lbnQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1TdGF0ZW1lbnRTcGxpdChub2RlLCBbe3ByZTogdHJ1ZX1dKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LklmU3RhdGVtZW50OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1TdGF0ZW1lbnRTcGxpdChub2RlLCBbe3Byb3A6IFwidGVzdFwiLCBwcmU6IHRydWV9XSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVN0YXRlbWVudFNwbGl0KG5vZGUsIFt7cHJvcDogXCJhcmd1bWVudFwiLCBwcmU6IHRydWV9XSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5XaGlsZVN0YXRlbWVudDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtU3RhdGVtZW50U3BsaXQobm9kZSwgW3twcm9wOiBcInRlc3RcIiwgcHJlOiB0cnVlLCBwb3N0OiB0cnVlfV0sIFwiYm9keVwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZvclN0YXRlbWVudDpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFjdGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuc2tpcEV4dHJhY3Rpb24uZm9ySW5pdFVwZGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdGlvbnMucHVzaCh7cHJvcDogXCJpbml0XCIsIHByZTogdHJ1ZSwgZXh0cmFjdDogdHJ1ZX0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBleHRyYWN0aW9ucy5wdXNoKHtwcm9wOiBcInRlc3RcIiwgcHJlOiB0cnVlLCBwb3N0OiB0cnVlfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLnNraXBFeHRyYWN0aW9uLmZvckluaXRVcGRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3Rpb25zLnB1c2goe3Byb3A6IFwidXBkYXRlXCIsIHBvc3Q6IHRydWUsIGV4dHJhY3Q6IHRydWV9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVN0YXRlbWVudFNwbGl0KG5vZGUsIGV4dHJhY3Rpb25zLCBcImJvZHlcIik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Eb1doaWxlU3RhdGVtZW50OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1TdGF0ZW1lbnRTcGxpdChub2RlLCBbe3Byb3A6IFwidGVzdFwiLCBwb3N0OiB0cnVlfV0sIFwiYm9keVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGV4aXROb2RlOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaChub2RlLnR5cGUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRUbXBEZWNsYXJhdGlvbihub2RlKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlByb2dyYW06XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVSZWR1bmRhbnRCbG9ja3Mobm9kZSwgXCJib2R5XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFRtcERlY2xhcmF0aW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQmxvY2tTdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlUmVkdW5kYW50QmxvY2tzKG5vZGUsIFwiYm9keVwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlN3aXRjaENhc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlUmVkdW5kYW50QmxvY2tzKG5vZGUsIFwiY29uc2VxdWVudFwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNvbnRpbnVlU3RhdGVtZW50OlxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLl9leHRlbmRlZDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LldoaWxlU3RhdGVtZW50OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRm9yU3RhdGVtZW50OlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRG9XaGlsZVN0YXRlbWVudDpcclxuICAgICAgICAgICAgICAgICAgICBpZihub2RlLl9wcmVDb250aW51ZVN0YWNrZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5fcHJlQ29udGludWVTdGFja2VkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZUNvbnRpbnVlU3RhdGVtZW50cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgYWRkRGVjbGFyZWRJZGVudGlmaWVyOiBmdW5jdGlvbihuYW1lKXtcclxuICAgICAgICAgICAgdmFyIGRlY2xhcmVkID0gdGhpcy5nZXRTY29wZSgpLmRlY2xhcmVkO1xyXG4gICAgICAgICAgICBpZihkZWNsYXJlZC5pbmRleE9mKG5hbWUpID09IC0xKVxyXG4gICAgICAgICAgICAgICAgZGVjbGFyZWQucHVzaChuYW1lKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc05hbWVEZWNsYXJlZDogZnVuY3Rpb24obmFtZSwgdW50eXBlZCl7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5zY29wZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5zY29wZXNbaV0uZGVjbGFyZWQuaW5kZXhPZihuYW1lKSAhPSAtMSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih1bnR5cGVkICYmIHRoaXMuZ2V0U2NvcGUoKS50bXBEZWNsYXJlZC5pbmRleE9mKG5hbWUpICE9IC0xKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRGcmVlTmFtZTogZnVuY3Rpb24odHlwZSwga2luZCl7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRJZHggPSAwO1xyXG4gICAgICAgICAgICB2YXIgdW50eXBlZCA9ICh0eXBlID09PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBwcmVmaXggPSB0aGlzLl9nZXRUeXBlZFByZWZpeCh0eXBlLCBraW5kKTtcclxuICAgICAgICAgICAgZG97XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVmaXggKyByZXN1bHRJZHgrKztcclxuICAgICAgICAgICAgfXdoaWxlKHRoaXMuaXNOYW1lRGVjbGFyZWQocmVzdWx0LCB1bnR5cGVkKSB8fCB0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkLmluZGV4T2YocmVzdWx0KSAhPSAtMSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlbWVudFRtcFVzZWQucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLmdldFNjb3BlKCk7XHJcbiAgICAgICAgICAgIGlmKHNjb3BlLnRtcERlY2xhcmVkLmluZGV4T2YocmVzdWx0KSA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICBzY29wZS50bXBEZWNsYXJlZC5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICBzY29wZS50bXBEZWNsYXJlZFR5cGVzLnB1c2goe3R5cGU6IHR5cGUsIGtpbmQ6IGtpbmR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFN0YXRlbWVudFRtcFVzZWRDb3VudDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFN0YXRlbWVudFRtcFVzZWQubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVkdWNlU3RhdGVtZW50VG1wVXNlZDogZnVuY3Rpb24obmV3Q291bnQpe1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkLmxlbmd0aCA9IG5ld0NvdW50O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZVN0YXRlbWVudFRtcFVzZWRBZnRlcjogZnVuY3Rpb24obmFtZSl7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLmN1cnJlbnRTdGF0ZW1lbnRUbXBVc2VkLmluZGV4T2YobmFtZSk7XHJcbiAgICAgICAgICAgIGlmKGlkeCA9PSAtMSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZHgrKztcclxuICAgICAgICAgICAgdmFyIHJlbW92ZUNvdW50ID0gdGhpcy5jdXJyZW50U3RhdGVtZW50VG1wVXNlZC5sZW5ndGggLSBpZHg7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlbWVudFRtcFVzZWQuc3BsaWNlKGlkeCwgcmVtb3ZlQ291bnQgKTtcclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgX2dldFR5cGVkUHJlZml4OiBmdW5jdGlvbih0eXBlLCBraW5kKXtcclxuICAgICAgICAgICAgaWYodHlwZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiX3RtcFwiO1xyXG4gICAgICAgICAgICBzd2l0Y2godHlwZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVzLkJPT0xFQU46IHJldHVybiBcIl9ib29sVG1wXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVzLk5VTUJFUjogcmV0dXJuIFwiX251bVRtcFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlcy5JTlQ6IHJldHVybiBcIl9pbnRUbXBcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZXMuU1RSSU5HOiByZXR1cm4gXCJfc3RyaW5nVG1wXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVzLk9CSkVDVDogc3dpdGNoKGtpbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2luZHMuRkxPQVQyOiByZXR1cm4gXCJfdmVjMlRtcFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2luZHMuRkxPQVQzOiByZXR1cm4gXCJfdmVjM1RtcFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2luZHMuRkxPQVQ0OiByZXR1cm4gXCJfdmVjNFRtcFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2luZHMuTUFUUklYMzogcmV0dXJuIFwiX21hdDNUbXBcIjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEtpbmRzLk1BVFJJWDQ6IHJldHVybiBcIl9tYXQ0VG1wXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwZXJmb3JtU3RhdGVtZW50U3BsaXQ6IGZ1bmN0aW9uKG5vZGUsIHN1YlByb3BlcnRpZXMsIGJvZHlQcm9wZXJ0eSl7XHJcbiAgICAgICAgICAgIGlmKGJvZHlQcm9wZXJ0eSAmJiAhbm9kZS5fcHJlQ29udGludWVTdGFja2VkKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlQ29udGludWVTdGF0ZW1lbnRzLnB1c2goW10pO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5fcHJlQ29udGludWVTdGFja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsTm9kZSA9IG5vZGUsIHJldHVybk5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICB2YXIgaSA9IHN1YlByb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gc3ViUHJvcGVydGllc1tpXS5wcm9wO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IG9yaWdpbmFsTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmKHByb3BlcnR5KSB0YXJnZXQgPSBvcmlnaW5hbE5vZGVbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgaWYocHJvcGVydHkgJiYgc3ViUHJvcGVydGllc1tpXS5leHRyYWN0KXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uR2F0aGVyU3BsaXRJbmZvKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGVtZW50VG1wVXNlZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXNzaWdubWVudHNUb0JlUHJlcGVuZGVkID0gdGFyZ2V0ID8gW3RhcmdldF0gOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE5vZGVbcHJvcGVydHldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5nYXRoZXJTdGF0bWVudFNwbGl0SW5mbyh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE5vZGVbcHJvcGVydHldID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuTm9kZSA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuYXNzaWdubWVudHNUb0JlUHJlcGVuZGVkLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN1YlByb3BlcnRpZXNbaV0ucHJlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuTm9kZSA9IHRoaXMuZ2V0U3BsaXR0ZWRTdGF0ZW1lbnRCbG9jayh0aGlzLmFzc2lnbm1lbnRzVG9CZVByZXBlbmRlZCwgcmV0dXJuTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN1YlByb3BlcnRpZXNbaV0ucG9zdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gb3JpZ2luYWxOb2RlW2JvZHlQcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gdGhpcy5nZXRTcGxpdHRlZFN0YXRlbWVudEJsb2NrKHRoaXMuYXNzaWdubWVudHNUb0JlUHJlcGVuZGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYm9keSAmJiBib2R5LnR5cGUgPT0gU3ludGF4LkJsb2NrU3RhdGVtZW50KXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LmJvZHkucHVzaChzdGF0ZW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYm9keSkgc3RhdGVtZW50cy5ib2R5LnVuc2hpZnQoYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE5vZGVbYm9keVByb3BlcnR5XSA9IHN0YXRlbWVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQcmVDb250aW51ZVN0YXRlbWVudHModGhpcy5hc3NpZ25tZW50c1RvQmVQcmVwZW5kZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuTm9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBleHRlbmRDb250aW51ZVN0YXRlbWVudDogZnVuY3Rpb24obm9kZSl7XHJcbiAgICAgICAgICAgIGlmKG5vZGUuX2V4dGVuZGVkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBub2RlLl9leHRlbmRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gdGhpcy5nZXRQcmVDb250aW51ZVN0YXRlbWVudHMoKTtcclxuICAgICAgICAgICAgaWYoc3RhdGVtZW50cy5sZW5ndGggPT0gMCApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3BsaXR0ZWRTdGF0ZW1lbnRCbG9jayhzdGF0ZW1lbnRzLG5vZGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICBnZXRTcGxpdHRlZFN0YXRlbWVudEJsb2NrOiBmdW5jdGlvbihzdGF0ZW1lbnRzLCBub2RlKXtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CbG9ja1N0YXRlbWVudCxcclxuICAgICAgICAgICAgICAgIGJvZHk6IFtdLFxyXG4gICAgICAgICAgICAgICAgbG9jOiBub2RlICYmIG5vZGUubG9jXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBhc3NpZ25tZW50ID0gQmFzZS5kZWVwRXh0ZW5kKHt9LCBzdGF0ZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBhc3NpZ25tZW50LFxyXG4gICAgICAgICAgICAgICAgICAgbG9jOiBhc3NpZ25tZW50LmxvY1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYobm9kZSAmJiAobm9kZS50eXBlICE9IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50IHx8ICF0aGlzLmlzUmVkdW5kYW50KG5vZGUpKSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYm9keS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG5cclxuICAgICAgICByZW1vdmVSZWR1bmRhbnRCbG9ja3M6IGZ1bmN0aW9uKG5vZGUsIHByb3BlcnR5TmFtZSl7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gbm9kZVtwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICAgICAgaWYobGlzdFtpXS50eXBlID09IFN5bnRheC5CbG9ja1N0YXRlbWVudCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbaSwgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGxpc3RbaV0uYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWRkVG1wRGVjbGFyYXRpb246IGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgICAgICB2YXIgdG1wRGVjbGFyZWQgPSB0aGlzLmdldFNjb3BlKCkudG1wRGVjbGFyZWQsXHJcbiAgICAgICAgICAgICAgICB0bXBEZWNsYXJlZFR5cGVzID0gdGhpcy5nZXRTY29wZSgpLnRtcERlY2xhcmVkVHlwZXM7XHJcbiAgICAgICAgICAgIGlmKHRtcERlY2xhcmVkLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgbGlzdDtcclxuICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5Qcm9ncmFtKVxyXG4gICAgICAgICAgICAgICAgbGlzdCA9IG5vZGUuYm9keTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbGlzdCA9IG5vZGUuYm9keS5ib2R5O1xyXG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBpZihsaXN0WzBdLnR5cGUgPT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pXHJcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IGxpc3RbMF07XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidmFyXCJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsaXN0LnVuc2hpZnQoZGVjbGFyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXBEZWNsYXJlZC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRvciA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlIDogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcixcclxuICAgICAgICAgICAgICAgICAgICBpZDogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogdG1wRGVjbGFyZWRbaV0gfSxcclxuICAgICAgICAgICAgICAgICAgICBpbml0OiBudWxsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYodG1wRGVjbGFyZWRUeXBlc1tpXS50eXBlICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIEFOTk8oZGVjbGFyYXRvcikuc2V0VHlwZSh0bXBEZWNsYXJlZFR5cGVzW2ldLnR5cGUsIHRtcERlY2xhcmVkVHlwZXNbaV0ua2luZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMucHVzaChkZWNsYXJhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHRoaXMucG9wU2NvcGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFNwbGl0VHJhdmVyc2VyO1xyXG5cclxufShtb2R1bGUpKTtcclxuIiwiKGZ1bmN0aW9uIChtb2R1bGUpIHtcclxuXHJcbiAgICAvLyBkZXBlbmRlbmNpZXNcclxuICAgIHZhciB3YWxrZXIgPSByZXF1aXJlKCd3YWxrZXMnKTtcclxuICAgIHZhciB3b3JrbGlzdCA9IHJlcXVpcmUoJ2FuYWx5c2VzJyk7XHJcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpO1xyXG4gICAgdmFyIGNvZGVnZW4gPSByZXF1aXJlKCdlc2NvZGVnZW4nKTtcclxuICAgIHZhciBUb29scyA9IHJlcXVpcmUoXCIuLy4uL3NldHRvb2xzLmpzXCIpO1xyXG4gICAgdmFyIGVzZ3JhcGggPSByZXF1aXJlKCdlc2dyYXBoJyk7XHJcblxyXG5cclxuICAgIC8vIHNob3J0Y3V0c1xyXG4gICAgdmFyIFN5bnRheCA9IGNvbW1vbi5TeW50YXg7XHJcbiAgICB2YXIgU2V0ID0gd29ya2xpc3QuU2V0O1xyXG4gICAgdmFyIEFOTk8gPSBjb21tb24uQU5OTztcclxuXHJcbiAgICAvLyBkZWZpbmVzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NzaWJsZSBzZW1hbnRpY3NcclxuICAgICAqIEBlbnVtXHJcbiAgICAgKiBAdHlwZSB7e0NPTE9SOiBzdHJpbmcsIE5PUk1BTDogc3RyaW5nLCBVTktOT1dOOiBzdHJpbmd9fVxyXG4gICAgICovXHJcbiAgICB2YXIgU2VtYW50aWMgPSB7XHJcbiAgICAgICAgQ09MT1I6ICdjb2xvcicsXHJcbiAgICAgICAgTk9STUFMOiAnbm9ybWFsJyxcclxuICAgICAgICBVTktOT1dOOiAndW5rbm93bidcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNmZ1xyXG4gICAgICogQHBhcmFtIHtGbG93Tm9kZX0gc3RhcnRcclxuICAgICAqIEByZXR1cm5zIHtNYXB9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGUoYm9keSwgc3RhcnQpIHtcclxuXHJcbiAgICAgICAgdmFyIGNmZyA9IGVzZ3JhcGgoYm9keSwgeyBvbWl0RXhjZXB0aW9uczogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHdvcmtsaXN0KGNmZywgdHJhbnNmZXJGdW5jdGlvbiwge1xyXG4gICAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCcsXHJcbiAgICAgICAgICAgIHN0YXJ0OiBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgIG1lcmdlOiB3b3JrbGlzdC5tZXJnZShtZXJnZVNlbWFudGljcylcclxuICAgICAgICB9KTtcclxuICAgICAgICAvL1Rvb2xzLnByaW50TWFwKHJlc3VsdCwgY2ZnKTtcclxuICAgICAgICByZXR1cm4gYm9keTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7U2V0fSBpbnB1dFxyXG4gICAgICogQHRoaXMge0Zsb3dOb2RlfVxyXG4gICAgICogQHJldHVybnMge1NldH0gb3V0cHV0IHdpdGggcmVzcGVjdCB0byBpbnB1dFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cmFuc2ZlckZ1bmN0aW9uKGlucHV0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZSB8fCAhdGhpcy5hc3ROb2RlKSAvLyBTdGFydCBhbmQgZW5kIG5vZGUgZG8gbm90IGluZmx1ZW5jZSB0aGUgcmVzdWx0XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuXHJcbiAgICAgICAgLy8gTG9jYWxcclxuICAgICAgICB2YXIga2lsbCA9IHRoaXMua2lsbCA9IHRoaXMua2lsbCB8fCBUb29scy5maW5kVmFyaWFibGVBc3NpZ25tZW50cyh0aGlzLmFzdE5vZGUpO1xyXG4gICAgICAgIHZhciBnZW5lcmF0ZWREZXBlbmRlbmNpZXMgPSB0aGlzLmdlbmVyYXRlID0gdGhpcy5nZW5lcmF0ZSB8fCBnZW5lcmF0ZVNlbWFudGljRGVwZW5kZW5jaWVzKHRoaXMuYXN0Tm9kZSwga2lsbCk7XHJcbiAgICAgICAgdmFyIGdlbmVyYXRlZFNlbWFudGljcyA9IHRoaXMuZ2VuZXJhdGVkU2VtYW50aWNzID0gdGhpcy5nZW5lcmF0ZWRTZW1hbnRpY3MgfHwgZ2VuZXJhdGVOZXdTZW1hbnRpY3ModGhpcy5hc3ROb2RlKTtcclxuICAgICAgICAvL2dlbmVyYXRlICYmIGNvbnNvbGUubG9nKHRoaXMubGFiZWwsIGdlbmVyYXRlKTtcclxuXHJcbiAgICAgICAgLy8gRGVwZW5kcyBvbiBpbnB1dFxyXG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBudWxsO1xyXG4gICAgICAgIGlmIChnZW5lcmF0ZWREZXBlbmRlbmNpZXMgJiYgZ2VuZXJhdGVkRGVwZW5kZW5jaWVzLmRlcHMuc2l6ZSkge1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5hbWUgPT0gZ2VuZXJhdGVkRGVwZW5kZW5jaWVzLmRlZjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgICAgIGdlbmVyYXRlZERlcGVuZGVuY2llcy5kZXBzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7IG5hbWU6IGRlcCwgdHlwZTogZW50cnlbMF0udHlwZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5hZGQob2JqKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBraWxsZWQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAga2lsbC5mb3JFYWNoKGZ1bmN0aW9uICh0b0tpbGwpIHtcclxuICAgICAgICAgICAga2lsbGVkID0gbmV3IFNldChpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5hbWUgPT0gdG9LaWxsO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlU2VtYW50aWNzKFNldC5taW51cyhpbnB1dCwga2lsbGVkKSwgbWVyZ2VTZW1hbnRpY3MoZGVwZW5kZW5jaWVzLCBnZW5lcmF0ZWRTZW1hbnRpY3MpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpYWwgbWVyZ2UgZnVuY3Rpb24gdGhhdCBtZXJnZXMgZW50cmllcyB3aXRoIHNhbWUgbmFtZXNcclxuICAgICAqIHRvIGEgbmV3IGVudHJ5IHdpdGggdG9wIGVsZW1lbnQgU2VtYW50aWMuVU5LTk9XTlxyXG4gICAgICogQHBhcmFtIHtTZXR9IGFcclxuICAgICAqIEBwYXJhbSB7U2V0fSBiXHJcbiAgICAgKiBAcmV0dXJucyB7U2V0fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtZXJnZVNlbWFudGljcyhhLCBiKSB7XHJcblxyXG4gICAgICAgIHZhciBtZXJnZUVudHJ5ID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBhLm5hbWUsIHR5cGU6IGEudHlwZSAhPSBiLnR5cGUgPyBTZW1hbnRpYy5VTktOT1dOIDogYS50eXBlIH07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCFhICYmIGIpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KGIpO1xyXG4gICAgICAgIHZhciBzID0gbmV3IFNldChhKTtcclxuICAgICAgICBpZiAoYilcclxuICAgICAgICAgICAgYi5mb3JFYWNoKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0QSA9IGEuZmlsdGVyKGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIubmFtZSA9PSBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBpbiBBLCBqdXN0IGFkZCBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0QS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcy5hZGQoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gQSwgYW5kIHR5cGUgaXMgZGlmZmVyZW50OiBtZXJnZVR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdEFbMF0udHlwZSAhPT0gZWxlbS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmFkZChtZXJnZUVudHJ5KGVsZW0sIHJlc3VsdEFbMF0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMuZGVsZXRlKHJlc3VsdEFbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVNlbWFudGljRGVwZW5kZW5jaWVzKGFzdCwgZGVmcykge1xyXG5cclxuICAgICAgICB2YXIgZGVmQ291bnQgPSBkZWZzLnNpemU7XHJcbiAgICAgICAgaWYgKGRlZkNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmIChkZWZDb3VudCA+IDEpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGUgbm90IHNhbml0aXplZCwgZm91bmQgbXVsdGlwbGUgZGVmaW5pdGlvbnMgaW4gb25lIHN0YXRlbWVudFwiKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgZGVmOiBkZWZzLnZhbHVlcygpWzBdLCBkZXBzOiBldmFsdWF0ZVNlbWFudGljRGVwZW5kZW5jaWVzKGFzdCkgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBldmFsdWF0ZVNlbWFudGljRGVwZW5kZW5jaWVzKGFzdCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgaWYgKCFhc3QgJiYgIWFzdC50eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB3YWxrZXIoYXN0LCB7XHJcbiAgICAgICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAocmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLnJpZ2h0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiBmdW5jdGlvbiAocmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLmluaXQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIE5ld0V4cHJlc3Npb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqZWN0LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgJiYgdGhpcy5wcm9wZXJ0eS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZCh0aGlzLm9iamVjdC5uYW1lICsgXCIuXCIgKyB0aGlzLnByb3BlcnR5Lm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGVlLnR5cGUgPT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGVlID0gdGhpcy5jYWxsZWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1lbWJlckhhbmRsZXJzLmhhc093blByb3BlcnR5KGNhbGxlZS5vYmplY3QubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5SGFuZGxlciA9IE1lbWJlckhhbmRsZXJzW2NhbGxlZS5vYmplY3QubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eUhhbmRsZXIuaGFzT3duUHJvcGVydHkoY2FsbGVlLnByb3BlcnR5Lm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHByb3BlcnR5SGFuZGxlcltjYWxsZWUucHJvcGVydHkubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHRoaXMuYXJndW1lbnRzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBvbiBlbnZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBub3Qgc2FmZS4gUGVyZm9ybSBvbiBhbm5vdGF0ZWQgQVNUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChWZWMzSGFuZGxlci5oYXNPd25Qcm9wZXJ0eShjYWxsZWUucHJvcGVydHkubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBWZWMzSGFuZGxlcltjYWxsZWUucHJvcGVydHkubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKGNhbGxlZSwgdGhpcy5hcmd1bWVudHMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmhhbmRsZWQ6IFwiLCBjb2RlZ2VuLmdlbmVyYXRlKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TmFtZShub2RlKSB7XHJcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm5hbWU7XHJcbiAgICAgICAgICAgIGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5vYmplY3QubmFtZSArIFwiLlwiICsgbm9kZS5wcm9wZXJ0eS5uYW1lO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIG5hbWUgZm9yXCIsIGNvZGVnZW4uZ2VuZXJhdGUobm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiP1wiXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IFN1cHBvcnQgbW9yZSBmdW5jdGlvbnNcclxuICAgIHZhciBNYXRoSGFuZGxlcnMgPSB7XHJcbiAgICAgICAgbWl4OiBmdW5jdGlvbiAoYXJncywgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFNldC51bmlvbihyZXN1bHQsIGV2YWx1YXRlU2VtYW50aWNEZXBlbmRlbmNpZXMoYXJnc1swXSkpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBTZXQudW5pb24ocmVzdWx0LCBldmFsdWF0ZVNlbWFudGljRGVwZW5kZW5jaWVzKGFyZ3NbMV0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBWZWMzSGFuZGxlciA9IHtcclxuICAgICAgICBub3JtYWxpemU6IGZ1bmN0aW9uIChjYWxsZWUsIGFyZ3MsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHQuYWRkKGdldE5hbWUoY2FsbGVlLm9iamVjdCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbXVsOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFkZChnZXROYW1lKGNhbGxlZS5vYmplY3QpKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gU2V0LnVuaW9uKHJlc3VsdCwgZXZhbHVhdGVTZW1hbnRpY0RlcGVuZGVuY2llcyhhcmdzWzBdKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmFyIE1lbWJlckhhbmRsZXJzID0ge1xyXG4gICAgICAgIFwiTWF0aFwiOiBNYXRoSGFuZGxlcnNcclxuICAgIH07XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTmV3U2VtYW50aWNzKGFzdE5vZGUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFNldCgpO1xyXG5cclxuICAgICAgICB3YWxrZXIoYXN0Tm9kZSwge1xyXG4gICAgICAgICAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxlZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIGlzQlJERkNhbGwodGhpcy5jYWxsZWUub2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5jYWxsZWUucHJvcGVydHkubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRpZmZ1c2VcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBob25nXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJlKFNlbWFudGljLkNPTE9SLCB0aGlzLmFyZ3VtZW50c1swXSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmUoU2VtYW50aWMuTk9STUFMLCB0aGlzLmFyZ3VtZW50c1sxXSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZWN1cnNlKHRoaXMuY2FsbGVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLmNhbGxlZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLmFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0JSREZDYWxsKGFzdCkge1xyXG4gICAgICAgIGlmICghYXN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFzdC50eXBlID09IFN5bnRheC5OZXdFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3QuY2FsbGVlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgJiYgYXN0LmNhbGxlZS5uYW1lID09PSBcIlNoYWRlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhc3QudHlwZSA9PSBTeW50YXguQ2FsbEV4cHJlc3Npb24gJiYgYXN0LmNhbGxlZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0JSREZDYWxsKGFzdC5jYWxsZWUub2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlY2xhcmUoc2VtYW50aWMsIGFzdE5vZGUsIHZhcmlhYmxlcykge1xyXG4gICAgICAgIHdhbGtlcihhc3ROb2RlLCB7XHJcbiAgICAgICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIEFOTk8odGhpcykuc2V0U2VtYW50aWMoc2VtYW50aWMpO1xyXG4gICAgICAgICAgICAgICAgYWRkTWVyZ2VkKHZhcmlhYmxlcywge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBzZW1hbnRpY1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iamVjdC50eXBlID09IFN5bnRheC5JZGVudGlmaWVyICYmIHRoaXMucHJvcGVydHkudHlwZSA9PSBTeW50YXguSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIEFOTk8odGhpcykuc2V0U2VtYW50aWMoc2VtYW50aWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZE1lcmdlZCh2YXJpYWJsZXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZ2V0TmFtZSh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogc2VtYW50aWNcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZE1lcmdlZCh0YXJnZXQsIGVsZW0pIHtcclxuICAgICAgICB2YXIgc2FtZU5hbWUgPSB0YXJnZXQuZmlsdGVyKGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIubmFtZSA9PSBlbGVtLm5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFzYW1lTmFtZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZChlbGVtKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoc2FtZU5hbWVbMF0udHlwZSAhPT0gZWxlbS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkKHtuYW1lOiBlbGVtLm5hbWUsIHR5cGU6IFNlbWFudGljLlVOS05PV059KTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5kZWxldGUoc2FtZU5hbWVbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXB1dGUuU2VtYW50aWMgPSBTZW1hbnRpYztcclxuICAgIG1vZHVsZS5leHBvcnRzID0gY29tcHV0ZTtcclxuXHJcbn0obW9kdWxlKSk7XHJcbiIsIlxyXG52YXIgU2V0ID0gcmVxdWlyZSgnYW5hbHlzZXMnKS5TZXQ7XHJcbnZhciB3YWxrID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpO1xyXG52YXIgY29kZWdlbiA9IHJlcXVpcmUoJ2VzY29kZWdlbicpO1xyXG5cclxudmFyIFN5bnRheCA9IHdhbGsuU3ludGF4O1xyXG5cclxudmFyIFRvb2xzID0ge1xyXG5cclxuICAgIGdldFNldExhYmVsczogZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICBpZiAoIXMpXHJcbiAgICAgICAgICAgIHJldHVybiBcIlNldDogbnVsbFwiO1xyXG5cclxuICAgICAgICBpZiAoIXMuc2l6ZSlcclxuICAgICAgICAgICAgcmV0dXJuIFwiU2V0OiB7fVwiO1xyXG5cclxuICAgICAgICByZXR1cm4gXCJTZXQ6IHtcIiArIHMudmFsdWVzKCkubWFwKGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuLmxhYmVsO1xyXG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKSArIFwifVwiO1xyXG4gICAgfSxcclxuXHJcbiAgICBwcmludE1hcDogZnVuY3Rpb24gKG1hcCwgY2ZnLCBjYikge1xyXG4gICAgICAgIGNiID0gY2IgfHwgSlNPTi5zdHJpbmdpZnk7XHJcbiAgICAgICAgZm9yICh2YXIgbm9kZSBpbiBjZmdbMl0pIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBjZmdbMl1bbm9kZV07XHJcbiAgICAgICAgICAgIGlmIChuLmxhYmVsIHx8IG4udHlwZSB8fCAhbi5hc3ROb2RlKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobi5sYWJlbCB8fCBuLnR5cGUsIGNiKG1hcC5nZXQobikpKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29kZWdlbi5nZW5lcmF0ZShuLmFzdE5vZGUpLCBjYihtYXAuZ2V0KG4pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBmaW5kVmFyaWFibGVBc3NpZ25tZW50czogZnVuY3Rpb24gKGFzdCwgaWdub3JlVW5pbml0YWxpemVkRGVjbGFyYXRpb25zKSB7XHJcbiAgICAgICAgdmFyIGRlZmluaXRpb25zID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHdhbGsudHJhdmVyc2UoYXN0LCB7XHJcbiAgICAgICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zLmFkZChub2RlLmxlZnQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5pZC50eXBlID09IFN5bnRheC5JZGVudGlmaWVyICYmICghaWdub3JlVW5pbml0YWxpemVkRGVjbGFyYXRpb25zIHx8IG5vZGUuaW5pdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zLmFkZChub2RlLmlkLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlVwZGF0ZUV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zLmFkZChub2RlLmFyZ3VtZW50Lm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbnM7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRvb2xzO1xyXG5cclxuXHJcbiIsIihmdW5jdGlvbiAobW9kdWxlKSB7XHJcblxyXG4gICAgLy8gZGVwZW5kZW5jaWVzXHJcbiAgICB2YXIgd2Fsa2VyID0gcmVxdWlyZSgnd2Fsa2VzJyk7XHJcbiAgICB2YXIgd29ya2xpc3QgPSByZXF1aXJlKCdhbmFseXNlcycpO1xyXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi9iYXNlL2NvbW1vbi5qc1wiKTtcclxuICAgIHZhciBlc2dyYXBoID0gcmVxdWlyZSgnZXNncmFwaCcpO1xyXG4gICAgdmFyIGNvZGVnZW4gPSByZXF1aXJlKCdlc2NvZGVnZW4nKTtcclxuICAgIHZhciBUb29scyA9IHJlcXVpcmUoXCIuL3NldHRvb2xzLmpzXCIpO1xyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBTcGFjZVR5cGUgPSBTaGFkZS5TcGFjZVR5cGUsXHJcbiAgICAgICAgVmVjdG9yVHlwZSA9IFNoYWRlLlZlY3RvclR5cGUsXHJcbiAgICAgICAgU3BhY2VWZWN0b3JUeXBlID0gU2hhZGUuU3BhY2VWZWN0b3JUeXBlO1xyXG5cclxuXHJcbiAgICAvLyBzaG9ydGN1dHNcclxuICAgIHZhciBTeW50YXggPSBjb21tb24uU3ludGF4O1xyXG4gICAgdmFyIFNldCA9IHdvcmtsaXN0LlNldCxcclxuICAgICAgICBUeXBlcyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEtpbmRzID0gU2hhZGUuT0JKRUNUX0tJTkRTO1xyXG5cclxuICAgIC8vIGRlZmluZXNcclxuXHJcblxyXG4gICAgdmFyIGNfcmVzdWx0UG9pbnRPayA9IHRydWUsIGNfcmVzdWx0Tm9ybWFsT2sgPSB0cnVlLFxyXG4gICAgICAgIGNfY3VzdG9tRnVuY3Rpb25Qcm9wYWdhdGlvbnMgPSBudWxsLCBjX2RlYnVnID0gZmFsc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gYW5hbHl6ZShmdW5jdGlvbkFhc3QsIGN1c3RvbUZ1bmN0aW9uUHJvcGFnYXRpb25zKSB7XHJcbiAgICAgICAgdmFyIGNmZyA9IGVzZ3JhcGgoZnVuY3Rpb25BYXN0LmJvZHksIHsgb21pdEV4Y2VwdGlvbnM6IHRydWUgfSk7XHJcbiAgICAgICAgY19yZXN1bHRQb2ludE9rID0gdHJ1ZTsgY19yZXN1bHROb3JtYWxPayA9IHRydWU7XHJcbiAgICAgICAgY19jdXN0b21GdW5jdGlvblByb3BhZ2F0aW9ucyA9IGN1c3RvbUZ1bmN0aW9uUHJvcGFnYXRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSB3b3JrbGlzdChjZmcsIHRyYW5zZmVyU3BhY2VJbmZvLCB7XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJyxcclxuICAgICAgICAgICAgc3RhcnQ6IG51bGwsXHJcbiAgICAgICAgICAgIG1lcmdlOiB3b3JrbGlzdC5tZXJnZShtZXJnZVNwYWNlSW5mbylcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgc3RhcnROb2RlUmVzdWx0ID0gb3V0cHV0LmdldChjZmdbMF0pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICB2YXIgdHJhbmZlckVudHJ5ID0ge1xyXG4gICAgICAgICAgICB0cmFuc2ZlclBvaW50T2s6IGNfcmVzdWx0UG9pbnRPayxcclxuICAgICAgICAgICAgdHJhbnNmZXJOb3JtYWxPazogY19yZXN1bHROb3JtYWxPayxcclxuICAgICAgICAgICAgdHJhbnNmZXJBcmdzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRyYW5zZmVyU3BhY2VzID0ge307XHJcbiAgICAgICAgc3RhcnROb2RlUmVzdWx0LmZvckVhY2goZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICB2YXIgc3BsaXQgPSBlbGVtLnNwbGl0KFwiO1wiKSwgbmFtZSA9IHNwbGl0WzBdLCBzcGFjZSA9IHNwbGl0WzFdKjE7XHJcbiAgICAgICAgICAgIGlmKFNoYWRlLmdldFNwYWNlRnJvbVNwYWNlVmVjdG9yKHNwYWNlKSA9PSBTcGFjZVR5cGUuUkVTVUxUKXtcclxuICAgICAgICAgICAgICAgIHRyYW5zZmVyU3BhY2VzW25hbWVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighcmVzdWx0W25hbWVdKSByZXN1bHRbbmFtZV0gPSBbXTtcclxuICAgICAgICAgICAgcmVzdWx0W25hbWVdLnB1c2goc3BhY2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbkFhc3QucGFyYW1zLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBmdW5jdGlvbkFhc3QucGFyYW1zW2ldLm5hbWU7XHJcbiAgICAgICAgICAgIHRyYW5mZXJFbnRyeS50cmFuc2ZlckFyZ3MucHVzaCggdHJhbnNmZXJTcGFjZXNbbmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjX2N1c3RvbUZ1bmN0aW9uUHJvcGFnYXRpb25zW2Z1bmN0aW9uQWFzdC5pZC5uYW1lXSA9IHRyYW5mZXJFbnRyeTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTcGFjZUluZm8oYXN0LCBrZXksIHZhbHVlKXtcclxuICAgICAgICBpZighYXN0LnNwYWNlSW5mbylcclxuICAgICAgICAgICAgYXN0LnNwYWNlSW5mbyA9IHt9O1xyXG4gICAgICAgIGFzdC5zcGFjZUluZm9ba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0U3BhY2VJbmZvU3BhY2VzKGFzdCwga2V5LCBzcGFjZXMpe1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBzcGFjZXMgJiYgc3BhY2VzLmZpbHRlcihmdW5jdGlvbihzcGFjZSl7IHJldHVybiBTaGFkZS5nZXRTcGFjZUZyb21TcGFjZVZlY3RvcihzcGFjZSkgIT0gU3BhY2VUeXBlLlJFU1VMVCB9KTtcclxuICAgICAgICBzZXRTcGFjZUluZm8oYXN0LCBrZXksIHZhbHVlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1NldH0gaW5wdXRcclxuICAgICAqIEB0aGlzIHtGbG93Tm9kZX1cclxuICAgICAqIEByZXR1cm5zIHtTZXR9IG91dHB1dCB3aXRoIHJlc3BlY3QgdG8gaW5wdXRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdHJhbnNmZXJTcGFjZUluZm8oaW5wdXQpIHtcclxuICAgICAgICBpZiAodGhpcy50eXBlIHx8ICF0aGlzLmFzdE5vZGUpIC8vIFN0YXJ0IGFuZCBlbmQgbm9kZSBkbyBub3QgaW5mbHVlbmNlIHRoZSByZXN1bHRcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG5cclxuICAgICAgICAvLyBMb2NhbFxyXG4gICAgICAgIHZhciBraWxsID0gdGhpcy5raWxsID0gdGhpcy5raWxsIHx8IFRvb2xzLmZpbmRWYXJpYWJsZUFzc2lnbm1lbnRzKHRoaXMuYXN0Tm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGdlbmVyYXRlZERlcGVuZGVuY2llcyA9IHRoaXMuZ2VuZXJhdGUgPSB0aGlzLmdlbmVyYXRlIHx8IGdlbmVyYXRlU3BhY2VEZXBlbmRlbmNpZXModGhpcy5hc3ROb2RlLCBraWxsKTtcclxuICAgICAgICAvL2dlbmVyYXRlICYmIGNvbnNvbGUubG9nKHRoaXMubGFiZWwsIGdlbmVyYXRlKTtcclxuXHJcbiAgICAgICAgLy8gRGVwZW5kcyBvbiBpbnB1dFxyXG4gICAgICAgIHZhciBkZXBTcGFjZUluZm8gPSBuZXcgU2V0KCksIGZpbmFsU3BhY2VzID0gbnVsbCwgc3BhY2VUeXBlcyA9IG51bGw7XHJcbiAgICAgICAgc2V0U3BhY2VJbmZvKHRoaXMuYXN0Tm9kZSwgXCJ0cmFuc2ZlclNwYWNlc1wiLCBudWxsKTtcclxuICAgICAgICBzZXRTcGFjZUluZm8odGhpcy5hc3ROb2RlLCBcImhhc1NwYWNlT3ZlcnJpZGVzXCIsIGdlbmVyYXRlZERlcGVuZGVuY2llcy5kZXBlbmRlbmNpZXMuc3BhY2VPdmVycmlkZXMubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgaWYoZ2VuZXJhdGVkRGVwZW5kZW5jaWVzLmRlZil7XHJcbiAgICAgICAgICAgIHZhciBkZWYgPSBnZW5lcmF0ZWREZXBlbmRlbmNpZXMuZGVmO1xyXG4gICAgICAgICAgICBzZXRTcGFjZUluZm8odGhpcy5hc3ROb2RlLCBcImRlZlwiLCBkZWYpO1xyXG4gICAgICAgICAgICBzcGFjZVR5cGVzID0gZ2V0U3BhY2VWZWN0b3JUeXBlc0Zyb21JbmZvKGlucHV0LCBkZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBzcGFjZVR5cGVzID0gbmV3IFNldChbU3BhY2VWZWN0b3JUeXBlLk9CSkVDVF0pXHJcbiAgICAgICAgICAgIGlmKHRoaXMuYXN0Tm9kZS50eXBlID09IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQpe1xyXG4gICAgICAgICAgICAgICAgc3BhY2VUeXBlcy5hZGQoU3BhY2VWZWN0b3JUeXBlLlJFU1VMVF9OT1JNQUwpO1xyXG4gICAgICAgICAgICAgICAgc3BhY2VUeXBlcy5hZGQoU3BhY2VWZWN0b3JUeXBlLlJFU1VMVF9QT0lOVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U3BhY2VJbmZvU3BhY2VzKHRoaXMuYXN0Tm9kZSwgXCJ0cmFuc2ZlclNwYWNlc1wiLCBzcGFjZVR5cGVzKTtcclxuICAgICAgICBmaW5hbFNwYWNlcyA9IGNyZWF0ZVNwYWNlSW5mb0Zyb21EZXBlbmRlbmNpZXMoZGVwU3BhY2VJbmZvLCBnZW5lcmF0ZWREZXBlbmRlbmNpZXMuZGVwZW5kZW5jaWVzLCBzcGFjZVR5cGVzKTtcclxuICAgICAgICBzZXRTcGFjZUluZm9TcGFjZXModGhpcy5hc3ROb2RlLCBcImZpbmFsU3BhY2VzXCIsIChmaW5hbFNwYWNlcyAmJiBmaW5hbFNwYWNlcy5zaXplID4gMCkgPyBmaW5hbFNwYWNlcyA6IG51bGwpO1xyXG5cclxuICAgICAgICBpbnB1dCA9IG5ldyBTZXQoaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAha2lsbC5oYXMoZWxlbS5zcGxpdChcIjtcIilbMF0pO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gbWVyZ2VTcGFjZUluZm8oaW5wdXQsIGRlcFNwYWNlSW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U3BhY2VWZWN0b3JUeXBlc0Zyb21JbmZvKHNwYWNlSW5mbywgaWRlbnRpZmllcil7XHJcbiAgICAgICAgdmFyIHNldCA9IG5ldyBTZXQoc3BhY2VJbmZvLmZpbHRlcihmdW5jdGlvbihlbGVtKXtyZXR1cm4gZWxlbS5zcGxpdChcIjtcIilbMF0gPT0gaWRlbnRpZmllcn0pLm1hcChmdW5jdGlvbihlbGVtKXsgcmV0dXJuIGVsZW0uc3BsaXQoXCI7XCIpWzFdKjF9KSk7XHJcbiAgICAgICAgaWYoc2V0LnNpemUgPT0gMClcclxuICAgICAgICAgICAgc2V0LmFkZChTcGFjZVZlY3RvclR5cGUuT0JKRUNUKTtcclxuICAgICAgICByZXR1cm4gc2V0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNTcGFjZVR5cGVWYWxpZChzcGFjZVR5cGUsIGRlcGVuZGVuY2llcyl7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBTaGFkZS5nZXRWZWN0b3JGcm9tU3BhY2VWZWN0b3Ioc3BhY2VUeXBlKTtcclxuICAgICAgICByZXR1cm4gdHlwZSA9PSBWZWN0b3JUeXBlLk5PTkUgfHwgKHR5cGUgPT0gVmVjdG9yVHlwZS5OT1JNQUwgJiYgIWRlcGVuZGVuY2llcy5ub3JtYWxTcGFjZVZpb2xhdGlvbilcclxuICAgICAgICAgICB8fCAodHlwZSA9PSBWZWN0b3JUeXBlLlBPSU5UICYmICFkZXBlbmRlbmNpZXMucG9pbnRTcGFjZVZpb2xhdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlU3BhY2VJbmZvRnJvbURlcGVuZGVuY2llcyhkZXBTcGFjZUluZm8sIGRlcGVuZGVuY2llcywgc3BhY2VzKXtcclxuICAgICAgICB2YXIgZmluYWxTcGFjZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgZGVwZW5kZW5jaWVzLnRvT2JqZWN0U2V0LmZvckVhY2goZnVuY3Rpb24obmFtZSl7XHJcbiAgICAgICAgICAgIGRlcFNwYWNlSW5mby5hZGQoICBuYW1lICsgXCI7XCIgKyBTcGFjZVZlY3RvclR5cGUuT0JKRUNUKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNwYWNlVmVjdG9yKXtcclxuICAgICAgICAgICAgdmFyIHNwYWNlID0gU2hhZGUuZ2V0U3BhY2VGcm9tU3BhY2VWZWN0b3Ioc3BhY2VWZWN0b3IpO1xyXG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IGlzU3BhY2VUeXBlVmFsaWQoc3BhY2VWZWN0b3IsIGRlcGVuZGVuY2llcyk7XHJcblxyXG4gICAgICAgICAgICBpZihzcGFjZSAhPSBTcGFjZVR5cGUuT0JKRUNUICYmIGRlcGVuZGVuY2llcy5oYXNEaXJlY3RWZWMzU3BhY2VPdmVycmlkZSgpKXtcclxuICAgICAgICAgICAgICAgIGlmKHNwYWNlID09IFNwYWNlVHlwZS5SRVNVTFQpXHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRldGVjdGlvbiBvZiByZXBlYXRlZCBzcGFjZSBjb252ZXJzaW9uLiBOb3Qgc3VwcG9ydGVkIVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmluYWxTcGFjZXMuYWRkKHNwYWNlVmVjdG9yKTtcclxuXHJcbiAgICAgICAgICAgIGlmKCFpc1ZhbGlkICYmIHNwYWNlID09IFNwYWNlVHlwZS5SRVNVTFQpe1xyXG4gICAgICAgICAgICAgICAgaWYoU2hhZGUuZ2V0VmVjdG9yRnJvbVNwYWNlVmVjdG9yKHNwYWNlVmVjdG9yKSA9PSBWZWN0b3JUeXBlLk5PUk1BTClcclxuICAgICAgICAgICAgICAgICAgICBjX3Jlc3VsdE5vcm1hbE9rID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY19yZXN1bHRQb2ludE9rID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3BhY2VWZWN0b3IgPSBpc1ZhbGlkID8gIHNwYWNlVmVjdG9yIDogU3BhY2VWZWN0b3JUeXBlLk9CSkVDVDtcclxuXHJcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wcm9wYWdhdGVTZXQuZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcclxuICAgICAgICAgICAgICAgIGRlcFNwYWNlSW5mby5hZGQoIG5hbWUgKyBcIjtcIiAgKyBzcGFjZVZlY3RvciApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgb3ZlcnJpZGVzID0gZGVwZW5kZW5jaWVzLnNwYWNlT3ZlcnJpZGVzO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvdmVycmlkZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBjcmVhdGVTcGFjZUluZm9Gcm9tRGVwZW5kZW5jaWVzKGRlcFNwYWNlSW5mbywgb3ZlcnJpZGVzW2ldLmRlcGVuZGVuY2llcywgbmV3IFNldCggW292ZXJyaWRlc1tpXS5zcGFjZV0gKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaW5hbFNwYWNlcztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWFsIG1lcmdlIGZ1bmN0aW9uIHRoYXQgbWVyZ2VzIGVudHJpZXMgd2l0aCBzYW1lIG5hbWVzXHJcbiAgICAgKiB0byBhIG5ldyBlbnRyeSB3aXRoIHRvcCBlbGVtZW50IFNlbWFudGljLlVOS05PV05cclxuICAgICAqIEBwYXJhbSB7U2V0fSBhXHJcbiAgICAgKiBAcGFyYW0ge1NldH0gYlxyXG4gICAgICogQHJldHVybnMge1NldH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbWVyZ2VTcGFjZUluZm8oYSwgYikge1xyXG4gICAgICAgIHZhciBzID0gYSA/IG5ldyBTZXQoYSkgOiBuZXcgU2V0KCk7XHJcbiAgICAgICAgaWYgKGIpXHJcbiAgICAgICAgICAgIGIuZm9yRWFjaChcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5hZGQoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gU3BhY2VEZXBlbmRlbmNpZXMoKXtcclxuICAgICAgICB0aGlzLm5vcm1hbFNwYWNlVmlvbGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wb2ludFNwYWNlVmlvbGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy50b09iamVjdFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLnNwYWNlT3ZlcnJpZGVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgU3BhY2VEZXBlbmRlbmNpZXMucHJvdG90eXBlLmFkZFNwYWNlT3ZlcnJpZGUgPSBmdW5jdGlvbihzcGFjZSwgZnJvbU9iamVjdFNwYWNlLCBkZXBlbmRlbmNpZXMpe1xyXG4gICAgICAgIHRoaXMuc3BhY2VPdmVycmlkZXMucHVzaCh7IHNwYWNlOiBzcGFjZSwgZnJvbU9iamVjdFNwYWNlOiBmcm9tT2JqZWN0U3BhY2UsIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzfSlcclxuICAgIH1cclxuICAgIFNwYWNlRGVwZW5kZW5jaWVzLnByb3RvdHlwZS5oYXNEaXJlY3RWZWMzU3BhY2VPdmVycmlkZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGkgPSB0aGlzLnNwYWNlT3ZlcnJpZGVzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICBpZighdGhpcy5zcGFjZU92ZXJyaWRlc1tpXS5mcm9tT2JqZWN0U3BhY2UpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVNwYWNlRGVwZW5kZW5jaWVzKGFzdCwgZGVmcykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7ZGVmOiBudWxsLCBkZXBlbmRlbmNpZXM6IG5ldyBTcGFjZURlcGVuZGVuY2llcygpfTtcclxuICAgICAgICBpZiAoIWFzdCAmJiAhYXN0LnR5cGUpXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgdmFyIGRlZkNvdW50ID0gZGVmcy5zaXplO1xyXG4gICAgICAgIGlmIChkZWZDb3VudCA+IDEpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGUgbm90IHNhbml0aXplZCwgZm91bmQgbXVsdGlwbGUgZGVmaW5pdGlvbnMgaW4gb25lIHN0YXRlbWVudFwiKTtcclxuICAgICAgICBpZihkZWZDb3VudCA9PSAxKVxyXG4gICAgICAgICAgICByZXN1bHQuZGVmID0gZGVmcy52YWx1ZXMoKVswXTtcclxuICAgICAgICAvLyBUT0RPOiBQcm9wZXJseSBkZXRlcm1pbmUgRkxPQVQzIHN0YXRlbWVudHNcclxuICAgICAgICB2YXIgaXNGbG9hdDNTdGF0ZW1lbnQgPSAoYXN0LmV4dHJhICYmIGFzdC5leHRyYS5raW5kID09IEtpbmRzLkZMT0FUMyk7XHJcblxyXG4gICAgICAgIGlmKGlzRmxvYXQzU3RhdGVtZW50KXtcclxuICAgICAgICAgICAgZ2F0aGVyU3BhY2VEZXBlbmRlbmNpZXMoYXN0LCByZXN1bHQuZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICAgICAgc2V0U3BhY2VJbmZvKGFzdCwgXCJwcm9wYWdhdGVTZXRcIiwgcmVzdWx0LmRlcGVuZGVuY2llcy5wcm9wYWdhdGVTZXQudmFsdWVzKCkpO1xyXG4gICAgICAgICAgICBzZXRTcGFjZUluZm8oYXN0LCBcIm5vcm1hbFNwYWNlVmlvbGF0aW9uXCIsIHJlc3VsdC5kZXBlbmRlbmNpZXMubm9ybWFsU3BhY2VWaW9sYXRpb24pO1xyXG4gICAgICAgICAgICBzZXRTcGFjZUluZm8oYXN0LCBcInBvaW50U3BhY2VWaW9sYXRpb25cIiwgcmVzdWx0LmRlcGVuZGVuY2llcy5wb2ludFNwYWNlVmlvbGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBnYXRoZXJPYmplY3REZXBlbmRlbmNpZXMoYXN0LCByZXN1bHQuZGVwZW5kZW5jaWVzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTcGFjZUNvbnZlcnNpb24oY2FsbEFzdCl7XHJcbiAgICAgICAgdmFyIGNhbGxlZSA9IGNhbGxBc3QuY2FsbGVlO1xyXG4gICAgICAgIGlmKGNhbGxlZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIGNhbGxlZS5vYmplY3QudHlwZSA9PSBTeW50YXguSWRlbnRpZmllclxyXG4gICAgICAgICAgICAmJiBjYWxsZWUub2JqZWN0Lm5hbWUgPT0gXCJTcGFjZVwiKXtcclxuICAgICAgICAgICAgdmFyIHNwYWNlVHlwZSA9IDA7XHJcbiAgICAgICAgICAgIHN3aXRjaChjYWxsZWUucHJvcGVydHkubmFtZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidHJhbnNmb3JtUG9pbnRcIjogc3BhY2VUeXBlID0gVmVjdG9yVHlwZS5QT0lOVDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidHJhbnNmb3JtRGlyZWN0aW9uXCI6IHNwYWNlVHlwZSA9IFZlY3RvclR5cGUuTk9STUFMOyBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzcGFjZVR5cGUgPSBzcGFjZVR5cGUgPDwgMztcclxuICAgICAgICAgICAgaWYoc3BhY2VUeXBlKXtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdEFyZyA9IGNhbGxBc3QuYXJndW1lbnRzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGZpcnN0QXJnLnR5cGUgIT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gfHwgZmlyc3RBcmcub2JqZWN0LnR5cGUgIT0gU3ludGF4LklkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgICAgICB8fCBmaXJzdEFyZy5vYmplY3QubmFtZSAhPSBcIlNwYWNlXCIgfHwgZmlyc3RBcmcucHJvcGVydHkudHlwZSAhPSBTeW50YXguSWRlbnRpZmllcilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgb2YgJ1wiICsgY2FsbGVlLnByb3BlcnR5ICsgXCInIG11c3QgYmUgYSBTcGFjZSBlbnVtIHZhbHVlLlwiKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaChmaXJzdEFyZy5wcm9wZXJ0eS5uYW1lKXtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVklFV1wiIDogc3BhY2VUeXBlICs9IFNwYWNlVHlwZS5WSUVXOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiV09STERcIjogc3BhY2VUeXBlICs9IFNwYWNlVHlwZS5XT1JMRDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhY2VUeXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVNwYWNlT3ZlcnJpZGUoY2FsbEFzdCwgcmVzdWx0LCBmcm9tT2JqZWN0U3BhY2Upe1xyXG4gICAgICAgIHZhciBzcGFjZSA9IGdldFNwYWNlQ29udmVyc2lvbihjYWxsQXN0KTtcclxuICAgICAgICBpZihzcGFjZSl7XHJcbiAgICAgICAgICAgIHZhciBzdWJSZXN1bHQgPSBuZXcgU3BhY2VEZXBlbmRlbmNpZXMoKTtcclxuICAgICAgICAgICAgZ2F0aGVyU3BhY2VEZXBlbmRlbmNpZXMoY2FsbEFzdC5hcmd1bWVudHNbMV0sIHN1YlJlc3VsdCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hZGRTcGFjZU92ZXJyaWRlKHNwYWNlLCBmcm9tT2JqZWN0U3BhY2UsIHN1YlJlc3VsdCk7XHJcbiAgICAgICAgICAgIHNldFNwYWNlSW5mbyhjYWxsQXN0LCBcInNwYWNlT3ZlcnJpZGVcIiwgc3BhY2UpO1xyXG4gICAgICAgICAgICBzZXRTcGFjZUluZm8oY2FsbEFzdCwgXCJwcm9wYWdhdGVTZXRcIiwgc3ViUmVzdWx0LnByb3BhZ2F0ZVNldC52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgIHNldFNwYWNlSW5mbyhjYWxsQXN0LCBcIm5vcm1hbFNwYWNlVmlvbGF0aW9uXCIsIHN1YlJlc3VsdC5ub3JtYWxTcGFjZVZpb2xhdGlvbik7XHJcbiAgICAgICAgICAgIHNldFNwYWNlSW5mbyhjYWxsQXN0LCBcInBvaW50U3BhY2VWaW9sYXRpb25cIiwgc3ViUmVzdWx0LnBvaW50U3BhY2VWaW9sYXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdhdGhlck9iamVjdERlcGVuZGVuY2llcyhhc3QsIHJlc3VsdCl7XHJcbiAgICAgICAgd2Fsa2VyKGFzdCwge1xyXG4gICAgICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbigpe30sXHJcbiAgICAgICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmV4dHJhLmtpbmQgPT0gS2luZHMuRkxPQVQzKXtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQudG9PYmplY3RTZXQuYWRkKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAocmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5leHRyYS5raW5kID09IEtpbmRzLkZMT0FUMyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqZWN0LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgJiYgdGhpcy5wcm9wZXJ0eS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub2JqZWN0LmV4dHJhLmdsb2JhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm9wYWdhdGVTZXQuYWRkKFwiZW52LlwiICsgdGhpcy5wcm9wZXJ0eS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih0aGlzLm9iamVjdC5uYW1lICE9PSBcInVleHBcIikgeyAvLyBGSVhNRVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVtYmVyIEFjY2VzcyBvZiBub24gJ2Vudicgb2JqZWN0IGluIHNwYWNlIGVxdWF0aW9uIC0gbm90IHN1cHBvcnRlZDogXCIgKyBjb2RlZ2VuLmdlbmVyYXRlKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLm9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLnByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIChyZWN1cnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZihoYW5kbGVTcGFjZU92ZXJyaWRlKHRoaXMsIHJlc3VsdCwgdHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLmNhbGxlZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyZ3VtZW50cy5tYXAocmVjdXJzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnYXRoZXJTcGFjZURlcGVuZGVuY2llcyhhc3QsIHJlc3VsdCkge1xyXG4gICAgICAgIHdhbGtlcihhc3QsIHtcclxuICAgICAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24oKXt9LFxyXG4gICAgICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgIHJlY3Vyc2UodGhpcy5yaWdodCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZXh0cmEua2luZCA9PSBLaW5kcy5GTE9BVDMpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm9wYWdhdGVTZXQuYWRkKHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3BhY2VJbmZvKHRoaXMsIFwicHJvcGFnYXRlXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24gKHJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY2FsbGVlID09IFwiVmVjM1wiKXtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVWZWMzQXJncyh0aGlzLmFyZ3VtZW50cywgcmVjdXJzZSwgcmVzdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChyZWN1cnNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmV4dHJhLmtpbmQgPT0gS2luZHMuRkxPQVQzKXtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmplY3QudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciAmJiB0aGlzLnByb3BlcnR5LnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5vYmplY3QuZXh0cmEuZ2xvYmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnByb3BhZ2F0ZVNldC5hZGQoXCJlbnYuXCIgKyB0aGlzLnByb3BlcnR5Lm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHRoaXMub2JqZWN0Lm5hbWUgIT09IFwidWV4cFwiKSB7IC8vIEZJWE1FXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZW1iZXIgQWNjZXNzIG9mIG5vbiAnZW52JyBvYmplY3QgaW4gc3BhY2UgZXF1YXRpb24gLSBub3Qgc3VwcG9ydGVkLlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFNwYWNlSW5mbyh0aGlzLCBcInByb3BhZ2F0ZVwiLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UodGhpcy5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UodGhpcy5wcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAocmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoaGFuZGxlU3BhY2VPdmVycmlkZSh0aGlzLCByZXN1bHQsIGZhbHNlKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsZWUudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wb2ludFNwYWNlVmlvbGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbE9iamVjdCA9IHRoaXMuY2FsbGVlLm9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0S2luZCA9IGNhbGxPYmplY3QuZXh0cmEua2luZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdGhpcy5jYWxsZWUucHJvcGVydHkubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRoaXMuYXJndW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKFByb3BhZ2F0aW9uUnVsZXNbb2JqZWN0S2luZF0gJiYgUHJvcGFnYXRpb25SdWxlc1tvYmplY3RLaW5kXVttZXRob2RdKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvcGFnYXRpb25SdWxlc1tvYmplY3RLaW5kXVttZXRob2RdKGNhbGxPYmplY3QsIGFyZ3MsIHJlY3Vyc2UsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY19kZWJ1ZyAmJiBjb25zb2xlLmxvZyhcIlVuaGFuZGxlZDogXCIsIGNvZGVnZW4uZ2VuZXJhdGUodGhpcykpXHJcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZih0aGlzLmNhbGxlZS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmNhbGxlZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21FbnRyeSA9IGNfY3VzdG9tRnVuY3Rpb25Qcm9wYWdhdGlvbnMgJiYgY19jdXN0b21GdW5jdGlvblByb3BhZ2F0aW9uc1tpZF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VzdG9tRW50cnkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighY3VzdG9tRW50cnkudHJhbnNmZXJQb2ludE9rKSByZXN1bHQucG9pbnRTcGFjZVZpb2xhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjdXN0b21FbnRyeS50cmFuc2Zlck5vcm1hbE9rKSByZXN1bHQubm9ybWFsU3BhY2VWaW9sYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGN1c3RvbUVudHJ5LnRyYW5zZmVyQXJncy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXN0b21FbnRyeS50cmFuc2ZlckFyZ3NbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLmFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2F0aGVyT2JqZWN0RGVwZW5kZW5jaWVzKHRoaXMuYXJndW1lbnRzW2ldLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucG9pbnRTcGFjZVZpb2xhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQubm9ybWFsU3BhY2VWaW9sYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZ2F0aGVyT2JqZWN0RGVwZW5kZW5jaWVzKHRoaXMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24oYXJnKXsgZ2F0aGVyT2JqZWN0RGVwZW5kZW5jaWVzKGFyZywgcmVzdWx0KX0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU2NhbGVPcGVyYXRvcihjYWxsT2JqZWN0LCBhcmdzLCByZWN1cnNlLCByZXN1bHQpe1xyXG4gICAgICAgIGhhbmRsZVZlYzNBcmdzKGFyZ3MsIHJlY3Vyc2UsIHJlc3VsdCwgdHJ1ZSk7XHJcbiAgICAgICAgcmVjdXJzZShjYWxsT2JqZWN0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUFkZFN1Yk9wZXJhdGlvbihjYWxsT2JqZWN0LCBhcmdzLCByZWN1cnNlLCByZXN1bHQpe1xyXG4gICAgICAgIGhhbmRsZVZlYzNBcmdzKGFyZ3MsIHJlY3Vyc2UsIHJlc3VsdCwgZmFsc2UpO1xyXG4gICAgICAgIHJlY3Vyc2UoY2FsbE9iamVjdCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlVmVjM0FyZ3MoYXJncywgcmVjdXJzZSwgcmVzdWx0LCBzY2FsaW5nKXtcclxuICAgICAgICBpZighc2NhbGluZyAmJiBhcmdzLmxlbmd0aCA9PSAwKXtcclxuICAgICAgICAgICAgcmVzdWx0Lm5vcm1hbFNwYWNlVmlvbGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihhcmdzLmxlbmd0aCA+IDEpe1xyXG4gICAgICAgICAgICByZXN1bHQubm9ybWFsU3BhY2VWaW9sYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFyZ3MubGVuZ3RoID09IDEpe1xyXG4gICAgICAgICAgICBpZihhcmdzWzBdLmV4dHJhLmtpbmQgPT0gS2luZHMuRkxPQVQzKXtcclxuICAgICAgICAgICAgICAgIHJlY3Vyc2UoYXJnc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzY2FsaW5nICYmIHR5cGVJc1NjYWxhcihhcmdzWzBdLmV4dHJhLnR5cGUpKXtcclxuICAgICAgICAgICAgICAgIGdhdGhlck9iamVjdERlcGVuZGVuY2llcyhhcmdzWzBdLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQubm9ybWFsU3BhY2VWaW9sYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHR5cGVJc1NjYWxhcih0eXBlKXtcclxuICAgICAgICByZXR1cm4gdHlwZSA9PSBUeXBlcy5OVU1CRVIgfHwgdHlwZSA9PSBUeXBlcy5JTlQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHZhciBQcm9wYWdhdGlvblJ1bGVzID0ge1xyXG4gICAgICAgIFwiZmxvYXQzXCIgOiB7XHJcbiAgICAgICAgICAgIFwiYWRkXCIgOiBoYW5kbGVBZGRTdWJPcGVyYXRpb24sXHJcbiAgICAgICAgICAgIFwic3ViXCIgOiBoYW5kbGVBZGRTdWJPcGVyYXRpb24sXHJcbiAgICAgICAgICAgIFwiY3Jvc3NcIiA6IGhhbmRsZUFkZFN1Yk9wZXJhdGlvbixcclxuICAgICAgICAgICAgXCJtdWxcIiA6IGhhbmRsZVNjYWxlT3BlcmF0b3IsXHJcbiAgICAgICAgICAgIFwiZGl2XCIgOiBoYW5kbGVTY2FsZU9wZXJhdG9yLFxyXG4gICAgICAgICAgICBcIm5vcm1hbGl6ZVwiIDogaGFuZGxlU2NhbGVPcGVyYXRvclxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIGFuYWx5emU6IGFuYWx5emVcclxuICAgIH07XHJcblxyXG59KG1vZHVsZSkpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgLy8gRGVwZW5kZW5jaWVzXHJcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxyXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgZXZhbHVhdG9yID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9ldmFsdWF0b3IuanNcIiksXHJcbiAgICAgICAgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKSxcclxuICAgICAgICBFcnJvckhhbmRsZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9lcnJvcnMuanNcIik7XHJcblxyXG4gICAgdmFyIGNvZGVnZW4gPSByZXF1aXJlKCdlc2NvZGVnZW4nKTtcclxuXHJcbiAgICAvLyBTaG9ydGN1dHNcclxuICAgIHZhciBTeW50YXggPSBjb21tb24uU3ludGF4LFxyXG4gICAgICAgIFRZUEVTID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgQU5OTyA9IGNvbW1vbi5BTk5PLFxyXG4gICAgICAgIGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbiA9IEVycm9ySGFuZGxlci5nZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24sXHJcbiAgICAgICAgRVJST1JfVFlQRVMgPSBFcnJvckhhbmRsZXIuRVJST1JfVFlQRVM7XHJcblxyXG4gICAgdmFyIGRlYnVnID0gZmFsc2U7XHJcblxyXG5cclxuXHJcbiAgICB2YXIgaGFuZGxlcnMgPSB7XHJcblxyXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gQU5OTyhub2RlKSwgZWxlbWVudHMgPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUuZWxlbWVudHMpLCBlbGVtZW50VHlwZSA9IEFOTk8oe30pO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0LnNldFR5cGUoVFlQRVMuQVJSQVkpO1xyXG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRUeXBlLmNvcHkoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxlbWVudFR5cGUuc2V0Q29tbW9uVHlwZShlbGVtZW50VHlwZSwgZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlNIQURFSlNfRVJST1IsIFwic2hhZGUuanMgZG9lcyBub3Qgc3VwcG9ydCBpbmhvbW9nZW5vdXMgYXJyYXlzOiBbXCIsIGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZ2V0VHlwZVN0cmluZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSwgXCJdXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSBub2RlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGl0ZXJhbDogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5yYXcgIT09IHVuZGVmaW5lZCA/IG5vZGUucmF3IDogbm9kZS52YWx1ZSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEFOTk8obm9kZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNOYU4obnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkuaW5kZXhPZihcIi5cIikgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5JTlQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFR5cGUoVFlQRVMuTlVNQkVSKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5CT09MRUFOKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ251bGwnKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5OVUxMKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLlNUUklORyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuaXNOdWxsKCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRTdGF0aWNWYWx1ZShldmFsdWF0b3IuZ2V0U3RhdGljVmFsdWUobm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXhwcmVzc2lvblN0YXRlbWVudDogSnVzdCBjb3B5IHRoZSByZXN1bHQgZnJvbSB0aGUgYWN0dWFsIGV4cHJlc3Npb25cclxuICAgICAgICAgKi9cclxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gQU5OTyhub2RlKSxcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBBTk5PKG5vZGUuZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jb3B5KGV4cHJlc3Npb24pO1xyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5TdGF0ZW1lbnQ6IElmIHJldHVybiBoYXMgYW4gYXJndW1lbnQsIGNvcHkgdGhlIFR5cGVJbmZvXHJcbiAgICAgICAgICogZm9ybSB0aGUgYXJndW1lbnQsIG90aGVyd2lzZSBpdCdzIHVuZGVmaW5lZC4gSW5mb3JtIHRoZSBzY29wZSBvblxyXG4gICAgICAgICAqIHRoZSByZXR1cm4gdHlwZSBvZiB0aGlzIHJldHVybiBicmFuY2guXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpLFxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnQgPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUuYXJndW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuY29weShhcmd1bWVudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5VTkRFRklORUQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQuZ2V0U2NvcGUoKS51cGRhdGVSZXR1cm5JbmZvKHJlc3VsdCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTmV3RXhwcmVzc2lvbjogRmluZCB0aGUgdHlwZSBvZiB0aGUgQ2FsbGVlIGZyb21cclxuICAgICAgICAgKiB0aGUgc2NvcGUgYW5kIGV2YWx1YXRlIGJhc2VkIG9uIGFubm90YXRlZCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpLCBzdGF0aWNWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJlIG9uIHRoZSBzYWZlIHNpZGUsIGFzc3VtZSByZXN1bHQgaXMgc3RhdGljIGluZGVwZW5kZW50bHkgb2YgZm9ybWVyIGFubm90YXRpb25zXHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXREeW5hbWljVmFsdWUoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzY29wZSA9IGNvbnRleHQuZ2V0U2NvcGUoKTtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gc2NvcGUuZ2V0QmluZGluZ0J5TmFtZShub2RlLmNhbGxlZS5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5Lmhhc0NvbnN0cnVjdG9yKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGVudHJ5LmdldENvbnN0cnVjdG9yKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmEgPSBjb25zdHJ1Y3Rvci5ldmFsdWF0ZShyZXN1bHQsIGFyZ3MsIHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0RnJvbUV4dHJhKGV4dHJhKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZChlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RydWN0b3IuY29tcHV0ZVN0YXRpY1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWUgPSBjb25zdHJ1Y3Rvci5jb21wdXRlU3RhdGljVmFsdWUocmVzdWx0LCBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUuYXJndW1lbnRzKSwgc2NvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGljVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFN0YXRpY1ZhbHVlKHN0YXRpY1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldER5bmFtaWNWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5SRUZFUkVOQ0VfRVJST1IsIG5vZGUuY2FsbGVlLm5hbWUsIFwiaXMgbm90IGRlZmluZWRcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuYXJ5RXhwcmVzc2lvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gQU5OTyhub2RlKSxcclxuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmFyZ3VtZW50KSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcclxuXHJcbiAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiIVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLkJPT0xFQU4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudC5jYW5PYmplY3QoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0U3RhdGljVmFsdWUoZmFsc2UpOyAvLyAhb2JqID09IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiK1wiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIi1cIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnQuY2FuSW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFR5cGUoVFlQRVMuSU5UKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50LmNhbk51bWJlcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLk5VTUJFUik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLk5BTl9FUlJPUikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0eXBlb2ZcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGFyZ3VtZW50LmlzVmFsaWQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFN0YXRpY1ZhbHVlKGFyZ3VtZW50LmdldEphdmFTY3JpcHRUeXBlU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiflwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInZvaWRcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIjpcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlNIQURFSlNfRVJST1IsIG9wZXJhdG9yLCBcImlzIG5vdCBzdXBwb3J0ZWQuXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnQuaGFzU3RhdGljVmFsdWUoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldFN0YXRpY1ZhbHVlKGV2YWx1YXRvci5nZXRTdGF0aWNWYWx1ZShub2RlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0RHluYW1pY1ZhbHVlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAnVW5kZWZpbmVkJyBpcyBhbiBpZGVudGlmaWVyLiBWYXJpYWJsZXMsIG5hbWVzIG9mIGZ1bmN0aW9ucyBhbmRcclxuICAgICAgICAgKiBtZW1iZXIgcHJvcGVydGllcyBhcmUgaGFuZGxlZCB3aXRoaW4gcGFyZW50IGV4cHJlc3Npb25zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSWRlbnRpZmllcjogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgQU5OTyhub2RlKS5zZXRUeXBlKFRZUEVTLlVOREVGSU5FRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCaW5hcnlFeHByZXNzaW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG5vZGUubGVmdCwgbm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmxlZnQpLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUucmlnaHQpLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQU5OTyhub2RlKSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcixcclxuICAgICAgICAgICAgICAgIHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYoIShsZWZ0LmlzVmFsaWQoKSAmJiByaWdodC5pc1ZhbGlkKCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcclxuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIitcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCItXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiKlwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCIlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ICdvcCcgaW50ID0+IGludFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludCAvIGludCA9PiBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jYW5JbnQoKSAmJiByaWdodC5jYW5JbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgPT0gXCIvXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5OVU1CRVIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5JTlQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnQgJ29wJyBudW1iZXIgPT4gbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdC5jYW5JbnQoKSAmJiByaWdodC5pc051bWJlcigpIHx8IHJpZ2h0LmNhbkludCgpICYmIGxlZnQuaXNOdW1iZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5OVU1CRVIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgJ29wJyBudW1iZXIgPT4gbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdC5pc051bWJlcigpICYmIHJpZ2h0LmlzTnVtYmVyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFR5cGUoVFlQRVMuTlVNQkVSKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50ICdvcCcgbnVsbCA9PiBpbnRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdC5pc0ludCgpICYmIHJpZ2h0LmlzTnVsbCgpIHx8IHJpZ2h0LmlzSW50KCkgJiYgbGVmdC5pc051bGwoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5JTlQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgJ29wJyBudWxsID0+IG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChsZWZ0LmlzTnVtYmVyKCkgJiYgcmlnaHQuaXNOdWxsKCkpIHx8IChyaWdodC5pc051bWJlcigpICYmIGxlZnQuaXNOdWxsKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLk5VTUJFUik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOYU5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHVuZGVmaW5lZCwgYXMgdGhpcyBpcyB0aGUgbWFpbiByZWFzb24gZm9yIHRoaXMgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICBpZihsZWZ0LmlzTnVsbE9yVW5kZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBjb2RlZ2VuLmdlbmVyYXRlKG5vZGUubGVmdCkgKyBcIiBpcyB1bmRlZmluZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0LmlzTnVsbE9yVW5kZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBjb2RlZ2VuLmdlbmVyYXRlKG5vZGUucmlnaHQpICsgXCIgaXMgdW5kZWZpbmVkXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZChnZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgRVJST1JfVFlQRVMuTkFOX0VSUk9SLCBtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIj09PVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIiE9PVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRUeXBlKFRZUEVTLkJPT0xFQU4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmlzVW5kZWZpbmVkKCkgfHwgcmlnaHQuaXNVbmRlZmluZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxlZnQuaXNVbmRlZmluZWQoKSAmJiByaWdodC5pc1VuZGVmaW5lZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0U3RhdGljVmFsdWUob3BlcmF0b3IgPT0gXCI9PT1cIiA/IHZhbHVlIDogIXZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCI9PVwiOiAvLyBjb21wYXJpc29uXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiIT1cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCI+XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiPFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIj49XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiPD1cIjpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5CT09MRUFOKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5pc1VuZGVmaW5lZCgpIHx8IHJpZ2h0LmlzVW5kZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZWZ0LmlzVW5kZWZpbmVkKCkgJiYgcmlnaHQuaXNVbmRlZmluZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFN0YXRpY1ZhbHVlKG9wZXJhdG9yID09IFwiIT1cIiA/ICF2YWx1ZSA6IHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlNIQURFSlNfRVJST1IsIG9wZXJhdG9yLCBcImlzIG5vdCBzdXBwb3J0ZWQuXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIGlmIChsZWZ0Lmhhc1N0YXRpY1ZhbHVlKCkgJiYgcmlnaHQuaGFzU3RhdGljVmFsdWUoKSkge1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhsZWZ0LmdldFN0YXRpY1ZhbHVlKCksIG9wZXJhdG9yLCByaWdodC5nZXRTdGF0aWNWYWx1ZSgpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRTdGF0aWNWYWx1ZShldmFsdWF0b3IuZ2V0U3RhdGljVmFsdWUobm9kZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldER5bmFtaWNWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24obm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBhcmd1bWVudCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5hcmd1bWVudCksXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgICAgICBpZihhcmd1bWVudC5jYW5OdW1iZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkoYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYobm9kZS5wcmVmaXggJiYgYXJndW1lbnQuaGFzU3RhdGljVmFsdWUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5vZGUub3BlcmF0b3IgPT0gXCIrK1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRTdGF0aWNWYWx1ZShhcmd1bWVudC5nZXRTdGF0aWNWYWx1ZSgpKzEpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKG5vZGUub3BlcmF0b3IgPT0gXCItLVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRTdGF0aWNWYWx1ZShhcmd1bWVudC5nZXRTdGF0aWNWYWx1ZSgpLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3BlcmF0b3Igbm90IHN1cHBvcnRlZDogXCIgKyBub2RlLm9wZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlLmcuIHZhciBhID0ge307IGErKztcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5OQU5fRVJST1IpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5yaWdodCksXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBTk5PKG5vZGUpO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0LmNvcHkocmlnaHQpO1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0RHluYW1pY1ZhbHVlKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jbGVhclVuaWZvcm1EZXBlbmRlbmNpZXMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrLCBpZiBhIGFzc2lnbmVkIHZhcmlhYmxlIHN0aWxsIGhhcyB0aGUgc2FtZSB0eXBlIGFzXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZSBhbmQgdXBkYXRlIHR5cGUgb2YgdW5pbml0aWFsaXplZCB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgIGlmIChub2RlLmxlZnQudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciAmJiAhY29udGV4dC5pbkRlY2xhcmF0aW9uKCkgJiYgcmlnaHQuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUubGVmdC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjb3BlID0gY29udGV4dC5nZXRTY29wZSgpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlVHlwZUluZm8obmFtZSwgcmlnaHQsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcblxyXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdFR5cGUgPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUpLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0QW5ub3RhdGlvbiA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5vYmplY3QpLFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlBbm5vdGF0aW9uID0gQU5OTyhub2RlLnByb3BlcnR5KSxcclxuICAgICAgICAgICAgICAgIHNjb3BlID0gY29udGV4dC5nZXRTY29wZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYoIW9iamVjdEFubm90YXRpb24uaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRUeXBlLnNldEludmFsaWQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIk1lbWJlclwiLCBub2RlLm9iamVjdC5uYW1lLCBub2RlLnByb3BlcnR5Lm5hbWUsIG5vZGUuY29tcHV0ZWQpO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdEFubm90YXRpb24uaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydHkgaXMgY29tcHV0ZWQsIHRodXMgaXQgY291bGQgYmUgYSB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVR5cGUgPSAgY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLnByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5VHlwZS5jYW5OdW1iZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiRXhwZWN0ZWQgJ2ludCcgb3IgJ251bWJlcicgdHlwZSBmb3IgYXJyYXkgYWNjZXNzb3JcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50SW5mbyA9IG9iamVjdEFubm90YXRpb24uZ2V0QXJyYXlFbGVtZW50VHlwZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFR5cGUuc2V0VHlwZShlbGVtZW50SW5mby50eXBlLCBlbGVtZW50SW5mby5raW5kKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRUeXBlLnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlNIQURFSlNfRVJST1IsIFwibm8gYXJyYXkgYWNjZXNzIHRvIG9iamVjdCB5ZXRcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAvL1NoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJUeXBlRXJyb3I6IENhbm5vdCBhY2Nlc3MgbWVtYmVyIHZpYSBjb21wdXRlZCB2YWx1ZSBmcm9tIG9iamVjdCAnXCIgKyBvYmplY3RBbm5vdGF0aW9uLmdldFR5cGVTdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IG5vZGUucHJvcGVydHkubmFtZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvYmplY3RPZkludGVyZXN0ID0gY29tbW9uLmdldE9iamVjdFJlZmVyZW5jZUZyb21Ob2RlKG5vZGUub2JqZWN0LCBzY29wZSk7XHJcblxyXG4gICAgICAgICAgICBvYmplY3RPZkludGVyZXN0IHx8IFNoYWRlLnRocm93RXJyb3Iobm9kZSxcIlJlZmVyZW5jZUVycm9yOiBcIiArIG5vZGUub2JqZWN0Lm5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZC4gQ29udGV4dDogXCIgKyBzY29wZS5zdHIoKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW9iamVjdE9mSW50ZXJlc3QuaXNWYWxpZCgpIHx8IG9iamVjdE9mSW50ZXJlc3QuZ2V0VHlwZSgpID09IFRZUEVTLlVOREVGSU5FRCkgeyAgLy8gZS5nLiB2YXIgYSA9IHVuZGVmaW5lZDsgYS51bmtub3duO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0VHlwZS5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5UWVBFX0VSUk9SLCBcIkNhbm5vdCByZWFkIHByb3BlcnR5ICdcIiArIHByb3BlcnR5TmFtZSArIFwiJyBvZiB1bmRlZmluZWRcIikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmplY3RPZkludGVyZXN0LmdldFR5cGUoKSAhPSBUWVBFUy5PQkpFQ1QpIHsgLy8gZS5nLiB2YXIgYSA9IDU7IGEudW5rbm93bjtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFR5cGUuc2V0VHlwZShUWVBFUy5VTkRFRklORUQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqZWN0SW5mbyA9IHNjb3BlLmdldE9iamVjdEluZm9Gb3Iob2JqZWN0T2ZJbnRlcmVzdCk7XHJcbiAgICAgICAgICAgIGlmKCFvYmplY3RJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRUeXBlLnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlNIQURFSlNfRVJST1IsIFwiSW50ZXJuYWw6IEluY29tcGxldGUgcmVnaXN0cmF0aW9uIGZvciBvYmplY3Q6XCIsIG9iamVjdE9mSW50ZXJlc3QuZ2V0VHlwZVN0cmluZygpLCBcIixcIiwgSlNPTi5zdHJpbmdpZnkobm9kZS5vYmplY3QpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG9iamVjdEFubm90YXRpb24uY29weShvYmplY3RPZkludGVyZXN0KTtcclxuICAgICAgICAgICAgaWYgKCFvYmplY3RJbmZvLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFR5cGUuc2V0VHlwZShUWVBFUy5VTkRFRklORUQpO1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlBbm5vdGF0aW9uLnNldFR5cGUoVFlQRVMuVU5ERUZJTkVEKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5VHlwZUluZm8gPSBvYmplY3RJbmZvW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgICAgIHByb3BlcnR5QW5ub3RhdGlvbi5zZXRGcm9tRXh0cmEocHJvcGVydHlUeXBlSW5mbyk7XHJcbiAgICAgICAgICAgIHJlc3VsdFR5cGUuY29weShwcm9wZXJ0eUFubm90YXRpb24pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpLFxyXG4gICAgICAgICAgICAgICAgc2NvcGUgPSBjb250ZXh0LmdldFNjb3BlKCksXHJcbiAgICAgICAgICAgICAgICBhcmdzID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmFyZ3VtZW50cyksXHJcbiAgICAgICAgICAgICAgICBleHRyYSwgc3RhdGljVmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykge3JldHVybiBhcmcuaXNWYWxpZCgpIH0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZChnZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgRVJST1JfVFlQRVMuU0hBREVKU19FUlJPUiwgXCJOb3QgYWxsIGFyZ3VtZW50cyB0eXBlcyBvZiBjYWxsIGV4cHJlc3Npb24gY291bGQgYmUgZXZhbHVhdGVkXCIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBCZSBvbiB0aGUgc2FmZSBzaWRlLCBhc3N1bWUgcmVzdWx0IGlzIHN0YXRpYyBpbmRlcGVuZGVudGx5IG9mIGZvcm1lciBhbm5vdGF0aW9uc1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0RHluYW1pY1ZhbHVlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxsIG9uIGFuIG9iamVjdCwgZS5nLiBNYXRoLmNvcygpXHJcbiAgICAgICAgICAgIGlmIChub2RlLmNhbGxlZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1lbWJlckV4cHJlc3Npb24gPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUuY2FsbGVlKTtcclxuICAgICAgICAgICAgICAgIGlmKCFtZW1iZXJFeHByZXNzaW9uLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSBub2RlLmNhbGxlZS5vYmplY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lID0gbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0UmVmZXJlbmNlID0gY29udGV4dC5nZXRUeXBlSW5mbyhvYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgaWYoIW9iamVjdFJlZmVyZW5jZSkgIHtcclxuICAgICAgICAgICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiSW50ZXJuYWw6IE5vIG9iamVjdCBpbmZvIGZvcjogXCIgKyBvYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdEluZm8gPSBzY29wZS5nZXRPYmplY3RJbmZvRm9yKG9iamVjdFJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgICAgICBpZighb2JqZWN0SW5mbykgeyAvLyBFdmVyeSBvYmplY3QgbmVlZHMgYW4gaW5mbywgb3RoZXJ3aXNlIHdlIGRpZCBzb21ldGhpbmcgd3JvbmdcclxuICAgICAgICAgICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiSW50ZXJuYWwgRXJyb3I6IE5vIG9iamVjdCByZWdpc3RlcmVkIGZvcjogXCIgKyBvYmplY3RSZWZlcmVuY2UuZ2V0VHlwZVN0cmluZygpICsgSlNPTi5zdHJpbmdpZnkobm9kZS5vYmplY3QpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW1lbWJlckV4cHJlc3Npb24uaXNGdW5jdGlvbigpKSB7IC8vIGUuZy4gTWF0aC5QSSgpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdEluZm8uaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldEludmFsaWQoZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVSUk9SX1RZUEVTLlRZUEVfRVJST1IsIFwiUHJvcGVydHkgJ1wiICsgcHJvcGVydHlOYW1lICsgXCInIG9mIG9iamVjdCAjPFwiKyBvYmplY3RSZWZlcmVuY2UuZ2V0VHlwZVN0cmluZygpICtcIj4gaXMgbm90IGEgZnVuY3Rpb25cIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZChnZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgRVJST1JfVFlQRVMuVFlQRV9FUlJPUiwgKG9iamVjdC50eXBlID09IFN5bnRheC5UaGlzRXhwcmVzc2lvbiA/IFwiJ3RoaXMnXCIgOiBvYmplY3RSZWZlcmVuY2UuZ2V0VHlwZVN0cmluZygpKSsgXCIgaGFzIG5vIG1ldGhvZCAnXCIrIHByb3BlcnR5TmFtZSArIFwiJ1wiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RJbmZvLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VHlwZShUWVBFUy5VTkRFRklORUQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eUhhbmRsZXIgPSBvYmplY3RJbmZvW3Byb3BlcnR5TmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eUhhbmRsZXIuZXZhbHVhdGUgIT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihub2RlLCBcIkludGVybmFsOiBubyBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yICdcIiArIHByb3BlcnR5TmFtZSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIHR5cGUgb2YgY2FsbFxyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBwcm9wZXJ0eUhhbmRsZXIuZXZhbHVhdGUocmVzdWx0LCBhcmdzLCBzY29wZSwgb2JqZWN0UmVmZXJlbmNlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0RnJvbUV4dHJhKGV4dHJhKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0SW52YWxpZChnZW5lcmF0ZUVycm9ySW5mb3JtYXRpb24obm9kZSwgZS5tZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSB0eXBlLCBldmFsdWF0ZSBzdGF0aWMgdmFsdWVcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlIYW5kbGVyLmNvbXB1dGVTdGF0aWNWYWx1ZSAhPSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyAmJiBjb25zb2xlLndhcm4oXCJObyBzdGF0aWMgZXZhbHVhdGlvbiBleGlzdHMgZm9yIGZ1bmN0aW9uXCIsIGNvZGVnZW4uZ2VuZXJhdGUobm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlID0gcHJvcGVydHlIYW5kbGVyLmNvbXB1dGVTdGF0aWNWYWx1ZShyZXN1bHQsIGFyZ3MsIHNjb3BlLCBvYmplY3RSZWZlcmVuY2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRpY1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0U3RhdGljVmFsdWUoc3RhdGljVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgfSAgZWxzZSBpZiAobm9kZS5jYWxsZWUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IG5vZGUuY2FsbGVlLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IHNjb3BlLmdldEJpbmRpbmdCeU5hbWUoZnVuY3Rpb25OYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghZnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5SRUZFUkVOQ0VfRVJST1IsIGZ1bmN0aW9uTmFtZSwgIFwiaXMgbm90IGRlZmluZWRcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKCFmdW5jLmlzRnVuY3Rpb24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5UWVBFX0VSUk9SLCBmdW5jLmdldFR5cGVTdHJpbmcoKSwgXCJpcyBub3QgYSBmdW5jdGlvblwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBleHRyYSA9IGNvbnRleHQuY2FsbEZ1bmN0aW9uKHNjb3BlLmdldFZhcmlhYmxlSWRlbnRpZmllcihmdW5jdGlvbk5hbWUpLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRyYSAmJiByZXN1bHQuc2V0RnJvbUV4dHJhKGV4dHJhKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBcIkZhaWx1cmUgaW4gZnVuY3Rpb24gY2FsbDogXCIsIGUubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBcIkludGVybmFsOlwiLCBcIlVuaGFuZGxlZCBDYWxsRXhwcmVzc2lvblwiLCBub2RlLmNhbGxlZS50eXBlKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBpbml0ID0gbm9kZS5pbml0ID8gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmluaXQpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEFOTk8obm9kZSk7XHJcbiAgICAgICAgICAgIGlmKGluaXQpIHtcclxuICAgICAgICAgICAgICAgIEFOTk8obm9kZS5pbml0KS5jb3B5KGluaXQpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkoaW5pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2V0SW5EZWNsYXJhdGlvbihmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBjb250ZXh0LmdldFR5cGVJbmZvKG5vZGUubGVmdCksXHJcbiAgICAgICAgICAgICAgICByaWdodCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5yaWdodCksXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBBTk5PKG5vZGUpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIHN0YXRpYzogdHJ1ZSB8fCBmYWxzZSwgZHluYW1pYzogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHZhciBsZWZ0Qm9vbCA9IGxlZnQuZ2V0U3RhdGljVHJ1dGhWYWx1ZSgpLFxyXG4gICAgICAgICAgICAgICAgcmlnaHRCb29sID0gcmlnaHQuZ2V0U3RhdGljVHJ1dGhWYWx1ZSgpLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcInx8XCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0Qm9vbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29weShyaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRCb29sID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkobGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gTGVmdCBpcyBkeW5hbWljLCBsZXQncyBjaGVjayByaWdodFxyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0Qm9vbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgdGhlIHJlc3VsdCB0eXBlIGlzIGFsd2F5cyB0aGUgb25lIG9mIHRoZSBsZWZ0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkobGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSBcIiYmXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0Qm9vbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUKHgpID09IGZhbHNlID0+IHggJiYgeSA9PSB4XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkobGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRCb29sID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkocmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIExlZnQgaXMgZHluYW1pYywgbGV0J3MgY2hlY2sgcmlnaHRcclxuICAgICAgICAgICAgICAgIGlmIChyaWdodEJvb2wgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgdGhlIHJlc3VsdCB0eXBlIGlzIGFsd2F5cyB0aGUgb25lIG9mIHRoZSBsZWZ0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkobGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0Qm9vbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgdGhlIHJlc3VsdCBtdXN0IGJlIGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFR5cGUoVFlQRVMuQk9PTEVBTik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFN0YXRpY1ZhbHVlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbiBjYXN0IGJvdGggc2lkZXMgdG8gYSBjb21tb24gdHlwZSwgaXQncyBmaW5lXHJcbiAgICAgICAgICAgIGlmKHJlc3VsdC5zZXRDb21tb25UeXBlKGxlZnQsIHJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBcIkNhbid0IGV2YWx1YXRlIHBvbHltb3JwaGljIGxvZ2ljYWwgZXhwcmVzc2lvblwiKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBjb25zZXF1ZW50ID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmNvbnNlcXVlbnQpLFxyXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmFsdGVybmF0ZSksXHJcbiAgICAgICAgICAgICAgICB0ZXN0ID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLnRlc3QpLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQU5OTyhub2RlKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXN0UmVzdWx0ID0gdGVzdC5nZXRTdGF0aWNUcnV0aFZhbHVlKCk7XHJcbiAgICAgICAgICAgIGlmKHRlc3RSZXN1bHQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5KGNvbnNlcXVlbnQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRlc3RSZXN1bHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuY29weShhbHRlcm5hdGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zZXRDb21tb25UeXBlKGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0RHluYW1pY1ZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRJbnZhbGlkKGdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBcIkNhbid0IGV2YWx1YXRlIHBvbHltb3JwaGljIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25cIikpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgbnMuYW5ub3RhdGVSaWdodCAgPSBmdW5jdGlvbihjb250ZXh0LCBhc3QsIHByb3BhZ2F0ZWRDb25zdGFudHMpIHtcclxuXHJcbiAgICAgICAgaWYoIWFzdClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJObyBub2RlIHRvIGFuYWx5emVcIik7XHJcblxyXG4gICAgICAgIHZhciBjb250cm9sbGVyID0gbmV3IGVzdHJhdmVyc2UuQ29udHJvbGxlcigpO1xyXG5cclxuICAgICAgICBjb250ZXh0LnNldENvbnN0YW50cyhwcm9wYWdhdGVkQ29uc3RhbnRzIHx8IG51bGwpO1xyXG5cclxuICAgICAgICBjb250cm9sbGVyLnRyYXZlcnNlKGFzdCwge1xyXG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zZXRJbkRlY2xhcmF0aW9uKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24obm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMuaGFzT3duUHJvcGVydHkobm9kZS50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyc1tub2RlLnR5cGVdLmNhbGwodGhpcywgbm9kZSwgcGFyZW50LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnRleHQuc2V0Q29uc3RhbnRzKG51bGwpO1xyXG5cclxuICAgIH1cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcblxyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUyxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoXCIuL3Rvb2xzLmpzXCIpO1xyXG5cclxuICAgIHZhciBDb2xvckNsb3N1cmVJbnN0YW5jZSA9IHtcclxuICAgICAgICBtdWw6IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVFlQRVMuT0JKRUNULFxyXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtJTkRTLkNPTE9SX0NMT1NVUkVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogS0lORFMuQ09MT1JfQ0xPU1VSRVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XHJcbiAgICAgICAgaWQ6IFwiQ29sb3JDbG9zdXJlXCIsXHJcbiAgICAgICAga2luZDogS0lORFMuQ09MT1JfQ0xPU1VSRSxcclxuICAgICAgICBvYmplY3Q6IHtcclxuICAgICAgICAgICAgY29uc3RydWN0b3I6IG51bGwsXHJcbiAgICAgICAgICAgIHN0YXRpYzogbnVsbFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5zdGFuY2U6IENvbG9yQ2xvc3VyZUluc3RhbmNlXHJcbiAgICB9KTtcclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBTY29wZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL3Njb3BlLmpzXCIpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9pbmRleC5qc1wiKTtcclxuXHJcblxyXG4gICAgdmFyIG9iamVjdHMgPSB7XHJcbiAgICAgICAgU2hhZGUgOiByZXF1aXJlKFwiLi9zaGFkZS5qc1wiKSxcclxuICAgICAgICBTcGFjZSA6IHJlcXVpcmUoXCIuL3NwYWNlLmpzXCIpLFxyXG4gICAgICAgIE1hdGggOiByZXF1aXJlKFwiLi9tYXRoLmpzXCIpLFxyXG4gICAgICAgIFZlYzIgOiByZXF1aXJlKFwiLi92ZWMyLmpzXCIpLFxyXG4gICAgICAgIFZlYzMgOiByZXF1aXJlKFwiLi92ZWMzLmpzXCIpLFxyXG4gICAgICAgIENvbG9yOiByZXF1aXJlKFwiLi92ZWMzLmpzXCIpLFxyXG4gICAgICAgIFZlYzQgOiByZXF1aXJlKFwiLi92ZWM0LmpzXCIpLFxyXG4gICAgICAgIE1hdDMgOiByZXF1aXJlKFwiLi9tYXQzLmpzXCIpLFxyXG4gICAgICAgIE1hdDQgOiByZXF1aXJlKFwiLi9tYXQ0LmpzXCIpLFxyXG4gICAgICAgIFRleHR1cmUgOiByZXF1aXJlKFwiLi90ZXh0dXJlLmpzXCIpLFxyXG4gICAgICAgIENvbG9yQ2xvc3VyZTogcmVxdWlyZShcIi4vY29sb3JjbG9zdXJlLmpzXCIpXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBSZWdpc3RyeSA9IHtcclxuICAgICAgICBuYW1lOiBcIlR5cGVJbmZlcmVuY2VcIixcclxuICAgICAgICBnZXRCeU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdHNbbmFtZV07XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEluc3RhbmNlRm9yS2luZDogZnVuY3Rpb24oa2luZCkge1xyXG4gICAgICAgICAgICBmb3IodmFyIG9iaiBpbiBvYmplY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0c1tvYmpdLmtpbmQgPT0ga2luZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3RzW29ial0uaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIHtTY29wZX1cclxuICAgICAqL1xyXG4gICAgdmFyIEluZmVyZW5jZVNjb3BlID0gZnVuY3Rpb24obm9kZSwgcGFyZW50U2NvcGUsIG9wdCkge1xyXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICBCYXNlLmV4dGVuZChvcHQsIHsgcmVnaXN0cnk6IFJlZ2lzdHJ5IH0pO1xyXG4gICAgICAgIFNjb3BlLmNhbGwodGhpcywgbm9kZSwgcGFyZW50U2NvcGUsIG9wdCk7XHJcbiAgICB9XHJcblxyXG4gICAgQmFzZS5jcmVhdGVDbGFzcyhJbmZlcmVuY2VTY29wZSwgU2NvcGUsIHtcclxuXHJcbiAgICAgICAgcmVnaXN0ZXJHbG9iYWxzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIk1hdGhcIiwgb2JqZWN0cy5NYXRoKTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIkNvbG9yXCIsICBvYmplY3RzLkNvbG9yKTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIlZlYzJcIiwgb2JqZWN0cy5WZWMyKTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIlZlYzNcIiwgb2JqZWN0cy5WZWMzKTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIlZlYzRcIiwgb2JqZWN0cy5WZWM0KTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIlRleHR1cmVcIiwgb2JqZWN0cy5UZXh0dXJlKTtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck9iamVjdChcIlNoYWRlXCIsIG9iamVjdHMuU2hhZGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiU3BhY2VcIiwgb2JqZWN0cy5TcGFjZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYmplY3QoXCJNYXQzXCIsIG9iamVjdHMuTWF0Myk7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYmplY3QoXCJNYXQ0XCIsIG9iamVjdHMuTWF0NCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyZVZhcmlhYmxlKFwiX2VudlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgZXhwb3J0cy5JbmZlcmVuY2VTY29wZSA9IEluZmVyZW5jZVNjb3BlO1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcblxyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUyxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoXCIuL3Rvb2xzLmpzXCIpO1xyXG5cclxuICAgIHZhciBNYXRyaXgzQ29uc3RydWN0b3IgPSAge1xyXG4gICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICBraW5kOiBLSU5EUy5NQVRSSVgzLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7QW5ub3RhdGlvbn0gcmVzdWx0XHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QW5ub3RhdGlvbj59IGFyZ3NcclxuICAgICAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGN0eFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV2YWx1YXRlOiBUb29scy5NYXQubWF0Q29uc3RydWN0b3JFdmFsdWF0ZS5iaW5kKG51bGwsIFwiTWF0M1wiKVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgTWF0cml4M1N0YXRpY09iamVjdCA9IHtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIE1hdHJpeDNJbnN0YW5jZSA9IHtcclxuICAgICAgICBjb2w6IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBUb29scy5NYXQuY29sRXZhbHVhdGUuYmluZChudWxsLCBcIk1hdDNcIilcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbHMuTWF0LmF0dGFjaE1hdE1ldGhvZHMoTWF0cml4M0luc3RhbmNlLCBcIk1hdDNcIiwgWydhZGQnLCAnc3ViJywgJ211bCcsICdkaXYnXSk7XHJcbiAgICBUb29scy5WZWMuYXR0YWNoVmVjTWV0aG9kcyhNYXRyaXgzSW5zdGFuY2UsIFwiTWF0M1wiLCAzLCAzLCBbJ211bFZlYyddKTtcclxuXHJcblxyXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XHJcbiAgICAgICAgaWQ6IFwiTWF0M1wiLFxyXG4gICAgICAgIGtpbmQ6IEtJTkRTLk1BVFJJWDMsXHJcbiAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBNYXRyaXgzQ29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIHN0YXRpYzogTWF0cml4M1N0YXRpY09iamVjdFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5zdGFuY2U6IE1hdHJpeDNJbnN0YW5jZVxyXG4gICAgfSk7XHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcblxyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUyxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoXCIuL3Rvb2xzLmpzXCIpO1xyXG5cclxuICAgIHZhciBNYXRyaXg0Q29uc3RydWN0b3IgPSAge1xyXG4gICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICBraW5kOiBLSU5EUy5NQVRSSVg0LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7QW5ub3RhdGlvbn0gcmVzdWx0XHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QW5ub3RhdGlvbj59IGFyZ3NcclxuICAgICAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGN0eFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV2YWx1YXRlOiBUb29scy5NYXQubWF0Q29uc3RydWN0b3JFdmFsdWF0ZS5iaW5kKG51bGwsIFwiTWF0NFwiKVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgTWF0cml4NFN0YXRpY09iamVjdCA9IHtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIE1hdHJpeDRJbnN0YW5jZSA9IHtcclxuICAgICAgICBjb2w6IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBUb29scy5NYXQuY29sRXZhbHVhdGUuYmluZChudWxsLCBcIk1hdDRcIilcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbHMuTWF0LmF0dGFjaE1hdE1ldGhvZHMoTWF0cml4NEluc3RhbmNlLCBcIk1hdDRcIiwgWydhZGQnLCAnc3ViJywgJ211bCcsICdkaXYnXSk7XHJcbiAgICBUb29scy5WZWMuYXR0YWNoVmVjTWV0aG9kcyhNYXRyaXg0SW5zdGFuY2UsIFwiTWF0NFwiLCA0LCA0LCBbJ211bFZlYyddKTtcclxuXHJcblxyXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XHJcbiAgICAgICAgaWQ6IFwiTWF0NFwiLFxyXG4gICAgICAgIGtpbmQ6IEtJTkRTLk1BVFJJWDQsXHJcbiAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBNYXRyaXg0Q29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIHN0YXRpYzogTWF0cml4NFN0YXRpY09iamVjdFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5zdGFuY2U6IE1hdHJpeDRJbnN0YW5jZVxyXG4gICAgfSk7XHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBUWVBFUyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9pbmRleC5qc1wiKSxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoXCIuL3Rvb2xzLmpzXCIpO1xyXG5cclxuXHJcbiAgICB2YXIgbm90U3RhdGljID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICB2YXIgZXZhbHVhdGVTdGF0aWMgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKFRvb2xzLmFsbEFyZ3VtZW50c0FyZVN0YXRpYyhhcmdzKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRTdGF0aWNWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aFtuYW1lXS5hcHBseShudWxsLCBjYWxsQXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGV2YWx1YXRlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtQ291bnQsIHJldHVyblR5cGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0Fubm90YXRpb259IHJlc3VsdFxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXkuPEFubm90YXRpb24+fSBhcmdzXHJcbiAgICAgICAgICogQHBhcmFtIHtDb250ZXh0fSBjdHhcclxuICAgICAgICAgKi9cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlc3VsdCwgYXJncywgY3R4KSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbUNvdW50ICE9IC0xKSB7IC8vIEFyYml0cmFyeSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggIT0gcGFyYW1Db3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBhcmFtZXRlcnMgZm9yIE1hdGguXCIgKyBuYW1lICsgXCIsIGV4cGVjdGVkIFwiICsgcGFyYW1Db3VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShwYXJhbS5jYW5OdW1iZXIoKSB8fCBwYXJhbS5pc1ZlY3RvcigpKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgXCIgKyBpbmRleCArIFwiIGhhcyBpbnZhbGlkIHR5cGUgZm9yIE1hdGguXCIgKyBuYW1lICsgXCIsIGV4cGVjdGVkICdudW1iZXInLCBidXQgZ290IFwiICsgcGFyYW0uZ2V0VHlwZSgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IHJldHVyblR5cGUgfHwgYXJnc1swXS5pc1ZlY3RvcigpID8gVFlQRVMuT0JKRUNUIDogVFlQRVMuTlVNQkVSXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJnc1swXS5pc1ZlY3RvcigpICYmICh0eXBlSW5mby5raW5kID0gYXJnc1swXS5nZXRLaW5kKCkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgTWF0aE9iamVjdCA9IHtcclxuICAgICAgICByYW5kb206IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAobm9kZSwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hdGgucmFuZG9tIGhhcyBubyBwYXJhbWV0ZXJzLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVFlQRVMuTlVNQkVSXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbXB1dGVTdGF0aWNWYWx1ZTogbm90U3RhdGljXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhYnM6IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAocmVzdWx0LCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICBUb29scy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIFwiTWF0aC5hYnNcIiwgWzFdLCBhcmdzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZUluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgIGlmKGFyZ3NbMF0uY2FuTnVtYmVyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gYXJnc1swXS5nZXRUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmdzWzBdLmlzVmVjdG9yKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gYXJnc1swXS5nZXRUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8ua2luZCA9IGFyZ3NbMF0uZ2V0S2luZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJJbnZhbGlkVHlwZSBmb3IgTWF0aC5hYnNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBTdGF0aWMgdmFsdWVcclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlSW5mbztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29tcHV0ZVN0YXRpY1ZhbHVlOiBldmFsdWF0ZVN0YXRpYyhcImFic1wiKVxyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAvLyBOb24tc3RhbmRhcmQgbWV0aG9kc1xyXG4gICAgICAgIGNsYW1wOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKHJlc3VsdCwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgVG9vbHMuY2hlY2tQYXJhbUNvdW50KHJlc3VsdC5ub2RlLCBcIk1hdGguY2xhbXBcIiwgWzNdLCBhcmdzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYXJnc1sxXS5jYW5OdW1iZXIoKSAmJiBhcmdzWzJdLmNhbk51bWJlcigpKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZUluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBpZihhcmdzWzBdLmNhbk51bWJlcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGUgPSBUWVBFUy5OVU1CRVI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3NbMF0uaXNWZWN0b3IoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlID0gYXJnc1swXS5nZXRUeXBlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLmtpbmQgPSBhcmdzWzBdLmdldEtpbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJNYXRoLmNsYW1wIG5vdCBzdXBwb3J0ZWQgd2l0aCBhcmd1bWVudCB0eXBlczogXCIgKyBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5nZXRUeXBlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiLCBcIikpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wdXRlU3RhdGljVmFsdWU6IGV2YWx1YXRlU3RhdGljKFwiY2xhbXBcIilcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzbW9vdGhzdGVwOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKHJlc3VsdCwgYXJncywgY3R4KSB7XHJcbiAgICAgICAgICAgICAgICBUb29scy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIFwiTWF0aC5zbW9vdGhzdGVwXCIsIFszXSwgYXJncy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmV2ZXJ5KGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmNhbk51bWJlcigpOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFRZUEVTLk5VTUJFUiB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MuZXZlcnkoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5pc1ZlY3RvcigpO1xyXG4gICAgICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcmdzWzBdLmVxdWFscyhhcmdzWzFdKSAmJiBhcmdzWzFdLmVxdWFscyhhcmdzWzJdKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJNYXRoLnNtb290aHN0ZXA6IEFsbCBhcmd1bWVudHMgaGF2ZSB0byBoYXZlIHRoZSBzYW1lIHR5cGU6IFwiICsgYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5nZXRUeXBlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogVFlQRVMuT0JKRUNULFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBhcmdzWzBdLmdldEtpbmQoKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJNYXRoLnNtb290aHN0ZXAgbm90IHN1cHBvcnRlZCB3aXRoIGFyZ3VtZW50IHR5cGVzOiBcIiArIGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLmdldFR5cGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsIFwiKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbXB1dGVTdGF0aWNWYWx1ZTogZXZhbHVhdGVTdGF0aWMoXCJzbW9vdGhzdGVwXCIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGVwOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKHJlc3VsdCwgYXJncywgY3R4KSB7XHJcbiAgICAgICAgICAgICAgICBUb29scy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIFwiU2hhZGUuc3RlcFwiLCBbMl0sIGFyZ3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoVG9vbHMuYWxsQXJndW1lbnRzQ2FuTnVtYmVyKGFyZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogVFlQRVMuTlVNQkVSIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiU2hhZGUuc3RlcCBub3Qgc3VwcG9ydGVkIHdpdGggYXJndW1lbnQgdHlwZXM6IFwiICsgYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcuZ2V0VHlwZVN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfSkuam9pbihcIiwgXCIpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29tcHV0ZVN0YXRpY1ZhbHVlOiBldmFsdWF0ZVN0YXRpYyhcInN0ZXBcIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyYWN0OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogVG9vbHMuVmVjLmFueVZlY0FyZ3VtZW50RXZhbHVhdGUuYmluZChudWxsLCBcImZyYWN0XCIpLFxyXG4gICAgICAgICAgICBjb21wdXRlU3RhdGljVmFsdWU6IGV2YWx1YXRlU3RhdGljKFwiZnJhY3RcIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1peDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MsIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgVG9vbHMuY2hlY2tQYXJhbUNvdW50KHJlc3VsdC5ub2RlLCBcIk1hdGgubWl4XCIsIFszXSwgYXJncy5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjbnQgPSBUb29scy5WZWMuY2hlY2tBbnlWZWNBcmd1bWVudChyZXN1bHQubm9kZSwgXCJNYXRoLm1peFwiLCBhcmdzWzBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZUluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgIEJhc2UuZXh0ZW5kKHR5cGVJbmZvLCBUb29scy5WZWMuZ2V0VHlwZShjbnQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3NbMV0uZXF1YWxzKGFyZ3NbMF0pKVxyXG4gICAgICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiTWF0aC5taXggdHlwZXMgb2YgZmlyc3QgdHdvIGFyZ3VtZW50cyBkbyBubyBtYXRjaDogZ290IFwiICsgYXJnc1swXS5nZXRUeXBlU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhbmQgXCIgKyBhcmdzWzFdLmdldFR5cGVTdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3NbMl0uY2FuTnVtYmVyKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJNYXRoLm1peCB0aGlyZCBhcmd1bWVudCBpcyBub3QgYSBudW1iZXIuXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlSW5mbztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29tcHV0ZVN0YXRpY1ZhbHVlOiBldmFsdWF0ZVN0YXRpYyhcIm1peFwiKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2F0dXJhdGU6IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAocmVzdWx0LCBhcmdzLCBjdHgpIHtcclxuICAgICAgICAgICAgICAgIFRvb2xzLmNoZWNrUGFyYW1Db3VudChyZXN1bHQubm9kZSwgXCJTaGFkZS5zYXR1cmF0ZVwiLCBbMV0sIGFyZ3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZUluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVFlQRVMuTlVNQkVSXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIGlmICghYXJnLmNhbk51bWJlcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJNYXRoLnNhdHVyYXRlIG5vdCBzdXBwb3J0ZWQgd2l0aCBhcmd1bWVudCB0eXBlOiBcIiArIGFyZy5nZXRUeXBlU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wdXRlU3RhdGljVmFsdWU6IGV2YWx1YXRlU3RhdGljKFwic2F0dXJhdGVcIilcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBNYXRoQ29uc3RhbnRzID0gW1wiRVwiLCBcIlBJXCIsIFwiTE4yXCIsIFwiTE9HMkVcIiwgXCJMT0cxMEVcIiwgXCJQSVwiLCBcIlNRUlQxXzJcIiwgXCJTUVJUMlwiXTtcclxuICAgIHZhciBPbmVQYXJhbWV0ZXJOdW1iZXJNZXRob2RzID0gW1wiYWNvc1wiLCBcImFzaW5cIiwgXCJhdGFuXCIsIFwiY29zXCIsIFwiZXhwXCIsIFwibG9nXCIsIFwicm91bmRcIiwgXCJzaW5cIiwgXCJzcXJ0XCIsIFwidGFuXCIsIFwiY2VpbFwiLCBcImZsb29yXCJdO1xyXG4gICAgdmFyIE9uZVBhcmFtZXRlckludE1ldGhvZHMgPSBbXTtcclxuICAgIHZhciBUd29QYXJhbWV0ZXJOdW1iZXJNZXRob2RzID0gW1wiYXRhbjJcIiwgXCJwb3dcIl07XHJcbiAgICB2YXIgQXJiaXRyYXJ5UGFyYW1ldGVyTnVtYmVyTWV0aG9kcyA9IFtcIm1heFwiLCBcIm1pblwiXTtcclxuXHJcbiAgICBNYXRoQ29uc3RhbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0YW50KSB7XHJcbiAgICAgICAgTWF0aE9iamVjdFtjb25zdGFudF0gPSB7IHR5cGU6IFRZUEVTLk5VTUJFUiwgc3RhdGljVmFsdWU6IE1hdGhbY29uc3RhbnRdIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBPbmVQYXJhbWV0ZXJOdW1iZXJNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICAgIE1hdGhPYmplY3RbbWV0aG9kXSA9IHsgdHlwZTogVFlQRVMuRlVOQ1RJT04sIGV2YWx1YXRlOiBldmFsdWF0ZU1ldGhvZChtZXRob2QsIDEpLCBjb21wdXRlU3RhdGljVmFsdWU6IGV2YWx1YXRlU3RhdGljKG1ldGhvZCkgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIFR3b1BhcmFtZXRlck51bWJlck1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICAgICAgTWF0aE9iamVjdFttZXRob2RdID0geyB0eXBlOiBUWVBFUy5GVU5DVElPTiwgZXZhbHVhdGU6IGV2YWx1YXRlTWV0aG9kKG1ldGhvZCwgMiksIGNvbXB1dGVTdGF0aWNWYWx1ZTogZXZhbHVhdGVTdGF0aWMobWV0aG9kKSAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIE9uZVBhcmFtZXRlckludE1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICAgICAgTWF0aE9iamVjdFttZXRob2RdID0geyB0eXBlOiBUWVBFUy5GVU5DVElPTiwgZXZhbHVhdGU6IGV2YWx1YXRlTWV0aG9kKG1ldGhvZCwgMSwgVFlQRVMuSU5UKSwgY29tcHV0ZVN0YXRpY1ZhbHVlOiBldmFsdWF0ZVN0YXRpYyhtZXRob2QpICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgQXJiaXRyYXJ5UGFyYW1ldGVyTnVtYmVyTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICAgICAgICBNYXRoT2JqZWN0W21ldGhvZF0gPSB7IHR5cGU6IFRZUEVTLkZVTkNUSU9OLCBldmFsdWF0ZTogZXZhbHVhdGVNZXRob2QobWV0aG9kLCAtMSksIGNvbXB1dGVTdGF0aWNWYWx1ZTogZXZhbHVhdGVTdGF0aWMobWV0aG9kKSAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIEJhc2UuZXh0ZW5kKG5zLCB7XHJcbiAgICAgICAgaWQ6IFwiTWF0aFwiLFxyXG4gICAgICAgIG9iamVjdDoge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogbnVsbCxcclxuICAgICAgICAgICAgc3RhdGljOiBNYXRoT2JqZWN0LFxyXG4gICAgICAgICAgICBzdGF0aWNWYWx1ZTogTWF0aFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5zdGFuY2U6IE1hdGhPYmplY3RcclxuICAgIH0pO1xyXG5cclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24obnMpe1xyXG5cclxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxyXG4gICAgICAgIFRZUEVTID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS0lORFMgPSBTaGFkZS5PQkpFQ1RfS0lORFMsXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxyXG4gICAgICAgIFRvb2xzID0gcmVxdWlyZShcIi4vdG9vbHMuanNcIik7XHJcblxyXG4gICAgdmFyIFNoYWRlQ29uc3RydWN0b3IgPSAge1xyXG4gICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICBraW5kOiBLSU5EUy5DT0xPUl9DTE9TVVJFLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7QW5ub3RhdGlvbn0gcmVzdWx0XHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QW5ub3RhdGlvbj59IGFyZ3NcclxuICAgICAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGN0eFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3MsIGNvbnRleHQsIG9iamVjdFJlZmVyZW5jZSwgcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhZGUuZW1pc3Npb24gZXhwZWN0cyBubyBwYXJhbWV0ZXJzLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgIGtpbmQ6IEtJTkRTLkNPTE9SX0NMT1NVUkVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjaGVja0FyZ3VtZW50SXNDb2xvciA9IGZ1bmN0aW9uKG5vZGUsIGFyZ3MsIHBvc2l0aW9uLCBuYW1lKSB7XHJcbiAgICAgICAgaWYoIWFyZ3NbcG9zaXRpb25dIHx8ICFhcmdzW3Bvc2l0aW9uXS5jYW5Db2xvcigpKVxyXG4gICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiQXJndW1lbnQgXCIrIHBvc2l0aW9uICsgXCIgb2YgU2hhZGUuXCIgKyBuYW1lICsgXCIgbXVzdCBldmFsdWF0ZSB0byBhIGNvbG9yLCBmb3VuZCBcIiArIChhcmdzW3Bvc2l0aW9uXSA/IGFyZ3NbcG9zaXRpb25dLmdldFR5cGVTdHJpbmcoKSA6IFwidW5kZWZpbmVkXCIpKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNoZWNrQXJndW1lbnRJc05vcm1hbCA9IGZ1bmN0aW9uKG5vZGUsIGFyZ3MsIHBvc2l0aW9uLCBuYW1lKSB7XHJcbiAgICAgICAgaWYoIWFyZ3NbcG9zaXRpb25dIHx8ICFhcmdzW3Bvc2l0aW9uXS5jYW5Ob3JtYWwoKSlcclxuICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihub2RlLCBcIkFyZ3VtZW50IFwiKyBwb3NpdGlvbiArIFwiIG9mIFNoYWRlLlwiICsgbmFtZSArIFwiIG11c3QgZXZhbHVhdGUgdG8gYSBub3JtYWwsIGZvdW5kIFwiICsgKGFyZ3NbcG9zaXRpb25dID8gYXJnc1twb3NpdGlvbl0uZ2V0VHlwZVN0cmluZygpIDogXCJ1bmRlZmluZWRcIikpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU2hhZGVPYmplY3QgPSB7XHJcbiAgICAgICAgZW1pc3Npb246IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3MsIGNvbnRleHQsIG9iamVjdFJlZmVyZW5jZSwgcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGFkZS5lbWlzc2lvbiBleHBlY3RzIG5vIHBhcmFtZXRlcnMuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogS0lORFMuQ09MT1JfQ0xPU1VSRVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlmZnVzZToge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgbmFtZTogXCJkaWZmdXNlXCIsXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3MsIGNvbnRleHQsIG9iamVjdFJlZmVyZW5jZSwgcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tBcmd1bWVudElzQ29sb3IocmVzdWx0Lm5vZGUsIGFyZ3MsIDAsIHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjaGVja0FyZ3VtZW50SXNOb3JtYWwocmVzdWx0Lm5vZGUsIGFyZ3MsIDEsIHRoaXMubmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogS0lORFMuQ09MT1JfQ0xPU1VSRVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGhvbmc6IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIG5hbWU6IFwicGhvbmdcIixcclxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgYXJncywgY3R4KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBhcmd1bWVudHMgYmFzZWQgb24gaW50ZXJmYWNlIGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgICAgICBjaGVja0FyZ3VtZW50SXNDb2xvcihyZXN1bHQubm9kZSwgYXJncywgMCwgdGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGNoZWNrQXJndW1lbnRJc05vcm1hbChyZXN1bHQubm9kZSwgYXJncywgMSwgdGhpcy5uYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoaW5pbmVzcyA9IGFyZ3NbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXNoaW5pbmVzcy5jYW5OdW1iZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlyZCBhcmd1bWVudCAoc2hpbmluZXNzKSBvZiBTaGFkZS5waG9uZyBtdXN0IGV2YWx1YXRlIHRvIGEgbnVtYmVyLiBGb3VuZDogXCIgKyBzaGluaW5lc3Muc3RyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgICAgICBraW5kOiBLSU5EUy5DT0xPUl9DTE9TVVJFXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb29rVG9ycmFuY2U6IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIG5hbWU6IFwiY29va1RvcnJhbmNlXCIsXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3MsIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgYXJndW1lbnRzIGJhc2VkIG9uIGludGVyZmFjZSBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICAgICAgY2hlY2tBcmd1bWVudElzQ29sb3IocmVzdWx0Lm5vZGUsIGFyZ3MsIDAsIHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjaGVja0FyZ3VtZW50SXNOb3JtYWwocmVzdWx0Lm5vZGUsIGFyZ3MsIDEsIHRoaXMubmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogS0lORFMuQ09MT1JfQ0xPU1VSRVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2FyZDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgbmFtZTogXCJ3YXJkXCIsXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3MsIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgYXJndW1lbnRzIGJhc2VkIG9uIGludGVyZmFjZSBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICAgICAgY2hlY2tBcmd1bWVudElzQ29sb3IocmVzdWx0Lm5vZGUsIGFyZ3MsIDAsIHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjaGVja0FyZ3VtZW50SXNOb3JtYWwocmVzdWx0Lm5vZGUsIGFyZ3MsIDEsIHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjaGVja0FyZ3VtZW50SXNOb3JtYWwocmVzdWx0Lm5vZGUsIGFyZ3MsIDIsIHRoaXMubmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogS0lORFMuQ09MT1JfQ0xPU1VSRVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVmbGVjdDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgbmFtZTogXCJyZWZsZWN0XCIsXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3MsIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgYXJndW1lbnRzIGJhc2VkIG9uIGludGVyZmFjZSBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgICAgICAgY2hlY2tBcmd1bWVudElzTm9ybWFsKHJlc3VsdC5ub2RlLCBhcmdzLCAwLCB0aGlzLm5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVFlQRVMuT0JKRUNULFxyXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IEtJTkRTLkNPTE9SX0NMT1NVUkVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZnJhY3Q6IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgIG5hbWU6IFwicmVmcmFjdFwiLFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBhcmdzLCBjdHgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IENoZWNrIGFyZ3VtZW50cyBiYXNlZCBvbiBpbnRlcmZhY2UgZGVzY3JpcHRpb25cclxuICAgICAgICAgICAgICAgIGNoZWNrQXJndW1lbnRJc05vcm1hbChyZXN1bHQubm9kZSwgYXJncywgMCwgdGhpcy5uYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgICAgICBraW5kOiBLSU5EUy5DT0xPUl9DTE9TVVJFXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2F0dGVyOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgICAgICBuYW1lOiBcInNjYXR0ZXJcIixcclxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgYXJncywgY3R4KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBhcmd1bWVudHMgYmFzZWQgb24gaW50ZXJmYWNlIGRlc2NyaXB0aW9uXHJcbiAgICAgICAgICAgICAgICBjaGVja0FyZ3VtZW50SXNDb2xvcihyZXN1bHQubm9kZSwgYXJncywgMCwgdGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGNoZWNrQXJndW1lbnRJc05vcm1hbChyZXN1bHQubm9kZSwgYXJncywgMSwgdGhpcy5uYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgICAgICBraW5kOiBLSU5EUy5DT0xPUl9DTE9TVVJFXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgQmFzZS5leHRlbmQobnMsIHtcclxuICAgICAgICBpZDogXCJTaGFkZVwiLFxyXG4gICAgICAgIGtpbmQ6IEtJTkRTLkNPTE9SX0NMT1NVUkUsXHJcbiAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBTaGFkZUNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBzdGF0aWM6IG51bGxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluc3RhbmNlOiBTaGFkZU9iamVjdFxyXG5cclxuICAgIH0pO1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBUWVBFUyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEtJTkRTID0gU2hhZGUuT0JKRUNUX0tJTkRTO1xyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9pbmRleC5qc1wiKSxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoXCIuL3Rvb2xzLmpzXCIpO1xyXG5cclxuXHJcbiAgICB2YXIgU3BhY2VPYmplY3QgPSB7XHJcbiAgICAgICAgdHJhbnNmb3JtRGlyZWN0aW9uOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKHJlc3VsdCwgYXJncywgY29udGV4dCwgb2JqZWN0UmVmZXJlbmNlLCByb290KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggIT0gMilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2Zvcm1EaXJlY3Rpb24gZXhwZWN0cyAyIHBhcmFtZXRlcnMuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogS0lORFMuRkxPQVQzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmFuc2Zvcm1Qb2ludDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIGFyZ3MsIGNvbnRleHQsIG9iamVjdFJlZmVyZW5jZSwgcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNmb3JtUG9pbnQgZXhwZWN0cyAyIHBhcmFtZXRlcnMuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogS0lORFMuRkxPQVQzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBWSUVXOiB7IHR5cGU6IFRZUEVTLk5VTUJFUn0sXHJcbiAgICAgICAgV09STEQ6IHsgdHlwZTogVFlQRVMuTlVNQkVSfVxyXG4gICAgfTtcclxuXHJcbiAgICBCYXNlLmV4dGVuZChucywge1xyXG4gICAgICAgIGlkOiBcIlNwYWNlXCIsXHJcbiAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBudWxsLFxyXG4gICAgICAgICAgICBzdGF0aWM6IFNwYWNlT2JqZWN0LFxyXG4gICAgICAgICAgICBzdGF0aWNWYWx1ZTogTWF0aFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5zdGFuY2U6IFNwYWNlT2JqZWN0XHJcbiAgICB9KTtcclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uKG5zKXtcclxuXHJcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvaW5kZXguanNcIiksXHJcbiAgICAgICAgQW5ub3RhdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9hbm5vdGF0aW9uLmpzXCIpLFxyXG4gICAgICAgIFRvb2xzID0gcmVxdWlyZShcIi4vdG9vbHMuanNcIik7XHJcblxyXG4gICAgdmFyIFRZUEVTID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS0lORFMgPSBTaGFkZS5PQkpFQ1RfS0lORFMsXHJcbiAgICAgICAgQU5OTyA9IEFubm90YXRpb25zLkFOTk87XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVyaXZlZCBwYXJhbWV0ZXJzOiBUaGVzZSBleGlzdCBpbiB0aGUgc3lzdGVtIGZvciBjb252ZW5pZW5jZSxcclxuICAgICAqIGJ1dCBjYW4gYmUgZGVyaXZlZCBmcm9tIG90aGVyIHN5c3RlbSBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIHZhciBEZXJpdmVkQ2FudmFzUHJvcGVydGllcyA9IHtcclxuICAgICAgICBub3JtYWxpemVkQ29vcmRzOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICAgICAga2luZDogS0lORFMuRkxPQVQzLFxyXG4gICAgICAgICAgICBkZXJpdmVkOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBoZWlnaHQ6IHtcclxuICAgICAgICAgICAgdHlwZTogVFlQRVMuSU5ULFxyXG4gICAgICAgICAgICBkZXJpdmVkOiB0cnVlXHJcbiAgICAgICAgfSxcclxuICAgICAgICB3aWR0aDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5JTlQsXHJcbiAgICAgICAgICAgIGRlcml2ZWQ6IHRydWVcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBhbGxvd051bWJlck9yVmVjdG9yKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzdWx0LCBhcmdzKSB7XHJcbiAgICAgICAgICAgVG9vbHMuY2hlY2tQYXJhbUNvdW50KHJlc3VsdC5ub2RlLCBuYW1lLCBbMV0sIGFyZ3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZy5jYW5OdW1iZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFyZy5nZXRUeXBlKClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmlzVmVjdG9yKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IGFyZy5nZXRLaW5kKClcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKHJlc3VsdC5ub2RlLCBcIklsbGVnYWxBcmd1bWVudEVycm9yOiBmaXJzdCBhcmd1bWVudCBvZiB0aGlzLlwiICsgbmFtZSArIFwiIGlzIG9mIHR5cGU6IFwiICsgYXJnLmdldFR5cGVTdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICB2YXIgT3B0aW9uYWxNZXRob2RzID0ge1xyXG4gICAgICAgIGZ3aWR0aDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgZXZhbHVhdGU6IGFsbG93TnVtYmVyT3JWZWN0b3IoXCJmd2lkdGhcIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIGR4OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogYWxsb3dOdW1iZXJPclZlY3RvcihcImR4XCIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkeToge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgZXZhbHVhdGU6IGFsbG93TnVtYmVyT3JWZWN0b3IoXCJkeVwiKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbnMuZ2V0VGhpc1R5cGVJbmZvID0gZnVuY3Rpb24oc3lzdGVtSW5mbykge1xyXG4gICAgICAgIHN5c3RlbUluZm8gPSBzeXN0ZW1JbmZvIHx8IHsgdHlwZTogVFlQRVMuT0JKRUNULCBraW5kOiBLSU5EUy5BTlksIGluZm86IHt9fTtcclxuICAgICAgICB2YXIgdGhpc0Fubm90YXRpb24gPSBBTk5PKHt9LCBzeXN0ZW1JbmZvKTtcclxuICAgICAgICAvLyBBZGQgdGhvc2UgcGFyYW1ldGVycyB0aGF0IGNhbiBiZSBjYWxjdWxhdGVkIGZyb20gc3lzdGVtIGlucHV0c1xyXG4gICAgICAgIHZhciBvYmplY3RJbmZvID0gdGhpc0Fubm90YXRpb24uZ2V0Tm9kZUluZm8oKTtcclxuICAgICAgICBpZiAoIW9iamVjdEluZm8pIHtcclxuICAgICAgICAgICAgb2JqZWN0SW5mbyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzQW5ub3RhdGlvbi5zZXROb2RlSW5mbyhvYmplY3RJbmZvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG9iamVjdEluZm8uaGFzT3duUHJvcGVydHkoXCJjb29yZHNcIikpIHtcclxuICAgICAgICAgICAgQmFzZS5leHRlbmQob2JqZWN0SW5mbywgRGVyaXZlZENhbnZhc1Byb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IodmFyIGVudHJ5IGluIE9wdGlvbmFsTWV0aG9kcykge1xyXG4gICAgICAgICAgICBpZihvYmplY3RJbmZvLmhhc093blByb3BlcnR5KGVudHJ5KSkge1xyXG4gICAgICAgICAgICAgICAgQmFzZS5leHRlbmQob2JqZWN0SW5mb1tlbnRyeV0sIE9wdGlvbmFsTWV0aG9kc1tlbnRyeV0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzQW5ub3RhdGlvbjtcclxuICAgIH1cclxuXHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcblxyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUyxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoXCIuL3Rvb2xzLmpzXCIpO1xyXG5cclxuICAgIHZhciBUZXh0dXJlQ29uc3RydWN0b3IgPSAge1xyXG4gICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICBraW5kOiBLSU5EUy5URVhUVVJFLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7QW5ub3RhdGlvbn0gcmVzdWx0XHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QW5ub3RhdGlvbj59IGFyZ3NcclxuICAgICAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGN0eFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGFyZ3MsIGN0eCkge1xyXG4gICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKHJlc3VsdC5ub2RlLCBcIkNvbnN0cnVjdGlvbiBvZiBUZXh0dXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgVGV4dHVyZVN0YXRpY09iamVjdCA9IHtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFRleHR1cmVJbnN0YW5jZSA9IHtcclxuICAgICAgICB3aWR0aDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5JTlRcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhlaWdodDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5JTlRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFRvb2xzLlZlYy5hdHRhY2hWZWNNZXRob2RzKFRleHR1cmVJbnN0YW5jZSwgXCJUZXh0dXJlXCIsIDQsIDIsIFsnc2FtcGxlMkQnXSk7XHJcblxyXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XHJcbiAgICAgICAgaWQ6IFwiVGV4dHVyZVwiLFxyXG4gICAgICAgIGtpbmQ6IEtJTkRTLlRFWFRVUkUsXHJcbiAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBUZXh0dXJlQ29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIHN0YXRpYzogVGV4dHVyZVN0YXRpY09iamVjdFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5zdGFuY2U6IFRleHR1cmVJbnN0YW5jZVxyXG4gICAgfSk7XHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2luZGV4LmpzXCIpO1xyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUyxcclxuICAgICAgICBWZWNCYXNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvdmVjLmpzXCIpO1xyXG5cclxuICAgIHZhciBhbGxBcmd1bWVudHNBcmVTdGF0aWMgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgIHJldHVybiBhcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZy5oYXNTdGF0aWNWYWx1ZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbnMuYWxsQXJndW1lbnRzQ2FuTnVtYmVyID0gZnVuY3Rpb24oYXJncykge1xyXG4gICAgICAgIHJldHVybiBhcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyZy5jYW5OdW1iZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBucy5jaGVja1BhcmFtQ291bnQgPSBmdW5jdGlvbihub2RlLCBuYW1lLCBhbGxvd2VkLCBpcykge1xyXG4gICAgICAgIGlmIChhbGxvd2VkLmluZGV4T2YoaXMpID09IC0xKSB7XHJcbiAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJJbnZhbGlkIG51bWJlciBvZiBwYXJhbWV0ZXJzIGZvciBcIiArIG5hbWUgKyBcIiwgZXhwZWN0ZWQgXCIgKyBhbGxvd2VkLmpvaW4oXCIgb3IgXCIpICsgXCIsIGZvdW5kOiBcIiArIGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbnMuc2luZ2xlQWNjZXNzb3IgPSBmdW5jdGlvbiAobmFtZSwgb2JqLCB2YWxpZEFyZ0NvdW50cywgc3RhdGljVmFsdWVGdW5jdGlvbikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKHJlc3VsdCwgYXJncywgY3R4LCBjYWxsT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBucy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIG5hbWUsIHZhbGlkQXJnQ291bnRzLCBhcmdzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZUluZm8gPSAgYXJncy5sZW5ndGggPyBvYmogOiB7IHR5cGU6IFRZUEVTLk5VTUJFUiB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzdGF0aWNWYWx1ZUZ1bmN0aW9uICYmIGNhbGxPYmplY3QuaGFzU3RhdGljVmFsdWUoKSAmJiBhcmdzLmV2ZXJ5KGZ1bmN0aW9uKGEpIHtyZXR1cm4gYS5oYXNTdGF0aWNWYWx1ZSgpOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLnN0YXRpY1ZhbHVlID0gc3RhdGljVmFsdWVGdW5jdGlvbihjYWxsT2JqZWN0LmdldFN0YXRpY1ZhbHVlKCksIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBucy5leHRlbmQgPSBCYXNlLmV4dGVuZDtcclxuXHJcbiAgICB2YXIgVmVjID0ge1xyXG4gICAgICAgIFRZUEVTOiB7XHJcbiAgICAgICAgICAgIDE6IHsgdHlwZTogVFlQRVMuTlVNQkVSIH0sXHJcbiAgICAgICAgICAgIDI6IHsgdHlwZTogVFlQRVMuT0JKRUNULCBraW5kOiBLSU5EUy5GTE9BVDIgfSxcclxuICAgICAgICAgICAgMzogeyB0eXBlOiBUWVBFUy5PQkpFQ1QsIGtpbmQ6IEtJTkRTLkZMT0FUMyB9LFxyXG4gICAgICAgICAgICA0OiB7IHR5cGU6IFRZUEVTLk9CSkVDVCwga2luZDogS0lORFMuRkxPQVQ0IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKGRlc3RWZWN0b3Ipe1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjLlRZUEVTW2Rlc3RWZWN0b3JdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3RhdGljVmFsdWU6IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHJlc3VsdCwgYXJncywgY3R4LCBjYWxsT2JqZWN0KXtcclxuICAgICAgICAgICAgaWYoY2FsbE9iamVjdC5oYXNTdGF0aWNWYWx1ZSgpICYmIGFsbEFyZ3VtZW50c0FyZVN0YXRpYyhhcmdzKSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gY2FsbE9iamVjdC5nZXRTdGF0aWNWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxBcmdzID0gYXJncy5tYXAoZnVuY3Rpb24oYSkge3JldHVybiBhLmdldFN0YXRpY1ZhbHVlKCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG9iamVjdFttZXRob2ROYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmKG1ldGhvZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KG9iamVjdCwgY2FsbEFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGVja0FueVZlY0FyZ3VtZW50OiBmdW5jdGlvbihhc3ROb2RlLCBtZXRob2ROYW1lLCBhcmcpe1xyXG4gICAgICAgICAgICB2YXIgY250O1xyXG5cclxuICAgICAgICAgICAgaWYoYXJnLmNhbk51bWJlcigpKSBjbnQgPSAxO1xyXG4gICAgICAgICAgICBlbHNlIGlmKGFyZy5pc09mS2luZChLSU5EUy5GTE9BVDIpKSBjbnQgPSAyO1xyXG4gICAgICAgICAgICBlbHNlIGlmKGFyZy5pc09mS2luZChLSU5EUy5GTE9BVDMpKSBjbnQgPSAzO1xyXG4gICAgICAgICAgICBlbHNlIGlmKGFyZy5pc09mS2luZChLSU5EUy5GTE9BVDQpKSBjbnQgPSA0O1xyXG4gICAgICAgICAgICBlbHNlIFNoYWRlLnRocm93RXJyb3IoYXN0Tm9kZSwgXCJJbnZhbGlkIHBhcmFtZXRlciBmb3IgXCIgKyBtZXRob2ROYW1lICsgXCIsIHR5cGUgJ1wiICtcclxuICAgICAgICAgICAgICAgICAgICBhcmcuZ2V0VHlwZVN0cmluZygpICsgXCInIGlzIG5vdCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBjbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGVja1ZlY0FyZ3VtZW50czogZnVuY3Rpb24obWV0aG9kTmFtZSwgdmVjU2l6ZSwgd2l0aEVtcHR5LCBhcmdTdGFydCwgcmVzdWx0LCBhcmdzKXtcclxuICAgICAgICAgICAgd2l0aEVtcHR5ID0gKHdpdGhFbXB0eSB8fCB2ZWNTaXplID09IDApO1xyXG4gICAgICAgICAgICB2YXIgYWxsb3dlZCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSB3aXRoRW1wdHkgPyAwIDogMTsgaSA8PSB2ZWNTaXplOyArK2kpIGFsbG93ZWQucHVzaChpICsgYXJnU3RhcnQpO1xyXG4gICAgICAgICAgICBucy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIG1ldGhvZE5hbWUsIGFsbG93ZWQsIGFyZ3MubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHdpdGhFbXB0eSAmJiBhcmdzLmxlbmd0aCAtIGFyZ1N0YXJ0ID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZihhcmdzLmxlbmd0aCAtIGFyZ1N0YXJ0PT0gMSAmJiBhcmdzWzBdLmNhbk51bWJlcigpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlkeCA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IGFyZ1N0YXJ0OyBpZHggPCB2ZWNTaXplICYmIGkgPCBhcmdzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBhcmc9IGFyZ3NbaV0sIGNudDtcclxuICAgICAgICAgICAgICAgIGlmKGFyZy5jYW5OdW1iZXIoKSkgY250ID0gMTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYXJnLmlzT2ZLaW5kKEtJTkRTLkZMT0FUMikpIGNudCA9IDI7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFyZy5pc09mS2luZChLSU5EUy5GTE9BVDMpKSBjbnQgPSAzO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhcmcuaXNPZktpbmQoS0lORFMuRkxPQVQ0KSkgY250ID0gNDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYXJnLmlzT2ZLaW5kKEtJTkRTLk1BVFJJWDMpKSBjbnQgPSA5O1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhcmcuaXNPZktpbmQoS0lORFMuTUFUUklYNCkpIGNudCA9IDE2O1xyXG4gICAgICAgICAgICAgICAgZWxzZSBTaGFkZS50aHJvd0Vycm9yKHJlc3VsdC5ub2RlLCBcIkludmFsaWQgcGFyYW1ldGVyIGZvciBcIiArIG1ldGhvZE5hbWUgKyBcIiwgdHlwZSAnXCIgKyBhcmcuZ2V0VHlwZVN0cmluZygpICsgXCInIGlzIG5vdCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICBpZHggKz0gY250O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihpZHggPCB2ZWNTaXplKVxyXG4gICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJJbnZhbGlkIHBhcmFtZXRlcnMgZm9yIFwiICsgbWV0aG9kTmFtZSArIFwiLCBleHBlY3RlZCBcIiArIHZlY1NpemUgKyBcIiBzY2FsYXIgdmFsdWVzLCBnb3QgXCIgKyBpZHgpO1xyXG4gICAgICAgICAgICBlbHNlIGlmKGkgPCBhcmdzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKHJlc3VsdC5ub2RlLCBcIkludmFsaWQgcGFyYW1ldGVycyBmb3IgXCIgKyBtZXRob2ROYW1lICsgXCIsIHRvbyBtYW55IHBhcmFtZXRlcnNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB2ZWNFdmFsdWF0ZTogZnVuY3Rpb24ob2JqZWN0TmFtZSwgbWV0aG9kTmFtZSwgZGVzdFZlY1NpemUsIHNyY1ZlY1NpemUsIHJlc3VsdCwgYXJncywgY3R4LCBjYWxsT2JqZWN0KXtcclxuICAgICAgICAgICAgVmVjLmNoZWNrVmVjQXJndW1lbnRzKG9iamVjdE5hbWUgKyBcIi5cIiArIG1ldGhvZE5hbWUsIHNyY1ZlY1NpemUsIGZhbHNlLCAwLCByZXN1bHQsIGFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHR5cGVJbmZvID0ge307XHJcbiAgICAgICAgICAgIEJhc2UuZXh0ZW5kKHR5cGVJbmZvLCBWZWMuZ2V0VHlwZShkZXN0VmVjU2l6ZSkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYW55VmVjQXJndW1lbnRFdmFsdWF0ZTogZnVuY3Rpb24obWV0aG9kTmFtZSwgcmVzdWx0LCBhcmdzLCBjdHgsIGNhbGxPYmplY3Qpe1xyXG4gICAgICAgICAgICBucy5jaGVja1BhcmFtQ291bnQocmVzdWx0Lm5vZGUsIG1ldGhvZE5hbWUsIFsxXSwgYXJncy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1swXTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgY250ID0gVmVjLmNoZWNrQW55VmVjQXJndW1lbnQocmVzdWx0Lm5vZGUsIG1ldGhvZE5hbWUsIGFyZyk7XHJcbiAgICAgICAgICAgIEJhc2UuZXh0ZW5kKHR5cGVJbmZvLCBWZWMuZ2V0VHlwZShjbnQpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlSW5mbztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvcHRpb25hbFplcm9FdmFsdWF0ZTogZnVuY3Rpb24ob2JqZWN0TmFtZSwgbWV0aG9kTmFtZSwgZGVzdFZlY1NpemUsIHplcm9EZXN0VmVjU2l6ZSwgc3JjVmVjU2l6ZSwgcmVzdWx0LCBhcmdzLCBjdHgsIGNhbGxPYmplY3QpIHtcclxuICAgICAgICAgICAgdmFyIHF1YWxpZmllZE5hbWUgPSBvYmplY3ROYW1lICsgXCIuXCIgKyBtZXRob2ROYW1lO1xyXG4gICAgICAgICAgICB2YXIgdHlwZUluZm8gPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGlmKGFyZ3MubGVuZ3RoID09IDApe1xyXG4gICAgICAgICAgICAgICAgQmFzZS5leHRlbmQodHlwZUluZm8sIFZlYy5nZXRUeXBlKHplcm9EZXN0VmVjU2l6ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBWZWMuY2hlY2tWZWNBcmd1bWVudHMocXVhbGlmaWVkTmFtZSwgc3JjVmVjU2l6ZSwgdHJ1ZSwgMCwgcmVzdWx0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIEJhc2UuZXh0ZW5kKHR5cGVJbmZvLCBWZWMuZ2V0VHlwZShkZXN0VmVjU2l6ZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZUluZm87XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3dpenpsZUV2YWx1YXRlOiBmdW5jdGlvbihvYmplY3ROYW1lLCB2ZWNTaXplLCBzd2l6emxlLCB3aXRoU2V0dGVyLCByZXN1bHQsIGFyZ3MsIGN0eCwgY2FsbE9iamVjdCkge1xyXG4gICAgICAgICAgICBpZih3aXRoU2V0dGVyKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBWZWMub3B0aW9uYWxaZXJvRXZhbHVhdGUob2JqZWN0TmFtZSwgc3dpenpsZSwgdmVjU2l6ZSwgc3dpenpsZS5sZW5ndGgsIHN3aXp6bGUubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCwgYXJncywgY3R4LCBjYWxsT2JqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYy52ZWNFdmFsdWF0ZShvYmplY3ROYW1lLCBzd2l6emxlLCBzd2l6emxlLmxlbmd0aCwgMCwgcmVzdWx0LCBhcmdzLCBjdHgsIGNhbGxPYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzd2l6emxlT3BlcmF0b3JFdmFsdWF0ZTogZnVuY3Rpb24ob2JqZWN0TmFtZSwgdmVjU2l6ZSwgc3dpenpsZSwgb3BlcmF0b3IsIHJlc3VsdCwgYXJncywgY3R4LCBjYWxsT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWMudmVjRXZhbHVhdGUob2JqZWN0TmFtZSwgc3dpenpsZSArIG9wZXJhdG9yLCB2ZWNTaXplLCBzd2l6emxlLmxlbmd0aCwgcmVzdWx0LCBhcmdzLCBjdHgsIGNhbGxPYmplY3QpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3dpenpsZUV2YWx1YXRlOiBmdW5jdGlvbihvYmplY3ROYW1lLCB2ZWNTaXplLCBzd2l6emxlLCB3aXRoU2V0dGVyKXtcclxuICAgICAgICAgICAgcmV0dXJuICB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgICAgIGV2YWx1YXRlOiBWZWMuc3dpenpsZUV2YWx1YXRlLmJpbmQobnVsbCwgb2JqZWN0TmFtZSwgdmVjU2l6ZSwgc3dpenpsZSwgd2l0aFNldHRlciksXHJcbiAgICAgICAgICAgICAgICBjb21wdXRlU3RhdGljVmFsdWU6IFZlYy5nZXRTdGF0aWNWYWx1ZS5iaW5kKG51bGwsIHN3aXp6bGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFN3aXp6bGVPcGVyYXRvckV2YWx1YXRlOiBmdW5jdGlvbihvYmplY3ROYW1lLCB2ZWNTaXplLCBzd2l6emxlLCBvcGVyYXRvcil7XHJcbiAgICAgICAgICAgIHJldHVybiAge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogVFlQRVMuRlVOQ1RJT04sXHJcbiAgICAgICAgICAgICAgICBldmFsdWF0ZTogVmVjLnN3aXp6bGVPcGVyYXRvckV2YWx1YXRlLmJpbmQobnVsbCwgb2JqZWN0TmFtZSwgdmVjU2l6ZSwgc3dpenpsZSwgb3BlcmF0b3IpLFxyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVN0YXRpY1ZhbHVlOiBWZWMuZ2V0U3RhdGljVmFsdWUuYmluZChudWxsLCBzd2l6emxlICsgb3BlcmF0b3IpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGF0dGFjaFN3aXp6bGVzOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9iamVjdE5hbWUsIHZlY0NvdW50KXtcclxuICAgICAgICAgICAgZm9yKHZhciBzID0gMDsgcyA8IFZlY0Jhc2Uuc3dpenpsZVNldHMubGVuZ3RoOyArK3Mpe1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBjb3VudCA9IDE7IGNvdW50IDw9IDQ7ICsrY291bnQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLnBvdyh2ZWNDb3VudCwgY291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWF4OyArK2kpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdLCB3aXRoU2V0dGVyID0gKGNvdW50IDw9IHZlY0NvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciAgaiA9IDA7IGogPCBjb3VudDsgKytqKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSB2YWwgJSB2ZWNDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsIC8gdmVjQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Kz0gVmVjQmFzZS5zd2l6emxlU2V0c1tzXVtpZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaW5kaWNlc1tpZHhdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhTZXR0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzW2lkeF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW2tleV0gPSBWZWMuZ2V0U3dpenpsZUV2YWx1YXRlKG9iamVjdE5hbWUsIHZlY0NvdW50LCBrZXksIHdpdGhTZXR0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3aXRoU2V0dGVyKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgb3BlcmF0b3IgaW4gVmVjQmFzZS5zd2l6emxlT3BlcmF0b3JzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVtrZXkgKyBvcGVyYXRvcl0gPSBWZWMuZ2V0U3dpenpsZU9wZXJhdG9yRXZhbHVhdGUob2JqZWN0TmFtZSwgdmVjQ291bnQsIGtleSwgb3BlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhdHRhY2hWZWNNZXRob2RzOiBmdW5jdGlvbihpbnN0YW5jZSwgb2JqZWN0TmFtZSwgZGVzdFZlY1NpemUsIHNyY1ZlY1NpemUsIG1ldGhvZE5hbWVzKXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW21ldGhvZE5hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGU6IFZlYy52ZWNFdmFsdWF0ZS5iaW5kKG51bGwsIG9iamVjdE5hbWUsIG1ldGhvZE5hbWUsIGRlc3RWZWNTaXplLCBzcmNWZWNTaXplKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldFN0YXRpY1ZhbHVlRnJvbUNvbnN0cnVjdG9yOiBmdW5jdGlvbihvYmplY3ROYW1lLCBhcmdzKXtcclxuICAgICAgICAgICAgdmFyIGFyZ0FycmF5ID0gW107XHJcbiAgICAgICAgICAgIHZhciBpc1N0YXRpYyA9IHRydWU7XHJcbiAgICAgICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICAgICAgICAgIGlzU3RhdGljID0gaXNTdGF0aWMgJiYgcGFyYW0uaGFzU3RhdGljVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0YXRpYylcclxuICAgICAgICAgICAgICAgICAgICBhcmdBcnJheS5wdXNoKHBhcmFtLmdldFN0YXRpY1ZhbHVlKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc1N0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBuZXcgU2hhZGVbb2JqZWN0TmFtZV0oKTtcclxuICAgICAgICAgICAgICAgIFNoYWRlW29iamVjdE5hbWVdLmFwcGx5KHYsIGFyZ0FycmF5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY29uc3RydWN0b3JFdmFsdWF0ZTogZnVuY3Rpb24ob2JqZWN0TmFtZSwgdmVjU2l6ZSwgcmVzdWx0LCBhcmdzLCBjdHgpIHtcclxuICAgICAgICAgICAgVmVjLmNoZWNrVmVjQXJndW1lbnRzKG9iamVjdE5hbWUsIHZlY1NpemUsIHRydWUsIDAsIHJlc3VsdCwgYXJncyk7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWMuZ2V0VHlwZSh2ZWNTaXplKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnN0cnVjdG9yQ29tcHV0ZVN0YXRpY1ZhbHVlOiBmdW5jdGlvbihvYmplY3ROYW1lLCByZXN1bHQsIGFyZ3MsIGN0eCkge1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjLmdldFN0YXRpY1ZhbHVlRnJvbUNvbnN0cnVjdG9yKG9iamVjdE5hbWUsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBNYXQgPSB7XHJcbiAgICAgICAgVFlQRVM6IHtcclxuICAgICAgICAgICAgXCJNYXQzXCI6IHsgdHlwZTogeyB0eXBlOiBUWVBFUy5PQkpFQ1QsIGtpbmQ6IEtJTkRTLk1BVFJJWDMgfSwgY29sczogMywgcm93czogMyB9LFxyXG4gICAgICAgICAgICBcIk1hdDRcIjogeyB0eXBlOiB7IHR5cGU6IFRZUEVTLk9CSkVDVCwga2luZDogS0lORFMuTUFUUklYNCB9LCBjb2xzOiA0LCByb3dzOiA0IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKG1hdE5hbWUpe1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0LlRZUEVTW21hdE5hbWVdLnR5cGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRWZWNTaXplOiBmdW5jdGlvbihtYXROYW1lKXtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdC5UWVBFU1ttYXROYW1lXS5jb2xzICogTWF0LlRZUEVTW21hdE5hbWVdLnJvd3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGVja01hdEFyZ3VtZW50czogZnVuY3Rpb24obWV0aG9kTmFtZSwgbWF0TmFtZSwgd2l0aEVtcHR5LCByZXN1bHQsIGFyZ3Mpe1xyXG4gICAgICAgICAgICBpZihhcmdzLmxlbmd0aCA9PSAxICYmIChhcmdzWzBdLmlzT2ZLaW5kKEtJTkRTLk1BVFJJWDMpIHx8IGFyZ3NbMF0uaXNPZktpbmQoS0lORFMuTUFUUklYNCkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgaWYoYXJnc1tpXS5pc09mS2luZChLSU5EUy5NQVRSSVgzKSB8fCBhcmdzW2ldLmlzT2ZLaW5kKEtJTkRTLk1BVFJJWDQpKVxyXG4gICAgICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiSW52YWxpZCBwYXJhbWV0ZXIgZm9yIFwiICsgbWV0aG9kTmFtZSArIFwiOiBDb25zdHJ1Y3RpbmcgTWF0cml4IGZyb20gTWF0cml4IGNhbiBvbmx5IHRha2Ugb25lIGFyZ3VtZW50XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFZlYy5jaGVja1ZlY0FyZ3VtZW50cyhtZXRob2ROYW1lLCBNYXQuZ2V0VmVjU2l6ZShtYXROYW1lKSwgd2l0aEVtcHR5LCAwLCByZXN1bHQsIGFyZ3MpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG1hdEV2YWx1YXRlOiBmdW5jdGlvbihtYXROYW1lLCBtZXRob2ROYW1lLCByZXN1bHQsIGFyZ3MsIGN0eCwgY2FsbE9iamVjdCl7XHJcbiAgICAgICAgICAgIE1hdC5jaGVja01hdEFyZ3VtZW50cyhtYXROYW1lICsgXCIuXCIgKyBtZXRob2ROYW1lLCBtYXROYW1lLCBmYWxzZSwgcmVzdWx0LCBhcmdzKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0eXBlSW5mbyA9IHt9O1xyXG4gICAgICAgICAgICBCYXNlLmV4dGVuZCh0eXBlSW5mbywgTWF0LmdldFR5cGUobWF0TmFtZSkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVJbmZvO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG1hdENvbnN0cnVjdG9yRXZhbHVhdGU6IGZ1bmN0aW9uKG1hdE5hbWUsIHJlc3VsdCwgYXJncywgY3R4KXtcclxuICAgICAgICAgICAgTWF0LmNoZWNrTWF0QXJndW1lbnRzKG1hdE5hbWUsIG1hdE5hbWUsIHRydWUsIHJlc3VsdCwgYXJncyk7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWMuZ2V0Q29uc3RydWN0b3JUeXBlSW5mbyhtYXROYW1lLCBNYXQuZ2V0VmVjU2l6ZShtYXROYW1lKSwgTWF0LmdldFR5cGUobWF0TmFtZSksIHJlc3VsdCwgYXJncyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXR0YWNoTWF0TWV0aG9kczogZnVuY3Rpb24oaW5zdGFuY2UsIG1hdE5hbWUsIG1ldGhvZE5hbWVzKXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbWV0aG9kTmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVttZXRob2ROYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZTogTWF0Lm1hdEV2YWx1YXRlLmJpbmQobnVsbCwgbWF0TmFtZSwgbWV0aG9kTmFtZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sRXZhbHVhdGU6IGZ1bmN0aW9uKG1hdE5hbWUsIHJlc3VsdCwgYXJncywgY3R4LCBjYWxsT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBxdWFsaWZpZWROYW1lID0gbWF0TmFtZSArIFwiLmNvbFwiO1xyXG4gICAgICAgICAgICB2YXIgdHlwZUluZm8gPSB7fTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb2xzID0gTWF0LlRZUEVTW21hdE5hbWVdLmNvbHMsIHJvd3MgPSBNYXQuVFlQRVNbbWF0TmFtZV0ucm93cztcclxuXHJcbiAgICAgICAgICAgIGlmKGFyZ3MubGVuZ3RoID4gMSl7XHJcbiAgICAgICAgICAgICAgICBWZWMuY2hlY2tWZWNBcmd1bWVudHMocXVhbGlmaWVkTmFtZSwgcm93cywgdHJ1ZSwgMSwgcmVzdWx0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIEJhc2UuZXh0ZW5kKHR5cGVJbmZvLCBNYXQuZ2V0VHlwZShtYXROYW1lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIG5zLmNoZWNrUGFyYW1Db3VudChyZXN1bHQubm9kZSwgcXVhbGlmaWVkTmFtZSwgWzFdLCBhcmdzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBCYXNlLmV4dGVuZCh0eXBlSW5mbywgVmVjLmdldFR5cGUocm93cykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFhcmdzWzBdLmNhbk51bWJlcigpKXtcclxuICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiSW52YWxpZCBwYXJhbWV0ZXIgZm9yIFwiICsgcXVhbGlmaWVkTmFtZSArIFwiLCBmaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIG51bWJlci5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IFZlYy5nZXRTdGF0aWNWYWx1ZSh0eXBlSW5mbywgXCJjb2xcIiwgYXJncywgY2FsbE9iamVjdCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZUluZm87XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBucy5WZWMgPSBWZWM7XHJcbiAgICBucy5NYXQgPSBNYXQ7XHJcbiAgICBucy5hbGxBcmd1bWVudHNBcmVTdGF0aWMgPSBhbGxBcmd1bWVudHNBcmVTdGF0aWM7XHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcblxyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUyxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoXCIuL3Rvb2xzLmpzXCIpO1xyXG5cclxuICAgIHZhciBWZWN0b3IyQ29uc3RydWN0b3IgPSAge1xyXG4gICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICBraW5kOiBLSU5EUy5GTE9BVDIsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtBbm5vdGF0aW9ufSByZXN1bHRcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxBbm5vdGF0aW9uPn0gYXJnc1xyXG4gICAgICAgICAqIEBwYXJhbSB7Q29udGV4dH0gY3R4XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXZhbHVhdGU6IFRvb2xzLlZlYy5jb25zdHJ1Y3RvckV2YWx1YXRlLmJpbmQobnVsbCwgXCJWZWMyXCIsIDIpLFxyXG4gICAgICAgIGNvbXB1dGVTdGF0aWNWYWx1ZTogVG9vbHMuVmVjLmNvbnN0cnVjdG9yQ29tcHV0ZVN0YXRpY1ZhbHVlLmJpbmQobnVsbCwgXCJWZWMyXCIpXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBWZWN0b3IyU3RhdGljT2JqZWN0ID0ge1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgVmVjdG9yMkluc3RhbmNlID0ge1xyXG4gICAgICAgIGxlbmd0aDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgZXZhbHVhdGU6IFRvb2xzLlZlYy5vcHRpb25hbFplcm9FdmFsdWF0ZS5iaW5kKG51bGwsXCJWZWMyXCIsIFwibGVuZ3RoXCIsIDIsIDEsIDEpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xzLlZlYy5hdHRhY2hTd2l6emxlcyhWZWN0b3IySW5zdGFuY2UsIFwiVmVjMlwiLCAyKTtcclxuICAgIFRvb2xzLlZlYy5hdHRhY2hWZWNNZXRob2RzKFZlY3RvcjJJbnN0YW5jZSwgXCJWZWMyXCIsIDIsIDIsIFsnYWRkJywgJ3N1YicsICdtdWwnLCAnZGl2JywgJ21vZCcsICdyZWZsZWN0J10pO1xyXG4gICAgVG9vbHMuVmVjLmF0dGFjaFZlY01ldGhvZHMoVmVjdG9yMkluc3RhbmNlLCBcIlZlYzJcIiwgMSwgMiwgWydkb3QnXSk7XHJcbiAgICBUb29scy5WZWMuYXR0YWNoVmVjTWV0aG9kcyhWZWN0b3IySW5zdGFuY2UsIFwiVmVjMlwiLCAyLCAwLCBbJ25vcm1hbGl6ZScsICdmbGlwJ10pO1xyXG5cclxuXHJcbiAgICBUb29scy5leHRlbmQobnMsIHtcclxuICAgICAgICBpZDogXCJWZWMyXCIsXHJcbiAgICAgICAga2luZDogS0lORFMuRkxPQVQyLFxyXG4gICAgICAgIG9iamVjdDoge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogVmVjdG9yMkNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBzdGF0aWM6IFZlY3RvcjJTdGF0aWNPYmplY3RcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluc3RhbmNlOiBWZWN0b3IySW5zdGFuY2VcclxuICAgIH0pO1xyXG5cclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24obnMpe1xyXG5cclxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxyXG4gICAgICAgIFRZUEVTID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS0lORFMgPSBTaGFkZS5PQkpFQ1RfS0lORFMsXHJcbiAgICAgICAgVG9vbHMgPSByZXF1aXJlKFwiLi90b29scy5qc1wiKTtcclxuXHJcbiAgICB2YXIgVmVjdG9yM0NvbnN0cnVjdG9yID0gIHtcclxuICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAga2luZDogS0lORFMuRkxPQVQzLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7QW5ub3RhdGlvbn0gcmVzdWx0XHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48QW5ub3RhdGlvbj59IGFyZ3NcclxuICAgICAgICAgKiBAcGFyYW0ge0NvbnRleHR9IGN0eFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV2YWx1YXRlOiBUb29scy5WZWMuY29uc3RydWN0b3JFdmFsdWF0ZS5iaW5kKG51bGwsIFwiVmVjM1wiLCAzKSxcclxuICAgICAgICBjb21wdXRlU3RhdGljVmFsdWU6IFRvb2xzLlZlYy5jb25zdHJ1Y3RvckNvbXB1dGVTdGF0aWNWYWx1ZS5iaW5kKG51bGwsIFwiVmVjM1wiKVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgdmFyIFZlY3RvcjNTdGF0aWNPYmplY3QgPSB7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBWZWN0b3IzSW5zdGFuY2UgPSB7XHJcbiAgICAgICAgbGVuZ3RoOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogVG9vbHMuVmVjLm9wdGlvbmFsWmVyb0V2YWx1YXRlLmJpbmQobnVsbCxcIlZlYzNcIiwgXCJsZW5ndGhcIiwgMywgMSwgMSlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbHMuVmVjLmF0dGFjaFN3aXp6bGVzKFZlY3RvcjNJbnN0YW5jZSwgXCJWZWMzXCIsIDMpO1xyXG4gICAgVG9vbHMuVmVjLmF0dGFjaFZlY01ldGhvZHMoVmVjdG9yM0luc3RhbmNlLCBcIlZlYzNcIiwgMywgMywgWydhZGQnLCAnc3ViJywgJ211bCcsICdkaXYnLCAnbW9kJywgJ3JlZmxlY3QnLCBcImNyb3NzXCJdKTtcclxuICAgIFRvb2xzLlZlYy5hdHRhY2hWZWNNZXRob2RzKFZlY3RvcjNJbnN0YW5jZSwgXCJWZWMzXCIsIDEsIDMsIFsnZG90J10pO1xyXG4gICAgVG9vbHMuVmVjLmF0dGFjaFZlY01ldGhvZHMoVmVjdG9yM0luc3RhbmNlLCBcIlZlYzNcIiwgMywgMCwgWydub3JtYWxpemUnLCAnZmxpcCddKTtcclxuXHJcbiAgICBWZWN0b3IzSW5zdGFuY2VbXCJyZWZyYWN0XCJdID0ge1xyXG4gICAgICAgIHR5cGU6IFRZUEVTLkZVTkNUSU9OLFxyXG4gICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAocmVzdWx0LCBhcmdzLCBjdHgpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMilcclxuICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3IocmVzdWx0Lm5vZGUsIFwiTm90IGVub3VnaCBwYXJhbWV0ZXJzIGZvciByZWZyYWN0LlwiKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBldGEgPSBhcmdzLnBvcCgpO1xyXG4gICAgICAgICAgICBpZiAoIWV0YSB8fCAhZXRhLmNhbk51bWJlcigpKVxyXG4gICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihyZXN1bHQubm9kZSwgXCJJbnZhbGlkIHBhcmFtZXRlciBmb3IgcmVmcmFjdCwgZXhwZWN0ZWQgYSBudW1iZXIgZ290IFwiICsgZXRhLmdldFR5cGVTdHJpbmcoKSk7XHJcblxyXG4gICAgICAgICAgICBUb29scy5WZWMuY2hlY2tWZWNBcmd1bWVudHMoVmVjdG9yM0luc3RhbmNlICsgXCIuXCIgKyBcInJlZnJhY3RcIiwgMywgZmFsc2UsIDAsIHJlc3VsdCwgYXJncyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHlwZUluZm8gPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICBraW5kOiBLSU5EUy5GTE9BVDNcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlSW5mbztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFRvb2xzLmV4dGVuZChucywge1xyXG4gICAgICAgIGlkOiBcIlZlYzNcIixcclxuICAgICAgICBraW5kOiBLSU5EUy5GTE9BVDMsXHJcbiAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBWZWN0b3IzQ29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIHN0YXRpYzogVmVjdG9yM1N0YXRpY09iamVjdFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5zdGFuY2U6IFZlY3RvcjNJbnN0YW5jZVxyXG4gICAgfSk7XHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcblxyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUyxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoXCIuL3Rvb2xzLmpzXCIpO1xyXG5cclxuICAgIHZhciBWZWN0b3I0Q29uc3RydWN0b3IgPSAge1xyXG4gICAgICAgIHR5cGU6IFRZUEVTLk9CSkVDVCxcclxuICAgICAgICBraW5kOiBLSU5EUy5GTE9BVDQsXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtBbm5vdGF0aW9ufSByZXN1bHRcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5LjxBbm5vdGF0aW9uPn0gYXJnc1xyXG4gICAgICAgICAqIEBwYXJhbSB7Q29udGV4dH0gY3R4XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXZhbHVhdGU6IFRvb2xzLlZlYy5jb25zdHJ1Y3RvckV2YWx1YXRlLmJpbmQobnVsbCwgXCJWZWM0XCIsIDQpLFxyXG4gICAgICAgIGNvbXB1dGVTdGF0aWNWYWx1ZTogVG9vbHMuVmVjLmNvbnN0cnVjdG9yQ29tcHV0ZVN0YXRpY1ZhbHVlLmJpbmQobnVsbCwgXCJWZWM0XCIpXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBWZWN0b3I0U3RhdGljT2JqZWN0ID0ge1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgVmVjdG9yNEluc3RhbmNlID0ge1xyXG4gICAgICAgIGxlbmd0aDoge1xyXG4gICAgICAgICAgICB0eXBlOiBUWVBFUy5GVU5DVElPTixcclxuICAgICAgICAgICAgZXZhbHVhdGU6IFRvb2xzLlZlYy5vcHRpb25hbFplcm9FdmFsdWF0ZS5iaW5kKG51bGwsXCJWZWM0XCIsIFwibGVuZ3RoXCIsIDQsIDEsIDEpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xzLlZlYy5hdHRhY2hTd2l6emxlcyhWZWN0b3I0SW5zdGFuY2UsIFwiVmVjNFwiLCA0KTtcclxuICAgIFRvb2xzLlZlYy5hdHRhY2hWZWNNZXRob2RzKFZlY3RvcjRJbnN0YW5jZSwgXCJWZWM0XCIsIDQsIDQsIFsnYWRkJywgJ3N1YicsICdtdWwnLCAnZGl2JywgJ21vZCcsICdyZWZsZWN0J10pO1xyXG4gICAgVG9vbHMuVmVjLmF0dGFjaFZlY01ldGhvZHMoVmVjdG9yNEluc3RhbmNlLCBcIlZlYzRcIiwgMSwgNCwgWydkb3QnXSk7XHJcbiAgICBUb29scy5WZWMuYXR0YWNoVmVjTWV0aG9kcyhWZWN0b3I0SW5zdGFuY2UsIFwiVmVjNFwiLCA0LCAwLCBbJ25vcm1hbGl6ZScsICdmbGlwJ10pO1xyXG5cclxuXHJcbiAgICBUb29scy5leHRlbmQobnMsIHtcclxuICAgICAgICBpZDogXCJWZWM0XCIsXHJcbiAgICAgICAga2luZDogS0lORFMuRkxPQVQ0LFxyXG4gICAgICAgIG9iamVjdDoge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogVmVjdG9yNENvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBzdGF0aWM6IFZlY3RvcjRTdGF0aWNPYmplY3RcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluc3RhbmNlOiBWZWN0b3I0SW5zdGFuY2VcclxuICAgIH0pO1xyXG5cclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgLy8gZGVwZW5kZW5jaWVzXHJcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XHJcbiAgICB2YXIgZXNncmFwaCA9IHJlcXVpcmUoJ2VzZ3JhcGgnKTtcclxuICAgIHZhciB3b3JrbGlzdCA9IHJlcXVpcmUoJ2FuYWx5c2VzJyk7XHJcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpO1xyXG4gICAgdmFyIENvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9jb250ZXh0LmpzXCIpO1xyXG4gICAgdmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9pbmRleC5qc1wiKTtcclxuICAgIHZhciBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyk7XHJcbiAgICB2YXIgYW5ub3RhdGVSaWdodCA9IHJlcXVpcmUoXCIuL2luZmVyX2V4cHJlc3Npb24uanNcIikuYW5ub3RhdGVSaWdodDtcclxuICAgIHZhciBJbmZlcmVuY2VTY29wZSA9IHJlcXVpcmUoXCIuL3JlZ2lzdHJ5L1wiKS5JbmZlcmVuY2VTY29wZTtcclxuICAgIHZhciBTeXN0ZW0gPSByZXF1aXJlKFwiLi9yZWdpc3RyeS9zeXN0ZW0uanNcIik7XHJcbiAgICB2YXIgQW5ub3RhdGlvbnMgPSByZXF1aXJlKFwiLi8uLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIik7XHJcbiAgICB2YXIgd2FsayA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcclxuICAgIHZhciBUb29scyA9IHJlcXVpcmUoXCIuLi9zZXR0b29scy5qc1wiKTtcclxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xyXG4gICAgdmFyIHdhbGtlcyA9IHJlcXVpcmUoJ3dhbGtlcycpO1xyXG4gICAgdmFyIHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcicpO1xyXG4gICAgdmFyIFR5cGVJbmZvID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvdHlwZWluZm8uanNcIikuVHlwZUluZm87XHJcblxyXG4gICAgLy8gc2hvcnRjdXRzXHJcbiAgICB2YXIgU3ludGF4ID0gY29tbW9uLlN5bnRheDtcclxuICAgIHZhciBNYXAgPSBjb21tb24uTWFwO1xyXG4gICAgdmFyIFNldCA9IHdvcmtsaXN0LlNldDtcclxuICAgIHZhciBGdW5jdGlvbkFubm90YXRpb24gPSBBbm5vdGF0aW9ucy5GdW5jdGlvbkFubm90YXRpb247XHJcbiAgICB2YXIgQU5OTyA9IEFubm90YXRpb25zLkFOTk87XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmRDb25zdGFudHNGb3IoYXN0LCBuYW1lcywgY29uc3RhbnRWYXJpYWJsZXMpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFNldCgpLCBhbm5vdGF0aW9uLCBuYW1lLCBmb3JtZXJWYWx1ZTtcclxuICAgICAgICBjb25zdGFudFZhcmlhYmxlcyA9IGNvbnN0YW50VmFyaWFibGVzID8gY29uc3RhbnRWYXJpYWJsZXMudmFsdWVzKCkgOiBbXTtcclxuXHJcbiAgICAgICAgd2Fsa2VzKGFzdCwge1xyXG4gICAgICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24ocmVjdXJzZSkge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0LnR5cGUgIT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKGFzdCwgXCJDYW4ndCBmaW5kIGNvbnN0YW50IGZvciBjb21wdXRlZCBsZWZ0IGV4cHJlc3Npb25cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5sZWZ0Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZihuYW1lcy5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uID0gQU5OTyh0aGlzLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZihhbm5vdGF0aW9uLmhhc1N0YXRpY1ZhbHVlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHRoaXMub3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCI9XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZCh7IG5hbWU6IG5hbWUsIGNvbnN0YW50OiBUeXBlSW5mby5jb3B5U3RhdGljVmFsdWUoYW5ub3RhdGlvbil9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCItPVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIis9XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiKj1cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIvPVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1lclZhbHVlID0gY29uc3RhbnRWYXJpYWJsZXMuZmlsdGVyKGZ1bmN0aW9uKHYpeyByZXR1cm4gdi5uYW1lID09IG5hbWU7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZvcm1lclZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGZvcm1lclZhbHVlWzBdLmNvbnN0YW50LCB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2godGhpcy5vcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIis9XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGMgKyBUeXBlSW5mby5jb3B5U3RhdGljVmFsdWUoYW5ub3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLT1cIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gYyAtIFR5cGVJbmZvLmNvcHlTdGF0aWNWYWx1ZShhbm5vdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCIqPVwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBjICogVHlwZUluZm8uY29weVN0YXRpY1ZhbHVlKGFubm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIi89XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGMgLyBUeXBlSW5mby5jb3B5U3RhdGljVmFsdWUoYW5ub3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZCh7IG5hbWU6IG5hbWUsIGNvbnN0YW50OiB2fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQoIXRoaXMub3BlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlY3Vyc2UodGhpcy5yaWdodCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6IGZ1bmN0aW9uKHJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSB0aGlzLmlkLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0ICYmIG5hbWVzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb24gPSBBTk5PKHRoaXMuaW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYW5ub3RhdGlvbi5oYXNTdGF0aWNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoeyBuYW1lOiBuYW1lLCBjb25zdGFudDogVHlwZUluZm8uY29weVN0YXRpY1ZhbHVlKGFubm90YXRpb24pfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVjdXJzZSh0aGlzLmluaXQpO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24ocmVjdXJzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5hcmd1bWVudC50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuYXJndW1lbnQubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uID0gQU5OTyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihhbm5vdGF0aW9uLmhhc1N0YXRpY1ZhbHVlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gVHlwZUluZm8uY29weVN0YXRpY1ZhbHVlKGFubm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlZml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMub3BlcmF0b3IgPT0gXCItLVwiID8gLS12YWx1ZSA6ICsrdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZCh7IG5hbWU6IG5hbWUsIGNvbnN0YW50OiB2YWx1ZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFzdFxyXG4gICAgICogQHBhcmFtIHtBbmFseXNpc0NvbnRleHR9IGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB7Kn0gb3B0XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIFR5cGVJbmZlcmVuY2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0LCBvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcblxyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcblxyXG4gICAgICAgIHRoaXMucHJvcGFnYXRlQ29uc3RhbnRzID0gb3B0LnByb3BhZ2F0ZUNvbnN0YW50cyB8fCBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgQmFzZS5leHRlbmQoVHlwZUluZmVyZW5jZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBhc3RcclxuICAgICAgICAgKiBAcGFyYW0geyp9IG9wdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluZmVyQm9keTogZnVuY3Rpb24gKGFzdCwgb3B0KSB7XHJcbiAgICAgICAgICAgICB2YXIgY2ZnID0gZXNncmFwaChhc3QsIHsgb21pdEV4Y2VwdGlvbnM6IHRydWUgfSksXHJcbiAgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcclxuICAgICAgICAgICAgICAgICBwcm9wYWdhdGVDb25zdGFudHMgPSB0aGlzLnByb3BhZ2F0ZUNvbnN0YW50cztcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImluZmVyIGJvZHlcIiwgY2ZnKVxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gd29ya2xpc3QoY2ZnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTZXR9IGlucHV0XHJcbiAgICAgICAgICAgICAqIEB0aGlzIHtGbG93Tm9kZX1cclxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGlucHV0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFzdE5vZGUgfHwgdGhpcy50eXBlKSAvLyBTdGFydCBhbmQgZW5kIG5vZGUgZG8gbm90IGluZmx1ZW5jZSB0aGUgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJBbmFseXplXCIsIGNvZGVnZW4uZ2VuZXJhdGUodGhpcy5hc3ROb2RlKSwgdGhpcy5hc3ROb2RlLnR5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExvY2FsXHJcbiAgICAgICAgICAgICAgICBpZihwcm9wYWdhdGVDb25zdGFudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtpbGwgPSB0aGlzLmtpbGwgfHwgVG9vbHMuZmluZFZhcmlhYmxlQXNzaWdubWVudHModGhpcy5hc3ROb2RlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBhbm5vdGF0ZVJpZ2h0KGNvbnRleHQsIHRoaXMuYXN0Tm9kZSwgcHJvcGFnYXRlQ29uc3RhbnRzID8gaW5wdXQgOiBudWxsICk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNsID0gdGhpcy5kZWNsIHx8IGNvbnRleHQuZGVjbGFyZVZhcmlhYmxlcyh0aGlzLmFzdE5vZGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29udGV4dC5jb21wdXRlQ29uc3RhbnRzKHRoaXMuYXN0Tm9kZSwgaW5wdXQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKCFwcm9wYWdhdGVDb25zdGFudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRJbnB1dCA9IG51bGwsIGdlbmVyYXRlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtpbGwuc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgaWYgdGhlcmUncyBhbiBhc3NpZ25tZW50LCB3ZSBuZWVkIHRvIGdlbmVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGUgPSBmaW5kQ29uc3RhbnRzRm9yKHRoaXMuYXN0Tm9kZSwgdGhpcy5raWxsLCBwcm9wYWdhdGVDb25zdGFudHMgPyBpbnB1dCA6IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZElucHV0ID0gbmV3IFNldChpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhdGhhdC5raWxsLnNvbWUoZnVuY3Rpb24odG9raWxsKSB7IHJldHVybiBlbGVtLm5hbWUgPT0gdG9raWxsIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gU2V0LnVuaW9uKGZpbHRlcmVkSW5wdXQgfHwgaW5wdXQsIGdlbmVyYXRlKTtcclxuLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnB1dDpcIiwgaW5wdXQpO1xyXG4vLyAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImtpbGw6XCIsIHRoaXMua2lsbCk7XHJcbi8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2VuZXJhdGU6XCIsIGdlbmVyYXRlKTtcclxuLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmaWx0ZXJlZElucHV0OlwiLCBmaWx0ZXJlZElucHV0KTtcclxuLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZXN1bHQ6XCIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICwge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCcsXHJcbiAgICAgICAgICAgICAgICBtZXJnZTogd29ya2xpc3QubWVyZ2UoZnVuY3Rpb24oYSxiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhICYmICFiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTWVyZ2VcIiwgYSAmJiBhLnZhbHVlcygpLCBiICYmIGIudmFsdWVzKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNldC5pbnRlcnNlY3QoYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJlc3VsdFwiLCByZXN1bHQgJiYgcmVzdWx0LnZhbHVlcygpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAvL1Rvb2xzLnByaW50TWFwKHJlc3VsdCwgY2ZnKTtcclxuICAgICAgICByZXR1cm4gYXN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXN0XHJcbiAgICAgKiBAcGFyYW0ge0FuYWx5c2lzQ29udGV4dH0gY29udGV4dFxyXG4gICAgICogQHBhcmFtIG9wdFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHZhciBpbmZlclByb2dyYW0gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0LCBvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgLy92YXIgZ2xvYmFsU2NvcGUgPSBjcmVhdGVHbG9iYWxTY29wZShhc3QpO1xyXG4gICAgICAgIC8vcmVnaXN0ZXJTeXN0ZW1JbmZvcm1hdGlvbihnbG9iYWxTY29wZSwgb3B0KTtcclxuXHJcbiAgICAgICAgdmFyIHR5cGVJbmZlcmVuY2UgPSBuZXcgVHlwZUluZmVyZW5jZShhc3QsIGNvbnRleHQsIG9wdCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHR5cGVJbmZlcmVuY2UuaW5mZXJCb2R5KGFzdCwgb3B0KTtcclxuXHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIG5zLmluZmVyID0gaW5mZXJQcm9ncmFtO1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICAvLyBEZXBlbmRlbmNpZXNcclxuICAgIHZhciB0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKSxcclxuICAgICAgICBjb21tb24gPSByZXF1aXJlKFwiLi8uLi8uLi9iYXNlL2NvbW1vbi5qc1wiKSxcclxuICAgICAgICBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxyXG4gICAgICAgIGNvZGVnZW4gPSByZXF1aXJlKCdlc2NvZGVnZW4nKSxcclxuICAgICAgICBTZXQgPSByZXF1aXJlKCdhbmFseXNlcycpLlNldCxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UvYXN0dG9vbHMuanMnKTtcclxuXHJcblxyXG4gICAgLy8gU2hvcnRjdXRzXHJcbiAgICB2YXIgU3ludGF4ID0gdHJhdmVyc2UuU3ludGF4LCBBTk5PID0gY29tbW9uLkFOTk87XHJcblxyXG4gICAgZnVuY3Rpb24gdG9NYXAodW5pZm9ybVNldCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICB1bmlmb3JtU2V0ICYmIHVuaWZvcm1TZXQuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xyXG4gICAgICAgICAgICByZXN1bHRbZW50cnkubmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IGVudHJ5LmRlcGVuZGVuY2llcyxcclxuICAgICAgICAgICAgICAgIGNvc3RzOiBlbnRyeS5jb3N0c1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGFsbG93ZWRNZW1iZXJDYWxscyA9IFtcIk1hdGhcIiwgXCJTaGFkZVwiXTtcclxuXHJcbiAgICBucy5nZW5lcmF0ZVVuaWZvcm1FeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChhc3QsIGlucHV0KSB7XHJcblxyXG4gICAgICAgIHZhciB1bmlmb3JtVmFyaWFibGVzID0gdG9NYXAoaW5wdXQpO1xyXG5cclxuICAgICAgICB0cmF2ZXJzZS50cmF2ZXJzZShhc3QsIHtcclxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNsZWFyVW5pZm9ybURlcGVuZGVuY2llcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyB1bmlmb3JtcyBjYW4gY29tZSB2aWEgdGhlIGVudiBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlBbm5vdGF0aW9uID0gQU5OTyhub2RlLnByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5QW5ub3RhdGlvbi5nZXRTb3VyY2UoKSA9PSBTaGFkZS5TT1VSQ0VTLlVOSUZPUk0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtRGVwZW5kZW5jaWVzKG5vZGUucHJvcGVydHkubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VW5pZm9ybUNvc3RzKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighVG9vbHMuaXNWYXJpYWJsZVJlZmVyZW5jZShub2RlLCBwYXJlbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdmFyaWFibGUgb24gdGhlIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyZW50LnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHBhcmVudC5sZWZ0ID09IG5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih1bmlmb3JtVmFyaWFibGVzLmhhc093blByb3BlcnR5KG5vZGUubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wYWdhdGVkVW5pZm9ybSA9IHVuaWZvcm1WYXJpYWJsZXNbbm9kZS5uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtRGVwZW5kZW5jaWVzKHByb3BhZ2F0ZWRVbmlmb3JtLmRlcGVuZGVuY2llcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VW5pZm9ybUNvc3RzKHByb3BhZ2F0ZWRVbmlmb3JtLmNvc3RzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQmluYXJ5RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gQU5OTyhub2RlLmxlZnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gQU5OTyhub2RlLnJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNhblVuaWZvcm1FeHByZXNzaW9uKCkgJiYgcmlnaHQuY2FuVW5pZm9ybUV4cHJlc3Npb24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFVuaWZvcm1EZXBlbmRlbmNpZXMobGVmdC5nZXRVbmlmb3JtRGVwZW5kZW5jaWVzKCksIHJpZ2h0LmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VW5pZm9ybUNvc3RzKGxlZnQuZ2V0VW5pZm9ybUNvc3RzKCkgKyByaWdodC5nZXRVbmlmb3JtQ29zdHMoKSArIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3VtZW50ID0gQU5OTyhub2RlLmFyZ3VtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFyZ3VtZW50LmlzVW5pZm9ybUV4cHJlc3Npb24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFVuaWZvcm1EZXBlbmRlbmNpZXMoYXJndW1lbnQuZ2V0VW5pZm9ybURlcGVuZGVuY2llcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtQ29zdHMoYXJndW1lbnQuZ2V0VW5pZm9ybUNvc3RzKCkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5DYWxsRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5jYWxsZWUudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IG5vZGUuY2FsbGVlLm9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gbm9kZS5hcmd1bWVudHMubWFwKGZ1bmN0aW9uKGFyZykgeyByZXR1cm4gQU5OTyhhcmcpO30pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9iamVjdC5uYW1lICYmIH5hbGxvd2VkTWVtYmVyQ2FsbHMuaW5kZXhPZihvYmplY3QubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gbWVyZ2VVbmlmb3JtRGVwZW5kZW5jaWVzKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VW5pZm9ybURlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29zdHMgPSBhcmdzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7IHJldHVybiBwcmV2ICsgbmV4dC5nZXRVbmlmb3JtQ29zdHMoKTsgfSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtQ29zdHMoY29zdHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBDbGVhbkNvZGU6IE1lcmdlIHdpdGggYWJvdmUgYXMgc29vbiBhcyBhbGwgZGlmZmVyZW5jZXMgYXJlIGNsZWFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdEFubm8gPSBBTk5PKG9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JqZWN0QW5uby5pc1VuaWZvcm1FeHByZXNzaW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IG1lcmdlVW5pZm9ybURlcGVuZGVuY2llcyhhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY2llcyB8fCBhcmdzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0VW5pZm9ybURlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMsIG9iamVjdEFubm8uZ2V0VW5pZm9ybURlcGVuZGVuY2llcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3N0cyA9IGFyZ3MucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHsgcmV0dXJuIHByZXYgKyBuZXh0LmdldFVuaWZvcm1Db3N0cygpOyB9LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRVbmlmb3JtQ29zdHMoY29zdHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJObyBleHA6XCIsIFNoYWRlLnRvSmF2YVNjcmlwdChub2RlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTmV3RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5jYWxsZWUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBub2RlLmFyZ3VtZW50cy5tYXAoZnVuY3Rpb24oYXJnKSB7IHJldHVybiBBTk5PKGFyZyk7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gbWVyZ2VVbmlmb3JtRGVwZW5kZW5jaWVzKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFVuaWZvcm1EZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29zdHMgPSBhcmdzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7IHJldHVybiBwcmV2ICsgbmV4dC5nZXRVbmlmb3JtQ29zdHMoKTsgfSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldFVuaWZvcm1Db3N0cyhjb3N0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgc3dpdGNoIChhc3QudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IEFOTk8oYXN0LnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pc1VuaWZvcm1FeHByZXNzaW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKHsgbmFtZTogYXN0LmxlZnQubmFtZSwgZGVwZW5kZW5jaWVzOiByaWdodC5nZXRVbmlmb3JtRGVwZW5kZW5jaWVzKCksIGNvc3RzOiByaWdodC5nZXRVbmlmb3JtQ29zdHMoKSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgYXN0LmRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvbi5pbml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbml0ID0gQU5OTyhkZWNsYXJhdGlvbi5pbml0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXQuaXNVbmlmb3JtRXhwcmVzc2lvbigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKHsgbmFtZTogZGVjbGFyYXRpb24uaWQubmFtZSwgZGVwZW5kZW5jaWVzOiBpbml0LmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKSwgY29zdHM6IGluaXQuZ2V0VW5pZm9ybUNvc3RzKCkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGF0TGVhc3RPbmVBcmd1bWVudElzVW5pZm9ybShhcmdzKSB7XHJcbiAgICAgICAgdmFyIGFsbFVuaWZvcm1PclN0YXRpYyA9IHRydWUsXHJcbiAgICAgICAgICAgIG9uZVVuaWZvcm0gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoICYmIGFsbFVuaWZvcm1PclN0YXRpYzsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGlzVW5pZm9ybSA9IGFyZ3NbaV0uaXNVbmlmb3JtRXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICBhbGxVbmlmb3JtT3JTdGF0aWMgPSBhbGxVbmlmb3JtT3JTdGF0aWMgJiYgKHRoaXNVbmlmb3JtIHx8IGFyZ3NbaV0uaGFzU3RhdGljVmFsdWUoKSk7XHJcbiAgICAgICAgICAgIG9uZVVuaWZvcm0gPSBvbmVVbmlmb3JtIHx8IHRoaXNVbmlmb3JtO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxsVW5pZm9ybU9yU3RhdGljICYmIG9uZVVuaWZvcm07XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG1lcmdlVW5pZm9ybURlcGVuZGVuY2llcyhhcmdzKSB7XHJcbiAgICAgICAgdmFyIHVuaWZvcm1EZXBlbmRlbmNpZXMgPSBudWxsO1xyXG5cclxuICAgICAgICBpZihhdExlYXN0T25lQXJndW1lbnRJc1VuaWZvcm0oYXJncykpIHtcclxuICAgICAgICAgICAgdW5pZm9ybURlcGVuZGVuY2llcyA9IFtdXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8IGFyZ3MubGVuZ3RoO2krKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbaV0uaXNVbmlmb3JtRXhwcmVzc2lvbigpKSAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaWZvcm1EZXBlbmRlbmNpZXMgPSB1bmlmb3JtRGVwZW5kZW5jaWVzLmNvbmNhdChhcmdzW2ldLmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuaWZvcm1EZXBlbmRlbmNpZXM7XHJcbiAgICB9O1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICAvLyBEZXBlbmRlbmNpZXNcclxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9jb21tb24uanNcIik7XHJcbiAgICB2YXIgZXNncmFwaCA9IHJlcXVpcmUoJ2VzZ3JhcGgnKTtcclxuICAgIHZhciB3b3JrbGlzdCA9IHJlcXVpcmUoJ2FuYWx5c2VzJyk7XHJcbiAgICB2YXIgZXZhbHVhdG9yID0gcmVxdWlyZSgnLi9ldmFsdWF0b3IuanMnKTtcclxuICAgIHZhciB0cmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vdW5pZm9ybVRyYW5zZm9ybWVyLmpzJyk7XHJcbiAgICB2YXIgVG9vbHMgPSByZXF1aXJlKFwiLi4vc2V0dG9vbHMuanNcIik7XHJcbiAgICB2YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcclxuXHJcbiAgICAvLyBTaG9ydGN1dHNcclxuICAgIHZhciBTZXQgPSB3b3JrbGlzdC5TZXQsXHJcbiAgICAgICAgU3ludGF4ID0gY29tbW9uLlN5bnRheDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSByb290XHJcbiAgICAgKiBAcGFyYW0gb3B0XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVW5pZm9ybUFuYWx5c2lzKHJvb3QsIG9wdCkge1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XHJcbiAgICAgICAgdGhpcy5vcHQgPSBvcHQgfHwge307XHJcbiAgICB9XHJcblxyXG5cclxuICAgIFVuaWZvcm1BbmFseXNpcy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgYW5hbHl6ZUJvZHk6IGZ1bmN0aW9uIChib2R5KSB7XHJcbiAgICAgICAgICAgIHZhciBjZmcgPSBlc2dyYXBoKGJvZHksIHsgb21pdEV4Y2VwdGlvbnM6IHRydWUgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHdvcmtsaXN0KGNmZyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U2V0fSBpbnB1dFxyXG4gICAgICAgICAgICAgKiBAdGhpcyB7Rmxvd05vZGV9XHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpbnB1dCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hc3ROb2RlIHx8IHRoaXMudHlwZSkgLy8gU3RhcnQgYW5kIGVuZCBub2RlIGRvIG5vdCBpbmZsdWVuY2UgdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2VuZXJhdGUgPSBldmFsdWF0b3IuZ2VuZXJhdGVVbmlmb3JtRXhwcmVzc2lvbnModGhpcy5hc3ROb2RlLCBpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtpbGwgPSB0aGlzLmtpbGwgfHwgVG9vbHMuZmluZFZhcmlhYmxlQXNzaWdubWVudHModGhpcy5hc3ROb2RlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWRJbnB1dCA9IGlucHV0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2lsbC5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkSW5wdXQgPSBuZXcgU2V0KGlucHV0LmZpbHRlcihmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF0aGF0LmtpbGwuc29tZShmdW5jdGlvbih0b2tpbGwpIHsgcmV0dXJuIGVsZW0ubmFtZSA9PSB0b2tpbGwgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBTZXQudW5pb24oZmlsdGVyZWRJbnB1dCwgZ2VuZXJhdGUpO1xyXG5cclxuLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnB1dDpcIiwgaW5wdXQpO1xyXG4vLyAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImtpbGw6XCIsIHRoaXMua2lsbCk7XHJcbi8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2VuZXJhdGU6XCIsIGdlbmVyYXRlKTtcclxuLy8gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmaWx0ZXJlZElucHV0OlwiLCBmaWx0ZXJlZElucHV0KTtcclxuLy8gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInJlc3VsdDpcIiwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJyxcclxuICAgICAgICAgICAgICAgIG1lcmdlOiB3b3JrbGlzdC5tZXJnZShmdW5jdGlvbihhLGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWEgJiYgIWIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXQuaW50ZXJzZWN0KGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vVG9vbHMucHJpbnRNYXAocmVzdWx0LCBjZmcpO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh0aGlzLnJvb3QsIHRoaXMub3B0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBucy5leHRyYWN0ID0gZnVuY3Rpb24gKGFzdCwgb3B0KSB7XHJcblxyXG4gICAgICAgIGFzc2VydChhc3QudHlwZSA9PSBTeW50YXguUHJvZ3JhbSB8fCBhc3QudHlwZSA9PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQpO1xyXG5cclxuICAgICAgICB2YXIgYW5hbHlzaXMgPSBuZXcgVW5pZm9ybUFuYWx5c2lzKGFzdCwgb3B0KTtcclxuXHJcbiAgICAgICAgLy8gUHJvcGFnYXRlIGFuZCBhbmFseXplXHJcbiAgICAgICAgYW5hbHlzaXMuYW5hbHl6ZUJvZHkoYXN0LnR5cGUgPT0gU3ludGF4LlByb2dyYW0gPyBhc3QuYm9keSA6IGFzdCk7XHJcblxyXG4gICAgICAgIC8vIFRyYW5zZm9ybVxyXG4gICAgICAgIHJldHVybiBhbmFseXNpcy50cmFuc2Zvcm0oKTtcclxuICAgIH07XHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgd2FsayA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcclxuICAgIHZhciBTeW50YXggPSB3YWxrLlN5bnRheDtcclxuICAgIHZhciBBTk5PID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYW5ub3RhdGlvbi5qc1wiKS5BTk5PO1xyXG5cclxuICAgIHZhciBpbnRlcmZhY2VzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIik7XHJcbiAgICB2YXIgVFlQRVMgPSBpbnRlcmZhY2VzLlRZUEVTLFxyXG4gICAgICAgIEtJTkRTID0gaW50ZXJmYWNlcy5PQkpFQ1RfS0lORFM7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3Ioa2luZCl7XHJcbiAgICAgICAgc3dpdGNoKGtpbmQpe1xyXG4gICAgICAgICAgICBjYXNlIEtJTkRTLkZMT0FUMjogcmV0dXJuIFwiU2hhZGUuVmVjMlwiOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBLSU5EUy5GTE9BVDM6IHJldHVybiBcIlNoYWRlLlZlYzNcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgS0lORFMuRkxPQVQ0OiByZXR1cm4gXCJTaGFkZS5WZWM0XCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEtJTkRTLk1BVFJJWDM6IHJldHVybiBcIlNoYWRlLk1hdDNcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgS0lORFMuTUFUUklYNDogcmV0dXJuIFwiU2hhZGUuTWF0NFwiOyBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgXCJVbnN1cHBvcnRlZCBvYmplY3Qga2luZCBpbiB1bmlmb3JtIGV4cHJlc3Npb24gYXJndW1lbnQ6IFwiICsga2luZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGlzTWF0aENhbGwobm9kZSkge1xyXG4gICAgICAgIHJldHVybiAobm9kZS5jYWxsZWUudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiYgbm9kZS5jYWxsZWUub2JqZWN0LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lID09PSBcIk1hdGhcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNWZWNNYXRoQ2FsbChub2RlKSB7XHJcbiAgICAgICAgaWYoIWlzTWF0aENhbGwobm9kZSkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgZmlyc3RBcmd1bWVudCA9IEFOTk8obm9kZS5hcmd1bWVudHNbMF0pO1xyXG4gICAgICAgIHJldHVybiBmaXJzdEFyZ3VtZW50LmlzVmVjdG9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlYXZlVmlzaXRvciA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIHZhcmlhYmxlcywgY29udHJvbGxlcikge1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IEFOTk8obm9kZS5vYmplY3QpO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5vYmplY3QudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciAmJiBvYmplY3QuaXNVbmlmb3JtRXhwcmVzc2lvbigpKSB7XHJcbiAgICAgICAgICAgICAgICBpZih2YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobm9kZS5vYmplY3QubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGb3VuZDogXCIgKyBub2RlLm9iamVjdC5uYW1lLCB2YXJpYWJsZXNbbm9kZS5vYmplY3QubmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUub2JqZWN0ID0gdmFyaWFibGVzW25vZGUub2JqZWN0Lm5hbWVdLmNvZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9iamVjdC5pc0dsb2JhbCgpICYmIG5vZGUucHJvcGVydHkudHlwZSA9PSBTeW50YXguSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gQU5OTyhub2RlLnByb3BlcnR5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihwcm9wZXJ0eS5pc09iamVjdCgpKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGUgYWNjZXNzZWQgcGFyYW1ldGVyIGlzIGEgdmVjdG9yIG9yIG1hdHJpeCAsIHdlIGhhdmUgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyB3cmFwIHRoZSB0eXBlZCBhcnJheSBpbiB0aGUgcmVzcGVjdGl2ZSBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKHByb3BlcnR5LmdldEtpbmQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk5ld0V4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZTogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogY29uc3RydWN0b3J9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6ICBbbm9kZV1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKChwYXJlbnQgPT0gbm9kZSkgfHwgcGFyZW50LnR5cGUgIT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZSBhY2Nlc3NlZCBwYXJhbWV0ZXIgaXMgYSBzY2FsYXIgdmFsdWUsIHdlIGhhdmUgdG9cclxuICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBpbnB1dCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobm9kZS50eXBlID09IFN5bnRheC5DYWxsRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICBpZiAoaXNWZWNNYXRoQ2FsbChub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jYWxsZWUub2JqZWN0Lm5hbWUgPSBcIk1hdGhcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgaWYgKH5bU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uLCBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yXS5pbmRleE9mKHBhcmVudC50eXBlKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PSBTeW50YXguTmV3RXhwcmVzc2lvbiAmJiBwYXJlbnQuY2FsbGVlID09IG5vZGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBOb3QgYSB2YXJpYWJsZSBvbiB0aGUgcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHBhcmVudC5sZWZ0ID09IG5vZGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZih2YXJpYWJsZXMuaGFzT3duUHJvcGVydHkobm9kZS5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZvdW5kOiBcIiArIG5vZGUubmFtZSwgdGhpc1tub2RlLm5hbWVdKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gdmFyaWFibGVzW25vZGUubmFtZV0uY29kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobm9kZS50eXBlID09IFN5bnRheC5OZXdFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmNhbGxlZS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUuY2FsbGVlLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJWZWMyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlZlYzNcIjpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVmVjNFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNhbGxlZS5uYW1lID0gXCJTaGFkZS5cIiArIG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguUmV0dXJuU3RhdGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBhbm5vID0gQU5OTyhub2RlLmFyZ3VtZW50KTtcclxuICAgICAgICAgICAgaWYoYW5uby5pc09iamVjdCgpKXtcclxuICAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQgPSB7IHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogbm9kZS5hcmd1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiX3RvRmxvYXRBcnJheVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW11cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgbnMudHJhbnNmb3JtVW5pZm9ybVNldHRlciA9IGZ1bmN0aW9uIChhc3QsIHZhcmlhYmxlcykge1xyXG4gICAgICAgIHJldHVybiB3YWxrLnJlcGxhY2UoYXN0LCB7IGxlYXZlOiBmdW5jdGlvbihub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlYXZlVmlzaXRvcihub2RlLCBwYXJlbnQsIHZhcmlhYmxlcywgdGhpcyk7XHJcbiAgICAgICAgfX0pO1xyXG4gICAgfTtcclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uKG5zKXtcclxuXHJcbiAgICAvLyBEZXBlbmRlbmNpZXNcclxuICAgIHZhciB0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKSxcclxuICAgICAgICBjb21tb24gPSByZXF1aXJlKFwiLi8uLi8uLi9iYXNlL2NvbW1vbi5qc1wiKSxcclxuICAgICAgICBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyksXHJcbiAgICAgICAgc2V0dGVyR2VuZXJhdG9yID0gcmVxdWlyZSgnLi91bmlmb3JtU2V0dGVyVHJhbnNmb3JtYXRpb24uanMnKTtcclxuXHJcbiAgICAvLyBTaG9ydGN1dHNcclxuICAgIHZhciBBTk5PID0gY29tbW9uLkFOTk8sXHJcbiAgICAgICAgU3ludGF4ID0gdHJhdmVyc2UuU3ludGF4O1xyXG5cclxuICAgIHZhciBVbmlmb3JtVHJhbnNmb3JtZXIgPSBmdW5jdGlvbihvcHQpe1xyXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuXHJcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBvcHQudW5pZm9ybUNvdW50ZXIgfHwgMTtcclxuICAgICAgICB0aGlzLmdldENvdW50ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvdW50ZXIrKztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudW5pZm9ybUV4cHJlc3Npb25zID0ge307XHJcbiAgICAgICAgdGhpcy5hY3RpdmVVbmlmb3JtVmFyaWFibGVzID0ge307XHJcbiAgICB9O1xyXG5cclxuICAgIFVuaWZvcm1UcmFuc2Zvcm1lci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbihhc3QpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2UucmVwbGFjZShhc3QsIHtcclxuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFubm8gPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGFubm8uaXNVbmlmb3JtRXhwcmVzc2lvbigpICYmIHNob3VsZEdlbmVyYXRlVW5pZm9ybUV4cHJlc3Npb24obm9kZSwgYW5ubykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZ2VuZXJhdGVVbmlmb3JtRXhwcmVzc2lvbihub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24gfHwgKG5vZGUudHlwZSA9PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yICYmIG5vZGUuaW5pdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gQU5OTyhub2RlLnJpZ2h0IHx8IG5vZGUuaW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5vZGUubGVmdCB8fCBub2RlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQuaXNVbmlmb3JtRXhwcmVzc2lvbigpICYmIGxlZnROb2RlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYWN0aXZlVW5pZm9ybVZhcmlhYmxlc1tsZWZ0Tm9kZS5uYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBzZXR0ZXJHZW5lcmF0b3IudHJhbnNmb3JtVW5pZm9ybVNldHRlcihub2RlLnJpZ2h0IHx8IG5vZGUuaW5pdCwgdGhhdC5hY3RpdmVVbmlmb3JtVmFyaWFibGVzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHJpZ2h0LmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFVuaWZvcm1FeHByZXNzaW9uOiBmdW5jdGlvbih1ZXhwKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgbmFtZSBpbiB0aGlzLnVuaWZvcm1FeHByZXNzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy51bmlmb3JtRXhwcmVzc2lvbnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZih1ZXhwLmNvZGUgPT0gb3RoZXIuY29kZSAmJiBlcXVhbERlcGVuZGVuY2llcyh1ZXhwLmRlcGVuZGVuY2llcywgb3RoZXIuZGVwZW5kZW5jaWVzKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdlbmVyYXRlVW5pZm9ybUV4cHJlc3Npb246IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIGFubm8gPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgdWV4cCA9IHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVnZW4uZ2VuZXJhdGUoc2V0dGVyR2VuZXJhdG9yLnRyYW5zZm9ybVVuaWZvcm1TZXR0ZXIobm9kZSwgdGhpcy5hY3RpdmVVbmlmb3JtVmFyaWFibGVzKSksXHJcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IGFubm8uZ2V0VW5pZm9ybURlcGVuZGVuY2llcygpXHJcblxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldFVuaWZvcm1FeHByZXNzaW9uKHVleHApO1xyXG4gICAgICAgICAgICBpZighbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IFwidVwiICsgdGhpcy5nZXRDb3VudGVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1FeHByZXNzaW9uc1tuYW1lXSA9IHVleHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ1ZXhwXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQU5OTyhyZXN1bHQpLmNvcHkoYW5ubyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBlcXVhbERlcGVuZGVuY2llcyhhLCBiKSB7XHJcbiAgICAgICAgaWYoYS5sZW5ndGggIT0gYi5sZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICBpZihiLmluZGV4T2YoZWxlbSkgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2hvdWxkR2VuZXJhdGVVbmlmb3JtRXhwcmVzc2lvbihub2RlLCBhbm5vKSB7XHJcbiAgICAgICAgdmFyIGNvc3RzID0gYW5uby5nZXRVbmlmb3JtQ29zdHMoKTtcclxuICAgICAgICByZXR1cm4gY29zdHMgPiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgdHJhbnNmb3JtID0gbnMudHJhbnNmb3JtID0gZnVuY3Rpb24gKGFzdCwgb3B0KSB7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gbmV3IFVuaWZvcm1UcmFuc2Zvcm1lcihvcHQpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1lci50cmFuc2Zvcm0oYXN0KTtcclxuICAgICAgICBvcHQudW5pZm9ybUV4cHJlc3Npb25zID0gdHJhbnNmb3JtZXIudW5pZm9ybUV4cHJlc3Npb25zO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZShcIi4vLi4vYmFzZS9jb21tb24uanNcIiksXHJcbiAgICAgICAgU2hhZGUgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBlc3RyYXZlcnNlID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpO1xyXG5cclxuICAgIC8vIHZhciBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyk7XHJcblxyXG4gICAgdmFyIFN5bnRheCA9IGNvbW1vbi5TeW50YXgsXHJcbiAgICAgICAgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBBTk5PID0gY29tbW9uLkFOTk87XHJcblxyXG4gICAgdmFyIGxlYXZlTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IEFOTk8obm9kZSksIHJpZ2h0O1xyXG5cclxuICAgICAgICBpZighYW5ub3RhdGlvbi5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGFubm90YXRpb24uZ2V0RXJyb3IoKTtcclxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVycm9ySW5mby5tZXNzYWdlKTtcclxuICAgICAgICAgICAgZXJyb3IubG9jID0gZXJyb3JJbmZvLmxvYztcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihub2RlLnR5cGUgPT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcikge1xyXG4gICAgICAgICAgICBpZihub2RlLmluaXQpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gQU5OTyhub2RlLmluaXQpO1xyXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5jb3B5KHJpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFubm90YXRpb24uZ2V0VHlwZSgpID09IFRZUEVTLkFOWSB8fCBhbm5vdGF0aW9uLmlzTnVsbE9yVW5kZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJObyB0eXBlIGNvdWxkIGJlIGNhbGN1bGF0ZWQgZm9yIFwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG5vZGUudHlwZSA9PSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgcmlnaHQgPSBBTk5PKG5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICBhbm5vdGF0aW9uLmNvcHkocmlnaHQpO1xyXG4gICAgICAgICAgICBhbm5vdGF0aW9uLmNsZWFyVW5pZm9ybURlcGVuZGVuY2llcygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFubm90YXRpb24uZ2V0VHlwZSgpID09IFRZUEVTLkFOWSB8fCBhbm5vdGF0aW9uLmlzTnVsbE9yVW5kZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJObyB0eXBlIGNvdWxkIGJlIGNhbGN1bGF0ZWQgZm9yIFwiKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKG5vZGUudHlwZSA9PSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgZXhwID0gQU5OTyhub2RlLmV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICBhbm5vdGF0aW9uLmNvcHkoZXhwKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZXMgQVNUOiBUZXN0cyBpZiB0aGUgbm9uLWVsaW1pbmF0ZWQgbm9kZXNcclxuICAgICAqIGFyZSBhbGwgdmFsaWQgYW5kIGhhdmUgdHlwZSBpbmZvcm1hdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFzdFxyXG4gICAgICogQHJldHVybnMgT2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHZhciB2YWxpZGF0ZSA9IG5zLnZhbGlkYXRlID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHJldHVybiBlc3RyYXZlcnNlLnJlcGxhY2UoYXN0LCB7XHJcbiAgICAgICAgICAgIGxlYXZlOiBsZWF2ZU5vZGVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uKG5zKXtcclxuXHJcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4LFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKSxcclxuICAgICAgICBUeXBlSW5mbyA9IHJlcXVpcmUoXCIuL3R5cGVpbmZvLmpzXCIpLlR5cGVJbmZvO1xyXG5cclxuICAgIHZhciBUWVBFUyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEtJTkRTID0gU2hhZGUuT0JKRUNUX0tJTkRTO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXh0cmFcclxuICAgICAqIEBleHRlbmRzIFR5cGVJbmZvXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIEFubm90YXRpb24gPSBmdW5jdGlvbiAobm9kZSwgZXh0cmEpIHtcclxuICAgICAgICBUeXBlSW5mby5jYWxsKHRoaXMsIG5vZGUsIGV4dHJhKTtcclxuICAgIH07XHJcblxyXG4gICAgQmFzZS5jcmVhdGVDbGFzcyhBbm5vdGF0aW9uLCBUeXBlSW5mbywge1xyXG5cclxuICAgICAgICBzZXRDYWxsIDogZnVuY3Rpb24oY2FsbCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmdldEV4dHJhKCk7XHJcbiAgICAgICAgICAgIGV4dHJhLmV2YWx1YXRlID0gY2FsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldENhbGwgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXh0cmEoKS5ldmFsdWF0ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyQ2FsbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IHRoaXMuZ2V0RXh0cmEoKTtcclxuICAgICAgICAgICAgZGVsZXRlIGV4dHJhLmV2YWx1YXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbm9kZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGV4dHJhXHJcbiAgICAgKiBAZXh0ZW5kcyBBbm5vdGF0aW9uXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIEZ1bmN0aW9uQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBleHRyYSkge1xyXG4gICAgICAgIEFubm90YXRpb24uY2FsbCh0aGlzLCBub2RlLCBleHRyYSk7XHJcbiAgICAgICAgdGhpcy5zZXRUeXBlKFRZUEVTLkZVTkNUSU9OKTtcclxuICAgIH07XHJcblxyXG4gICAgQmFzZS5jcmVhdGVDbGFzcyhGdW5jdGlvbkFubm90YXRpb24sIEFubm90YXRpb24sIHtcclxuICAgICAgICBnZXRSZXR1cm5JbmZvOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXh0cmEoKS5yZXR1cm5JbmZvO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0UmV0dXJuSW5mbzogZnVuY3Rpb24oaW5mbykge1xyXG4gICAgICAgICAgICB0aGlzLmdldEV4dHJhKCkucmV0dXJuSW5mbyA9IGluZm87XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1VzZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmdldEV4dHJhKCkudXNlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFVzZWQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRFeHRyYSgpLnVzZWQgPSB2O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG5zLkFubm90YXRpb24gPSBBbm5vdGF0aW9uO1xyXG4gICAgbnMuRnVuY3Rpb25Bbm5vdGF0aW9uID0gRnVuY3Rpb25Bbm5vdGF0aW9uO1xyXG4gICAgbnMuQU5OTyA9IGZ1bmN0aW9uKG9iamVjdCwgZXh0cmEpe3JldHVybiBuZXcgQW5ub3RhdGlvbihvYmplY3QsIGV4dHJhKX07XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBTeW50YXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIikuU3ludGF4O1xyXG5cclxuXHJcbiAgICB2YXIgaXNWYXJpYWJsZU5hbWUgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciAmJiAhKChwYXJlbnQudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiBwYXJlbnQucHJvcGVydHkgPT0gbm9kZSkgfHwgcGFyZW50LnR5cGUgPT0gU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb24gfHwgKHBhcmVudC50eXBlID09IFN5bnRheC5OZXdFeHByZXNzaW9uICYmIHBhcmVudC5jYWxsZWUgPT0gbm9kZSkgfHwgIChwYXJlbnQudHlwZSA9PSBTeW50YXguQ2FsbEV4cHJlc3Npb24gJiYgcGFyZW50LmNhbGxlZSA9PSBub2RlKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpc1ZhcmlhYmxlUmVmZXJlbmNlID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgIHJldHVybiBpc1ZhcmlhYmxlTmFtZShub2RlLCBwYXJlbnQpICYmIHBhcmVudC50eXBlICE9IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgIG5zLmlzVmFyaWFibGVSZWZlcmVuY2UgPSBpc1ZhcmlhYmxlUmVmZXJlbmNlO1xyXG4gICAgbnMuaXNWYXJpYWJsZU5hbWUgPSBpc1ZhcmlhYmxlTmFtZTtcclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgdmFyIEFOTk8gPSByZXF1aXJlKFwiLi4vYmFzZS9hbm5vdGF0aW9uLmpzXCIpLkFOTk8sXHJcbiAgICAgICAgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKSxcclxuICAgICAgICBFcnJvckhhbmRsZXIgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XHJcblxyXG5cclxuICAgIHZhciBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheS48b2JqZWN0Pn0gbm9kZVxyXG4gICAgICogQHBhcmFtIHNjb3BlXHJcbiAgICAgKiBAcmV0dXJucyB7VHlwZUluZm98QXJyYXkuPFR5cGVJbmZvPn1cclxuICAgICAqL1xyXG4gICAgbnMuY3JlYXRlVHlwZUluZm8gPSBmdW5jdGlvbiAobm9kZSwgc2NvcGUpIHtcclxuICAgICAgICBpZihBcnJheS5pc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcChmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuY3JlYXRlVHlwZUluZm8oYXJnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgfHwgbm9kZS50eXBlID09IFN5bnRheC5UaGlzRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllciA/IG5vZGUubmFtZSA6ICd0aGlzJztcclxuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSBzY29wZS5nZXRCaW5kaW5nQnlOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoYmluZGluZykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkoYmluZGluZyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZGluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxBcnJheS48b2JqZWN0Pn0gbm9kZVxyXG4gICAgICogQHBhcmFtIHNjb3BlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5P30gY29uc3RhbnRzIEFkZGl0aW9uYWwgYXJyYXkgb2YgY29uc3RhbnRzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyB7VHlwZUluZm98QXJyYXkuPFR5cGVJbmZvPn1cclxuICAgICAqL1xyXG4gICAgbnMuZ2V0VHlwZUluZm8gPSBmdW5jdGlvbiBnZXRUeXBlSW5mbyhub2RlLCBzY29wZSwgY29uc3RhbnRzLCBjaGVjaykge1xyXG4gICAgICAgIGlmKCFub2RlKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2hlY2sgPSBjaGVjayA9PSB1bmRlZmluZWQgPyBmYWxzZSA6IGNoZWNrO1xyXG5cclxuICAgICAgICBpZihBcnJheS5pc0FycmF5KG5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcChmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VHlwZUluZm8oYXJnLCBzY29wZSwgY29uc3RhbnRzLCBjaGVjayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmluZGluZztcclxuICAgICAgICBpZiAobm9kZS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xyXG5cclxuICAgICAgICAgICAgaWYobmFtZSA9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBBTk5PKG5vZGUpO1xyXG5cclxuICAgICAgICAgICAgYmluZGluZyA9IHNjb3BlLmdldEJpbmRpbmdCeU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmKGJpbmRpbmcgPT0gdW5kZWZpbmVkICYmIGNoZWNrKSB7XHJcbiAgICAgICAgICAgICAgICBBTk5PKG5vZGUpLnNldEludmFsaWQoRXJyb3JIYW5kbGVyLmdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbihub2RlLCBFcnJvckhhbmRsZXIuRVJST1JfVFlQRVMuUkVGRVJFTkNFX0VSUk9SLCBuYW1lLCBcImlzIG5vdCBkZWZpbmVkXCIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBTk5PKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGJpbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUsIGJpbmRpbmcuZ2V0RXh0cmEoKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBBIHZhcmlhYmxlIGlzIGR5bmFtaWMgcGVyIGRlZmF1bHQuIE9ubHkgaWYgaXQncyBsaXN0ZWQgaW4gY29uc3RhbnRcclxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBhc3N1bWUgYSBzdGF0aWMgdmFsdWVcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXREeW5hbWljVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIGJpbmRpbmcuc2V0RHluYW1pY1ZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uc3RhbnRzICYmICFiaW5kaW5nLmlzTnVsbE9yVW5kZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGFnYXRlZENvbnN0YW50ID0gY29uc3RhbnRzLmZpbHRlcihmdW5jdGlvbiAoY29uc3RhbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0YW50Lm5hbWUgPT0gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BhZ2F0ZWRDb25zdGFudC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZy5zZXRTdGF0aWNWYWx1ZShwcm9wYWdhdGVkQ29uc3RhbnRbMF0uY29uc3RhbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0U3RhdGljVmFsdWUocHJvcGFnYXRlZENvbnN0YW50WzBdLmNvbnN0YW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluZGluZztcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguVGhpc0V4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgYmluZGluZyA9IHNjb3BlLmdldEJpbmRpbmdCeU5hbWUoJ3RoaXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpbmRpbmcgfHwgQU5OTyhub2RlKTtcclxuICAgIH07XHJcblxyXG5cclxuXHJcbiAgICBucy5TeW50YXggPSBTeW50YXg7XHJcbiAgICBucy5WaXNpdG9yT3B0aW9uID0gZXN0cmF2ZXJzZS5WaXNpdG9yT3B0aW9uO1xyXG4gICAgbnMuTWFwID0gcmVxdWlyZSgnZXM2LW1hcC1zaGltJykuTWFwO1xyXG5cclxuICAgIG5zLkFOTk8gPSBBTk5PO1xyXG4gICAgbnMuZ2V0T2JqZWN0UmVmZXJlbmNlRnJvbU5vZGUgPSBucy5nZXRUeXBlSW5mbztcclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChtb2R1bGUpIHtcclxuXHJcbiAgICB2YXIgQ29udGV4dCA9IGZ1bmN0aW9uIChyb290LCBvcHQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0IHx8IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcm9vdCBvZiB0aGUgcHJvZ3JhbSB0byBhbmFseXplXHJcbiAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVG8gaWRlbnRpZnkgdGhlIG1haW4gbWV0aG9kIG9mIHRoZSBzaGFkZXJcclxuICAgICAgICAgKiBAdHlwZSB7KnxzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYWluRnVuY3Rpb24gPSBvcHQubWFpbkZ1bmN0aW9uIHx8IFwiZ2xvYmFsLnNoYWRlXCI7XHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPFNjb3BlPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjb3BlU3RhY2sgPSBvcHQuc2NvcGUgPyBbb3B0LnNjb3BlXSA6IFsgIF07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2VydmVkIGtleXdvcmRzXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxzdHJpbmc+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYmxvY2tlZE5hbWVzID0gb3B0LmJsb2NrZWROYW1lcyB8fCBbXTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCBuYW1lc1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVzZWROYW1lcyA9IFtdO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBDb250ZXh0LnByb3RvdHlwZSA9IHtcclxuICAgICAgICBnZXRTY29wZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHB1c2hTY29wZTogZnVuY3Rpb24gKHNjb3BlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3BlU3RhY2sucHVzaChzY29wZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwb3BTY29wZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5NYWluRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTY29wZSgpLnN0cigpID09IHRoaXMubWFpbkZ1bmN0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0SW5EZWNsYXJhdGlvbjogZnVuY3Rpb24oaW5EZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gaW5EZWNsYXJhdGlvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluRGVjbGFyYXRpb24gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY2xhcmF0aW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2FmZU5hbWU6IGZ1bmN0aW9uKGJhc2VOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDAsIHNlYXJjaE5hbWUgPSBiYXNlTmFtZTtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuYmxvY2tlZE5hbWVzLmluZGV4T2Yoc2VhcmNoTmFtZSkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHNlYXJjaE5hbWUgPSBiYXNlTmFtZSArIGluZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaE5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRTYWZlVW5pcXVlTmFtZTogZnVuY3Rpb24oYmFzZU5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMSwgc2VhcmNoTmFtZSA9IGJhc2VOYW1lO1xyXG4gICAgICAgICAgICB3aGlsZSAoISh0aGlzLnVzZWROYW1lcy5pbmRleE9mKHNlYXJjaE5hbWUpID09IC0xICYmIHRoaXMuYmxvY2tlZE5hbWVzLmluZGV4T2Yoc2VhcmNoTmFtZSkgPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBzZWFyY2hOYW1lID0gYmFzZU5hbWUgKyBpbmRleCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXNlZE5hbWVzLnB1c2goc2VhcmNoTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hOYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XHJcblxyXG59KG1vZHVsZSkpO1xyXG4iLCIoZnVuY3Rpb24oKXtcclxuXHJcbiAgICAvLyBEZXBlbmRlbmNpZXNcclxuICAgIHZhciBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyk7XHJcblxyXG4gICAgdmFyIEVycm9ySGFuZGxlciA9IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAqIEBwYXJhbSBub2RlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gICAgICogQHBhcmFtIHsuLi4qfSBtZXNzYWdlXHJcbiAgICAgKiBAcmV0dXJucyB7e21lc3NhZ2U6IHN0cmluZywgbG9jOiAqfX1cclxuICAgICAqL1xyXG4gICAgRXJyb3JIYW5kbGVyLmdlbmVyYXRlRXJyb3JJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIG1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuc3BsaWNlKDIpLFxyXG4gICAgICAgICAgICBsb2MgPSBub2RlLmxvYyxcclxuICAgICAgICAgICAgY29kZUluZm8gPSBcIlwiO1xyXG5cclxuICAgICAgICBjb2RlSW5mbyArPSBjb2RlZ2VuLmdlbmVyYXRlKG5vZGUpO1xyXG4gICAgICAgIGlmIChsb2MgJiYgbG9jLnN0YXJ0LmxpbmUpIHtcclxuICAgICAgICAgICAgY29kZUluZm8gKz0gXCIgKExpbmUgXCIgKyBsb2Muc3RhcnQubGluZSArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXNzYWdlID0gYXJncy5sZW5ndGggPyBhcmdzLmpvaW4oXCIgXCIpICsgXCI6IFwiIDogXCJcIjtcclxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiB0eXBlICsgXCI6IFwiICsgbWVzc2FnZSArIGNvZGVJbmZvLCBsb2M6IGxvY307XHJcbiAgICB9O1xyXG5cclxuICAgIEVycm9ySGFuZGxlci5FUlJPUl9UWVBFUyA9IHtcclxuICAgICAgICBUWVBFX0VSUk9SOiBcIlR5cGVFcnJvclwiLFxyXG4gICAgICAgIFJFRkVSRU5DRV9FUlJPUjogXCJSZWZlcmVuY2VFcnJvclwiLFxyXG4gICAgICAgIE5BTl9FUlJPUjogXCJOb3RBTnVtYmVyRXJyb3JcIixcclxuICAgICAgICBTSEFERUpTX0VSUk9SOiBcIlNoYWRlSlNFcnJvclwiXHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRXJyb3JIYW5kbGVyO1xyXG5cclxufShtb2R1bGUpKTtcclxuIiwiKGZ1bmN0aW9uKG5zKXtcclxuXHJcbiAgICBucy5leHRlbmQgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgZm9yICggdmFyIHByb3AgaW4gYikge1xyXG4gICAgICAgICAgICB2YXIgZyA9IGIuX19sb29rdXBHZXR0ZXJfXyhwcm9wKSwgcyA9IGIuX19sb29rdXBTZXR0ZXJfXyhwcm9wKTtcclxuICAgICAgICAgICAgaWYgKGd8fHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5fX2RlZmluZUdldHRlcl9fKHByb3AsIGcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhLl9fZGVmaW5lU2V0dGVyX18ocHJvcCwgcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYltwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgIT09IFwiY29uc3RydWN0b3JcIiB8fCBhICE9PSB3aW5kb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICBhW3Byb3BdID0gYltwcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH07XHJcblxyXG5cclxuXHJcbiAgICBucy5kZWVwRXh0ZW5kID0gZnVuY3Rpb24oZGVzdGluYXRpb24sIHNvdXJjZSkge1xyXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICB2YXIgc3JjVmFsdWUgPSBzb3VyY2VbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB2YXIgZHN0VmFsdWUgPSBkZXN0aW5hdGlvbltwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgIHZhciBjb3B5O1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcmNWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvcHkgPSBkc3RWYWx1ZSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIG5zLmRlZXBFeHRlbmQoY29weSwgc3JjVmFsdWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcmNWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBzcmNWYWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29weSA9IGRzdFZhbHVlIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgbnMuZGVlcEV4dGVuZChjb3B5LCBzcmNWYWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb3B5ID0gc3JjVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gY29weTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICBucy5zaGFsbG93RXh0ZW5kID0gZnVuY3Rpb24oZGVzdGluYXRpb24sIHNvdXJjZSkge1xyXG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdG9yIENvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFBhcmVudCBjbGFzc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBtZXRob2RzIE1ldGhvZHMgdG8gYWRkIHRvIHRoZSBjbGFzc1xyXG4gICAgICogQHJldHVybiB7T2JqZWN0IX1cclxuICAgICAqL1xyXG4gICAgbnMuY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbihjdG9yLCBwYXJlbnQsIG1ldGhvZHMpIHtcclxuICAgICAgICBtZXRob2RzID0gbWV0aG9kcyB8fCB7fTtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIC8qKiBAY29uc3RydWN0b3IgKi9cclxuICAgICAgICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xyXG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBGKCk7XHJcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcclxuICAgICAgICAgICAgY3Rvci5zdXBlcmNsYXNzID0gcGFyZW50LnByb3RvdHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICggdmFyIG0gaW4gbWV0aG9kcykge1xyXG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZVttXSA9IG1ldGhvZHNbbV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdG9yO1xyXG4gICAgfTtcclxuXHJcblxyXG59KGV4cG9ydHMpKVxyXG4iLCIoZnVuY3Rpb24obnMpe1xyXG5cclxuICAgIHZhciBCYXNlID0gcmVxdWlyZShcIi4vaW5kZXguanNcIiksXHJcbiAgICAgICAgU2hhZGUgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBUWVBFUyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEFubm90YXRpb24gPSByZXF1aXJlKFwiLi9hbm5vdGF0aW9uLmpzXCIpLkFubm90YXRpb24sXHJcbiAgICAgICAgVHlwZUluZm8gPSByZXF1aXJlKFwiLi90eXBlaW5mby5qc1wiKS5UeXBlSW5mbyxcclxuICAgICAgICBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4LFxyXG4gICAgICAgIEVycm9ySGFuZGxlciA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJpbmRpbmdcclxuICAgICAqIEBleHRlbmRzIFR5cGVJbmZvXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIEJpbmRpbmcgPSBmdW5jdGlvbihiaW5kaW5nLCByZWdpc3RyeSkge1xyXG4gICAgICAgIFR5cGVJbmZvLmNhbGwodGhpcywgYmluZGluZyk7XHJcbiAgICAgICAgaWYodGhpcy5ub2RlLnJlZikge1xyXG4gICAgICAgICAgICBpZiAoIXJlZ2lzdHJ5W3RoaXMubm9kZS5yZWZdKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJObyBvYmplY3QgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3I6IFwiICsgdGhpcy5ub2RlLnJlZik7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsT2JqZWN0ID0gcmVnaXN0cnlbdGhpcy5ub2RlLnJlZl0ub2JqZWN0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nbG9iYWxPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHlwZShUWVBFUy5PQkpFQ1QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgQmFzZS5jcmVhdGVDbGFzcyhCaW5kaW5nLCBUeXBlSW5mbywge1xyXG4gICAgICAgIGhhc0NvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRDb25zdHJ1Y3RvcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxPYmplY3QgJiYgdGhpcy5nbG9iYWxPYmplY3QuY29uc3RydWN0b3I7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0luaXRpYWxpemVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5pbml0aWFsaXplZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEluaXRpYWxpemVkOiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9kZS5pbml0aWFsaXplZCA9IHY7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNTdGF0aWNWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE9iamVjdCA/IHRydWUgOiBUeXBlSW5mby5wcm90b3R5cGUuaGFzU3RhdGljVmFsdWUuY2FsbCh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFN0YXRpY1ZhbHVlIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNTdGF0aWNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGhhcyBubyBzdGF0aWMgdmFsdWU6IFwiICsgdGhpcy5ub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE9iamVjdCA/IHRoaXMuZ2xvYmFsT2JqZWN0LnN0YXRpY1ZhbHVlIDogVHlwZUluZm8ucHJvdG90eXBlLmdldFN0YXRpY1ZhbHVlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0dsb2JhbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuaW5mbyAmJiB0aGlzLm5vZGUuaW5mby5fZ2xvYmFsIHx8IFR5cGVJbmZvLnByb3RvdHlwZS5pc0dsb2JhbC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE9iamVjdD8gVFlQRVMuT0JKRUNUIDogVHlwZUluZm8ucHJvdG90eXBlLmdldFR5cGUuY2FsbCh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFN0YXRpY1Byb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nbG9iYWxPYmplY3QpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxPYmplY3Quc3RhdGljO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEluZm9Gb3JTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmdldEV4dHJhKCk7XHJcbiAgICAgICAgICAgIGlmKCFleHRyYS5zaWduYXR1cmVzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRyYS5zaWduYXR1cmVzW3NpZ25hdHVyZV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRJbmZvRm9yU2lnbmF0dXJlOiBmdW5jdGlvbihzaWduYXR1cmUsIGluZm8pIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYSgpO1xyXG4gICAgICAgICAgICBpZighZXh0cmEuc2lnbmF0dXJlcylcclxuICAgICAgICAgICAgICAgIGV4dHJhLnNpZ25hdHVyZXMgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnNpZ25hdHVyZXNbc2lnbmF0dXJlXSA9IGluZm87XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9KVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7U2NvcGV8bnVsbH0gcGFyZW50XHJcbiAgICAgKiBAcGFyYW0gb3B0XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIFNjb3BlID0gZnVuY3Rpb24obm9kZSwgcGFyZW50LCBvcHQpIHtcclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcblxyXG4gICAgICAgIC8qKiBAdHlwZSAoU2NvcGV8bnVsbCkgKi9cclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBvcHQucGFyZW50IHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IG9wdC5yZWdpc3RyeSB8fCAocGFyZW50ID8gcGFyZW50LnJlZ2lzdGVyeSA6IHt9KTtcclxuXHJcbiAgICAgICAgdGhpcy5zY29wZSA9IG5vZGUuc2NvcGUgPSBub2RlLnNjb3BlIHx8IHt9O1xyXG5cclxuICAgICAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCB7aW5pdGlhbGl6ZWQ6IGJvb2xlYW4sIGFubm90YXRpb246IEFubm90YXRpb259Pn0gKi9cclxuICAgICAgICB0aGlzLnNjb3BlLmJpbmRpbmdzID0gdGhpcy5zY29wZS5iaW5kaW5ncyB8fCB7fTtcclxuICAgICAgICBpZihvcHQuYmluZGluZ3MpIHtcclxuICAgICAgICAgICAgQmFzZS5leHRlbmQodGhpcy5zY29wZS5iaW5kaW5ncywgb3B0LmJpbmRpbmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc2NvcGUubmFtZSA9IG9wdC5uYW1lIHx8IG5vZGUubmFtZSB8fCBcIjxhbm9ueW1vdXM+XCI7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBCYXNlLmV4dGVuZChTY29wZS5wcm90b3R5cGUsIHtcclxuICAgICAgICBzZXRSZWdpc3RyeTogZnVuY3Rpb24ocmVnaXN0cnkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3BlLm5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRSb290Q29udGV4dDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRSb290Q29udGV4dCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRCaW5kaW5nczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmJpbmRpbmdzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZVJldHVybkluZm86IGZ1bmN0aW9uKGFubm90YXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5zY29wZS5yZXR1cm5JbmZvID0gYW5ub3RhdGlvbi5nZXRFeHRyYSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UmV0dXJuSW5mbzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3BlLnJldHVybkluZm8gfHwgeyB0eXBlOiBUWVBFUy5VTkRFRklORUQgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEJpbmRpbmdCeU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5nZXRCaW5kaW5ncygpO1xyXG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzW25hbWVdO1xyXG4gICAgICAgICAgICBpZihiaW5kaW5nICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmcoYmluZGluZywgdGhpcy5yZWdpc3RyeSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRCaW5kaW5nQnlOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAgICAgICAgICogQHJldHVybnMge1Njb3BlfG51bGx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0Q29udGV4dEZvck5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5nZXRCaW5kaW5ncygpO1xyXG4gICAgICAgICAgICBpZihiaW5kaW5nc1tuYW1lXSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRDb250ZXh0Rm9yTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0VmFyaWFibGVJZGVudGlmaWVyOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXMuZ2V0Q29udGV4dEZvck5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmKCFzY29wZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gc2NvcGUuc3RyKCkgKyBcIi5cIiArIG5hbWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGVjbGFyZVZhcmlhYmxlOiBmdW5jdGlvbihuYW1lLCBmYWlsLCBwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgYmluZGluZ3MgPSB0aGlzLmdldEJpbmRpbmdzKCk7XHJcbiAgICAgICAgICAgIGZhaWwgPSAoZmFpbCA9PSB1bmRlZmluZWQpID8gdHJ1ZSA6IGZhaWw7XHJcbiAgICAgICAgICAgIGlmIChiaW5kaW5nc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZhaWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIHdhcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoaXMgc2NvcGUuXCIpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGluaXQgPSB7XHJcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplZCA6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaW5pdFBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVFlQRVMuVU5ERUZJTkVEXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGJpbmRpbmdzW25hbWVdID0gaW5pdDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7VHlwZUluZm99IHR5cGVJbmZvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlVHlwZUluZm86IGZ1bmN0aW9uIChuYW1lLCB0eXBlSW5mbywgbm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0QmluZGluZ0J5TmFtZShuYW1lKTtcclxuICAgICAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8uc2V0SW52YWxpZChFcnJvckhhbmRsZXIuZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVycm9ySGFuZGxlci5FUlJPUl9UWVBFUy5SRUZFUkVOQ0VfRVJST1IsIG5hbWUsIFwiaXMgbm90IGRlZmluZWRcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZmVyZW5jZSBlcnJvcjogXCIgKyBuYW1lICsgXCIgaXMgbm90IGRlZmluZWQuXCIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHYuaXNJbml0aWFsaXplZCgpICYmIHYuZ2V0VHlwZSgpICE9PSB0eXBlSW5mby5nZXRUeXBlKCkpIHtcclxuICAgICAgICAgICAgICAgICBpZihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8uc2V0SW52YWxpZChFcnJvckhhbmRsZXIuZ2VuZXJhdGVFcnJvckluZm9ybWF0aW9uKG5vZGUsIEVycm9ySGFuZGxlci5FUlJPUl9UWVBFUy5TSEFERUpTX0VSUk9SLCBuYW1lLCBcIm1heSBub3QgY2hhbmdlIGl0J3MgdHlwZVwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFyaWFibGUgbWF5IG5vdCBjaGFuZ2UgaXQncyB0eXBlOiBcIiArIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdi5pc0luaXRpYWxpemVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFubm90YXRlIHRoZSBkZWNsYXJhdGlvbiwgaWYgb25lIGlzIGdpdmVuXHJcbiAgICAgICAgICAgICAgICBpZih2Lm5vZGUuaW5pdFBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHYubm9kZS5pbml0UG9zaXRpb24uY29weSh0eXBlSW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHYuY29weSh0eXBlSW5mbyk7XHJcbiAgICAgICAgICAgIHYuc2V0RHluYW1pY1ZhbHVlKCk7XHJcbiAgICAgICAgICAgIHYuc2V0SW5pdGlhbGl6ZWQoIXR5cGVJbmZvLmlzVW5kZWZpbmVkKCkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlZ2lzdGVyT2JqZWN0OiBmdW5jdGlvbihuYW1lLCBvYmopIHtcclxuICAgICAgICAgICAgdGhpcy5yZWdpc3RyeVtvYmouaWRdID0gb2JqO1xyXG4gICAgICAgICAgICB2YXIgYmluZGluZ3MgPSB0aGlzLmdldEJpbmRpbmdzKCk7XHJcbiAgICAgICAgICAgIGJpbmRpbmdzW25hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUWVBFUy5PQkpFQ1RcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByZWY6IG9iai5pZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlY2xhcmVQYXJhbWV0ZXJzOiBmdW5jdGlvbihwYXJhbXMpIHtcclxuICAgICAgICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5nZXRCaW5kaW5ncygpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gcGFyYW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBuZXcgQW5ub3RhdGlvbihwYXJhbWV0ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0geyBleHRyYTogeyB0eXBlOiBUWVBFUy5VTkRFRklORUQgfX07XHJcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IG5ldyBUeXBlSW5mbyhub2RlKTtcclxuICAgICAgICAgICAgICAgIGJpbmRpbmcuY29weShhbm5vdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIGJpbmRpbmdzW3BhcmFtZXRlci5uYW1lXSA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdHI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIG5hbWVzID0gW107XHJcbiAgICAgICAgICAgIHdoaWxlKGN0eCkge1xyXG4gICAgICAgICAgICAgICAgbmFtZXMudW5zaGlmdChjdHguZ2V0TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgIGN0eCA9IGN0eC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5hbWVzLmpvaW4oXCIuXCIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldEFsbEJpbmRpbmdzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5rZXlzKHRoaXMuZ2V0QmluZGluZ3MoKSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEJpbmRpbmdzID0gdGhpcy5wYXJlbnQuZ2V0QWxsQmluZGluZ3MoKTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaW5kZXhPZihwYXJlbnRCaW5kaW5nc1tpXSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmVudEJpbmRpbmdzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSBub2RlXHJcbiAgICAgICAgICogQHJldHVybnMge1R5cGVJbmZvfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZVR5cGVJbmZvOiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFubm90YXRpb24obm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmdCeU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb3B5KGJpbmRpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kaW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0T2JqZWN0SW5mb0ZvcjogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICAgIGlmICghb2JqLmlzT2JqZWN0KCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSB0aHJlZSB3YXlzIHRvIGdldCB0aGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3RcclxuXHJcbiAgICAgICAgICAgIC8vIDEuIE9iamVjdCBpcyBzdGF0aWMgYW5kIGhhcyByZWdpc3RlcmVkIGl0J3MgcHJvcGVydGllcyB2aWEgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIHZhciBzdGF0aWNQcm9wZXJ0aWVzID0gb2JqLmdldFN0YXRpY1Byb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgaWYgKHN0YXRpY1Byb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGljUHJvcGVydGllcztcclxuXHJcbiAgICAgICAgICAgIC8vIDE6IE9iamVjdCBpcyBnZW5lcmljIChhbnkpLCB0aGVuIGl0IGNhcnJpZXMgaXQncyBpbmZvcm1hdGlvbiBpdHNlbGZcclxuICAgICAgICAgICAgaWYgKG9iai5pc09mS2luZChTaGFkZS5PQkpFQ1RfS0lORFMuQU5ZKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai5nZXROb2RlSW5mbygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gMy4gTGFzdCBjaGFuY2U6IFRoZSBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSByZWdpc3RlcmVkIHR5cGUsXHJcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgZ2V0IHRoZSBpbmZvcm1hdGlvbiBmcm9tIGl0J3Mga2luZFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeSAmJiB0aGlzLnJlZ2lzdHJ5LmdldEluc3RhbmNlRm9yS2luZChvYmouZ2V0S2luZCgpKSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgbnMuZXhwb3J0cyA9IFNjb3BlO1xyXG5cclxuXHJcblxyXG5cclxufShtb2R1bGUpKTtcclxuIiwiKGZ1bmN0aW9uKG5zKXtcclxuXHJcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4LFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKSxcclxuICAgICAgICBTZXQgPSByZXF1aXJlKCdhbmFseXNlcycpLlNldDtcclxuXHJcbiAgICB2YXIgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0geyp9IG5vZGUgQ2FycmllciBvYmplY3QgZm9yIHRoZSB0eXBlIGluZm8sIG9ubHkgbm9kZS5leHRyYSBnZXRzIHBvbGx1dGVkXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdD99IGV4dHJhXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIFR5cGVJbmZvID0gZnVuY3Rpb24gKG5vZGUsIGV4dHJhKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLm5vZGUuZXh0cmEgPSB0aGlzLm5vZGUuZXh0cmEgfHwge307XHJcbiAgICAgICAgaWYgKGV4dHJhKSB7XHJcbiAgICAgICAgICAgIEJhc2Uuc2hhbGxvd0V4dGVuZCh0aGlzLm5vZGUuZXh0cmEsIGV4dHJhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgVHlwZUluZm8uY3JlYXRlRm9yQ29udGV4dCA9IGZ1bmN0aW9uKG5vZGUsIGN0eCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVHlwZUluZm8obm9kZSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5nZXRUeXBlKCkgIT09IFRZUEVTLkFOWSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBTeW50YXguSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcclxuICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gY3R4LmdldEJpbmRpbmdCeU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvcHkodmFyaWFibGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1R5cGVJbmZvfSB0eXBlSW5mb1xyXG4gICAgICogQHBhcmFtIHtPYmplY3Q/fSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBUeXBlSW5mby5jb3B5U3RhdGljVmFsdWUgPSBmdW5jdGlvbih0eXBlSW5mbywgdmFsdWUpIHtcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8IHR5cGVJbmZvLmdldFN0YXRpY1ZhbHVlKCk7XHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byBjb3B5IHByaW1pdGl2ZSB0eXBlc1xyXG4gICAgICAgIGlmKCF0eXBlSW5mby5pc09iamVjdCgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgc3dpdGNoKHR5cGVJbmZvLmdldEtpbmQoKSkge1xyXG4gICAgICAgICAgICBjYXNlIEtJTkRTLkZMT0FUMjogcmV0dXJuIG5ldyBTaGFkZS5WZWMyKHZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSBLSU5EUy5GTE9BVDM6IHJldHVybiBuZXcgU2hhZGUuVmVjMyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgS0lORFMuRkxPQVQ0OiByZXR1cm4gbmV3IFNoYWRlLlZlYzQodmFsdWUpO1xyXG4gICAgICAgICAgICBjYXNlIEtJTkRTLk1BVFJJWDM6IHJldHVybiBuZXcgU2hhZGUuTWF0Myh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgS0lORFMuTUFUUklYNDogcmV0dXJuIG5ldyBTaGFkZS5NYXQ0KHZhbHVlKTtcclxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29weSBzdGF0aWMgdmFsdWUgb2Yga2luZDogXCIgKyB0eXBlSW5mby5nZXRLaW5kKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBUeXBlSW5mby5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgZ2V0RXh0cmE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5leHRyYTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYSgpO1xyXG4gICAgICAgICAgICBpZiAoZXh0cmEudHlwZSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmEudHlwZTtcclxuICAgICAgICAgICAgcmV0dXJuIFRZUEVTLkFOWTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRLaW5kOiBmdW5jdGlvbiAoa2luZCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmdldEV4dHJhKCk7XHJcbiAgICAgICAgICAgIGV4dHJhLmtpbmQgPSBraW5kO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldEtpbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT2JqZWN0KCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXh0cmEoKS5raW5kIHx8IEtJTkRTLkFOWTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRVc2VyRGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmdldEV4dHJhKCk7XHJcbiAgICAgICAgICAgIGlmKCFleHRyYS51c2VyRGF0YSkgZXh0cmEudXNlckRhdGEgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnVzZXJEYXRhO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldEFycmF5RWxlbWVudFR5cGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYoIXRoaXMuaXNBcnJheSgpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIGdldEFycmF5RWxlbWVudFR5cGUgb24gXCIgKyB0aGlzLmdldFR5cGUoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV4dHJhKCkuZWxlbWVudHM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNPZktpbmQ6IGZ1bmN0aW9uKGtpbmQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT2JqZWN0KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLaW5kKCkgPT0ga2luZDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nP30ga2luZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFR5cGU6IGZ1bmN0aW9uICh0eXBlLCBraW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IHRoaXMuZ2V0RXh0cmEoKTtcclxuICAgICAgICAgICAgZXh0cmEudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgIGlmIChraW5kKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRLaW5kKGtpbmQpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmlzVmFsaWQoKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJFcnJvcigpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldEludmFsaWQ6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUeXBlKFRZUEVTLklOVkFMSUQpO1xyXG4gICAgICAgICAgICBpZihtZXNzYWdlKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc09mVHlwZTogZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpID09IHR5cGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpID09IG90aGVyLmdldFR5cGUoKSAmJiB0aGlzLmdldEtpbmQoKSA9PSBvdGhlci5nZXRLaW5kKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNJbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZlR5cGUoVFlQRVMuSU5UKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzTnVtYmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2ZUeXBlKFRZUEVTLk5VTUJFUik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5pc09mVHlwZShUWVBFUy5JTlZBTElEKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzTnVsbCgpIHx8IHRoaXMuaXNVbmRlZmluZWQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzTnVsbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09mVHlwZShUWVBFUy5OVUxMKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzVW5kZWZpbmVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2ZUeXBlKFRZUEVTLlVOREVGSU5FRCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0Jvb2w6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZlR5cGUoVFlQRVMuQk9PTEVBTik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09mVHlwZShUWVBFUy5TVFJJTkcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNBcnJheTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09mVHlwZShUWVBFUy5BUlJBWSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0Z1bmN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2ZUeXBlKFRZUEVTLkZVTkNUSU9OKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2ZUeXBlKFRZUEVTLk9CSkVDVCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1ZlY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09iamVjdCgpICYmIHRoaXMuaXNPZktpbmQoS0lORFMuRkxPQVQyKSB8fCB0aGlzLmlzT2ZLaW5kKEtJTkRTLkZMT0FUMykgfHwgdGhpcy5pc09mS2luZChLSU5EUy5GTE9BVDQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNHbG9iYWw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmdldEV4dHJhKCkuZ2xvYmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0R2xvYmFsOiBmdW5jdGlvbiAoZ2xvYmFsKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IHRoaXMuZ2V0RXh0cmEoKTtcclxuICAgICAgICAgICAgZXh0cmEuZ2xvYmFsID0gZ2xvYmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNPdXRwdXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RXh0cmEoKS5vdXRwdXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRPdXRwdXQ6IGZ1bmN0aW9uIChvdXRwdXQpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYSgpO1xyXG4gICAgICAgICAgICBleHRyYS5vdXRwdXQgPSBvdXRwdXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYW5OdW1iZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNOdW1iZXIoKSB8fCB0aGlzLmlzSW50KCkgfHwgdGhpcy5pc0Jvb2woKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbkludDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0ludCgpIHx8IHRoaXMuaXNCb29sKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYW5PYmplY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3QoKSB8fCB0aGlzLmlzQXJyYXkoKSB8fCB0aGlzLmlzRnVuY3Rpb24oKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldENvbW1vblR5cGU6IGZ1bmN0aW9uKGEsYikge1xyXG4gICAgICAgICAgICBpZihhLmVxdWFscyhiKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5KGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoYS5jYW5OdW1iZXIoKSAmJiBiLmNhbk51bWJlcigpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFR5cGUoVFlQRVMuTlVNQkVSKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzU3RhdGljVmFsdWUgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc051bGxPclVuZGVmaW5lZCgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRyYS5oYXNPd25Qcm9wZXJ0eShcInN0YXRpY1ZhbHVlXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0U3RhdGljVmFsdWUgOiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IHRoaXMuZ2V0RXh0cmEoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOdWxsT3JVbmRlZmluZWQoKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bGwgYW5kIHVuZGVmaW5lZCBoYXZlIHByZWRlZmluZWQgdmFsdWVzLlwiKTtcclxuICAgICAgICAgICAgZXh0cmEuc3RhdGljVmFsdWUgPSB2O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2FuVW5pZm9ybUV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNTdGF0aWNWYWx1ZSgpIHx8IHRoaXMuaXNVbmlmb3JtRXhwcmVzc2lvbigpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzVW5pZm9ybUV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmdldEV4dHJhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRyYS5oYXNPd25Qcm9wZXJ0eShcInVuaWZvcm1EZXBlbmRlbmNpZXNcIilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFVuaWZvcm1EZXBlbmRlbmNpZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmdldEV4dHJhKCk7XHJcbiAgICAgICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uKGFyZykge1xyXG4gICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGFyZykpXHJcbiAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBTZXQudW5pb24oZGVwZW5kZW5jaWVzLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmFkZChhcmcpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZXh0cmEudW5pZm9ybURlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcy52YWx1ZXMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFVuaWZvcm1EZXBlbmRlbmNpZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLmdldEV4dHJhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBleHRyYS51bmlmb3JtRGVwZW5kZW5jaWVzIHx8IFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0VW5pZm9ybUNvc3RzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0cmEudW5pZm9ybUNvc3RzIHwgMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFVuaWZvcm1Db3N0czogZnVuY3Rpb24oY29zdHMpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYSgpO1xyXG4gICAgICAgICAgICBleHRyYS51bmlmb3JtQ29zdHMgPSBjb3N0cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyVW5pZm9ybURlcGVuZGVuY2llczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IHRoaXMuZ2V0RXh0cmEoKTtcclxuICAgICAgICAgICAgZGVsZXRlIGV4dHJhLnVuaWZvcm1EZXBlbmRlbmNpZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRTdGF0aWNWYWx1ZSA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhdGljVmFsdWUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBoYXMgbm8gc3RhdGljIHZhbHVlOiBcIiArIHRoaXMubm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOdWxsKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNVbmRlZmluZWQoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV4dHJhKCkuc3RhdGljVmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXREeW5hbWljVmFsdWUgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZ2V0RXh0cmEoKS5zdGF0aWNWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldENhbGwgOiBmdW5jdGlvbihjYWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IHRoaXMuZ2V0RXh0cmEoKTtcclxuICAgICAgICAgICAgZXh0cmEuZXZhbHVhdGUgPSBjYWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Q2FsbCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHRyYSgpLmV2YWx1YXRlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXJDYWxsOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYSgpO1xyXG4gICAgICAgICAgICBkZWxldGUgZXh0cmEuZXZhbHVhdGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb3B5OiBmdW5jdGlvbihvdGhlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNldEZyb21FeHRyYShvdGhlci5nZXRFeHRyYSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0cjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IHRoaXMuZ2V0RXh0cmEoKTtcclxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGV4dHJhLCBudWxsLCAxKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbk5vcm1hbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2JqZWN0KCkgJiYgKHRoaXMuaXNPZktpbmQoS0lORFMuTk9STUFMKSB8fCB0aGlzLmlzT2ZLaW5kKEtJTkRTLkZMT0FUMykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2FuQ29sb3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09iamVjdCgpICYmICh0aGlzLmlzT2ZLaW5kKEtJTkRTLkZMT0FUNCkgfHwgdGhpcy5pc09mS2luZChLSU5EUy5GTE9BVDMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc0Vycm9yIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEVycm9yKCkgIT0gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEVycm9yIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IHRoaXMuZ2V0RXh0cmEoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dHJhLmVycm9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0RXJyb3IgOiBmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYSgpO1xyXG4gICAgICAgICAgICBleHRyYS5lcnJvciA9IGVycjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsZWFyRXJyb3IgOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5nZXRFeHRyYSgpO1xyXG4gICAgICAgICAgICBleHRyYS5lcnJvciA9IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRGcm9tRXh0cmE6IGZ1bmN0aW9uKGV4dHJhKXtcclxuICAgICAgICAgICAgQmFzZS5zaGFsbG93RXh0ZW5kKHRoaXMubm9kZS5leHRyYSwgZXh0cmEpO1xyXG4gICAgICAgICAgICAvLyBTZXQgc3RhdGljIG9iamVjdCBleHRyYTogVGhpcyBtaWdodCBiZSBhbiBvYmplY3RcclxuICAgICAgICAgICAgaWYgKGV4dHJhLnN0YXRpY1ZhbHVlICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0aWNWYWx1ZShUeXBlSW5mby5jb3B5U3RhdGljVmFsdWUodGhpcywgZXh0cmEuc3RhdGljVmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0Tm9kZUluZm86IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc09iamVjdCgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXh0cmEoKS5pbmZvO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0Tm9kZUluZm86IGZ1bmN0aW9uKGluZm8pIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT2JqZWN0KCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9iamVjdHMgbWF5IGhhdmUgYSBub2RlIGluZm9cIik7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RXh0cmEoKS5pbmZvID0gaW5mbztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFR5cGVTdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc09iamVjdCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc09mS2luZChLSU5EUy5BTlkpID8gXCJPYmplY3RcIiA6IChcIk9iamVjdCAjPFwiICsgdGhpcy5nZXRLaW5kKCkgKyBcIj5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHRoZSBpbnRlcm5hbCB0eXBlIGFzIEphdmFTY3JpcHQgdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0SmF2YVNjcmlwdFR5cGVTdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmdldFR5cGUoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUWVBFUy5JTlQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRZUEVTLkZMT0FUOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBUWVBFUy5OVU1CRVI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRZUEVTLk9CSkVDVDpcclxuICAgICAgICAgICAgICAgIGNhc2UgVFlQRVMuQVJSQVk6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRZUEVTLlNUUklORzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgVFlQRVMuVU5ERUZJTkVEOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBGb3IgZGVidWcgd2UgdXNlIHRoaXMgbm93LCBzaG91bGQgdGhyb3cgYW4gZXhjZXB0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiP1wiICsgdGhpcy5nZXRUeXBlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFNvdXJjZTogZnVuY3Rpb24oc291cmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBleHRyYSA9IHRoaXMuZ2V0RXh0cmEoKTtcclxuICAgICAgICAgICAgZXh0cmEuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U291cmNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXh0cmEoKS5zb3VyY2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRTdGF0aWNQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgLy8gT25seSBib3VuZCBvYmplY3QgaGF2ZSBzdGF0aWMgcHJvcGVydGllcyAoTWF0aCwgU2hhZGUgZXRjKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzRGVyaXZlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEV4dHJhKCkuZGVyaXZlZCA9PSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U3RhdGljVHJ1dGhWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vICEhdW5kZWZpbmVkID09IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc051bGxPclVuZGVmaW5lZCgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAvLyAhIXt9ID09IHRydWVcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FuT2JqZWN0KCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gSW4gYWxsIG90aGVyIGNhc2VzLCBpdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSxcclxuICAgICAgICAgICAgLy8gdGh1cyB3ZSBjYW4gb25seSBldmFsdWF0ZSB0aGlzIGZvciBzdGF0aWMgb2JqZWN0c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTdGF0aWNWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLmdldFN0YXRpY1ZhbHVlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFNlbWFudGljOiBmdW5jdGlvbihzZW0pIHtcclxuICAgICAgICAgICAgdGhpcy5nZXRFeHRyYSgpLnNlbWFudGljID0gc2VtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0U2VtYW50aWM6IGZ1bmN0aW9uKHNlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFeHRyYSgpLnNlbWFudGljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgbnMuVHlwZUluZm8gPSBUeXBlSW5mbztcclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24obnMpe1xyXG5cclxuICAgIG5zLnN3aXp6bGVUb0luZGV4ID0gZnVuY3Rpb24oc3dpenpsZUtleSl7XHJcbiAgICAgICAgc3dpdGNoKHN3aXp6bGVLZXkpe1xyXG4gICAgICAgICAgICBjYXNlICd4JzpjYXNlICdyJyA6Y2FzZSAncyc6IHJldHVybiAwO1xyXG4gICAgICAgICAgICBjYXNlICd5JzpjYXNlICdnJyA6Y2FzZSAndCc6IHJldHVybiAxO1xyXG4gICAgICAgICAgICBjYXNlICd6JzpjYXNlICdiJyA6Y2FzZSAncCc6IHJldHVybiAyO1xyXG4gICAgICAgICAgICBjYXNlICd3JzpjYXNlICdhJyA6Y2FzZSAncSc6IHJldHVybiAzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHN3aXp6bGUga2V5OiAnXCIgKyBzd2l6emxlS2V5ICsgXCInXCIpO1xyXG4gICAgfTtcclxuICAgIG5zLmluZGV4VG9Td2l6emxlID0gZnVuY3Rpb24oaW5kZXgpe1xyXG4gICAgICAgIHN3aXRjaChpbmRleCl7XHJcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuICd4JztcclxuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gJ3knO1xyXG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiAneic7XHJcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuICd3JztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzd2l6emxlIGluZGV4OiAnXCIgKyBpbmRleCArIFwiJ1wiKTtcclxuICAgIH07XHJcbiAgICBucy5zd2l6emxlU2V0cyA9IFtcclxuICAgICAgICBbJ3gnLCAneScsICd6JywgJ3cnXSxcclxuICAgICAgICBbJ3InLCAnZycsICdiJywgJ2EnXSxcclxuICAgICAgICBbJ3MnLCAndCcsICdwJywgJ3EnXVxyXG4gICAgXTtcclxuICAgIG5zLnN3aXp6bGVPcGVyYXRvcnMgPSB7XHJcbiAgICAgICAgJ0FkZCcgOiAnKycsXHJcbiAgICAgICAgJ1N1YicgOiAnLScsXHJcbiAgICAgICAgJ011bCcgOiAnKicsXHJcbiAgICAgICAgJ0RpdicgOiAnLydcclxuICAgIH1cclxuXHJcblxyXG59KGV4cG9ydHMpKVxyXG4iLCIoZnVuY3Rpb24obnMpe1xyXG5cclxuICAgIHZhciBPbmVQYXJhbWV0ZXJOdW1iZXJNZXRob2RzID0gW1wiYWNvc1wiLCBcImFzaW5cIiwgXCJhdGFuXCIsIFwiY29zXCIsIFwiZXhwXCIsIFwibG9nXCIsIFwicm91bmRcIiwgXCJzaW5cIiwgXCJzcXJ0XCIsIFwidGFuXCIsIFwiY2VpbFwiLCBcImZsb29yXCJdO1xyXG5cclxuICAgIGZ1bmN0aW9uIG9uZVBhcmFtZXRlckZ1bmN0aW9uKG5hbWUpIHtcclxuXHJcbiAgICAgICAgdmFyIGZ1bmMgPSBNYXRoW25hbWVdO1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmVjKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB2ZWMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xyXG4gICAgICAgICAgICB3aGlsZShsZW5ndGgtLSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBmdW5jKHZlY1tsZW5ndGhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgVmVjTWF0aCA9IHtcclxuICAgICAgICBtaXggOiBmdW5jdGlvbih4LHksYSkge1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0geC5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICBvbmVNaW51c0E7XHJcblxyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBhLmxlbmd0aCA+PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBhW2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSB4W2xlbmd0aF0gKiAoMSAtIGEpICsgeVtsZW5ndGhdICogYTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9uZU1pbnVzQSA9IDEgLSBhO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUobGVuZ3RoLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IHhbbGVuZ3RoXSAqIG9uZU1pbnVzQSArIHlbbGVuZ3RoXSAqIGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGVwIDogZnVuY3Rpb24oZWRnZSwgeCkge1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZWRnZS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICB3aGlsZShsZW5ndGgtLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlZGdlW2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICB2YXIgeDAgPSB4W2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9ICh4MCA8PSBlKSA/IDAgOiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzbW9vdGhzdGVwIDogZnVuY3Rpb24oZWRnZTAsIGVkZ2UxLCB4KSB7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBlZGdlMC5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICB3aGlsZShsZW5ndGgtLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUwID0gZWRnZTBbbGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgIHZhciBlMSA9IGVkZ2UxW2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICB2YXIgeDAgPSB4W2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IE1hdGguY2xhbXAoKHgwIC0gZTApIC8gKGUxIC0gZTApLCAwLjAsIDEuMCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IHQgKiB0ICogKDMuMCAtIDIuMCAqIHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBPbmVQYXJhbWV0ZXJOdW1iZXJNZXRob2RzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgIFZlY01hdGhbbmFtZV0gPSBvbmVQYXJhbWV0ZXJGdW5jdGlvbihuYW1lKTtcclxuICAgIH0pO1xyXG5cclxuICAgIG5zLlZlY01hdGggPSBWZWNNYXRoO1xyXG5cclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgbnMuZXh0ZW5kID0gZnVuY3Rpb24oZGVzdCl7XHJcbiAgICAgICAgdmFyIHZlYzIgPSBkZXN0LnZlYzI7XHJcbiAgICAgICAgdmFyIHZlYzMgPSBkZXN0LnZlYzM7XHJcbiAgICAgICAgdmFyIHZlYzQgPSBkZXN0LnZlYzQ7XHJcbiAgICAgICAgdmFyIG1hdDIgPSBkZXN0Lm1hdDI7XHJcbiAgICAgICAgdmFyIG1hdDMgPSBkZXN0Lm1hdDM7XHJcbiAgICAgICAgdmFyIG1hdDQgPSBkZXN0Lm1hdDQ7XHJcblxyXG4gICAgICAgIHZlYzIuc2V0TGVuZ3RoID0gZnVuY3Rpb24oZGVzdCwgYSwgYil7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSB2ZWMyLmxlbmd0aChhKTtcclxuICAgICAgICAgICAgaWYoIWxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICAgICAgICB2ZWMyLnNjYWxlKGRlc3QsIGEsIGIgLyBsZW5ndGgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmVjMy5zZXRMZW5ndGggPSBmdW5jdGlvbihkZXN0LCBhLCBiKXtcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHZlYzMubGVuZ3RoKGEpO1xyXG4gICAgICAgICAgICBpZighbGVuZ3RoKSByZXR1cm47XHJcbiAgICAgICAgICAgIHZlYzMuc2NhbGUoZGVzdCwgYSwgYiAvIGxlbmd0aCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2ZWM0LnNldExlbmd0aCA9IGZ1bmN0aW9uKGRlc3QsIGEsIGIpe1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdmVjNC5sZW5ndGgoYSk7XHJcbiAgICAgICAgICAgIGlmKCFsZW5ndGgpIHJldHVybjtcclxuICAgICAgICAgICAgdmVjNC5zY2FsZShkZXN0LCBhLCBiIC8gbGVuZ3RoKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdmVjMi5jb3B5QXJyYXkgPSBmdW5jdGlvbihkZXN0LCBhcnJheSwgaSl7XHJcbiAgICAgICAgICAgIHZhciBvZmYgPSAyKmk7XHJcbiAgICAgICAgICAgIHZlYzIuc2V0KGRlc3QsIGFycmF5W29mZl0sIGFycmF5W29mZisxXSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2ZWMzLmNvcHlBcnJheSA9IGZ1bmN0aW9uKGRlc3QsIGFycmF5LCBpKXtcclxuICAgICAgICAgICAgdmFyIG9mZiA9IDMqaTtcclxuICAgICAgICAgICAgdmVjMy5zZXQoZGVzdCwgYXJyYXlbb2ZmXSwgYXJyYXlbb2ZmKzFdLCBhcnJheVtvZmYrMl0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmVjNC5jb3B5QXJyYXkgPSBmdW5jdGlvbihkZXN0LCBhcnJheSwgaSl7XHJcbiAgICAgICAgICAgIHZhciBvZmYgPSA0Kmk7XHJcbiAgICAgICAgICAgIHZlYzQuc2V0KGRlc3QsIGFycmF5W29mZl0sIGFycmF5W29mZisxXSwgYXJyYXlbb2ZmKzJdLCBhcnJheVtvZmYrM10pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbWF0My5jb3B5QXJyYXkgPSBmdW5jdGlvbihkZXN0LCBhcnJheSwgaSl7XHJcbiAgICAgICAgICAgIHZhciBqID0gOTtcclxuICAgICAgICAgICAgdmFyIG9mZiA9IGoqaTtcclxuICAgICAgICAgICAgd2hpbGUoai0tKXtcclxuICAgICAgICAgICAgICAgIGRlc3Rbal0gPSBhcnJheVtvZmYral07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG1hdDQuY29weUFycmF5ID0gZnVuY3Rpb24oZGVzdCwgYXJyYXksIGkpe1xyXG4gICAgICAgICAgICB2YXIgaiA9IDE2O1xyXG4gICAgICAgICAgICB2YXIgb2ZmID0gaippO1xyXG4gICAgICAgICAgICB3aGlsZShqLS0pe1xyXG4gICAgICAgICAgICAgICAgZGVzdFtqXSA9IGFycmF5W29mZitqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmVjMi5wYXN0ZUFycmF5ID0gZnVuY3Rpb24oZGVzdCwgaSwgdmFsdWUpe1xyXG4gICAgICAgICAgICB2YXIgb2ZmID0gMippO1xyXG4gICAgICAgICAgICBkZXN0W29mZl0gPSB2YWx1ZVswXTtcclxuICAgICAgICAgICAgZGVzdFtvZmYrMV0gPSB2YWx1ZVsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZlYzMucGFzdGVBcnJheSA9IGZ1bmN0aW9uKGRlc3QsIGksIHZhbHVlKXtcclxuICAgICAgICAgICAgdmFyIG9mZiA9IDMqaTtcclxuICAgICAgICAgICAgZGVzdFtvZmZdID0gdmFsdWVbMF07XHJcbiAgICAgICAgICAgIGRlc3Rbb2ZmKzFdID0gdmFsdWVbMV07XHJcbiAgICAgICAgICAgIGRlc3Rbb2ZmKzJdID0gdmFsdWVbMl07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2ZWM0LnBhc3RlQXJyYXkgPSBmdW5jdGlvbihkZXN0LCBpLCB2YWx1ZSl7XHJcbiAgICAgICAgICAgIHZhciBvZmYgPSAzKmk7XHJcbiAgICAgICAgICAgIGRlc3Rbb2ZmXSA9IHZhbHVlWzBdO1xyXG4gICAgICAgICAgICBkZXN0W29mZisxXSA9IHZhbHVlWzFdO1xyXG4gICAgICAgICAgICBkZXN0W29mZisyXSA9IHZhbHVlWzJdO1xyXG4gICAgICAgICAgICBkZXN0W29mZiszXSA9IHZhbHVlWzNdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbWF0My5wYXN0ZUFycmF5ID0gZnVuY3Rpb24oZGVzdCwgaSwgdmFsdWUpe1xyXG4gICAgICAgICAgICB2YXIgaiA9IDk7XHJcbiAgICAgICAgICAgIHZhciBvZmYgPSBqKmk7XHJcbiAgICAgICAgICAgIHdoaWxlKGotLSl7XHJcbiAgICAgICAgICAgICAgICBkZXN0W29mZitqXSA9IHZhbHVlW2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBtYXQ0LnBhc3RlQXJyYXkgPSBmdW5jdGlvbihkZXN0LCBpLCB2YWx1ZSl7XHJcbiAgICAgICAgICAgIHZhciBqID0gMTY7XHJcbiAgICAgICAgICAgIHZhciBvZmYgPSBqKmk7XHJcbiAgICAgICAgICAgIHdoaWxlKGotLSl7XHJcbiAgICAgICAgICAgICAgICBkZXN0W29mZitqXSA9IHZhbHVlW2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgZ2wtbWF0cml4IC0gSGlnaCBwZXJmb3JtYW5jZSBtYXRyaXggYW5kIHZlY3RvciBvcGVyYXRpb25zXHJcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xyXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxyXG4gKiBAdmVyc2lvbiAyLjIuMVxyXG4gKi9cclxuXHJcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5cclxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG5cclxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xyXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxyXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXHJcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXHJcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xyXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XHJcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxyXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cclxuXHJcblxyXG4oZnVuY3Rpb24oX2dsb2JhbCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICB2YXIgc2hpbSA9IHt9O1xyXG4gIGlmICh0eXBlb2YoZXhwb3J0cykgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZih0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICBzaGltLmV4cG9ydHMgPSB7fTtcclxuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBzaGltLmV4cG9ydHM7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZ2wtbWF0cml4IGxpdmVzIGluIGEgYnJvd3NlciwgZGVmaW5lIGl0cyBuYW1lc3BhY2VzIGluIGdsb2JhbFxyXG4gICAgICBzaGltLmV4cG9ydHMgPSB0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBfZ2xvYmFsO1xyXG4gICAgfVxyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIC8vIGdsLW1hdHJpeCBsaXZlcyBpbiBjb21tb25qcywgZGVmaW5lIGl0cyBuYW1lc3BhY2VzIGluIGV4cG9ydHNcclxuICAgIHNoaW0uZXhwb3J0cyA9IGV4cG9ydHM7XHJcbiAgfVxyXG5cclxuICAoZnVuY3Rpb24oZXhwb3J0cykge1xyXG4gICAgLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXHJcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXHJcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxyXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxyXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxyXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cclxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXHJcblxyXG5cclxuaWYoIUdMTUFUX0VQU0lMT04pIHtcclxuICAgIHZhciBHTE1BVF9FUFNJTE9OID0gMC4wMDAwMDE7XHJcbn1cclxuXHJcbmlmKCFHTE1BVF9BUlJBWV9UWVBFKSB7XHJcbiAgICB2YXIgR0xNQVRfQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcclxufVxyXG5cclxuaWYoIUdMTUFUX1JBTkRPTSkge1xyXG4gICAgdmFyIEdMTUFUX1JBTkRPTSA9IE1hdGgucmFuZG9tO1xyXG59XHJcblxyXG4vKipcclxuICogQGNsYXNzIENvbW1vbiB1dGlsaXRpZXNcclxuICogQG5hbWUgZ2xNYXRyaXhcclxuICovXHJcbnZhciBnbE1hdHJpeCA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcclxuICovXHJcbmdsTWF0cml4LnNldE1hdHJpeEFycmF5VHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIEdMTUFUX0FSUkFZX1RZUEUgPSB0eXBlO1xyXG59XHJcblxyXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBleHBvcnRzLmdsTWF0cml4ID0gZ2xNYXRyaXg7XHJcbn1cclxuXHJcbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xyXG5cclxuLyoqXHJcbiogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXHJcbipcclxuKiBAcGFyYW0ge051bWJlcn0gQW5nbGUgaW4gRGVncmVlc1xyXG4qL1xyXG5nbE1hdHJpeC50b1JhZGlhbiA9IGZ1bmN0aW9uKGEpe1xyXG4gICAgIHJldHVybiBhICogZGVncmVlO1xyXG59XHJcbjtcclxuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXHJcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXHJcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxyXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxyXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxyXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cclxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIDIgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBuYW1lIHZlYzJcclxuICovXHJcblxyXG52YXIgdmVjMiA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcclxuICpcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cclxudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgyKTtcclxuICAgIG91dFswXSA9IDA7XHJcbiAgICBvdXRbMV0gPSAwO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXHJcbiAqL1xyXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDIpO1xyXG4gICAgb3V0WzBdID0gYVswXTtcclxuICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cclxudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDIpO1xyXG4gICAgb3V0WzBdID0geDtcclxuICAgIG91dFsxXSA9IHk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXHJcbnZlYzIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgb3V0WzBdID0gYVswXTtcclxuICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xyXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xyXG4gICAgb3V0WzBdID0geDtcclxuICAgIG91dFsxXSA9IHk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xyXG52ZWMyLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cclxudmVjMi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cclxudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnZlYzIubXVsID0gdmVjMi5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cclxudmVjMi5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcclxuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cclxudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcclxuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xyXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xyXG52ZWMyLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XHJcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cclxudmVjMi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gYVswXSAqIGI7XHJcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xyXG52ZWMyLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xyXG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xyXG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cclxudmVjMi5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXHJcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG52ZWMyLmRpc3QgPSB2ZWMyLmRpc3RhbmNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cclxudmVjMi5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxyXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXTtcclxuICAgIHJldHVybiB4KnggKyB5Knk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cclxudmVjMi5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgdmFyIHggPSBhWzBdLFxyXG4gICAgICAgIHkgPSBhWzFdO1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cclxudmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcclxuICAgIHZhciB4ID0gYVswXSxcclxuICAgICAgICB5ID0gYVsxXTtcclxuICAgIHJldHVybiB4KnggKyB5Knk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XHJcblxyXG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cclxudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcclxuICAgIG91dFswXSA9IC1hWzBdO1xyXG4gICAgb3V0WzFdID0gLWFbMV07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cclxudmVjMi5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcclxuICAgIHZhciB4ID0gYVswXSxcclxuICAgICAgICB5ID0gYVsxXTtcclxuICAgIHZhciBsZW4gPSB4KnggKyB5Knk7XHJcbiAgICBpZiAobGVuID4gMCkge1xyXG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XHJcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xyXG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XHJcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xyXG52ZWMyLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xyXG52ZWMyLmNyb3NzID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XHJcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XHJcbiAgICBvdXRbMF0gPSBvdXRbMV0gPSAwO1xyXG4gICAgb3V0WzJdID0gejtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xyXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XHJcbiAgICB2YXIgYXggPSBhWzBdLFxyXG4gICAgICAgIGF5ID0gYVsxXTtcclxuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xyXG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXHJcbnZlYzIucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcclxuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xyXG4gICAgdmFyIHIgPSBHTE1BVF9SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XHJcbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xyXG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xyXG52ZWMyLnRyYW5zZm9ybU1hdDIgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcclxuICAgIHZhciB4ID0gYVswXSxcclxuICAgICAgICB5ID0gYVsxXTtcclxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XHJcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5O1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cclxudmVjMi50cmFuc2Zvcm1NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xyXG4gICAgdmFyIHggPSBhWzBdLFxyXG4gICAgICAgIHkgPSBhWzFdO1xyXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XHJcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xyXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xyXG52ZWMyLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcclxuICAgIHZhciB4ID0gYVswXSxcclxuICAgICAgICB5ID0gYVsxXTtcclxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xyXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN107XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcclxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cclxudmVjMi50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XHJcbiAgICB2YXIgeCA9IGFbMF0sIFxyXG4gICAgICAgIHkgPSBhWzFdO1xyXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xyXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjMnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMi4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cclxuICogQHJldHVybnMge0FycmF5fSBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxudmVjMi5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZlYyA9IHZlYzIuY3JlYXRlKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xyXG4gICAgICAgIHZhciBpLCBsO1xyXG4gICAgICAgIGlmKCFzdHJpZGUpIHtcclxuICAgICAgICAgICAgc3RyaWRlID0gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoY291bnQpIHtcclxuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XHJcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTtcclxuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XHJcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cclxudmVjMi5zdHIgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XHJcbn07XHJcblxyXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBleHBvcnRzLnZlYzIgPSB2ZWMyO1xyXG59XHJcbjtcclxuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXHJcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXHJcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxyXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxyXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxyXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cclxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIDMgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBuYW1lIHZlYzNcclxuICovXHJcblxyXG52YXIgdmVjMyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcclxuICpcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cclxudmVjMy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgzKTtcclxuICAgIG91dFswXSA9IDA7XHJcbiAgICBvdXRbMV0gPSAwO1xyXG4gICAgb3V0WzJdID0gMDtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cclxudmVjMy5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSgzKTtcclxuICAgIG91dFswXSA9IGFbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdO1xyXG4gICAgb3V0WzJdID0gYVsyXTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xyXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMyk7XHJcbiAgICBvdXRbMF0gPSB4O1xyXG4gICAgb3V0WzFdID0geTtcclxuICAgIG91dFsyXSA9IHo7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXHJcbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgb3V0WzBdID0gYVswXTtcclxuICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICBvdXRbMl0gPSBhWzJdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cclxudmVjMy5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHopIHtcclxuICAgIG91dFswXSA9IHg7XHJcbiAgICBvdXRbMV0gPSB5O1xyXG4gICAgb3V0WzJdID0gejtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXHJcbnZlYzMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcclxuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xyXG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXHJcbnZlYzMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcclxuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XHJcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnZlYzMuc3ViID0gdmVjMy5zdWJ0cmFjdDtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cclxudmVjMy5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcclxuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxudmVjMy5tdWwgPSB2ZWMzLm11bHRpcGx5O1xyXG5cclxuLyoqXHJcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xyXG52ZWMzLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcclxuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnZlYzMuZGl2ID0gdmVjMy5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXHJcbnZlYzMubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XHJcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcclxuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xyXG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xyXG52ZWMzLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XHJcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcclxuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xyXG52ZWMzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcclxuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xyXG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cclxudmVjMy5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcclxuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcclxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcclxuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXHJcbnZlYzMuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxyXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcclxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnZlYzMuZGlzdCA9IHZlYzMuZGlzdGFuY2U7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXHJcbiAqL1xyXG52ZWMzLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXHJcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxyXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcclxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG52ZWMzLnNxckRpc3QgPSB2ZWMzLnNxdWFyZWREaXN0YW5jZTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cclxudmVjMy5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgdmFyIHggPSBhWzBdLFxyXG4gICAgICAgIHkgPSBhWzFdLFxyXG4gICAgICAgIHogPSBhWzJdO1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxudmVjMy5sZW4gPSB2ZWMzLmxlbmd0aDtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cclxudmVjMy5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcclxuICAgIHZhciB4ID0gYVswXSxcclxuICAgICAgICB5ID0gYVsxXSxcclxuICAgICAgICB6ID0gYVsyXTtcclxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxudmVjMy5zcXJMZW4gPSB2ZWMzLnNxdWFyZWRMZW5ndGg7XHJcblxyXG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cclxudmVjMy5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcclxuICAgIG91dFswXSA9IC1hWzBdO1xyXG4gICAgb3V0WzFdID0gLWFbMV07XHJcbiAgICBvdXRbMl0gPSAtYVsyXTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xyXG52ZWMzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgdmFyIHggPSBhWzBdLFxyXG4gICAgICAgIHkgPSBhWzFdLFxyXG4gICAgICAgIHogPSBhWzJdO1xyXG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcclxuICAgIGlmIChsZW4gPiAwKSB7XHJcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cclxuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcclxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xyXG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKi9cclxudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXHJcbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcclxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxyXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl07XHJcblxyXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XHJcbiAgICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcclxuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXHJcbnZlYzMubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcclxuICAgIHZhciBheCA9IGFbMF0sXHJcbiAgICAgICAgYXkgPSBhWzFdLFxyXG4gICAgICAgIGF6ID0gYVsyXTtcclxuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xyXG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XHJcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cclxudmVjMy5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xyXG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XHJcblxyXG4gICAgdmFyIHIgPSBHTE1BVF9SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XHJcbiAgICB2YXIgeiA9IChHTE1BVF9SQU5ET00oKSAqIDIuMCkgLSAxLjA7XHJcbiAgICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGU7XHJcblxyXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XHJcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcclxuICAgIG91dFsyXSA9IHogKiBzY2FsZTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cclxudmVjMy50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XHJcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcclxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdO1xyXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM107XHJcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cclxudmVjMy50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XHJcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcclxuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcclxuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcclxuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cclxudmVjMy50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XHJcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xyXG5cclxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxyXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcclxuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcclxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcclxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcclxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XHJcblxyXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxyXG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcclxuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XHJcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qXHJcbiogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXHJcbiogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4qIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4qIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxyXG4qIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuKi9cclxudmVjMy5yb3RhdGVYID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcclxuICAgdmFyIHAgPSBbXSwgcj1bXTtcclxuXHQgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cclxuXHQgIHBbMF0gPSBhWzBdIC0gYlswXTtcclxuXHQgIHBbMV0gPSBhWzFdIC0gYlsxXTtcclxuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcclxuXHJcblx0ICAvL3BlcmZvcm0gcm90YXRpb25cclxuXHQgIHJbMF0gPSBwWzBdO1xyXG5cdCAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xyXG5cdCAgclsyXSA9IHBbMV0qTWF0aC5zaW4oYykgKyBwWzJdKk1hdGguY29zKGMpO1xyXG5cclxuXHQgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cclxuXHQgIG91dFswXSA9IHJbMF0gKyBiWzBdO1xyXG5cdCAgb3V0WzFdID0gclsxXSArIGJbMV07XHJcblx0ICBvdXRbMl0gPSByWzJdICsgYlsyXTtcclxuXHJcbiAgXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLypcclxuKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcclxuKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXHJcbiogQHJldHVybnMge3ZlYzN9IG91dFxyXG4qL1xyXG52ZWMzLnJvdGF0ZVkgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xyXG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcclxuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cclxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcclxuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcclxuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcclxuICBcclxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxyXG4gIFx0clswXSA9IHBbMl0qTWF0aC5zaW4oYykgKyBwWzBdKk1hdGguY29zKGMpO1xyXG4gIFx0clsxXSA9IHBbMV07XHJcbiAgXHRyWzJdID0gcFsyXSpNYXRoLmNvcyhjKSAtIHBbMF0qTWF0aC5zaW4oYyk7XHJcbiAgXHJcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXHJcbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcclxuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xyXG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XHJcbiAgXHJcbiAgXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLypcclxuKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcclxuKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcclxuKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXHJcbiogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXHJcbiogQHJldHVybnMge3ZlYzN9IG91dFxyXG4qL1xyXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xyXG4gIFx0dmFyIHAgPSBbXSwgcj1bXTtcclxuICBcdC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cclxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcclxuICBcdHBbMV0gPSBhWzFdIC0gYlsxXTtcclxuICBcdHBbMl0gPSBhWzJdIC0gYlsyXTtcclxuICBcclxuICBcdC8vcGVyZm9ybSByb3RhdGlvblxyXG4gIFx0clswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xyXG4gIFx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xyXG4gIFx0clsyXSA9IHBbMl07XHJcbiAgXHJcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXHJcbiAgXHRvdXRbMF0gPSByWzBdICsgYlswXTtcclxuICBcdG91dFsxXSA9IHJbMV0gKyBiWzFdO1xyXG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XHJcbiAgXHJcbiAgXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG52ZWMzLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmVjID0gdmVjMy5jcmVhdGUoKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XHJcbiAgICAgICAgdmFyIGksIGw7XHJcbiAgICAgICAgaWYoIXN0cmlkZSkge1xyXG4gICAgICAgICAgICBzdHJpZGUgPSAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoIW9mZnNldCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZihjb3VudCkge1xyXG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcclxuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07XHJcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xyXG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cclxudmVjMy5zdHIgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcclxufTtcclxuXHJcbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGV4cG9ydHMudmVjMyA9IHZlYzM7XHJcbn1cclxuO1xyXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuXHJcblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcclxuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcclxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXHJcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXHJcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXHJcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xyXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XHJcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxyXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgNCBEaW1lbnNpb25hbCBWZWN0b3JcclxuICogQG5hbWUgdmVjNFxyXG4gKi9cclxuXHJcbnZhciB2ZWM0ID0ge307XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXHJcbiAqL1xyXG52ZWM0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xyXG4gICAgb3V0WzBdID0gMDtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMDtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cclxudmVjNC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcclxuICAgIG91dFswXSA9IGFbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdO1xyXG4gICAgb3V0WzJdID0gYVsyXTtcclxuICAgIG91dFszXSA9IGFbM107XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cclxudmVjNC5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xyXG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xyXG4gICAgb3V0WzBdID0geDtcclxuICAgIG91dFsxXSA9IHk7XHJcbiAgICBvdXRbMl0gPSB6O1xyXG4gICAgb3V0WzNdID0gdztcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cclxudmVjNC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXTtcclxuICAgIG91dFsyXSA9IGFbMl07XHJcbiAgICBvdXRbM10gPSBhWzNdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cclxudmVjNC5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHosIHcpIHtcclxuICAgIG91dFswXSA9IHg7XHJcbiAgICBvdXRbMV0gPSB5O1xyXG4gICAgb3V0WzJdID0gejtcclxuICAgIG91dFszXSA9IHc7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xyXG52ZWM0LmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcclxuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xyXG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXHJcbnZlYzQuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcclxuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XHJcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcclxuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxudmVjNC5zdWIgPSB2ZWM0LnN1YnRyYWN0O1xyXG5cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xyXG52ZWM0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcclxuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xyXG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XHJcbiAgICBvdXRbM10gPSBhWzNdICogYlszXTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnZlYzQubXVsID0gdmVjNC5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cclxudmVjNC5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcclxuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XHJcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcclxuICAgIG91dFszXSA9IGFbM10gLyBiWzNdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnZlYzQuZGl2ID0gdmVjNC5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXHJcbnZlYzQubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XHJcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcclxuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xyXG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XHJcbiAgICBvdXRbM10gPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXHJcbnZlYzQubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XHJcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcclxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xyXG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XHJcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cclxudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xyXG4gICAgb3V0WzBdID0gYVswXSAqIGI7XHJcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcclxuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xyXG4gICAgb3V0WzNdID0gYVszXSAqIGI7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cclxudmVjNC5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcclxuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcclxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcclxuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcclxuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXHJcbnZlYzQuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxyXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcclxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXHJcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG52ZWM0LmRpc3QgPSB2ZWM0LmRpc3RhbmNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cclxudmVjNC5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxyXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcclxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXHJcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xyXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnZlYzQuc3FyRGlzdCA9IHZlYzQuc3F1YXJlZERpc3RhbmNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xyXG52ZWM0Lmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICB2YXIgeCA9IGFbMF0sXHJcbiAgICAgICAgeSA9IGFbMV0sXHJcbiAgICAgICAgeiA9IGFbMl0sXHJcbiAgICAgICAgdyA9IGFbM107XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG52ZWM0LmxlbiA9IHZlYzQubGVuZ3RoO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xyXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgdmFyIHggPSBhWzBdLFxyXG4gICAgICAgIHkgPSBhWzFdLFxyXG4gICAgICAgIHogPSBhWzJdLFxyXG4gICAgICAgIHcgPSBhWzNdO1xyXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xyXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgb3V0WzBdID0gLWFbMF07XHJcbiAgICBvdXRbMV0gPSAtYVsxXTtcclxuICAgIG91dFsyXSA9IC1hWzJdO1xyXG4gICAgb3V0WzNdID0gLWFbM107XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cclxudmVjNC5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcclxuICAgIHZhciB4ID0gYVswXSxcclxuICAgICAgICB5ID0gYVsxXSxcclxuICAgICAgICB6ID0gYVsyXSxcclxuICAgICAgICB3ID0gYVszXTtcclxuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XHJcbiAgICBpZiAobGVuID4gMCkge1xyXG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcclxuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xyXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XHJcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcclxuICAgICAgICBvdXRbM10gPSBhWzNdICogbGVuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXHJcbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXHJcbnZlYzQubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcclxuICAgIHZhciBheCA9IGFbMF0sXHJcbiAgICAgICAgYXkgPSBhWzFdLFxyXG4gICAgICAgIGF6ID0gYVsyXSxcclxuICAgICAgICBhdyA9IGFbM107XHJcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcclxuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xyXG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XHJcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cclxudmVjNC5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xyXG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XHJcblxyXG4gICAgLy9UT0RPOiBUaGlzIGlzIGEgcHJldHR5IGF3ZnVsIHdheSBvZiBkb2luZyB0aGlzLiBGaW5kIHNvbWV0aGluZyBiZXR0ZXIuXHJcbiAgICBvdXRbMF0gPSBHTE1BVF9SQU5ET00oKTtcclxuICAgIG91dFsxXSA9IEdMTUFUX1JBTkRPTSgpO1xyXG4gICAgb3V0WzJdID0gR0xNQVRfUkFORE9NKCk7XHJcbiAgICBvdXRbM10gPSBHTE1BVF9SQU5ET00oKTtcclxuICAgIHZlYzQubm9ybWFsaXplKG91dCwgb3V0KTtcclxuICAgIHZlYzQuc2NhbGUob3V0LCBvdXQsIHNjYWxlKTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cclxudmVjNC50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XHJcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XHJcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XHJcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XHJcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xyXG4gICAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cclxudmVjNC50cmFuc2Zvcm1RdWF0ID0gZnVuY3Rpb24ob3V0LCBhLCBxKSB7XHJcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcclxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXHJcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXHJcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXHJcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXHJcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcclxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XHJcbiAgICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xyXG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnZlYzQuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcclxuICAgIHZhciB2ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcclxuICAgICAgICB2YXIgaSwgbDtcclxuICAgICAgICBpZighc3RyaWRlKSB7XHJcbiAgICAgICAgICAgIHN0cmlkZSA9IDQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZighb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGNvdW50KSB7XHJcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xyXG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTsgdmVjWzNdID0gYVtpKzNdO1xyXG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcclxuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cclxudmVjNC5zdHIgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xyXG59O1xyXG5cclxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgZXhwb3J0cy52ZWM0ID0gdmVjNDtcclxufVxyXG47XHJcbi8qIENvcHlyaWdodCAoYykgMjAxMywgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5cclxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG5cclxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xyXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxyXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcblxyXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcclxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcclxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcclxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcclxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXHJcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcclxuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXHJcbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXHJcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyAyeDIgTWF0cml4XHJcbiAqIEBuYW1lIG1hdDJcclxuICovXHJcblxyXG52YXIgbWF0MiA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxyXG4gKi9cclxubWF0Mi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvdXQgPSBuZXcgR0xNQVRfQVJSQVlfVFlQRSg0KTtcclxuICAgIG91dFswXSA9IDE7XHJcbiAgICBvdXRbMV0gPSAwO1xyXG4gICAgb3V0WzJdID0gMDtcclxuICAgIG91dFszXSA9IDE7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XHJcbiAqL1xyXG5tYXQyLmNsb25lID0gZnVuY3Rpb24oYSkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xyXG4gICAgb3V0WzBdID0gYVswXTtcclxuICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICBvdXRbMl0gPSBhWzJdO1xyXG4gICAgb3V0WzNdID0gYVszXTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cclxubWF0Mi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXTtcclxuICAgIG91dFsyXSA9IGFbMl07XHJcbiAgICBvdXRbM10gPSBhWzNdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cclxubWF0Mi5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xyXG4gICAgb3V0WzBdID0gMTtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xyXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xyXG4gICAgaWYgKG91dCA9PT0gYSkge1xyXG4gICAgICAgIHZhciBhMSA9IGFbMV07XHJcbiAgICAgICAgb3V0WzFdID0gYVsyXTtcclxuICAgICAgICBvdXRbMl0gPSBhMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb3V0WzBdID0gYVswXTtcclxuICAgICAgICBvdXRbMV0gPSBhWzJdO1xyXG4gICAgICAgIG91dFsyXSA9IGFbMV07XHJcbiAgICAgICAgb3V0WzNdID0gYVszXTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cclxubWF0Mi5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcclxuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcclxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcclxuXHJcbiAgICBpZiAoIWRldCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZGV0ID0gMS4wIC8gZGV0O1xyXG4gICAgXHJcbiAgICBvdXRbMF0gPSAgYTMgKiBkZXQ7XHJcbiAgICBvdXRbMV0gPSAtYTEgKiBkZXQ7XHJcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XHJcbiAgICBvdXRbM10gPSAgYTAgKiBkZXQ7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXHJcbm1hdDIuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxyXG4gICAgdmFyIGEwID0gYVswXTtcclxuICAgIG91dFswXSA9ICBhWzNdO1xyXG4gICAgb3V0WzFdID0gLWFbMV07XHJcbiAgICBvdXRbMl0gPSAtYVsyXTtcclxuICAgIG91dFszXSA9ICBhMDtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cclxubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cclxubWF0Mi5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcclxuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XHJcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xyXG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XHJcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcclxuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xyXG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5tYXQyLm11bCA9IG1hdDIubXVsdGlwbHk7XHJcblxyXG4vKipcclxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xyXG5tYXQyLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xyXG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcclxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcclxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcclxuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XHJcbiAgICBvdXRbMV0gPSBhMSAqICBjICsgYTMgKiBzO1xyXG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcclxuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKiovXHJcbm1hdDIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcclxuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXHJcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XHJcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xyXG4gICAgb3V0WzFdID0gYTEgKiB2MDtcclxuICAgIG91dFsyXSA9IGEyICogdjE7XHJcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xyXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICByZXR1cm4gJ21hdDIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xyXG5tYXQyLmZyb2IgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4IFxyXG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeCBcclxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXHJcbiAqL1xyXG5cclxubWF0Mi5MRFUgPSBmdW5jdGlvbiAoTCwgRCwgVSwgYSkgeyBcclxuICAgIExbMl0gPSBhWzJdL2FbMF07IFxyXG4gICAgVVswXSA9IGFbMF07IFxyXG4gICAgVVsxXSA9IGFbMV07IFxyXG4gICAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXTsgXHJcbiAgICByZXR1cm4gW0wsIEQsIFVdOyAgICAgICBcclxufTsgXHJcblxyXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBleHBvcnRzLm1hdDIgPSBtYXQyO1xyXG59XHJcbjtcclxuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXHJcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXHJcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxyXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxyXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxyXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cclxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIDJ4MyBNYXRyaXhcclxuICogQG5hbWUgbWF0MmRcclxuICogXHJcbiAqIEBkZXNjcmlwdGlvbiBcclxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcclxuICogPHByZT5cclxuICogW2EsIGMsIHR4LFxyXG4gKiAgYiwgZCwgdHldXHJcbiAqIDwvcHJlPlxyXG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XHJcbiAqIDxwcmU+XHJcbiAqIFthLCBjLCB0eCxcclxuICogIGIsIGQsIHR5LFxyXG4gKiAgMCwgMCwgMV1cclxuICogPC9wcmU+XHJcbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXHJcbiAqL1xyXG5cclxudmFyIG1hdDJkID0ge307XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcclxuICovXHJcbm1hdDJkLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDYpO1xyXG4gICAgb3V0WzBdID0gMTtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMTtcclxuICAgIG91dFs0XSA9IDA7XHJcbiAgICBvdXRbNV0gPSAwO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDJkIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxyXG4gKi9cclxubWF0MmQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoNik7XHJcbiAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXTtcclxuICAgIG91dFsyXSA9IGFbMl07XHJcbiAgICBvdXRbM10gPSBhWzNdO1xyXG4gICAgb3V0WzRdID0gYVs0XTtcclxuICAgIG91dFs1XSA9IGFbNV07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xyXG5tYXQyZC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXTtcclxuICAgIG91dFsyXSA9IGFbMl07XHJcbiAgICBvdXRbM10gPSBhWzNdO1xyXG4gICAgb3V0WzRdID0gYVs0XTtcclxuICAgIG91dFs1XSA9IGFbNV07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCBhIG1hdDJkIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xyXG5tYXQyZC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xyXG4gICAgb3V0WzBdID0gMTtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMTtcclxuICAgIG91dFs0XSA9IDA7XHJcbiAgICBvdXRbNV0gPSAwO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXHJcbm1hdDJkLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgdmFyIGFhID0gYVswXSwgYWIgPSBhWzFdLCBhYyA9IGFbMl0sIGFkID0gYVszXSxcclxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xyXG5cclxuICAgIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcclxuICAgIGlmKCFkZXQpe1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZGV0ID0gMS4wIC8gZGV0O1xyXG5cclxuICAgIG91dFswXSA9IGFkICogZGV0O1xyXG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xyXG4gICAgb3V0WzJdID0gLWFjICogZGV0O1xyXG4gICAgb3V0WzNdID0gYWEgKiBkZXQ7XHJcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XHJcbiAgICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xyXG5tYXQyZC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xyXG5tYXQyZC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcclxuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxyXG4gICAgICAgIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XHJcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcclxuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xyXG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XHJcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcclxuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XHJcbiAgICBvdXRbNV0gPSBhMSAqIGI0ICsgYTMgKiBiNSArIGE1O1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xyXG5tYXQyZC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcclxuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxyXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxyXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xyXG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcclxuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XHJcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xyXG4gICAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcclxuICAgIG91dFs0XSA9IGE0O1xyXG4gICAgb3V0WzVdID0gYTU7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICoqL1xyXG5tYXQyZC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xyXG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXHJcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XHJcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xyXG4gICAgb3V0WzFdID0gYTEgKiB2MDtcclxuICAgIG91dFsyXSA9IGEyICogdjE7XHJcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xyXG4gICAgb3V0WzRdID0gYTQ7XHJcbiAgICBvdXRbNV0gPSBhNTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqKi9cclxubWF0MmQudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XHJcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcclxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcclxuICAgIG91dFswXSA9IGEwO1xyXG4gICAgb3V0WzFdID0gYTE7XHJcbiAgICBvdXRbMl0gPSBhMjtcclxuICAgIG91dFszXSA9IGEzO1xyXG4gICAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcclxuICAgIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXHJcbm1hdDJkLnN0ciA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICByZXR1cm4gJ21hdDJkKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcclxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcpJztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cclxubWF0MmQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7IFxyXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcclxufTsgXHJcblxyXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBleHBvcnRzLm1hdDJkID0gbWF0MmQ7XHJcbn1cclxuO1xyXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuXHJcblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcclxuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcclxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXHJcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXHJcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXHJcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xyXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XHJcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxyXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgM3gzIE1hdHJpeFxyXG4gKiBAbmFtZSBtYXQzXHJcbiAqL1xyXG5cclxudmFyIG1hdDMgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcclxuICpcclxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcclxuICovXHJcbm1hdDMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoOSk7XHJcbiAgICBvdXRbMF0gPSAxO1xyXG4gICAgb3V0WzFdID0gMDtcclxuICAgIG91dFsyXSA9IDA7XHJcbiAgICBvdXRbM10gPSAwO1xyXG4gICAgb3V0WzRdID0gMTtcclxuICAgIG91dFs1XSA9IDA7XHJcbiAgICBvdXRbNl0gPSAwO1xyXG4gICAgb3V0WzddID0gMDtcclxuICAgIG91dFs4XSA9IDE7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cclxubWF0My5mcm9tTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgb3V0WzBdID0gYVswXTtcclxuICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICBvdXRbMl0gPSBhWzJdO1xyXG4gICAgb3V0WzNdID0gYVs0XTtcclxuICAgIG91dFs0XSA9IGFbNV07XHJcbiAgICBvdXRbNV0gPSBhWzZdO1xyXG4gICAgb3V0WzZdID0gYVs4XTtcclxuICAgIG91dFs3XSA9IGFbOV07XHJcbiAgICBvdXRbOF0gPSBhWzEwXTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcclxuICovXHJcbm1hdDMuY2xvbmUgPSBmdW5jdGlvbihhKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoOSk7XHJcbiAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXTtcclxuICAgIG91dFsyXSA9IGFbMl07XHJcbiAgICBvdXRbM10gPSBhWzNdO1xyXG4gICAgb3V0WzRdID0gYVs0XTtcclxuICAgIG91dFs1XSA9IGFbNV07XHJcbiAgICBvdXRbNl0gPSBhWzZdO1xyXG4gICAgb3V0WzddID0gYVs3XTtcclxuICAgIG91dFs4XSA9IGFbOF07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQzIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXHJcbm1hdDMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgb3V0WzBdID0gYVswXTtcclxuICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICBvdXRbMl0gPSBhWzJdO1xyXG4gICAgb3V0WzNdID0gYVszXTtcclxuICAgIG91dFs0XSA9IGFbNF07XHJcbiAgICBvdXRbNV0gPSBhWzVdO1xyXG4gICAgb3V0WzZdID0gYVs2XTtcclxuICAgIG91dFs3XSA9IGFbN107XHJcbiAgICBvdXRbOF0gPSBhWzhdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cclxubWF0My5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xyXG4gICAgb3V0WzBdID0gMTtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMDtcclxuICAgIG91dFs0XSA9IDE7XHJcbiAgICBvdXRbNV0gPSAwO1xyXG4gICAgb3V0WzZdID0gMDtcclxuICAgIG91dFs3XSA9IDA7XHJcbiAgICBvdXRbOF0gPSAxO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXHJcbm1hdDMudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XHJcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXHJcbiAgICBpZiAob3V0ID09PSBhKSB7XHJcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XHJcbiAgICAgICAgb3V0WzFdID0gYVszXTtcclxuICAgICAgICBvdXRbMl0gPSBhWzZdO1xyXG4gICAgICAgIG91dFszXSA9IGEwMTtcclxuICAgICAgICBvdXRbNV0gPSBhWzddO1xyXG4gICAgICAgIG91dFs2XSA9IGEwMjtcclxuICAgICAgICBvdXRbN10gPSBhMTI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIG91dFswXSA9IGFbMF07XHJcbiAgICAgICAgb3V0WzFdID0gYVszXTtcclxuICAgICAgICBvdXRbMl0gPSBhWzZdO1xyXG4gICAgICAgIG91dFszXSA9IGFbMV07XHJcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcclxuICAgICAgICBvdXRbNV0gPSBhWzddO1xyXG4gICAgICAgIG91dFs2XSA9IGFbMl07XHJcbiAgICAgICAgb3V0WzddID0gYVs1XTtcclxuICAgICAgICBvdXRbOF0gPSBhWzhdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xyXG5tYXQzLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXHJcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcclxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxyXG5cclxuICAgICAgICBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjEsXHJcbiAgICAgICAgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMCxcclxuICAgICAgICBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjAsXHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcclxuICAgICAgICBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XHJcblxyXG4gICAgaWYgKCFkZXQpIHsgXHJcbiAgICAgICAgcmV0dXJuIG51bGw7IFxyXG4gICAgfVxyXG4gICAgZGV0ID0gMS4wIC8gZGV0O1xyXG5cclxuICAgIG91dFswXSA9IGIwMSAqIGRldDtcclxuICAgIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcclxuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xyXG4gICAgb3V0WzNdID0gYjExICogZGV0O1xyXG4gICAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XHJcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XHJcbiAgICBvdXRbNl0gPSBiMjEgKiBkZXQ7XHJcbiAgICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XHJcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xyXG5tYXQzLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcclxuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxyXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXHJcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcclxuXHJcbiAgICBvdXRbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcclxuICAgIG91dFsxXSA9IChhMDIgKiBhMjEgLSBhMDEgKiBhMjIpO1xyXG4gICAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XHJcbiAgICBvdXRbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcclxuICAgIG91dFs0XSA9IChhMDAgKiBhMjIgLSBhMDIgKiBhMjApO1xyXG4gICAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XHJcbiAgICBvdXRbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcclxuICAgIG91dFs3XSA9IChhMDEgKiBhMjAgLSBhMDAgKiBhMjEpO1xyXG4gICAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cclxubWF0My5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcclxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxyXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XHJcblxyXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXHJcbm1hdDMubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XHJcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcclxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxyXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXHJcblxyXG4gICAgICAgIGIwMCA9IGJbMF0sIGIwMSA9IGJbMV0sIGIwMiA9IGJbMl0sXHJcbiAgICAgICAgYjEwID0gYlszXSwgYjExID0gYls0XSwgYjEyID0gYls1XSxcclxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xyXG5cclxuICAgIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcclxuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcclxuICAgIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcclxuXHJcbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XHJcbiAgICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XHJcbiAgICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XHJcblxyXG4gICAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xyXG4gICAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xyXG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxubWF0My5tdWwgPSBtYXQzLm11bHRpcGx5O1xyXG5cclxuLyoqXHJcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cclxubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcclxuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxyXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXHJcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcclxuICAgICAgICB4ID0gdlswXSwgeSA9IHZbMV07XHJcblxyXG4gICAgb3V0WzBdID0gYTAwO1xyXG4gICAgb3V0WzFdID0gYTAxO1xyXG4gICAgb3V0WzJdID0gYTAyO1xyXG5cclxuICAgIG91dFszXSA9IGExMDtcclxuICAgIG91dFs0XSA9IGExMTtcclxuICAgIG91dFs1XSA9IGExMjtcclxuXHJcbiAgICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcclxuICAgIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xyXG4gICAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cclxubWF0My5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcclxuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxyXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXHJcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcclxuXHJcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXHJcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XHJcblxyXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XHJcbiAgICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcclxuICAgIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xyXG5cclxuICAgIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xyXG4gICAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XHJcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcclxuXHJcbiAgICBvdXRbNl0gPSBhMjA7XHJcbiAgICBvdXRbN10gPSBhMjE7XHJcbiAgICBvdXRbOF0gPSBhMjI7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKiovXHJcbm1hdDMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcclxuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV07XHJcblxyXG4gICAgb3V0WzBdID0geCAqIGFbMF07XHJcbiAgICBvdXRbMV0gPSB4ICogYVsxXTtcclxuICAgIG91dFsyXSA9IHggKiBhWzJdO1xyXG5cclxuICAgIG91dFszXSA9IHkgKiBhWzNdO1xyXG4gICAgb3V0WzRdID0geSAqIGFbNF07XHJcbiAgICBvdXRbNV0gPSB5ICogYVs1XTtcclxuXHJcbiAgICBvdXRbNl0gPSBhWzZdO1xyXG4gICAgb3V0WzddID0gYVs3XTtcclxuICAgIG91dFs4XSA9IGFbOF07XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqKi9cclxubWF0My5mcm9tTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEpIHtcclxuICAgIG91dFswXSA9IGFbMF07XHJcbiAgICBvdXRbMV0gPSBhWzFdO1xyXG4gICAgb3V0WzJdID0gMDtcclxuXHJcbiAgICBvdXRbM10gPSBhWzJdO1xyXG4gICAgb3V0WzRdID0gYVszXTtcclxuICAgIG91dFs1XSA9IDA7XHJcblxyXG4gICAgb3V0WzZdID0gYVs0XTtcclxuICAgIG91dFs3XSA9IGFbNV07XHJcbiAgICBvdXRbOF0gPSAxO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cclxuKlxyXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuKlxyXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcclxuKi9cclxubWF0My5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcclxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcclxuICAgICAgICB4MiA9IHggKyB4LFxyXG4gICAgICAgIHkyID0geSArIHksXHJcbiAgICAgICAgejIgPSB6ICsgeixcclxuXHJcbiAgICAgICAgeHggPSB4ICogeDIsXHJcbiAgICAgICAgeXggPSB5ICogeDIsXHJcbiAgICAgICAgeXkgPSB5ICogeTIsXHJcbiAgICAgICAgenggPSB6ICogeDIsXHJcbiAgICAgICAgenkgPSB6ICogeTIsXHJcbiAgICAgICAgenogPSB6ICogejIsXHJcbiAgICAgICAgd3ggPSB3ICogeDIsXHJcbiAgICAgICAgd3kgPSB3ICogeTIsXHJcbiAgICAgICAgd3ogPSB3ICogejI7XHJcblxyXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XHJcbiAgICBvdXRbM10gPSB5eCAtIHd6O1xyXG4gICAgb3V0WzZdID0genggKyB3eTtcclxuXHJcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xyXG4gICAgb3V0WzRdID0gMSAtIHh4IC0geno7XHJcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xyXG5cclxuICAgIG91dFsyXSA9IHp4IC0gd3k7XHJcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xyXG4gICAgb3V0WzhdID0gMSAtIHh4IC0geXk7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcclxuKlxyXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxyXG4qXHJcbiogQHJldHVybnMge21hdDN9IG91dFxyXG4qL1xyXG5tYXQzLm5vcm1hbEZyb21NYXQ0ID0gZnVuY3Rpb24gKG91dCwgYSkge1xyXG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXHJcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcclxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXHJcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXHJcblxyXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcclxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXHJcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxyXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcclxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXHJcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxyXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcclxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXHJcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxyXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcclxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXHJcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XHJcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xyXG5cclxuICAgIGlmICghZGV0KSB7IFxyXG4gICAgICAgIHJldHVybiBudWxsOyBcclxuICAgIH1cclxuICAgIGRldCA9IDEuMCAvIGRldDtcclxuXHJcbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcclxuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xyXG4gICAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XHJcblxyXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XHJcbiAgICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcclxuICAgIG91dFs1XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xyXG5cclxuICAgIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xyXG4gICAgb3V0WzddID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XHJcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXHJcbm1hdDMuc3RyID0gZnVuY3Rpb24gKGEpIHtcclxuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXHJcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgXHJcbiAgICAgICAgICAgICAgICAgICAgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArIGFbOF0gKyAnKSc7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xyXG5tYXQzLmZyb2IgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxyXG59O1xyXG5cclxuXHJcbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGV4cG9ydHMubWF0MyA9IG1hdDM7XHJcbn1cclxuO1xyXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTMsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuXHJcblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuXHJcbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcclxuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcclxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG5cclxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXHJcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXHJcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXHJcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xyXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XHJcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxyXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxyXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxyXG4gKiBAbmFtZSBtYXQ0XHJcbiAqL1xyXG5cclxudmFyIG1hdDQgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcclxuICpcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXHJcbm1hdDQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMTYpO1xyXG4gICAgb3V0WzBdID0gMTtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMDtcclxuICAgIG91dFs0XSA9IDA7XHJcbiAgICBvdXRbNV0gPSAxO1xyXG4gICAgb3V0WzZdID0gMDtcclxuICAgIG91dFs3XSA9IDA7XHJcbiAgICBvdXRbOF0gPSAwO1xyXG4gICAgb3V0WzldID0gMDtcclxuICAgIG91dFsxMF0gPSAxO1xyXG4gICAgb3V0WzExXSA9IDA7XHJcbiAgICBvdXRbMTJdID0gMDtcclxuICAgIG91dFsxM10gPSAwO1xyXG4gICAgb3V0WzE0XSA9IDA7XHJcbiAgICBvdXRbMTVdID0gMTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXHJcbm1hdDQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XHJcbiAgICB2YXIgb3V0ID0gbmV3IEdMTUFUX0FSUkFZX1RZUEUoMTYpO1xyXG4gICAgb3V0WzBdID0gYVswXTtcclxuICAgIG91dFsxXSA9IGFbMV07XHJcbiAgICBvdXRbMl0gPSBhWzJdO1xyXG4gICAgb3V0WzNdID0gYVszXTtcclxuICAgIG91dFs0XSA9IGFbNF07XHJcbiAgICBvdXRbNV0gPSBhWzVdO1xyXG4gICAgb3V0WzZdID0gYVs2XTtcclxuICAgIG91dFs3XSA9IGFbN107XHJcbiAgICBvdXRbOF0gPSBhWzhdO1xyXG4gICAgb3V0WzldID0gYVs5XTtcclxuICAgIG91dFsxMF0gPSBhWzEwXTtcclxuICAgIG91dFsxMV0gPSBhWzExXTtcclxuICAgIG91dFsxMl0gPSBhWzEyXTtcclxuICAgIG91dFsxM10gPSBhWzEzXTtcclxuICAgIG91dFsxNF0gPSBhWzE0XTtcclxuICAgIG91dFsxNV0gPSBhWzE1XTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cclxubWF0NC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XHJcbiAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgb3V0WzFdID0gYVsxXTtcclxuICAgIG91dFsyXSA9IGFbMl07XHJcbiAgICBvdXRbM10gPSBhWzNdO1xyXG4gICAgb3V0WzRdID0gYVs0XTtcclxuICAgIG91dFs1XSA9IGFbNV07XHJcbiAgICBvdXRbNl0gPSBhWzZdO1xyXG4gICAgb3V0WzddID0gYVs3XTtcclxuICAgIG91dFs4XSA9IGFbOF07XHJcbiAgICBvdXRbOV0gPSBhWzldO1xyXG4gICAgb3V0WzEwXSA9IGFbMTBdO1xyXG4gICAgb3V0WzExXSA9IGFbMTFdO1xyXG4gICAgb3V0WzEyXSA9IGFbMTJdO1xyXG4gICAgb3V0WzEzXSA9IGFbMTNdO1xyXG4gICAgb3V0WzE0XSA9IGFbMTRdO1xyXG4gICAgb3V0WzE1XSA9IGFbMTVdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cclxubWF0NC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xyXG4gICAgb3V0WzBdID0gMTtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMDtcclxuICAgIG91dFs0XSA9IDA7XHJcbiAgICBvdXRbNV0gPSAxO1xyXG4gICAgb3V0WzZdID0gMDtcclxuICAgIG91dFs3XSA9IDA7XHJcbiAgICBvdXRbOF0gPSAwO1xyXG4gICAgb3V0WzldID0gMDtcclxuICAgIG91dFsxMF0gPSAxO1xyXG4gICAgb3V0WzExXSA9IDA7XHJcbiAgICBvdXRbMTJdID0gMDtcclxuICAgIG91dFsxM10gPSAwO1xyXG4gICAgb3V0WzE0XSA9IDA7XHJcbiAgICBvdXRbMTVdID0gMTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xyXG5tYXQ0LnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xyXG4gICAgaWYgKG91dCA9PT0gYSkge1xyXG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxyXG4gICAgICAgICAgICBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxyXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcclxuXHJcbiAgICAgICAgb3V0WzFdID0gYVs0XTtcclxuICAgICAgICBvdXRbMl0gPSBhWzhdO1xyXG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xyXG4gICAgICAgIG91dFs0XSA9IGEwMTtcclxuICAgICAgICBvdXRbNl0gPSBhWzldO1xyXG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xyXG4gICAgICAgIG91dFs4XSA9IGEwMjtcclxuICAgICAgICBvdXRbOV0gPSBhMTI7XHJcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xyXG4gICAgICAgIG91dFsxMl0gPSBhMDM7XHJcbiAgICAgICAgb3V0WzEzXSA9IGExMztcclxuICAgICAgICBvdXRbMTRdID0gYTIzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBvdXRbMF0gPSBhWzBdO1xyXG4gICAgICAgIG91dFsxXSA9IGFbNF07XHJcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcclxuICAgICAgICBvdXRbM10gPSBhWzEyXTtcclxuICAgICAgICBvdXRbNF0gPSBhWzFdO1xyXG4gICAgICAgIG91dFs1XSA9IGFbNV07XHJcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcclxuICAgICAgICBvdXRbN10gPSBhWzEzXTtcclxuICAgICAgICBvdXRbOF0gPSBhWzJdO1xyXG4gICAgICAgIG91dFs5XSA9IGFbNl07XHJcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xyXG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcclxuICAgICAgICBvdXRbMTJdID0gYVszXTtcclxuICAgICAgICBvdXRbMTNdID0gYVs3XTtcclxuICAgICAgICBvdXRbMTRdID0gYVsxMV07XHJcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xyXG5tYXQ0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXHJcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcclxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXHJcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXHJcblxyXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcclxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXHJcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxyXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcclxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXHJcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxyXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcclxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXHJcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxyXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcclxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXHJcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XHJcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xyXG5cclxuICAgIGlmICghZGV0KSB7IFxyXG4gICAgICAgIHJldHVybiBudWxsOyBcclxuICAgIH1cclxuICAgIGRldCA9IDEuMCAvIGRldDtcclxuXHJcbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcclxuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xyXG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XHJcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcclxuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xyXG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XHJcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcclxuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xyXG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XHJcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcclxuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcclxuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcclxuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcclxuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcclxuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcclxuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcclxuXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cclxubWF0NC5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XHJcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcclxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxyXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcclxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcclxuXHJcbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xyXG4gICAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcclxuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XHJcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xyXG4gICAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcclxuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XHJcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xyXG4gICAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcclxuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XHJcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xyXG4gICAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcclxuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XHJcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xyXG4gICAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcclxuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XHJcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXHJcbm1hdDQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXHJcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcclxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXHJcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXHJcblxyXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcclxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXHJcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxyXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcclxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXHJcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxyXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcclxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXHJcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxyXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcclxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXHJcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcclxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XHJcbn07XHJcblxyXG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXHJcbm1hdDQubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XHJcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcclxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxyXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcclxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcclxuXHJcbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcclxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXHJcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XHJcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XHJcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XHJcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XHJcblxyXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xyXG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xyXG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xyXG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xyXG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xyXG5cclxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xyXG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xyXG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xyXG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcclxuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XHJcblxyXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcclxuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XHJcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xyXG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcclxuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5tYXQ0Lm11bCA9IG1hdDQubXVsdGlwbHk7XHJcblxyXG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xyXG5tYXQ0LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcclxuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxyXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcclxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXHJcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xyXG5cclxuICAgIGlmIChhID09PSBvdXQpIHtcclxuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XHJcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xyXG4gICAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XHJcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcclxuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xyXG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcclxuXHJcbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xyXG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcclxuICAgICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcclxuXHJcbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xyXG4gICAgICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcclxuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XHJcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICoqL1xyXG5tYXQ0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XHJcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcclxuXHJcbiAgICBvdXRbMF0gPSBhWzBdICogeDtcclxuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xyXG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XHJcbiAgICBvdXRbM10gPSBhWzNdICogeDtcclxuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xyXG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XHJcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcclxuICAgIG91dFs3XSA9IGFbN10gKiB5O1xyXG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XHJcbiAgICBvdXRbOV0gPSBhWzldICogejtcclxuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XHJcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xyXG4gICAgb3V0WzEyXSA9IGFbMTJdO1xyXG4gICAgb3V0WzEzXSA9IGFbMTNdO1xyXG4gICAgb3V0WzE0XSA9IGFbMTRdO1xyXG4gICAgb3V0WzE1XSA9IGFbMTVdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGVcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXHJcbm1hdDQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkLCBheGlzKSB7XHJcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcclxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcclxuICAgICAgICBzLCBjLCB0LFxyXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcclxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXHJcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxyXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXHJcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcclxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xyXG5cclxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgR0xNQVRfRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxyXG4gICAgXHJcbiAgICBsZW4gPSAxIC8gbGVuO1xyXG4gICAgeCAqPSBsZW47XHJcbiAgICB5ICo9IGxlbjtcclxuICAgIHogKj0gbGVuO1xyXG5cclxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xyXG4gICAgYyA9IE1hdGguY29zKHJhZCk7XHJcbiAgICB0ID0gMSAtIGM7XHJcblxyXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcclxuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XHJcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XHJcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XHJcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XHJcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XHJcblxyXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cclxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcclxuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcclxuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcclxuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcclxuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcclxuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcclxuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcclxuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcclxuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcclxuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcclxuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XHJcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xyXG5cclxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcclxuICAgICAgICBvdXRbMTJdID0gYVsxMl07XHJcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xyXG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcclxuICAgICAgICBvdXRbMTVdID0gYVsxNV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xyXG5tYXQ0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcclxuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcclxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcclxuICAgICAgICBhMTAgPSBhWzRdLFxyXG4gICAgICAgIGExMSA9IGFbNV0sXHJcbiAgICAgICAgYTEyID0gYVs2XSxcclxuICAgICAgICBhMTMgPSBhWzddLFxyXG4gICAgICAgIGEyMCA9IGFbOF0sXHJcbiAgICAgICAgYTIxID0gYVs5XSxcclxuICAgICAgICBhMjIgPSBhWzEwXSxcclxuICAgICAgICBhMjMgPSBhWzExXTtcclxuXHJcbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcclxuICAgICAgICBvdXRbMF0gID0gYVswXTtcclxuICAgICAgICBvdXRbMV0gID0gYVsxXTtcclxuICAgICAgICBvdXRbMl0gID0gYVsyXTtcclxuICAgICAgICBvdXRbM10gID0gYVszXTtcclxuICAgICAgICBvdXRbMTJdID0gYVsxMl07XHJcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xyXG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcclxuICAgICAgICBvdXRbMTVdID0gYVsxNV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxyXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XHJcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcclxuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xyXG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XHJcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcclxuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xyXG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xyXG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cclxubWF0NC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XHJcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXHJcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXHJcbiAgICAgICAgYTAwID0gYVswXSxcclxuICAgICAgICBhMDEgPSBhWzFdLFxyXG4gICAgICAgIGEwMiA9IGFbMl0sXHJcbiAgICAgICAgYTAzID0gYVszXSxcclxuICAgICAgICBhMjAgPSBhWzhdLFxyXG4gICAgICAgIGEyMSA9IGFbOV0sXHJcbiAgICAgICAgYTIyID0gYVsxMF0sXHJcbiAgICAgICAgYTIzID0gYVsxMV07XHJcblxyXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXHJcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XHJcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XHJcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XHJcbiAgICAgICAgb3V0WzddICA9IGFbN107XHJcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xyXG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcclxuICAgICAgICBvdXRbMTRdID0gYVsxNF07XHJcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cclxuICAgIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xyXG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XHJcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcclxuICAgIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xyXG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XHJcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcclxuICAgIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcclxuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXHJcbm1hdDQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xyXG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxyXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxyXG4gICAgICAgIGEwMCA9IGFbMF0sXHJcbiAgICAgICAgYTAxID0gYVsxXSxcclxuICAgICAgICBhMDIgPSBhWzJdLFxyXG4gICAgICAgIGEwMyA9IGFbM10sXHJcbiAgICAgICAgYTEwID0gYVs0XSxcclxuICAgICAgICBhMTEgPSBhWzVdLFxyXG4gICAgICAgIGExMiA9IGFbNl0sXHJcbiAgICAgICAgYTEzID0gYVs3XTtcclxuXHJcbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XHJcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XHJcbiAgICAgICAgb3V0WzldICA9IGFbOV07XHJcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xyXG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcclxuICAgICAgICBvdXRbMTJdID0gYVsxMl07XHJcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xyXG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcclxuICAgICAgICBvdXRbMTVdID0gYVsxNV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxyXG4gICAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XHJcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcclxuICAgIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xyXG4gICAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XHJcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcclxuICAgIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xyXG4gICAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XHJcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XHJcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXHJcbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAob3V0LCBxLCB2KSB7XHJcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcclxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcclxuICAgICAgICB4MiA9IHggKyB4LFxyXG4gICAgICAgIHkyID0geSArIHksXHJcbiAgICAgICAgejIgPSB6ICsgeixcclxuXHJcbiAgICAgICAgeHggPSB4ICogeDIsXHJcbiAgICAgICAgeHkgPSB4ICogeTIsXHJcbiAgICAgICAgeHogPSB4ICogejIsXHJcbiAgICAgICAgeXkgPSB5ICogeTIsXHJcbiAgICAgICAgeXogPSB5ICogejIsXHJcbiAgICAgICAgenogPSB6ICogejIsXHJcbiAgICAgICAgd3ggPSB3ICogeDIsXHJcbiAgICAgICAgd3kgPSB3ICogeTIsXHJcbiAgICAgICAgd3ogPSB3ICogejI7XHJcblxyXG4gICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcclxuICAgIG91dFsxXSA9IHh5ICsgd3o7XHJcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xyXG4gICAgb3V0WzNdID0gMDtcclxuICAgIG91dFs0XSA9IHh5IC0gd3o7XHJcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xyXG4gICAgb3V0WzZdID0geXogKyB3eDtcclxuICAgIG91dFs3XSA9IDA7XHJcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xyXG4gICAgb3V0WzldID0geXogLSB3eDtcclxuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xyXG4gICAgb3V0WzExXSA9IDA7XHJcbiAgICBvdXRbMTJdID0gdlswXTtcclxuICAgIG91dFsxM10gPSB2WzFdO1xyXG4gICAgb3V0WzE0XSA9IHZbMl07XHJcbiAgICBvdXRbMTVdID0gMTtcclxuICAgIFxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbm1hdDQuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XHJcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXHJcbiAgICAgICAgeDIgPSB4ICsgeCxcclxuICAgICAgICB5MiA9IHkgKyB5LFxyXG4gICAgICAgIHoyID0geiArIHosXHJcblxyXG4gICAgICAgIHh4ID0geCAqIHgyLFxyXG4gICAgICAgIHl4ID0geSAqIHgyLFxyXG4gICAgICAgIHl5ID0geSAqIHkyLFxyXG4gICAgICAgIHp4ID0geiAqIHgyLFxyXG4gICAgICAgIHp5ID0geiAqIHkyLFxyXG4gICAgICAgIHp6ID0geiAqIHoyLFxyXG4gICAgICAgIHd4ID0gdyAqIHgyLFxyXG4gICAgICAgIHd5ID0gdyAqIHkyLFxyXG4gICAgICAgIHd6ID0gdyAqIHoyO1xyXG5cclxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xyXG4gICAgb3V0WzFdID0geXggKyB3ejtcclxuICAgIG91dFsyXSA9IHp4IC0gd3k7XHJcbiAgICBvdXRbM10gPSAwO1xyXG5cclxuICAgIG91dFs0XSA9IHl4IC0gd3o7XHJcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcclxuICAgIG91dFs2XSA9IHp5ICsgd3g7XHJcbiAgICBvdXRbN10gPSAwO1xyXG5cclxuICAgIG91dFs4XSA9IHp4ICsgd3k7XHJcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xyXG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xyXG4gICAgb3V0WzExXSA9IDA7XHJcblxyXG4gICAgb3V0WzEyXSA9IDA7XHJcbiAgICBvdXRbMTNdID0gMDtcclxuICAgIG91dFsxNF0gPSAwO1xyXG4gICAgb3V0WzE1XSA9IDE7XHJcblxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXHJcbm1hdDQuZnJ1c3R1bSA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXHJcbiAgICAgICAgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSksXHJcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xyXG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xyXG4gICAgb3V0WzFdID0gMDtcclxuICAgIG91dFsyXSA9IDA7XHJcbiAgICBvdXRbM10gPSAwO1xyXG4gICAgb3V0WzRdID0gMDtcclxuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcclxuICAgIG91dFs2XSA9IDA7XHJcbiAgICBvdXRbN10gPSAwO1xyXG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcclxuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XHJcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XHJcbiAgICBvdXRbMTFdID0gLTE7XHJcbiAgICBvdXRbMTJdID0gMDtcclxuICAgIG91dFsxM10gPSAwO1xyXG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcclxuICAgIG91dFsxNV0gPSAwO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcclxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xyXG5tYXQ0LnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcclxuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxyXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcclxuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XHJcbiAgICBvdXRbMV0gPSAwO1xyXG4gICAgb3V0WzJdID0gMDtcclxuICAgIG91dFszXSA9IDA7XHJcbiAgICBvdXRbNF0gPSAwO1xyXG4gICAgb3V0WzVdID0gZjtcclxuICAgIG91dFs2XSA9IDA7XHJcbiAgICBvdXRbN10gPSAwO1xyXG4gICAgb3V0WzhdID0gMDtcclxuICAgIG91dFs5XSA9IDA7XHJcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XHJcbiAgICBvdXRbMTFdID0gLTE7XHJcbiAgICBvdXRbMTJdID0gMDtcclxuICAgIG91dFsxM10gPSAwO1xyXG4gICAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcclxuICAgIG91dFsxNV0gPSAwO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cclxubWF0NC5vcnRobyA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XHJcbiAgICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXHJcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXHJcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xyXG4gICAgb3V0WzBdID0gLTIgKiBscjtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMDtcclxuICAgIG91dFs0XSA9IDA7XHJcbiAgICBvdXRbNV0gPSAtMiAqIGJ0O1xyXG4gICAgb3V0WzZdID0gMDtcclxuICAgIG91dFs3XSA9IDA7XHJcbiAgICBvdXRbOF0gPSAwO1xyXG4gICAgb3V0WzldID0gMDtcclxuICAgIG91dFsxMF0gPSAyICogbmY7XHJcbiAgICBvdXRbMTFdID0gMDtcclxuICAgIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xyXG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XHJcbiAgICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XHJcbiAgICBvdXRbMTVdID0gMTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxyXG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cclxubWF0NC5sb29rQXQgPSBmdW5jdGlvbiAob3V0LCBleWUsIGNlbnRlciwgdXApIHtcclxuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXHJcbiAgICAgICAgZXlleCA9IGV5ZVswXSxcclxuICAgICAgICBleWV5ID0gZXllWzFdLFxyXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXHJcbiAgICAgICAgdXB4ID0gdXBbMF0sXHJcbiAgICAgICAgdXB5ID0gdXBbMV0sXHJcbiAgICAgICAgdXB6ID0gdXBbMl0sXHJcbiAgICAgICAgY2VudGVyeCA9IGNlbnRlclswXSxcclxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxyXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XHJcblxyXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IEdMTUFUX0VQU0lMT04gJiZcclxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBHTE1BVF9FUFNJTE9OICYmXHJcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgR0xNQVRfRVBTSUxPTikge1xyXG4gICAgICAgIHJldHVybiBtYXQ0LmlkZW50aXR5KG91dCk7XHJcbiAgICB9XHJcblxyXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcclxuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XHJcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xyXG5cclxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcclxuICAgIHowICo9IGxlbjtcclxuICAgIHoxICo9IGxlbjtcclxuICAgIHoyICo9IGxlbjtcclxuXHJcbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XHJcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XHJcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XHJcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcclxuICAgIGlmICghbGVuKSB7XHJcbiAgICAgICAgeDAgPSAwO1xyXG4gICAgICAgIHgxID0gMDtcclxuICAgICAgICB4MiA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxlbiA9IDEgLyBsZW47XHJcbiAgICAgICAgeDAgKj0gbGVuO1xyXG4gICAgICAgIHgxICo9IGxlbjtcclxuICAgICAgICB4MiAqPSBsZW47XHJcbiAgICB9XHJcblxyXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcclxuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XHJcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xyXG5cclxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xyXG4gICAgaWYgKCFsZW4pIHtcclxuICAgICAgICB5MCA9IDA7XHJcbiAgICAgICAgeTEgPSAwO1xyXG4gICAgICAgIHkyID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcclxuICAgICAgICB5MCAqPSBsZW47XHJcbiAgICAgICAgeTEgKj0gbGVuO1xyXG4gICAgICAgIHkyICo9IGxlbjtcclxuICAgIH1cclxuXHJcbiAgICBvdXRbMF0gPSB4MDtcclxuICAgIG91dFsxXSA9IHkwO1xyXG4gICAgb3V0WzJdID0gejA7XHJcbiAgICBvdXRbM10gPSAwO1xyXG4gICAgb3V0WzRdID0geDE7XHJcbiAgICBvdXRbNV0gPSB5MTtcclxuICAgIG91dFs2XSA9IHoxO1xyXG4gICAgb3V0WzddID0gMDtcclxuICAgIG91dFs4XSA9IHgyO1xyXG4gICAgb3V0WzldID0geTI7XHJcbiAgICBvdXRbMTBdID0gejI7XHJcbiAgICBvdXRbMTFdID0gMDtcclxuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XHJcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xyXG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcclxuICAgIG91dFsxNV0gPSAxO1xyXG5cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cclxubWF0NC5zdHIgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgKyBcclxuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXHJcbm1hdDQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcclxufTtcclxuXHJcblxyXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBleHBvcnRzLm1hdDQgPSBtYXQ0O1xyXG59XHJcbjtcclxuLyogQ29weXJpZ2h0IChjKSAyMDEzLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcblxyXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXHJcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXHJcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuXHJcblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxyXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxyXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxyXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcclxuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xyXG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cclxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcclxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXHJcblxyXG4vKipcclxuICogQGNsYXNzIFF1YXRlcm5pb25cclxuICogQG5hbWUgcXVhdFxyXG4gKi9cclxuXHJcbnZhciBxdWF0ID0ge307XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXHJcbiAqL1xyXG5xdWF0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG91dCA9IG5ldyBHTE1BVF9BUlJBWV9UWVBFKDQpO1xyXG4gICAgb3V0WzBdID0gMDtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxyXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cclxuICpcclxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cclxucXVhdC5yb3RhdGlvblRvID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xyXG4gICAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XHJcbiAgICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XHJcbiAgICAgICAgdmFyIGRvdCA9IHZlYzMuZG90KGEsIGIpO1xyXG4gICAgICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcclxuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xyXG4gICAgICAgICAgICBpZiAodmVjMy5sZW5ndGgodG1wdmVjMykgPCAwLjAwMDAwMSlcclxuICAgICAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeVVuaXRWZWMzLCBhKTtcclxuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XHJcbiAgICAgICAgICAgIHF1YXQuc2V0QXhpc0FuZ2xlKG91dCwgdG1wdmVjMywgTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xyXG4gICAgICAgICAgICBvdXRbMF0gPSAwO1xyXG4gICAgICAgICAgICBvdXRbMV0gPSAwO1xyXG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xyXG4gICAgICAgICAgICBvdXRbM10gPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XHJcbiAgICAgICAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XHJcbiAgICAgICAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XHJcbiAgICAgICAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XHJcbiAgICAgICAgICAgIG91dFszXSA9IDEgKyBkb3Q7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxyXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcclxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXHJcbiAqIEBwYXJhbSB7dmVjM30gcmlnaHQgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2FsIFwicmlnaHRcIiBkaXJlY3Rpb25cclxuICogQHBhcmFtIHt2ZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xyXG5xdWF0LnNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XHJcbiAgICAgICAgbWF0clswXSA9IHJpZ2h0WzBdO1xyXG4gICAgICAgIG1hdHJbM10gPSByaWdodFsxXTtcclxuICAgICAgICBtYXRyWzZdID0gcmlnaHRbMl07XHJcblxyXG4gICAgICAgIG1hdHJbMV0gPSB1cFswXTtcclxuICAgICAgICBtYXRyWzRdID0gdXBbMV07XHJcbiAgICAgICAgbWF0cls3XSA9IHVwWzJdO1xyXG5cclxuICAgICAgICBtYXRyWzJdID0gLXZpZXdbMF07XHJcbiAgICAgICAgbWF0cls1XSA9IC12aWV3WzFdO1xyXG4gICAgICAgIG1hdHJbOF0gPSAtdmlld1syXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgcXVhdC5mcm9tTWF0MyhvdXQsIG1hdHIpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnF1YXQuY2xvbmUgPSB2ZWM0LmNsb25lO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5xdWF0LmZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XHJcblxyXG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxucXVhdC5jb3B5ID0gdmVjNC5jb3B5O1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnF1YXQuc2V0ID0gdmVjNC5zZXQ7XHJcblxyXG4vKipcclxuICogU2V0IGEgcXVhdCB0byB0aGUgaWRlbnRpdHkgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cclxucXVhdC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xyXG4gICAgb3V0WzBdID0gMDtcclxuICAgIG91dFsxXSA9IDA7XHJcbiAgICBvdXRbMl0gPSAwO1xyXG4gICAgb3V0WzNdID0gMTtcclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXHJcbiAqIHRoZW4gcmV0dXJucyBpdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiovXHJcbnF1YXQuc2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0LCBheGlzLCByYWQpIHtcclxuICAgIHJhZCA9IHJhZCAqIDAuNTtcclxuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcclxuICAgIG91dFswXSA9IHMgKiBheGlzWzBdO1xyXG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XHJcbiAgICBvdXRbMl0gPSBzICogYXhpc1syXTtcclxuICAgIG91dFszXSA9IE1hdGguY29zKHJhZCk7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnF1YXQuYWRkID0gdmVjNC5hZGQ7XHJcblxyXG4vKipcclxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xyXG5xdWF0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XHJcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxyXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcclxuXHJcbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xyXG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcclxuICAgIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XHJcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxucXVhdC5tdWwgPSBxdWF0Lm11bHRpcGx5O1xyXG5cclxuLyoqXHJcbiAqIFNjYWxlcyBhIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5xdWF0LnNjYWxlID0gdmVjNC5zY2FsZTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cclxucXVhdC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XHJcbiAgICByYWQgKj0gMC41OyBcclxuXHJcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxyXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xyXG5cclxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xyXG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XHJcbiAgICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcclxuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cclxucXVhdC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XHJcbiAgICByYWQgKj0gMC41OyBcclxuXHJcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxyXG4gICAgICAgIGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xyXG5cclxuICAgIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xyXG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XHJcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcclxuICAgIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cclxucXVhdC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XHJcbiAgICByYWQgKj0gMC41OyBcclxuXHJcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxyXG4gICAgICAgIGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xyXG5cclxuICAgIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xyXG4gICAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XHJcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcclxuICAgIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cclxuICogQXNzdW1lcyB0aGF0IHF1YXRlcm5pb24gaXMgMSB1bml0IGluIGxlbmd0aC5cclxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xyXG5xdWF0LmNhbGN1bGF0ZVcgPSBmdW5jdGlvbiAob3V0LCBhKSB7XHJcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcclxuXHJcbiAgICBvdXRbMF0gPSB4O1xyXG4gICAgb3V0WzFdID0geTtcclxuICAgIG91dFsyXSA9IHo7XHJcbiAgICBvdXRbM10gPSAtTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5xdWF0LmRvdCA9IHZlYzQuZG90O1xyXG5cclxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5xdWF0LmxlcnAgPSB2ZWM0LmxlcnA7XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xyXG5xdWF0LnNsZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xyXG4gICAgLy8gYmVuY2htYXJrczpcclxuICAgIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXHJcblxyXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcclxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XHJcblxyXG4gICAgdmFyICAgICAgICBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcclxuXHJcbiAgICAvLyBjYWxjIGNvc2luZVxyXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xyXG4gICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXHJcbiAgICBpZiAoIGNvc29tIDwgMC4wICkge1xyXG4gICAgICAgIGNvc29tID0gLWNvc29tO1xyXG4gICAgICAgIGJ4ID0gLSBieDtcclxuICAgICAgICBieSA9IC0gYnk7XHJcbiAgICAgICAgYnogPSAtIGJ6O1xyXG4gICAgICAgIGJ3ID0gLSBidztcclxuICAgIH1cclxuICAgIC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcclxuICAgIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xyXG4gICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxyXG4gICAgICAgIG9tZWdhICA9IE1hdGguYWNvcyhjb3NvbSk7XHJcbiAgICAgICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xyXG4gICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xyXG4gICAgICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcclxuICAgIH0gZWxzZSB7ICAgICAgICBcclxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlIFxyXG4gICAgICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cclxuICAgICAgICBzY2FsZTAgPSAxLjAgLSB0O1xyXG4gICAgICAgIHNjYWxlMSA9IHQ7XHJcbiAgICB9XHJcbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXHJcbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xyXG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcclxuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XHJcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xyXG4gICAgXHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xyXG5xdWF0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xyXG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcclxuICAgICAgICBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMyxcclxuICAgICAgICBpbnZEb3QgPSBkb3QgPyAxLjAvZG90IDogMDtcclxuICAgIFxyXG4gICAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcclxuXHJcbiAgICBvdXRbMF0gPSAtYTAqaW52RG90O1xyXG4gICAgb3V0WzFdID0gLWExKmludkRvdDtcclxuICAgIG91dFsyXSA9IC1hMippbnZEb3Q7XHJcbiAgICBvdXRbM10gPSBhMyppbnZEb3Q7XHJcbiAgICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcclxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cclxucXVhdC5jb25qdWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XHJcbiAgICBvdXRbMF0gPSAtYVswXTtcclxuICAgIG91dFsxXSA9IC1hWzFdO1xyXG4gICAgb3V0WzJdID0gLWFbMl07XHJcbiAgICBvdXRbM10gPSBhWzNdO1xyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnF1YXQubGVuZ3RoID0gdmVjNC5sZW5ndGg7XHJcblxyXG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5xdWF0LmxlbiA9IHF1YXQubGVuZ3RoO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxucXVhdC5zcXVhcmVkTGVuZ3RoID0gdmVjNC5zcXVhcmVkTGVuZ3RoO1xyXG5cclxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXHJcbnF1YXQuc3FyTGVuID0gcXVhdC5zcXVhcmVkTGVuZ3RoO1xyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cclxucXVhdC5ub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxyXG4gKlxyXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxyXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xyXG5xdWF0LmZyb21NYXQzID0gZnVuY3Rpb24ob3V0LCBtKSB7XHJcbiAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3Rlc1xyXG4gICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXHJcbiAgICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xyXG4gICAgdmFyIGZSb290O1xyXG5cclxuICAgIGlmICggZlRyYWNlID4gMC4wICkge1xyXG4gICAgICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcclxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcclxuICAgICAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcclxuICAgICAgICBmUm9vdCA9IDAuNS9mUm9vdDsgIC8vIDEvKDR3KVxyXG4gICAgICAgIG91dFswXSA9IChtWzddLW1bNV0pKmZSb290O1xyXG4gICAgICAgIG91dFsxXSA9IChtWzJdLW1bNl0pKmZSb290O1xyXG4gICAgICAgIG91dFsyXSA9IChtWzNdLW1bMV0pKmZSb290O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyB8d3wgPD0gMS8yXHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIGlmICggbVs0XSA+IG1bMF0gKVxyXG4gICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgaWYgKCBtWzhdID4gbVtpKjMraV0gKVxyXG4gICAgICAgICAgaSA9IDI7XHJcbiAgICAgICAgdmFyIGogPSAoaSsxKSUzO1xyXG4gICAgICAgIHZhciBrID0gKGkrMiklMztcclxuICAgICAgICBcclxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChtW2kqMytpXS1tW2oqMytqXS1tW2sqMytrXSArIDEuMCk7XHJcbiAgICAgICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XHJcbiAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcclxuICAgICAgICBvdXRbM10gPSAobVtrKjMral0gLSBtW2oqMytrXSkgKiBmUm9vdDtcclxuICAgICAgICBvdXRbal0gPSAobVtqKjMraV0gKyBtW2kqMytqXSkgKiBmUm9vdDtcclxuICAgICAgICBvdXRba10gPSAobVtrKjMraV0gKyBtW2kqMytrXSkgKiBmUm9vdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcclxuICovXHJcbnF1YXQuc3RyID0gZnVuY3Rpb24gKGEpIHtcclxuICAgIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcclxufTtcclxuXHJcbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGV4cG9ydHMucXVhdCA9IHF1YXQ7XHJcbn1cclxuO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICB9KShzaGltLmV4cG9ydHMpO1xyXG59KSh0aGlzKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIC8vIERlcGVuZGVuY2llc1xyXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2NvbW1vbi5qc1wiKTtcclxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xyXG5cclxuICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgdmFyIFN5bnRheCA9IGNvbW1vbi5TeW50YXg7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVGbG9hdCh2YWx1ZSkge1xyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW50ZXJuYWw6IEV4cHJlc3Npb24gZ2VuZXJhdGVkIE5hTiFcIik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnICsgdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5pbmRleE9mKFwiLlwiKSA9PSAtMSAmJiByZXN1bHQuaW5kZXhPZihcImVcIikgPT0gLTEpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiLjBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29udHJvbGxlclxyXG4gICAgICogQHBhcmFtIHtvYmplY3Q/fSBvcHRpb25zXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIEV4cHJlc3Npb25IYW5kbGVyID0gZnVuY3Rpb24gKGNvbnRyb2xsZXIsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlci5nZW5lcmF0ZUZsb2F0ID0gdGhpcy5jb250cm9sbGVyLmdlbmVyYXRlRmxvYXQgfHwgZ2VuZXJhdGVGbG9hdDtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgfTtcclxuXHJcbiAgICBFeHByZXNzaW9uSGFuZGxlci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgYmluYXJ5OiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5leHByZXNzaW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcclxuICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkJpbmFyeUV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFwiKCBcIiArIHJlc3VsdCArIFwiIClcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXJndW1lbnRzOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIihcIjtcclxuICAgICAgICAgICAgY29udGFpbmVyLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmV4cHJlc3Npb24oYXJnKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGNvbnRhaW5lci5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiLCBcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyBcIilcIjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpdGVyYWw6IGZ1bmN0aW9uIChleHRyYSwgYWx0ZXJuYXRpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGV4dHJhID0gZXh0cmEgfHwge30sXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4dHJhLnN0YXRpY1ZhbHVlICE9PSB1bmRlZmluZWQgPyBleHRyYS5zdGF0aWNWYWx1ZSA6IGFsdGVybmF0aXZlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV4dHJhLnR5cGUgPT0gU2hhZGUuVFlQRVMuTlVNQkVSKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlci5nZW5lcmF0ZUZsb2F0KHZhbHVlKTsgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm4gXCJcIjtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG5cclxuICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXHJcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5OZXdFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29udHJvbGxlci50eXBlKG5vZGUuZXh0cmEsIHsgY29uc3RydWN0b3I6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJndW1lbnRzKG5vZGUuYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5MaXRlcmFsOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubGl0ZXJhbChub2RlLmV4dHJhLCBub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkJpbmFyeUV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5iaW5hcnkobm9kZS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyBub2RlLm9wZXJhdG9yICsgXCIgXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYmluYXJ5KG5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVW5hcnlFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUub3BlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYmluYXJ5KG5vZGUuYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZXhwcmVzc2lvbihub2RlLmNhbGxlZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJndW1lbnRzKG5vZGUuYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYmluYXJ5KG5vZGUub2JqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gbm9kZS5jb21wdXRlZCA/IFwiW1wiIDogXCIuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwcmVzc2lvbihub2RlLnByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbXB1dGVkICYmIChyZXN1bHQgKz0gXCJdXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmV4cHJlc3Npb24obm9kZS50ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgPyBcIjtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHByZXNzaW9uKG5vZGUuY29uc2VxdWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIDogXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwcmVzc2lvbihub2RlLmFsdGVybmF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVXBkYXRlRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlzUHJlZml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBub2RlLm9wZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHByZXNzaW9uKG5vZGUuYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1ByZWZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gbm9kZS5vcGVyYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50OlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIjx1bmhhbmRsZWQ6IFwiICsgbm9kZS50eXBlICsgXCI+XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhdGVtZW50OiBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJ1bmhhbmRsZWQgc3RhdGVtZW50XCI7XHJcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0FyZ3VtZW50cyA9IG5vZGUuYXJndW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJyZXR1cm5cIiArIChoYXNBcmd1bWVudHMgPyAoXCIgXCIgKyB0aGlzLmV4cHJlc3Npb24obm9kZS5hcmd1bWVudCkpIDogXCJcIikgKyBcIjtcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gRXhwb3J0c1xyXG4gICAgbnMuRXhwcmVzc2lvbkhhbmRsZXIgPSBFeHByZXNzaW9uSGFuZGxlcjtcclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBCYXNlID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvaW5kZXguanNcIiksXHJcbiAgICAgICAgY29kZWdlbiA9IHJlcXVpcmUoXCJlc2NvZGVnZW5cIik7XHJcblxyXG4gICAgdmFyIFNpbXBsaWZpZXIgPSByZXF1aXJlKFwiLi4vc2ltcGxlLXN0YXRlbWVudC9zaW1wbGUtc3RhdGVtZW50LmpzXCIpO1xyXG4gICAgdmFyIFRyYW5zZm9ybWVyID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtLmpzXCIpLkdMTWF0cml4VHJhbnNmb3JtZXI7XHJcblxyXG5cclxuICAgIHZhciBHTE1hdHJpeENvbXBpbGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgQmFzZS5leHRlbmQoR0xNYXRyaXhDb21waWxlci5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKGFhc3QsIG9wdCkge1xyXG4gICAgICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcblxyXG4gICAgICAgICAgICBhYXN0ID0gU2ltcGxpZmllci5zaW1wbGlmeVN0YXRlbWVudHMoYWFzdCwgb3B0KTtcclxuXHJcbiAgICAgICAgICAgIGFhc3QgPSBuZXcgVHJhbnNmb3JtZXIoKS50cmFuc2Zvcm0oYWFzdCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29kZSA9IGNvZGVnZW4uZ2VuZXJhdGUoYWFzdCwgb3B0KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgbnMuR0xNYXRyaXhDb21waWxlciA9IEdMTWF0cml4Q29tcGlsZXI7XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBCYXNlID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvaW5kZXguanNcIiksXHJcbiAgICAgICAgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxyXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBUeXBlcyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEtpbmRzID0gU2hhZGUuT0JKRUNUX0tJTkRTLFxyXG4gICAgICAgIGFuYWx5c2VzID0gcmVxdWlyZSgnYW5hbHlzZXMnKSxcclxuICAgICAgICBUb29scyA9IHJlcXVpcmUoJy4uL3Rvb2xzLmpzJyksXHJcbiAgICAgICAgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XHJcblxyXG5cclxuICAgIHZhciB3YWxrID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpO1xyXG4gICAgdmFyIFN5bnRheCA9IHdhbGsuU3ludGF4O1xyXG4gICAgdmFyIEFOTk8gPSBjb21tb24uQU5OTztcclxuICAgIHZhciBNYXAgPSBjb21tb24uTWFwO1xyXG4gICAgdmFyIFNldCA9IGFuYWx5c2VzLlNldDtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBKUyBBU1QgdG8gYW4gQVNUIHJlcHJlc2VudGF0aW9uIGNvbnZlbmllbnRcclxuICAgICAqIGZvciBjb2RlIGdlbmVyYXRpb25cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICB2YXIgR0xNYXRyaXhUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIEJhc2UuZXh0ZW5kKEdMTWF0cml4VHJhbnNmb3JtZXIucHJvdG90eXBlLCB7XHJcblxyXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKGFhc3QpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoYWFzdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0IX0gYXN0XHJcbiAgICAgICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVwbGFjZTogZnVuY3Rpb24oYWFzdCkge1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyB3YWxrLkNvbnRyb2xsZXIoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLnJlcGxhY2UoYWFzdCwge1xyXG5cclxuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24obm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKG5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVWYXJpYWJsZURlY2xhcmF0b3Iobm9kZSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQ2FsbEV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVDYWxsRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWF2ZUFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlYXZlRnVuY3Rpb24obm9kZSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGxlYXZlRnVuY3Rpb24obm9kZSwgcGFyZW50KXtcclxuICAgICAgICB2YXIgZGVjbGFyYXRvcnMgPSBbXTtcclxuICAgICAgICBhZGRNYXRoTGlua0RlY2xhcmF0aW9uKGRlY2xhcmF0b3JzLCBcInZlYzJcIik7XHJcbiAgICAgICAgYWRkTWF0aExpbmtEZWNsYXJhdGlvbihkZWNsYXJhdG9ycywgXCJ2ZWMzXCIpO1xyXG4gICAgICAgIGFkZE1hdGhMaW5rRGVjbGFyYXRpb24oZGVjbGFyYXRvcnMsIFwidmVjNFwiKTtcclxuICAgICAgICBhZGRNYXRoTGlua0RlY2xhcmF0aW9uKGRlY2xhcmF0b3JzLCBcIm1hdDNcIik7XHJcbiAgICAgICAgYWRkTWF0aExpbmtEZWNsYXJhdGlvbihkZWNsYXJhdG9ycywgXCJtYXQ0XCIpO1xyXG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24sIGtpbmQ6IFwidmFyXCIsXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRvcnNcclxuICAgICAgICB9O1xyXG4gICAgICAgIG5vZGUuYm9keS5ib2R5LnVuc2hpZnQoZGVjbGFyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZE1hdGhMaW5rRGVjbGFyYXRpb24oZGVzdCwgbmFtZSl7XHJcbiAgICAgICAgZGVzdC5wdXNoKHsgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcixcclxuICAgICAgICAgICAgaWQ6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogbmFtZX0sXHJcbiAgICAgICAgICAgIGluaXQ6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLCBjb21wdXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHsgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sIGNvbXB1dGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcIlNoYWRlXCJ9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJNYXRoXCJ9fSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IG5hbWV9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsZWF2ZVZhcmlhYmxlRGVjbGFyYXRvcihub2RlLCBwYXJlbnQpe1xyXG4gICAgICAgIHZhciBub2RlQW5ubyA9IEFOTk8obm9kZSk7XHJcblxyXG4gICAgICAgIHZhciBnbE9iamVjdCA9IGdldEdsTWF0cml4T2JqZWN0KG5vZGVBbm5vLmdldEtpbmQoKSk7XHJcbiAgICAgICAgaWYoZ2xPYmplY3Qpe1xyXG4gICAgICAgICAgICBub2RlLmluaXQgPSBnZXRDYWxsRXhwcmVzc2lvbihnbE9iamVjdCwgXCJjcmVhdGVcIiwgW10pO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbGVhdmVDYWxsRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpe1xyXG4gICAgICAgIGlmKG5vZGUuY2FsbGVlLnR5cGUgIT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgbm9kZUFubm8gPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgIHZhciBvYmplY3RBbm5vID0gQU5OTyhub2RlLmNhbGxlZS5vYmplY3QpO1xyXG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZTtcclxuXHJcbiAgICAgICAgdmFyIGdsT2JqZWN0ID0gZ2V0R2xNYXRyaXhPYmplY3Qob2JqZWN0QW5uby5nZXRLaW5kKCkpO1xyXG4gICAgICAgIGlmKG5vZGVBbm5vLmdldFR5cGUoKSAhPSBUeXBlcy5PQkpFQ1QgJiYgZ2xPYmplY3Qpe1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50SW5kZXggPSBnZXRDb21wb25lbnRJbmRleChtZXRob2ROYW1lKTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICAgICAgaWYoY29tcG9uZW50SW5kZXggIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBnZXRBcnJheUFjY2Vzc0FzdChub2RlLmNhbGxlZS5vYmplY3QsIGNvbXBvbmVudEluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgdmFyIGdsTWV0aG9kTmFtZSA9IGdldFNjYWxhckdsTWV0aG9kTmFtZShnbE9iamVjdCwgbWV0aG9kTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJndW1lbnRzID0gW25vZGUuY2FsbGVlLm9iamVjdF07XHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHMucHVzaC5hcHBseShhcmd1bWVudHMsIG5vZGUuYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdldENhbGxFeHByZXNzaW9uKGdsT2JqZWN0LCBnbE1ldGhvZE5hbWUsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQU5OTyhyZXN1bHQpLmNvcHkoQU5OTyhub2RlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50SW5kZXgobWV0aG9kTmFtZSl7XHJcbiAgICAgICAgc3dpdGNoKG1ldGhvZE5hbWUpe1xyXG4gICAgICAgICAgICBjYXNlIFwieFwiOiByZXR1cm4gMDtcclxuICAgICAgICAgICAgY2FzZSBcInlcIjogcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ6XCI6IHJldHVybiAyO1xyXG4gICAgICAgICAgICBjYXNlIFwid1wiOiByZXR1cm4gMztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsZWF2ZUFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIHBhcmVudCl7XHJcbiAgICAgICAgdmFyIGRlc3RBbm5vID0gQU5OTyhub2RlKTtcclxuICAgICAgICBpZihkZXN0QW5uby5nZXRUeXBlKCkgIT0gVHlwZXMuT0JKRUNUKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmKG5vZGUucmlnaHQudHlwZSA9PSBTeW50YXguTmV3RXhwcmVzc2lvbil7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWF2ZUFzc2lnbm1lbnROZXcobm9kZSwgcGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihub2RlLnJpZ2h0LnR5cGUgPT0gU3ludGF4LkNhbGxFeHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAmJiBub2RlLnJpZ2h0LmNhbGxlZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmXHJcbiAgICAgICAgICAgICAgICBnZXRHbE1hdHJpeE9iamVjdChBTk5PKG5vZGUucmlnaHQuY2FsbGVlLm9iamVjdCkuZ2V0S2luZCgpKSl7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWF2ZUFzc2lnbm1lbnRDYWxsKG5vZGUsIHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWF2ZUFzc2lnbm1lbnRDb3B5KG5vZGUsIHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsZWF2ZUFzc2lnbm1lbnROZXcobm9kZSwgcGFyZW50KXtcclxuICAgICAgICB2YXIgZGVzdEFubm8gPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgIHZhciBnbE9iamVjdCA9IGdldEdsTWF0cml4T2JqZWN0KGRlc3RBbm5vLmdldEtpbmQoKSk7XHJcblxyXG4gICAgICAgIHZhciBhcmd1bWVudHMgPSBbbm9kZS5sZWZ0XTtcclxuXHJcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gbm9kZS5yaWdodC5hcmd1bWVudHM7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVBcmdzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgcHVzaEFyZ0NvbXBvbmVudHMoYXJndW1lbnRzLCBub2RlQXJnc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSl7XHJcbiAgICAgICAgICAgIGFyZ3VtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5MaXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgICAgICByYXc6IFwiMFwiXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXhwZWN0ZWRBcmdMZW5ndGggPSAxICsgZ2V0Q29tcG9uZW50cyhkZXN0QW5ubyk7XHJcblxyXG5cclxuICAgICAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoIDwgZXhwZWN0ZWRBcmdMZW5ndGgpe1xyXG4gICAgICAgICAgICBhcmd1bWVudHMucHVzaChCYXNlLmRlZXBFeHRlbmQoe30sYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBnZXRDYWxsRXhwcmVzc2lvbihnbE9iamVjdCwgXCJzZXRcIiwgYXJndW1lbnRzKTtcclxuICAgICAgICBBTk5PKHJlc3VsdCkuY29weShBTk5PKG5vZGUpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxlYXZlQXNzaWdubWVudENhbGwobm9kZSwgcGFyZW50KXtcclxuICAgICAgICB2YXIgb2JqZWN0QW5ubyA9IEFOTk8obm9kZS5yaWdodC5jYWxsZWUub2JqZWN0KTtcclxuICAgICAgICB2YXIgZ2xPYmplY3QgPSBnZXRHbE1hdHJpeE9iamVjdChvYmplY3RBbm5vLmdldEtpbmQoKSk7XHJcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBub2RlLnJpZ2h0LmNhbGxlZS5wcm9wZXJ0eS5uYW1lO1xyXG5cclxuICAgICAgICByZXR1cm4gZ2V0T2JqZWN0R2xNZXRob2RDYWxsKG9iamVjdEFubm8uZ2V0S2luZCgpLCBtZXRob2ROYW1lLCBub2RlLmxlZnQsIG5vZGUucmlnaHQuY2FsbGVlLm9iamVjdCwgbm9kZS5yaWdodC5hcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxlYXZlQXNzaWdubWVudENvcHkobm9kZSwgcGFyZW50KXtcclxuICAgICAgICB2YXIgZGVzdEFubm8gPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgIHZhciBnbE9iamVjdCA9IGdldEdsTWF0cml4T2JqZWN0KGRlc3RBbm5vLmdldEtpbmQoKSk7XHJcbiAgICAgICAgdmFyIGFyZ3VtZW50cyA9IFtdO1xyXG5cclxuICAgICAgICBpZihpc0FycmF5QWNjZXNzKG5vZGUubGVmdCkpe1xyXG4gICAgICAgICAgICBhcmd1bWVudHMucHVzaChub2RlLmxlZnQub2JqZWN0KTtcclxuICAgICAgICAgICAgYXJndW1lbnRzLnB1c2gobm9kZS5sZWZ0LnByb3BlcnR5KTtcclxuICAgICAgICAgICAgYXJndW1lbnRzLnB1c2gobm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRDYWxsRXhwcmVzc2lvbihnbE9iamVjdCwgXCJwYXN0ZUFycmF5XCIsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGFyZ3VtZW50cy5wdXNoKG5vZGUubGVmdCk7XHJcbiAgICAgICAgICAgIGlmKGlzQXJyYXlBY2Nlc3Mobm9kZS5yaWdodCkpe1xyXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzLnB1c2gobm9kZS5yaWdodC5vYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzLnB1c2gobm9kZS5yaWdodC5wcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2FsbEV4cHJlc3Npb24oZ2xPYmplY3QsIFwiY29weUFycmF5XCIsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5wdXNoKG5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENhbGxFeHByZXNzaW9uKGdsT2JqZWN0LCBcImNvcHlcIiwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGlzQXJyYXlBY2Nlc3Mobm9kZSl7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiAmJiBBTk5PKG5vZGUub2JqZWN0KS5pc0FycmF5KCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHB1c2hBcmdDb21wb25lbnRzKGRlc3QsIGFyZyl7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBnZXRDb21wb25lbnRzKEFOTk8oYXJnKSk7XHJcbiAgICAgICAgaWYoY29tcG9uZW50cyA9PSAxKXtcclxuICAgICAgICAgICAgZGVzdC5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHM7ICsraSl7XHJcbiAgICAgICAgICAgIGRlc3QucHVzaChnZXRBcnJheUFjY2Vzc0FzdChhcmcsIGkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRzKGFubm8pe1xyXG4gICAgICAgIHZhciB0eXBlID0gYW5uby5nZXRUeXBlKCksIGtpbmQgPSBhbm5vLmdldEtpbmQoKTtcclxuICAgICAgICBpZih0eXBlID09IFR5cGVzLk5VTUJFUiB8fCB0eXBlID09IFR5cGVzLklOVClcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgc3dpdGNoKGtpbmQpe1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUMjogcmV0dXJuIDI7XHJcbiAgICAgICAgICAgIGNhc2UgS2luZHMuRkxPQVQzOiByZXR1cm4gMztcclxuICAgICAgICAgICAgY2FzZSBLaW5kcy5GTE9BVDQ6IHJldHVybiA0O1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLk1BVFJJWDM6IHJldHVybiA5O1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLk1BVFJJWDQ6IHJldHVybiAxNjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0R2xNYXRyaXhPYmplY3Qoa2luZCl7XHJcbiAgICAgICAgc3dpdGNoKGtpbmQpe1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUMjogcmV0dXJuIFwidmVjMlwiO1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUMzogcmV0dXJuIFwidmVjM1wiO1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUNDogcmV0dXJuIFwidmVjNFwiO1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLk1BVFJJWDM6IHJldHVybiBcIm1hdDNcIjtcclxuICAgICAgICAgICAgY2FzZSBLaW5kcy5NQVRSSVg0OiByZXR1cm4gXCJtYXQ0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE1lbWJlckV4cHJlc3Npb24ob2JqZWN0TmFtZSwgcHJvcGVydHlOYW1lICl7XHJcbiAgICAgICAgcmV0dXJuIHt0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiwgb2JqZWN0OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IG9iamVjdE5hbWV9LFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IHByb3BlcnR5TmFtZX1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENhbGxFeHByZXNzaW9uKG9iamVjdE5hbWUsIHByb3BlcnR5TmFtZSwgYXJndW1lbnRzICl7XHJcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICBjYWxsZWU6IGdldE1lbWJlckV4cHJlc3Npb24ob2JqZWN0TmFtZSwgcHJvcGVydHlOYW1lKSxcclxuICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEFycmF5QWNjZXNzQXN0KG9iamVjdCwgaW5kZXgpe1xyXG4gICAgICAgIHJldHVybiB7dHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sIG9iamVjdDogb2JqZWN0LCBjb21wdXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgIHByb3BlcnR5OiB7dHlwZTogU3ludGF4LkxpdGVyYWwsIHZhbHVlOiBpbmRleCwgcmF3OiBpbmRleH19O1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0U2NhbGFyR2xNZXRob2ROYW1lKGdsT2JqZWN0LCBtZXRob2ROYW1lKXtcclxuICAgICAgICBzd2l0Y2gobWV0aG9kTmFtZSl7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkb3RcIjogcmV0dXJuIFwiZG90XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJsZW5ndGhcIiA6IHJldHVybiBcImxlbmd0aFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdsTWF0cml4IG1ldGhvZCB3aXRoIHNjYWxhciBvdXRwdXQ6ICdcIiArIG1ldGhvZE5hbWUgKyBcIidcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0T2JqZWN0R2xNZXRob2RDYWxsKG9iamVjdEtpbmQsIG1ldGhvZE5hbWUsIGRlc3RPYmosIHNyY09iaiwgYXJndW1lbnRzKXtcclxuICAgICAgICB2YXIgYWN0dWFsS2luZCA9IG9iamVjdEtpbmQsIG1ldGhvZCwgc3JjQWZ0ZXJBcmdzID0gZmFsc2U7XHJcbiAgICAgICAgc3dpdGNoKG1ldGhvZE5hbWUpe1xyXG4gICAgICAgICAgICBjYXNlIFwiYWRkXCI6IG1ldGhvZCA9IFwiYWRkXCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic3ViXCI6IG1ldGhvZCA9IFwic3ViXCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibXVsXCI6IG1ldGhvZCA9IFwibXVsXCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGl2XCI6IG1ldGhvZCA9IFwiZGl2XCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWF4XCI6IG1ldGhvZCA9IFwibWF4XCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibWluXCIgOiBtZXRob2QgPSBcIm1pblwiOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImxlbmd0aFwiOiBtZXRob2QgPSBcInNldExlbmd0aFwiOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIm5vcm1hbGl6ZVwiIDogbWV0aG9kID0gXCJub3JtYWxpemVcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtdWxWZWNcIiA6IHN3aXRjaChvYmplY3RLaW5kKXtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEtpbmRzLk1BVFJJWDM6IGFjdHVhbEtpbmQ9IEtpbmRzLkZMT0FUMzsgbWV0aG9kID0gXCJ0cmFuc2Zvcm1NYXQzXCI7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2luZHMuTUFUUklYNDogYWN0dWFsS2luZD0gS2luZHMuRkxPQVQ0OyBtZXRob2QgPSBcInRyYW5zZm9ybU1hdDRcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzcmNBZnRlckFyZ3MgPSB0cnVlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZ2xNYXRyaXggbWV0aG9kIHdpdGggb2JqZWN0IG91dHB1dDogJ1wiICsgbWV0aG9kTmFtZSArIFwiJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbZGVzdE9ial07XHJcbiAgICAgICAgaWYoIXNyY0FmdGVyQXJncykgYXJncy5wdXNoKHNyY09iaik7XHJcbiAgICAgICAgYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgaWYoc3JjQWZ0ZXJBcmdzKSBhcmdzLnB1c2goc3JjT2JqKTtcclxuICAgICAgICB2YXIgZ2xPYmplY3QgPSBnZXRHbE1hdHJpeE9iamVjdChhY3R1YWxLaW5kKTtcclxuICAgICAgICByZXR1cm4gZ2V0Q2FsbEV4cHJlc3Npb24oZ2xPYmplY3QsIG1ldGhvZCwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhwb3J0c1xyXG4gICAgbnMuR0xNYXRyaXhUcmFuc2Zvcm1lciA9IEdMTWF0cml4VHJhbnNmb3JtZXI7XHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpO1xyXG5cclxuICAgIHZhciBUcmFuc2Zvcm1lciA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybS5qc1wiKS5HTEFTVFRyYW5zZm9ybWVyO1xyXG4gICAgdmFyIGdlbmVyYXRlID0gcmVxdWlyZShcIi4vZ2xzbC1nZW5lcmF0ZS5qc1wiKS5nZW5lcmF0ZTtcclxuXHJcbiAgICB2YXIgR0xTTENvbXBpbGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgQmFzZS5leHRlbmQoR0xTTENvbXBpbGVyLnByb3RvdHlwZSwge1xyXG5cclxuICAgICAgICBjb21waWxlRnJhZ21lbnRTaGFkZXI6IGZ1bmN0aW9uIChhYXN0LCBvcHQpIHtcclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gbmV3IFRyYW5zZm9ybWVyKGFhc3QsIFwiZ2xvYmFsLnNoYWRlXCIsIGZhbHNlLCBvcHQpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShhYXN0LCAwLCBcIiBcIikpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtZXIudHJhbnNmb3JtKGFhc3QpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShhYXN0LCAwLCBcIiBcIikpO1xyXG5cclxuICAgICAgICAgICAgb3B0LmhlYWRlcnMgPSB0cmFuc2Zvcm1lZC5oZWFkZXJzO1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IGdlbmVyYXRlKHRyYW5zZm9ybWVkLnByb2dyYW0sIGZhbHNlLCBvcHQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtzb3VyY2U6IGNvZGUsIHVuaWZvcm1TZXR0ZXI6IHRyYW5zZm9ybWVkLnVuaWZvcm1TZXR0ZXJ9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGlsZVZlcnRleFNoYWRlcjogZnVuY3Rpb24gKGFhc3QsIG9wdCkge1xyXG4gICAgICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcblxyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtZXIoYWFzdCwgXCJnbG9iYWwubWFpblwiLCB0cnVlLCBvcHQpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShhYXN0LCAwLCBcIiBcIikpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdHJhbnNmb3JtZXIudHJhbnNmb3JtKGFhc3QpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShhYXN0LCAwLCBcIiBcIikpO1xyXG5cclxuICAgICAgICAgICAgb3B0LmhlYWRlcnMgPSB0cmFuc2Zvcm1lZC5oZWFkZXJzO1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IGdlbmVyYXRlKHRyYW5zZm9ybWVkLnByb2dyYW0sIHRydWUsIG9wdCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge3NvdXJjZTogY29kZSwgdW5pZm9ybVNldHRlcjogdHJhbnNmb3JtZWQudW5pZm9ybVNldHRlcn07XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBucy5HTFNMQ29tcGlsZXIgPSBHTFNMQ29tcGlsZXI7XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIC8vIERlcGVuZGVuY2llc1xyXG4gICAgdmFyIEZ1bmN0aW9uQW5ub3RhdGlvbiA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jhc2UvYW5ub3RhdGlvbi5qc1wiKS5GdW5jdGlvbkFubm90YXRpb247XHJcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xyXG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XHJcbiAgICB2YXIgRXhwcmVzc2lvbkhhbmRsZXIgPSByZXF1aXJlKCcuLi9iYXNlL2V4cHJlc3Npb24taGFuZGxlci5qcycpLkV4cHJlc3Npb25IYW5kbGVyLFxyXG4gICAgICAgIFN5bnRheCA9IHdhbGsuU3ludGF4LFxyXG4gICAgICAgIFZpc2l0b3JPcHRpb24gPSB3YWxrLlZpc2l0b3JPcHRpb24sXHJcbiAgICAgICAgQU5OTyA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTztcclxuXHJcblxyXG4gICAgLy8gU2hvcnRjdXRzXHJcbiAgICB2YXIgVHlwZXMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLaW5kcyA9IFNoYWRlLk9CSkVDVF9LSU5EUyxcclxuICAgICAgICBTb3VyY2VzID0gU2hhZGUuU09VUkNFUztcclxuXHJcbiAgICB2YXIgSW50ZXJuYWxGdW5jdGlvbnMgPSB7XHJcbiAgICAgICAgXCJNYXRDb2xcIiA6IGZ1bmN0aW9uKG5hbWUsIGRldGFpbHMpe1xyXG4gICAgICAgICAgICB2YXIgbWF0VHlwZSA9IGRldGFpbHMubWF0VHlwZSxcclxuICAgICAgICAgICAgICAgIGNvbFR5cGUgPSBkZXRhaWxzLmNvbFR5cGU7XHJcbiAgICAgICAgICAgIHJldHVybiBbbWF0VHlwZSArIFwiIFwiICsgbmFtZSArIFwiKFwiICsgbWF0VHlwZSArIFwiIG1hdCwgaW50IGlkeCwgXCIgKyBjb2xUeXBlICsgXCIgdmFsdWUpe1wiLFxyXG4gICAgICAgICAgICAgICAgICBcIiAgXCIgKyBtYXRUeXBlICsgXCIgcmVzdWx0ID0gXCIgKyBtYXRUeXBlICsgXCIobWF0KTtcIixcclxuICAgICAgICAgICAgICAgICAgXCIgIHJlc3VsdFtpZHhdID0gdmFsdWU7XCIsXHJcbiAgICAgICAgICAgICAgICAgIFwiICByZXR1cm4gcmVzdWx0O1wiLFxyXG4gICAgICAgICAgICAgICAgICBcIn1cIl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBHTFNMID0ge1xyXG4gICAgICAgIFN0b3JhZ2U6IHtcclxuICAgICAgICAgICAgQ09OU1Q6IFwiY29uc3RcIixcclxuICAgICAgICAgICAgVU5JRk9STTogXCJ1bmlmb3JtXCIsXHJcbiAgICAgICAgICAgIFZBUllJTkc6IFwidmFyeWluZ1wiLFxyXG4gICAgICAgICAgICBBVFRSSUJVVEU6IFwiYXR0cmlidXRlXCJcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhhbmRsZXIgPSBuZXcgRXhwcmVzc2lvbkhhbmRsZXIoIHtcclxuICAgICAgICB0eXBlOiB0b0dMU0xUeXBlXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0XHJcbiAgICAgKi9cclxuICAgIHZhciBnZXRIZWFkZXIgPSBmdW5jdGlvbiAob3B0KSB7XHJcbiAgICAgICAgaWYgKG9wdC5vbWl0SGVhZGVyID09IHRydWUpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB2YXIgaGVhZGVyID0gW1xyXG4gICAgICAgICAgICBcIi8vIEdlbmVyYXRlZCBieSBzaGFkZS5qc1wiXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAob3B0LmhlYWRlcnMpXHJcbiAgICAgICAgICAgIGhlYWRlciA9IGhlYWRlci5jb25jYXQob3B0LmhlYWRlcnMpXHJcbiAgICAgICAgdmFyIGZsb2F0UHJlY2lzaW9uID0gb3B0LmZsb2F0UHJlY2lzaW9uIHx8IFwiaGlnaHBcIjtcclxuICAgICAgICBoZWFkZXIucHVzaChcInByZWNpc2lvbiBcIiArIGZsb2F0UHJlY2lzaW9uICsgXCIgZmxvYXQ7XCIpO1xyXG4gICAgICAgIGhlYWRlci5wdXNoKFwiXCIpO1xyXG4gICAgICAgIHJldHVybiBoZWFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9HTFNMVHlwZShpbmZvLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYoIWluZm8pIHJldHVybiBcIj9cIjtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUeXBlcy5PQkpFQ1Q6XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGluZm8ua2luZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2luZHMuRkxPQVQ0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2ZWM0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLaW5kcy5GTE9BVDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZlYzNcIjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmVjMlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2luZHMuVEVYVFVSRTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic2FtcGxlcjJEXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLaW5kcy5NQVRSSVgzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtYXQzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLaW5kcy5NQVRSSVg0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtYXQ0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLaW5kcy5DT0xPUl9DTE9TVVJFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2ZWM0XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPHVuZGVmaW5lZD5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBUeXBlcy5BUlJBWTpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0b0dMU0xUeXBlKGluZm8uZWxlbWVudHMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBUeXBlcy5VTkRFRklORUQ6XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1VuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2b2lkXCI7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIHR5cGVcIik7XHJcbiAgICAgICAgICAgIGNhc2UgVHlwZXMuTlVNQkVSOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZmxvYXRcIjtcclxuICAgICAgICAgICAgY2FzZSBUeXBlcy5CT09MRUFOOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYm9vbFwiO1xyXG4gICAgICAgICAgICBjYXNlIFR5cGVzLklOVDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImludFwiO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoXCJ0b0dMU0xUeXBlOiBVbmhhbmRsZWQgdHlwZTogXCIgKyBpbmZvLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZm8udHlwZTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0b0dMU0xTdG9yYWdlID0gZnVuY3Rpb24oaW5mbywgdmVydGV4U2hhZGVyKSB7XHJcbiAgICAgICAgaWYgKCFpbmZvLnNvdXJjZSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgaWYgKGluZm8uc291cmNlID09IFNvdXJjZXMuVkVSVEVYKXtcclxuICAgICAgICAgICAgaWYodmVydGV4U2hhZGVyICYmICFpbmZvLm91dHB1dClcclxuICAgICAgICAgICAgICAgIHJldHVybiBHTFNMLlN0b3JhZ2UuQVRUUklCVVRFO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gR0xTTC5TdG9yYWdlLlZBUllJTkc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICBpZiAoaW5mby5zb3VyY2UgPT0gU291cmNlcy5VTklGT1JNKVxyXG4gICAgICAgICAgICByZXR1cm4gR0xTTC5TdG9yYWdlLlVOSUZPUk07XHJcbiAgICAgICAgaWYgKGluZm8uc291cmNlID09IFNvdXJjZXMuQ09OU1RBTlQpXHJcbiAgICAgICAgICAgIHJldHVybiBHTFNMLlN0b3JhZ2UuQ09OU1Q7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9HTFNMU291cmNlOiBVbmhhbmRsZWQgdHlwZTogXCIgKyBpbmZvLnNvdXJjZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmlsdGVyVW5kZWZpbmVkKGFycikge1xyXG4gICAgICAgIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4uZXh0cmEudHlwZSAhPSBUeXBlcy5VTkRFRklORUQ7IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxpbmVTdGFjaygpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgYXJyLnB1c2guYXBwbHkoYXJyLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHZhciBpbmRlbnQgPSBcIlwiO1xyXG4gICAgICAgIGFyci5hcHBlbmRMaW5lID0gZnVuY3Rpb24obGluZSl7XHJcbiAgICAgICAgICAgIGxpbmUgPyB0aGlzLnB1c2goaW5kZW50ICsgbGluZSkgOiB0aGlzLnB1c2goXCJcIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBhcnIuY2hhbmdlSW5kZW50aW9uID0gZnVuY3Rpb24oYWRkKXtcclxuICAgICAgICAgICAgd2hpbGUoYWRkID4gMCl7XHJcbiAgICAgICAgICAgICAgICBpbmRlbnQgKz0gXCIgICAgXCI7IGFkZC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGFkZCA8IDApe1xyXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50LnN1YnN0cigwLCBpbmRlbnQubGVuZ3RoICsgYWRkKjQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBhcnIuYXBwZW5kID0gZnVuY3Rpb24oc3RyKXtcclxuICAgICAgICAgICAgdGhpc1t0aGlzLmxlbmd0aC0xXSA9IHRoaXNbdGhpcy5sZW5ndGgtMV0gKyBzdHI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypCYXNlLmV4dGVuZChMaW5lU3RhY2sucHJvdG90eXBlLCB7XHJcblxyXG4gICAgfSk7Ki9cclxuXHJcbiAgICB2YXIgZ2VuZXJhdGUgPSBmdW5jdGlvbiAoYXN0LCB2ZXJ0ZXhzaGFkZXIsIG9wdCkge1xyXG5cclxuICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcblxyXG4gICAgICAgIHZhciBsaW5lcyA9IGNyZWF0ZUxpbmVTdGFjaygpO1xyXG5cclxuICAgICAgICB0cmF2ZXJzZShhc3QsIGxpbmVzLCB2ZXJ0ZXhzaGFkZXIsIG9wdCk7XHJcblxyXG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGVuZEludGVybmFsRnVuY3Rpb25zKGxpbmVzLCBpbnRlcm5hbEZ1bmN0aW9ucyl7XHJcbiAgICAgICAgaWYoIWludGVybmFsRnVuY3Rpb25zKSByZXR1cm47XHJcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gaW50ZXJuYWxGdW5jdGlvbnMpe1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBpbnRlcm5hbEZ1bmN0aW9uc1trZXldO1xyXG4gICAgICAgICAgICBpZihJbnRlcm5hbEZ1bmN0aW9uc1tlbnRyeS50eXBlXSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZXNUb0FkZCA9IEludGVybmFsRnVuY3Rpb25zW2VudHJ5LnR5cGVdKGVudHJ5Lm5hbWUsIGVudHJ5LmRldGFpbHMpO1xyXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgbGluZXNUb0FkZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW50ZXJuYWw6IElubGluZUZ1bmN0aW9uIG9mIHR5cGUgJ1wiICsgZW50cnkudHlwZSArIFwiJyBub3QgYXZhaWxhYmxlIVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmF2ZXJzZShhc3QsIGxpbmVzLCB2ZXJ0ZXhTaGFkZXIsIG9wdCkge1xyXG4gICAgICAgIHZhciBpbnNpZGVNYWluID0gZmFsc2U7XHJcblxyXG5cclxuICAgICAgICB3YWxrLnRyYXZlcnNlKGFzdCwge1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlByb2dyYW06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0SGVhZGVyKG9wdCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kSW50ZXJuYWxGdW5jdGlvbnMobGluZXMsIEFOTk8oYXN0KS5nZXRVc2VyRGF0YSgpLmludGVybmFsRnVuY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3J3YXJkRGVjbGFyYXRpb25zKGxpbmVzLCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHQubmV3TGluZXMgJiYgbGluZXMuYXBwZW5kTGluZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vZGUuaWQubmFtZSA9PSBcIm1haW5cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlTWFpbiA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZExpbmUoZ2VuZXJhdGVGdW5jdGlvblNpZ25hdHVyZShub2RlKSArIFwiIHtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuY2hhbmdlSW5kZW50aW9uKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguUmV0dXJuU3RhdGVtZW50OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZExpbmUoaGFuZGxlci5zdGF0ZW1lbnQobm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiTWVlcCFcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2wgPSBoYW5kbGVWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIGluc2lkZU1haW4sIHZlcnRleFNoYWRlciwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKGRlY2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kTGluZShoYW5kbGVyLmV4cHJlc3Npb24obm9kZSkgKyBcIjtcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwOztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5JZlN0YXRlbWVudDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKFwiaWYoXCIgKyBoYW5kbGVyLmV4cHJlc3Npb24obm9kZS50ZXN0LCBvcHQpICsgXCIpIHtcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShub2RlLmNvbnNlcXVlbnQsIGxpbmVzLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigtMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmFsdGVybmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKFwifSBlbHNlIHtcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2Uobm9kZS5hbHRlcm5hdGUsIGxpbmVzLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5jaGFuZ2VJbmRlbnRpb24oLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKFwifVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZvclN0YXRlbWVudDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKFwiZm9yIChcIiArIGhhbmRsZUlubGluZURlY2xhcmF0aW9uKG5vZGUuaW5pdCwgb3B0KSArIFwiOyBcIiArIGhhbmRsZXIuZXhwcmVzc2lvbihub2RlLnRlc3QsIG9wdCkgK1wiOyBcIiArIGhhbmRsZXIuZXhwcmVzc2lvbihub2RlLnVwZGF0ZSwgb3B0KSArIFwiKSB7XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShub2RlLmJvZHksIGxpbmVzLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kTGluZShcIn1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uU2tpcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Db250aW51ZVN0YXRlbWVudDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKFwiY29udGludWU7XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkJyZWFrU3RhdGVtZW50OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZExpbmUoXCJicmVhaztcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlVuaGFuZGxlZDogXCIgKyB0eXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7Ly9jb25zb2xlLmVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1NoYWRlLnRocm93RXJyb3Iobm9kZSwgZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlByb2dyYW06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmNoYW5nZUluZGVudGlvbigtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKFwifVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkRm9yd2FyZERlY2xhcmF0aW9ucyhsaW5lcywgbm9kZSkge1xyXG4gICAgICAgIHZhciBmaXJzdCA9IHRydWU7XHJcbiAgICAgICAgd2Fsay50cmF2ZXJzZShub2RlLCB7XHJcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLnR5cGUgPT0gU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihub2RlLmlkLm5hbWUgPT0gXCJtYWluXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kTGluZShcIi8vIEZvcndhcmQgZGVjbGFyYXRpb25zXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmRMaW5lKGdlbmVyYXRlRnVuY3Rpb25TaWduYXR1cmUobm9kZSkrXCI7XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYoIWZpcnN0KSB7XHJcbiAgICAgICAgICAgIGxpbmVzLmFwcGVuZExpbmUoXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlRnVuY3Rpb25TaWduYXR1cmUobm9kZSkge1xyXG4gICAgICAgIHZhciBmdW5jID0gbmV3IEZ1bmN0aW9uQW5ub3RhdGlvbihub2RlKTtcclxuICAgICAgICB2YXIgbWV0aG9kU3RhcnQgPSBbdG9HTFNMVHlwZShmdW5jLmdldFJldHVybkluZm8oKSwgeyBhbGxvd1VuZGVmaW5lZDogdHJ1ZSB9KV07XHJcbiAgICAgICAgbWV0aG9kU3RhcnQucHVzaChub2RlLmlkLm5hbWUsICcoJyk7XHJcbiAgICAgICAgaWYgKCEobm9kZS5wYXJhbXMgJiYgbm9kZS5wYXJhbXMubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICBtZXRob2RTdGFydC5wdXNoKFwidm9pZFwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kQXJncyA9IFtdO1xyXG4gICAgICAgICAgICBub2RlLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kQXJncy5wdXNoKHRvR0xTTFR5cGUocGFyYW0uZXh0cmEpICsgXCIgXCIgKyBwYXJhbS5uYW1lKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgbWV0aG9kU3RhcnQucHVzaChtZXRob2RBcmdzLmpvaW4oXCIsIFwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1ldGhvZFN0YXJ0LnB1c2goXCIpXCIpO1xyXG4gICAgICAgIHJldHVybiBtZXRob2RTdGFydC5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTdGF0aWNWYWx1ZShleHRyYSkge1xyXG4gICAgICAgIGlmICghZXh0cmEgfHwgZXh0cmEuc3RhdGljVmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIGV4dHJhLnN0YXRpY1ZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIHdyaXRlU3RvcmFnZVF1YWxpZmllciwgdmVydGV4U2hhZGVyLCBvcHQpIHtcclxuICAgICAgICB2YXIgc3RvcmFnZVF1YWxpZmllciA9ICF3cml0ZVN0b3JhZ2VRdWFsaWZpZXIgPyB0b0dMU0xTdG9yYWdlKG5vZGUuZXh0cmEsIHZlcnRleFNoYWRlcikgOiBudWxsO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBzdG9yYWdlUXVhbGlmaWVyID8gc3RvcmFnZVF1YWxpZmllciArIFwiIFwiIDogXCJcIjtcclxuICAgICAgICByZXN1bHQgKz0gdG9HTFNMVHlwZShub2RlLmV4dHJhKSArIFwiIFwiICsgbm9kZS5pZC5uYW1lO1xyXG4gICAgICAgIGlmIChub2RlLmV4dHJhLmVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIltcIiArIChub2RlLmV4dHJhLnN0YXRpY1NpemUgPyBub2RlLmV4dHJhLnN0YXRpY1NpemUgOiBcIjBcIikgKyBcIl1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuaW5pdCkgcmVzdWx0ICs9IFwiID0gXCIgKyBoYW5kbGVyLmV4cHJlc3Npb24obm9kZS5pbml0KTtcclxuICAgICAgICBpZiAoIW5vZGUuaW5pdCAmJiBzdG9yYWdlUXVhbGlmaWVyID09IEdMU0wuU3RvcmFnZS5DT05TVCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIgPSBcIiArIGdldFN0YXRpY1ZhbHVlKG5vZGUuZXh0cmEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgXCI7XCI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUlubGluZURlY2xhcmF0aW9uKG5vZGUsIG9wdCkge1xyXG4gICAgICAgIGlmKCFub2RlKVxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICBpZiAobm9kZS50eXBlID09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBub2RlLmRlY2xhcmF0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKGRlY2xTdHJpbmcsIGRlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjbCA9IHRvR0xTTFR5cGUoZGVjbGFyYXRpb24uZXh0cmEpICsgXCIgXCIgKyBkZWNsYXJhdGlvbi5pZC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uLmluaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWNsICs9IFwiID0gXCIgKyBoYW5kbGVyLmV4cHJlc3Npb24oZGVjbGFyYXRpb24uaW5pdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjbFN0cmluZyArIGRlY2w7XHJcbiAgICAgICAgICAgIH0sIFwiXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR0xTTCBhbGxvd3Mgb25seSBkZWNsYXJhdGlvbiBpbiBpbml0LCBidXQgc2luY2UgdGhpcyBpcyBhIG5ldyBzY29wZSwgaXQgc2hvdWxkIGJlIGZpbmVcclxuICAgICAgICBpZiAobm9kZS50eXBlID09IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9HTFNMVHlwZShub2RlLmV4dHJhKSArIFwiIFwiICsgaGFuZGxlci5leHByZXNzaW9uKG5vZGUubGVmdCkgKyBcIiA9IFwiICsgaGFuZGxlci5leHByZXNzaW9uKG5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiSW50ZXJuYWwgZXJyb3IgaW4gR0xTTDo6aGFuZGxlSW5saW5lRGVjbGFyYXRpb24sIGZvdW5kIFwiICsgbm9kZS50eXBlKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xyXG5cclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24obnMpIHtcclxuXHJcbiAgICB2YXIgU2NvcGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9zY29wZS5qc1wiKSxcclxuICAgICAgICBDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvY29udGV4dC5qc1wiKSxcclxuICAgICAgICBCYXNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvaW5kZXguanNcIiksXHJcbiAgICAgICAgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBUeXBlSW5mbyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL3R5cGVpbmZvLmpzXCIpLlR5cGVJbmZvLFxyXG4gICAgICAgIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2NvbW1vbi5qc1wiKTtcclxuXHJcblxyXG4gICAgdmFyIFR5cGVzID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS2luZHMgPSBTaGFkZS5PQkpFQ1RfS0lORFM7XHJcblxyXG4gICAgdmFyIG9iamVjdHMgPSB7XHJcbiAgICAgICAgU2hhZGUgOiByZXF1aXJlKFwiLi9zaGFkZS5qc1wiKSxcclxuICAgICAgICBTcGFjZSA6IHJlcXVpcmUoXCIuL3NwYWNlLmpzXCIpLFxyXG4gICAgICAgIE1hdGggOiByZXF1aXJlKFwiLi9tYXRoLmpzXCIpLFxyXG4gICAgICAgIFN5c3RlbSA6IHJlcXVpcmUoXCIuL3N5c3RlbS5qc1wiKSxcclxuICAgICAgICBWZWMyIDogcmVxdWlyZShcIi4vdmVjMi5qc1wiKSxcclxuICAgICAgICBWZWMzIDogcmVxdWlyZShcIi4vdmVjMy5qc1wiKSxcclxuICAgICAgICBDb2xvcjogcmVxdWlyZShcIi4vdmVjMy5qc1wiKSxcclxuICAgICAgICBWZWM0IDogcmVxdWlyZShcIi4vdmVjNC5qc1wiKSxcclxuICAgICAgICBNYXQzIDogcmVxdWlyZShcIi4vbWF0My5qc1wiKSxcclxuICAgICAgICBNYXQ0IDogcmVxdWlyZShcIi4vbWF0NC5qc1wiKSxcclxuICAgICAgICBUZXh0dXJlIDogcmVxdWlyZShcIi4vdGV4dHVyZS5qc1wiKVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgUmVnaXN0cnkgPSB7XHJcbiAgICAgICAgbmFtZTogXCJHTFNMVHJhbnNmb3JtUmVnaXN0cnlcIixcclxuICAgICAgICBnZXRCeU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdHNbbmFtZV07XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldEluc3RhbmNlRm9yS2luZDogZnVuY3Rpb24oa2luZCkge1xyXG4gICAgICAgICAgICBmb3IodmFyIG9iaiBpbiBvYmplY3RzKSB7XHJcbiAgICAgICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBKU1VuZmlsdGVyZWRGb3JJbkxvb3BcclxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RzW29ial0ua2luZCA9PSBraW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbmZpbHRlcmVkRm9ySW5Mb29wXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdHNbb2JqXS5pbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSByb290XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlcclxuICAgICAqIEBwYXJhbSBvcHRcclxuICAgICAqIEBleHRlbmRzIHtDb250ZXh0fVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBHTFRyYW5zZm9ybUNvbnRleHQgPSBmdW5jdGlvbihyb290LCBlbnRyeSwgdmVydGV4U2hhZGVyLCBvcHQpIHtcclxuICAgICAgICBvcHQubWFpbkZ1bmN0aW9uID0gZW50cnk7XHJcbiAgICAgICAgQ29udGV4dC5jYWxsKHRoaXMsIHJvb3QsIG9wdCk7XHJcbiAgICAgICAgdGhpcy51c2VkUGFyYW1ldGVycyA9IHtcclxuICAgICAgICAgICAgc2hhZGVyOiB7fSxcclxuICAgICAgICAgICAgc3lzdGVtOiB7fSxcclxuICAgICAgICAgICAgdWV4cDoge31cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLnVuaWZvcm1FeHByZXNzaW9ucyA9IG9wdC51bmlmb3JtRXhwcmVzc2lvbnMgfHwge307XHJcblxyXG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtUGFyYW1ldGVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuYmxvY2tlZE5hbWVzID0gW107XHJcbiAgICAgICAgdGhpcy50b3BEZWNsYXJhdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmludGVybmFsRnVuY3Rpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5pZE5hbWVNYXAgPSB7fTtcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBbXTsgLy8gQ29sbGVjdGlvbiBvZiBoZWFkZXIgbGluZXMgdG8gZGVmaW5lXHJcblxyXG4gICAgICAgIHRoaXMuZ2xvYmFsUGFyYW1ldGVycyA9IHJvb3QuZ2xvYmFsUGFyYW1ldGVycyAmJiByb290Lmdsb2JhbFBhcmFtZXRlcnNbZW50cnldICYmIHJvb3QuZ2xvYmFsUGFyYW1ldGVyc1tlbnRyeV1bMF0gPyByb290Lmdsb2JhbFBhcmFtZXRlcnNbZW50cnldWzBdLmV4dHJhLmluZm8gOiB7fTtcclxuXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBCYXNlLmNyZWF0ZUNsYXNzKEdMVHJhbnNmb3JtQ29udGV4dCwgQ29udGV4dCwge1xyXG4gICAgICAgIGNyZWF0ZVNjb3BlOiBmdW5jdGlvbihub2RlLCBwYXJlbnQsIG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHTFRyYW5zZm9ybVNjb3BlKG5vZGUsIHBhcmVudCwge25hbWU6IG5hbWV9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFR5cGVJbmZvOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21tb24uZ2V0VHlwZUluZm8obm9kZSwgdGhpcy5nZXRTY29wZSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEhlYWRlcjogZnVuY3Rpb24oaGVhZGVyU3RyKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWRlcnMuaW5kZXhPZihoZWFkZXJTdHIpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMucHVzaChoZWFkZXJTdHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBleHRlbmRzIHtTY29wZX1cclxuICAgICAqL1xyXG4gICAgdmFyIEdMVHJhbnNmb3JtU2NvcGUgPSBmdW5jdGlvbihub2RlLCBwYXJlbnRTY29wZSwgb3B0KSB7XHJcbiAgICAgICAgU2NvcGUuY2FsbCh0aGlzLCBub2RlLCBwYXJlbnRTY29wZSwgb3B0KTtcclxuICAgICAgICB0aGlzLnNldFJlZ2lzdHJ5KFJlZ2lzdHJ5KTtcclxuICAgIH07XHJcblxyXG4gICAgQmFzZS5jcmVhdGVDbGFzcyhHTFRyYW5zZm9ybVNjb3BlLCBTY29wZSwge1xyXG5cclxuICAgICAgICByZWdpc3Rlckdsb2JhbHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiTWF0aFwiLCBvYmplY3RzLk1hdGgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiQ29sb3JcIiwgIG9iamVjdHMuQ29sb3IpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiVmVjMlwiLCBvYmplY3RzLlZlYzIpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiVmVjM1wiLCBvYmplY3RzLlZlYzMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiVmVjNFwiLCBvYmplY3RzLlZlYzQpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiVGV4dHVyZVwiLCBvYmplY3RzLlRleHR1cmUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyT2JqZWN0KFwiU2hhZGVcIiwgb2JqZWN0cy5TaGFkZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYmplY3QoXCJNYXQzXCIsIG9iamVjdHMuTWF0Myk7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYmplY3QoXCJNYXQ0XCIsIG9iamVjdHMuTWF0NCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJPYmplY3QoXCJTcGFjZVwiLCBvYmplY3RzLlNwYWNlKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyZVZhcmlhYmxlKFwiZ2xfRnJhZ0Nvb3JkXCIsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUeXBlSW5mbyhcImdsX0ZyYWdDb29yZFwiLCBuZXcgVHlwZUluZm8oe1xyXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUeXBlcy5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICAgICAga2luZDogS2luZHMuRkxPQVQzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuICAgIG5zLkdMVHJhbnNmb3JtU2NvcGUgPSBHTFRyYW5zZm9ybVNjb3BlO1xyXG4gICAgbnMuR0xUcmFuc2Zvcm1Db250ZXh0ID0gR0xUcmFuc2Zvcm1Db250ZXh0O1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcblxyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIik7XHJcbiAgICB2YXIgU3ludGF4ID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLlN5bnRheDtcclxuICAgIHZhciBUb29scyA9IHJlcXVpcmUoXCIuLi8uLi90b29scy5qc1wiKTtcclxuICAgIHZhciBBTk5PID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvYW5ub3RhdGlvbi5qc1wiKS5BTk5PO1xyXG5cclxuICAgIHZhciBUWVBFUyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEtJTkRTID0gU2hhZGUuT0JKRUNUX0tJTkRTO1xyXG5cclxuICAgIHZhciBNYXQzSW5zdGFuY2UgPSB7XHJcbiAgICAgICAgY29sOiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLk1hdC5nZW5lcmF0ZUNvbENhbGwuYmluZChudWxsLCBcIk1hdDNcIilcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBUb29scy5NYXQuYXR0YWNoT3BlcmF0b3JzKE1hdDNJbnN0YW5jZSwgXCJNYXQzXCIsIHtcclxuICAgICAgICBhZGQ6ICcrJyxcclxuICAgICAgICBzdWI6ICctJyxcclxuICAgICAgICBtdWw6ICcqJyxcclxuICAgICAgICBkaXY6ICcvJ1xyXG4gICAgfSk7XHJcbiAgICBUb29scy5WZWMuYXR0YWNoT3BlcmF0b3JzKE1hdDNJbnN0YW5jZSwgMywge1xyXG4gICAgICAgIG11bFZlYzogJyonXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XHJcbiAgICAgICAgaWQ6IFwiTWF0M1wiLFxyXG4gICAgICAgIGtpbmQ6IEtJTkRTLk1BVFJJWDMsXHJcbiAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBUb29scy5WZWMuZ2VuZXJhdGVDb25zdHJ1Y3RvcixcclxuICAgICAgICAgICAgc3RhdGljOiB7fVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5zdGFuY2U6IE1hdDNJbnN0YW5jZVxyXG4gICAgfSk7XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uKG5zKXtcclxuXHJcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKTtcclxuICAgIHZhciBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4O1xyXG4gICAgdmFyIFRvb2xzID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzLmpzXCIpO1xyXG4gICAgdmFyIEFOTk8gPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9hbm5vdGF0aW9uLmpzXCIpLkFOTk87XHJcblxyXG4gICAgdmFyIFRZUEVTID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS0lORFMgPSBTaGFkZS5PQkpFQ1RfS0lORFM7XHJcblxyXG4gICAgdmFyIE1hdDRJbnN0YW5jZSA9IHtcclxuICAgICAgICBjb2w6IHtcclxuICAgICAgICAgICAgY2FsbEV4cDogVG9vbHMuTWF0LmdlbmVyYXRlQ29sQ2FsbC5iaW5kKG51bGwsIFwiTWF0NFwiKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFRvb2xzLk1hdC5hdHRhY2hPcGVyYXRvcnMoTWF0NEluc3RhbmNlLCBcIk1hdDRcIiwge1xyXG4gICAgICAgIGFkZDogJysnLFxyXG4gICAgICAgIHN1YjogJy0nLFxyXG4gICAgICAgIG11bDogJyonLFxyXG4gICAgICAgIGRpdjogJy8nXHJcbiAgICB9KTtcclxuICAgIFRvb2xzLlZlYy5hdHRhY2hPcGVyYXRvcnMoTWF0NEluc3RhbmNlLCA0LCB7XHJcbiAgICAgICAgbXVsVmVjOiAnKidcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBUb29scy5leHRlbmQobnMsIHtcclxuICAgICAgICBpZDogXCJNYXQ0XCIsXHJcbiAgICAgICAga2luZDogS0lORFMuTUFUUklYNCxcclxuICAgICAgICBvYmplY3Q6IHtcclxuICAgICAgICAgICAgY29uc3RydWN0b3I6IFRvb2xzLlZlYy5nZW5lcmF0ZUNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBzdGF0aWM6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnN0YW5jZTogTWF0NEluc3RhbmNlXHJcbiAgICB9KTtcclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24obnMpe1xyXG5cclxuICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIik7XHJcbiAgIHZhciBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4O1xyXG4gICB2YXIgVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vdG9vbHMuanNcIik7XHJcblxyXG4gICAgdmFyIE1hdGhDb25zdGFudHMgPSBbXCJFXCIsIFwiUElcIiwgXCJMTjJcIiwgXCJMT0cyRVwiLCBcIkxPRzEwRVwiLCBcIlBJXCIsIFwiU1FSVDFfMlwiLCBcIlNRUlQyXCJdO1xyXG5cclxuXHJcbiAgICB2YXIgaGFuZGxlSW50VmVyc2lvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICBub2RlLmV4dHJhLnR5cGUgPSBTaGFkZS5UWVBFUy5OVU1CRVI7XHJcbiAgICAgICAgbm9kZS5jYWxsZWUgPSBUb29scy5yZW1vdmVNZW1iZXJGcm9tRXhwcmVzc2lvbihub2RlLmNhbGxlZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBoYW5kbGVNYXRoQ2FsbCA9IGZ1bmN0aW9uKG9wdCkge1xyXG4gICAgICAgIG9wdCA9IG9wdCB8fHt9O1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09IFN5bnRheC5DYWxsRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihub2RlLCBcIkludGVybmFsIEVycm9yIGluIE1hdGggb2JqZWN0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENhc3QgYWxsIGFyZ3VtZW50cyBvZiB0aGUgbWF0aCBmdW5jdGlvbiB0byBmbG9hdCwgYXMgdGhleSBhcmVcclxuICAgICAgICAgICAgLy8gbm90IGRlZmluZWQgZm9yIG90aGVyIHR5cGVzIChpbnQsIGJvb2wpXHJcbiAgICAgICAgICAgIC8vIERvbid0IHJlcGxhY2UgdGhlIGFyZ3VtZW50cyBhcnJheSwgaXQncyBhbHJlYWR5IGNhY2hlZCBieSB0aGUgdHJhdmVyc2FsXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tpXS5pc0ludCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnRzW2ldID0gVG9vbHMuY2FzdFRvRmxvYXQobm9kZS5hcmd1bWVudHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUuY2FsbGVlID0gVG9vbHMucmVtb3ZlTWVtYmVyRnJvbUV4cHJlc3Npb24obm9kZS5jYWxsZWUpO1xyXG4gICAgICAgICAgICBpZiAob3B0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuY2FsbGVlLm5hbWUgPSBvcHQubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0LmFyZ3VtZW50cykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgb3B0LmFyZ3VtZW50cy5sZW5ndGg7ICsraWR4KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0LmFyZ3VtZW50c1tpZHhdICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50c1tpZHhdID0gb3B0LmFyZ3VtZW50c1tpZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIE1hdGhFbnRyeSAgPSB7XHJcbiAgICAgICAgYWJzOiB7IGNhbGxFeHA6IGhhbmRsZU1hdGhDYWxsKCkgfSxcclxuICAgICAgICBhY29zOiB7IGNhbGxFeHA6IGhhbmRsZU1hdGhDYWxsKCkgfSxcclxuICAgICAgICBhc2luOiB7IGNhbGxFeHA6IGhhbmRsZU1hdGhDYWxsKCkgfSxcclxuICAgICAgICBhdGFuOiB7IGNhbGxFeHA6IGhhbmRsZU1hdGhDYWxsKCkgfSxcclxuICAgICAgICBhdGFuMjogeyBjYWxsRXhwOiBoYW5kbGVNYXRoQ2FsbCh7IG5hbWU6IFwiYXRhblwiIH0pIH0sXHJcbiAgICAgICAgY2VpbDogeyBjYWxsRXhwOiBoYW5kbGVJbnRWZXJzaW9uIH0sXHJcbiAgICAgICAgY29zOiAgeyBjYWxsRXhwOiBoYW5kbGVNYXRoQ2FsbCgpIH0sXHJcbiAgICAgICAgZXhwOiB7IGNhbGxFeHA6IGhhbmRsZU1hdGhDYWxsKCkgfSxcclxuICAgICAgICBmbG9vcjogeyBjYWxsRXhwOiBoYW5kbGVNYXRoQ2FsbCgpIH0sXHJcbiAgICAgICAgLy8gaW11bDogeyBjYWxsRXhwOiBoYW5kbGVNYXRoQ2FsbCB9LFxyXG4gICAgICAgIGxvZzogeyBjYWxsRXhwOiBoYW5kbGVNYXRoQ2FsbCgpIH0sXHJcbiAgICAgICAgbWF4OiB7IGNhbGxFeHA6IGhhbmRsZU1hdGhDYWxsKCkgfSxcclxuICAgICAgICBtaW46IHsgY2FsbEV4cDogaGFuZGxlTWF0aENhbGwoKSB9LFxyXG4gICAgICAgIHBvdzogeyBjYWxsRXhwOiBoYW5kbGVNYXRoQ2FsbCgpIH0sXHJcbiAgICAgICAgLy8gcmFuZG9tOiBmdW5jdGlvbiByYW5kb20oKSB7IFtuYXRpdmUgY29kZV0gfVxyXG4gICAgICAgIHJvdW5kOiB7IGNhbGxFeHA6IGhhbmRsZU1hdGhDYWxsKCkgfSwgLy8gU2luY2UgR0xTTCAxLjMsIHdoYXQgZG9lcyBXZWJHTCB1c2U/XHJcbiAgICAgICAgc2luOiAgeyBjYWxsRXhwOiBoYW5kbGVNYXRoQ2FsbCgpIH0sXHJcbiAgICAgICAgc3FydDogeyBjYWxsRXhwOiBoYW5kbGVNYXRoQ2FsbCgpIH0sXHJcbiAgICAgICAgdGFuOiB7IGNhbGxFeHA6IGhhbmRsZU1hdGhDYWxsKCkgfSxcclxuXHJcbiAgICAgICAgLy8gTm9uLXN0YW5kYXJkIG1ldGhvZHNcclxuICAgICAgICBjbGFtcDogeyBjYWxsRXhwOiBoYW5kbGVNYXRoQ2FsbCgpIH0sXHJcbiAgICAgICAgc2F0dXJhdGU6IHsgY2FsbEV4cDogaGFuZGxlTWF0aENhbGwoeyBuYW1lOiBcImNsYW1wXCIsIGFyZ3VtZW50czogW1xyXG4gICAgICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5MaXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IDAuMCxcclxuICAgICAgICAgICAgICAgIGV4dHJhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2hhZGUuVFlQRVMuTlVNQkVSLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlOiAwLjBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogMS4wLFxyXG4gICAgICAgICAgICAgICAgZXh0cmE6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTaGFkZS5UWVBFUy5OVU1CRVIsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWU6IDEuMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSB9KSB9LFxyXG4gICAgICAgIHNtb290aHN0ZXA6IHsgY2FsbEV4cDogaGFuZGxlTWF0aENhbGwoKSB9LFxyXG4gICAgICAgIHN0ZXA6IHsgY2FsbEV4cDogaGFuZGxlTWF0aENhbGwoKSB9LFxyXG4gICAgICAgIGZyYWN0OiB7IGNhbGxFeHA6IGhhbmRsZU1hdGhDYWxsKCkgfSxcclxuICAgICAgICBtaXg6IHsgY2FsbEV4cDogaGFuZGxlTWF0aENhbGwoKSB9XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGhDb25zdGFudHMuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RhbnQpIHtcclxuICAgICAgICBNYXRoRW50cnlbY29uc3RhbnRdID0ge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICB7IHR5cGU6IFN5bnRheC5MaXRlcmFsLCB2YWx1ZTogTWF0aFtjb25zdGFudF0sIGV4dHJhOiB7IHR5cGU6IFNoYWRlLlRZUEVTLk5VTUJFUiB9IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBUb29scy5leHRlbmQobnMsIHtcclxuICAgICAgICBpZDogXCJNYXRoXCIsXHJcbiAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBudWxsLFxyXG4gICAgICAgICAgICBzdGF0aWM6IE1hdGhFbnRyeVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5zdGFuY2U6IE1hdGhFbnRyeVxyXG4gICAgfSk7XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xyXG4gICAgdmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKS5TeW50YXg7XHJcbiAgICB2YXIgVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vdG9vbHMuanNcIik7XHJcblxyXG4gICAgdmFyIFNoYWRlSW5zdGFuY2UgPSB7XHJcbiAgICAgICAgZGlmZnVzZToge1xyXG4gICAgICAgICAgICBjYWxsRXhwOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiBub2RlLmNhbGxlZS5wcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBub2RlLmFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG5vZGUuY2FsbGVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogU2hhZGUuT0JKRUNUX0tJTkRTLkNPTE9SX0NMT1NVUkVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHBob25nOiB7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XHJcbiAgICAgICAgaWQ6IFwiU2hhZGVcIixcclxuICAgICAgICBraW5kOiBTaGFkZS5PQkpFQ1RfS0lORFMuQ09MT1JfQ0xPU1VSRSxcclxuICAgICAgICBvYmplY3Q6IHtcclxuICAgICAgICAgICAgY29uc3RydWN0b3I6IFRvb2xzLlZlYy5nZW5lcmF0ZUNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBzdGF0aWM6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnN0YW5jZTogU2hhZGVJbnN0YW5jZVxyXG4gICAgfSk7XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uKG5zKXtcclxuXHJcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKTtcclxuICAgIHZhciBTeW50YXggPSByZXF1aXJlKCdlc3RyYXZlcnNlJykuU3ludGF4O1xyXG4gICAgdmFyIFRvb2xzID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzLmpzXCIpO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTcGFjZVRyYW5zZm9ybShzcGFjZUFyZywgbm9ybWFsKXtcclxuICAgICAgICBpZiggc3BhY2VBcmcudHlwZSAhPSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbiB8fFxyXG4gICAgICAgICAgICBzcGFjZUFyZy5vYmplY3QudHlwZSAhPSBTeW50YXguSWRlbnRpZmllciB8fFxyXG4gICAgICAgICAgICBzcGFjZUFyZy5vYmplY3QubmFtZSAhPSBcIlNwYWNlXCIgfHxcclxuICAgICAgICAgICAgc3BhY2VBcmcucHJvcGVydHkudHlwZSAhPSBTeW50YXguSWRlbnRpZmllcilcclxuICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihzcGFjZUFyZywgXCJXZSBvbmx5IHN1cHBvcnQgU3BhY2UgZW51bXMgZm9yIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0cmFuc2Zvcm1EaXJlY3Rpb24gYW5kIHRyYW5zZm9ybVBvaW50XCIpO1xyXG5cclxuICAgICAgICBzd2l0Y2goc3BhY2VBcmcucHJvcGVydHkubmFtZSl7XHJcbiAgICAgICAgICAgIGNhc2UgXCJWSUVXXCI6IHJldHVybiBub3JtYWwgPyBcIm1vZGVsVmlld01hdHJpeE5cIiA6IFwibW9kZWxWaWV3TWF0cml4XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJXT1JMRFwiOiByZXR1cm4gbm9ybWFsID8gXCJtb2RlbE1hdHJpeE5cIiA6IFwibW9kZWxNYXRyaXhcIjtcclxuICAgICAgICAgICAgZGVmYXVsdDogU2hhZGUudGhyb3dFcnJvcihzcGFjZUFyZywgXCJVbmtub3duIFNwYWNlIFR5cGU6ICdcIiArIHNwYWNlQXJnLnByb3BlcnR5Lm5hbWUgKyBcIidcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBBTk5PID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvYW5ub3RhdGlvbi5qc1wiKS5BTk5PO1xyXG4gICAgdmFyIFRZUEVTID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS0lORFMgPSBTaGFkZS5PQkpFQ1RfS0lORFM7XHJcbiAgICB2YXIgU3BhY2VFbnRyeSAgPSB7XHJcbiAgICAgICAgdHJhbnNmb3JtRGlyZWN0aW9uOiB7IGNhbGxFeHA6IGZ1bmN0aW9uKGNhbGxFeHByZXNzaW9uLCBwYXJlbnQsIGNvbnRleHQsIHN0YXRlKXtcclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGdldFNwYWNlVHJhbnNmb3JtKGNhbGxFeHByZXNzaW9uLmFyZ3VtZW50c1swXSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7ICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbiwgb3BlcmF0b3I6IFwiKlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogdHJhbnNmb3JtfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHNbMV1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIEFOTk8ocmVzdWx0KS5zZXRUeXBlKFRZUEVTLk9CSkVDVCwgS0lORFMuRkxPQVQzKTtcclxuICAgICAgICAgICAgQU5OTyhyZXN1bHQubGVmdCkuc2V0VHlwZShUWVBFUy5PQkpFQ1QsIEtJTkRTLk1BVFJJWDMpO1xyXG4gICAgICAgICAgICBBTk5PKHJlc3VsdC5yaWdodCkuc2V0VHlwZShUWVBFUy5PQkpFQ1QsIEtJTkRTLkZMT0FUMyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3lzdGVtTmFtZSA9IFRvb2xzLmdldE5hbWVGb3JTeXN0ZW0odHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgc3RhdGUudXNlZFBhcmFtZXRlcnMuc3lzdGVtW3N5c3RlbU5hbWVdID0gc3RhdGUuc3lzdGVtUGFyYW1ldGVyc1t0cmFuc2Zvcm1dO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9IH0sXHJcbiAgICAgICAgdHJhbnNmb3JtUG9pbnQ6IHsgY2FsbEV4cDogZnVuY3Rpb24oY2FsbEV4cHJlc3Npb24sIHBhcmVudCwgY29udGV4dCwgc3RhdGUpe1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gZ2V0U3BhY2VUcmFuc2Zvcm0oY2FsbEV4cHJlc3Npb24uYXJndW1lbnRzWzBdLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7ICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogeyAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sIG9wZXJhdG9yOiBcIipcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiB0cmFuc2Zvcm19LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB7dHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZToge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcInZlYzRcIn0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHNbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6IFN5bnRheC5MaXRlcmFsLCB2YWx1ZTogMSwgcmF3OiAxfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHsgdHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IFwieHl6XCIgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFOTk8ocmVzdWx0KS5zZXRUeXBlKFRZUEVTLk9CSkVDVCwgS0lORFMuRkxPQVQzKTtcclxuICAgICAgICAgICAgQU5OTyhyZXN1bHQub2JqZWN0KS5zZXRUeXBlKFRZUEVTLk9CSkVDVCwgS0lORFMuRkxPQVQ0KTtcclxuICAgICAgICAgICAgQU5OTyhyZXN1bHQub2JqZWN0LmxlZnQpLnNldFR5cGUoVFlQRVMuT0JKRUNULCBLSU5EUy5NQVRSSVg0KTtcclxuICAgICAgICAgICAgQU5OTyhyZXN1bHQub2JqZWN0LnJpZ2h0KS5zZXRUeXBlKFRZUEVTLk9CSkVDVCwgS0lORFMuRkxPQVQ0KTtcclxuICAgICAgICAgICAgQU5OTyhyZXN1bHQub2JqZWN0LnJpZ2h0LmFyZ3VtZW50c1sxXSkuc2V0VHlwZShUWVBFUy5OVU1CRVIpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBzeXN0ZW1OYW1lID0gVG9vbHMuZ2V0TmFtZUZvclN5c3RlbSh0cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICBzdGF0ZS51c2VkUGFyYW1ldGVycy5zeXN0ZW1bc3lzdGVtTmFtZV0gPSBzdGF0ZS5zeXN0ZW1QYXJhbWV0ZXJzW3RyYW5zZm9ybV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0gfSxcclxuICAgICAgICBWSUVXOiB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAobWVtYmVyRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbWJlckV4cHJlc3Npb247XHJcbiAgICAgICAgICAgIH19LFxyXG4gICAgICAgIFdPUkxEOiB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAobWVtYmVyRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICBtZW1iZXJFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICB9fVxyXG4gICAgfTtcclxuXHJcbiAgICBUb29scy5leHRlbmQobnMsIHtcclxuICAgICAgICBpZDogXCJTcGFjZVwiLFxyXG4gICAgICAgIG9iamVjdDoge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogbnVsbCxcclxuICAgICAgICAgICAgc3RhdGljOiBTcGFjZUVudHJ5XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnN0YW5jZTogU3BhY2VFbnRyeVxyXG4gICAgfSk7XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIC8vIERlcGVuZGVuY2llc1xyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIik7XHJcbiAgICB2YXIgVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vdG9vbHMuanNcIik7XHJcbiAgICB2YXIgU3ludGF4ID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLlN5bnRheDtcclxuXHJcbiAgICAvLyBTaG9ydGN1dHNcclxuICAgIHZhciBUWVBFUyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEtJTkRTID0gU2hhZGUuT0JKRUNUX0tJTkRTO1xyXG5cclxuXHJcbiAgICB2YXIgU3lzdGVtRGVmaW5lcyA9IHt9O1xyXG4gICAgU3lzdGVtRGVmaW5lcy5DQU5WQVNfRElNRU5TSU9OUyA9IFwiY29vcmRzXCI7XHJcbiAgICBTeXN0ZW1EZWZpbmVzLkRFUklWQVRFX0VYVEVOU0lPTiA9IFwiI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcIjtcclxuXHJcbiAgICB2YXIgQ29vcmRzVHlwZSA9ICB7XHJcbiAgICAgICAgdHlwZTogU2hhZGUuVFlQRVMuT0JKRUNULFxyXG4gICAgICAgIGtpbmQ6IFNoYWRlLk9CSkVDVF9LSU5EUy5GTE9BVDMsXHJcbiAgICAgICAgc291cmNlOiBTaGFkZS5TT1VSQ0VTLlVOSUZPUk1cclxuICAgIH07XHJcblxyXG5cclxuICAgIHZhciBEZXJpdmVkUGFyYW1ldGVycyA9IHtcclxuICAgICAgICBjb29yZHM6IHtcclxuICAgICAgICAgICAgcHJvcGVydHk6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnR5Lm5hbWUgPSBcImdsX0ZyYWdDb29yZFwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG5vcm1hbGl6ZWRDb29yZHM6IHtcclxuICAgICAgICAgICAgcHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGNvbnRleHQsIHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVyTmFtZSA9IFRvb2xzLmdldE5hbWVGb3JTeXN0ZW0oU3lzdGVtRGVmaW5lcy5DQU5WQVNfRElNRU5TSU9OUyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzRGltZW5zaW9ucyA9IHN0YXRlLnN5c3RlbVBhcmFtZXRlcnNbU3lzdGVtRGVmaW5lcy5DQU5WQVNfRElNRU5TSU9OU107XHJcbiAgICAgICAgICAgICAgICBpZighY2FudmFzRGltZW5zaW9ucylcclxuICAgICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJJbnRlcm5hbCBFcnJvcjogTm8gY2FuYXZhcyBkaW1lbnNpb25zIGRlZmluZWRcIiApO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLnVzZWRQYXJhbWV0ZXJzLnN5c3RlbVtwYXJhbWV0ZXJOYW1lXSA9IGNhbnZhc0RpbWVuc2lvbnM7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTmV3RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVmVjM1wiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImdsX0ZyYWdDb29yZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJ4eXpcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFRvb2xzLmdldE5hbWVGb3JTeXN0ZW0oU3lzdGVtRGVmaW5lcy5DQU5WQVNfRElNRU5TSU9OUylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBTaGFkZS5PQkpFQ1RfS0lORFMuRkxPQVQzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogU2hhZGUuT0JKRUNUX0tJTkRTLkZMT0FUM1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGVpZ2h0OiB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0LCBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlck5hbWUgPSBUb29scy5nZXROYW1lRm9yU3lzdGVtKFN5c3RlbURlZmluZXMuQ0FOVkFTX0RJTUVOU0lPTlMpO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUudXNlZFBhcmFtZXRlcnMuc3lzdGVtW3BhcmFtZXRlck5hbWVdID0gc3RhdGUuc3lzdGVtUGFyYW1ldGVyc1tTeXN0ZW1EZWZpbmVzLkNBTlZBU19ESU1FTlNJT05TXTtcclxuXHJcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnR5Lm5hbWUgPSBwYXJhbWV0ZXJOYW1lICsgXCIueVwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHdpZHRoOiB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0LCBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlck5hbWUgPSBUb29scy5nZXROYW1lRm9yU3lzdGVtKFN5c3RlbURlZmluZXMuQ0FOVkFTX0RJTUVOU0lPTlMpO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUudXNlZFBhcmFtZXRlcnMuc3lzdGVtW3BhcmFtZXRlck5hbWVdID0gc3RhdGUuc3lzdGVtUGFyYW1ldGVyc1tTeXN0ZW1EZWZpbmVzLkNBTlZBU19ESU1FTlNJT05TXTtcclxuXHJcbiAgICAgICAgICAgICAgICBub2RlLnByb3BlcnR5Lm5hbWUgPSBwYXJhbWV0ZXJOYW1lICsgXCIueFwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ3aWR0aDoge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCwgc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmFkZEhlYWRlcihTeXN0ZW1EZWZpbmVzLkRFUklWQVRFX0VYVEVOU0lPTik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVG9vbHMucmVtb3ZlTWVtYmVyRnJvbUV4cHJlc3Npb24obm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGR4OiB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0LCBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUuYWRkSGVhZGVyKFN5c3RlbURlZmluZXMuREVSSVZBVEVfRVhURU5TSU9OKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBUb29scy5yZW1vdmVNZW1iZXJGcm9tRXhwcmVzc2lvbihub2RlKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gXCJkRmR4XCI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkeToge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCwgc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmFkZEhlYWRlcihTeXN0ZW1EZWZpbmVzLkRFUklWQVRFX0VYVEVOU0lPTik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IFRvb2xzLnJlbW92ZU1lbWJlckZyb21FeHByZXNzaW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFRvb2xzLnJlbW92ZU1lbWJlckZyb21FeHByZXNzaW9uKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBcImRGZHlcIjtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBUb29scy5leHRlbmQobnMsIHtcclxuICAgICAgICBpZDogXCJTeXN0ZW1cIixcclxuICAgICAgICBvYmplY3Q6IHtcclxuICAgICAgICAgICAgY29uc3RydWN0b3I6IG51bGwsXHJcbiAgICAgICAgICAgIHN0YXRpYzogRGVyaXZlZFBhcmFtZXRlcnNcclxuICAgICAgICB9LFxyXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxyXG4gICAgICAgIGRlcml2ZWRQYXJhbWV0ZXJzOiBEZXJpdmVkUGFyYW1ldGVyc1xyXG4gICAgfSk7XHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24obnMpe1xyXG5cclxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xyXG4gICAgdmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKS5TeW50YXg7XHJcbiAgICB2YXIgVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vdG9vbHMuanNcIik7XHJcbiAgICB2YXIgQU5OTyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTztcclxuXHJcbiAgICB2YXIgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcclxuXHJcbiAgICB2YXIgVGV4dHVyZUluc3RhbmNlID0ge1xyXG4gICAgICAgIHNhbXBsZTJEOiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAndGV4dHVyZTJEJywgMilcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdpZHRoOiB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0LCBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlck5hbWUgPSBub2RlLm9iamVjdC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eS5uYW1lID0gcGFyYW1ldGVyTmFtZSArIFwiX3dpZHRoXCI7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS51c2VkUGFyYW1ldGVycy5zaGFkZXJbcGFyYW1ldGVyTmFtZSArIFwiX3dpZHRoXCJdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLklOVCxcclxuICAgICAgICAgICAgICAgICAgICBraW5kOiBTaGFkZS5PQkpFQ1RfS0lORFMuSU5ULFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogU2hhZGUuU09VUkNFUy5VTklGT1JNXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGhlaWdodDoge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCwgY29udGV4dCwgc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJOYW1lID0gbm9kZS5vYmplY3QubmFtZTtcclxuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydHkubmFtZSA9IHBhcmFtZXRlck5hbWUgKyBcIl9oZWlnaHRcIjtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnVzZWRQYXJhbWV0ZXJzLnNoYWRlcltwYXJhbWV0ZXJOYW1lICsgXCJfaGVpZ2h0XCJdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNoYWRlLlRZUEVTLklOVCxcclxuICAgICAgICAgICAgICAgICAgICBraW5kOiBTaGFkZS5PQkpFQ1RfS0lORFMuSU5ULFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogU2hhZGUuU09VUkNFUy5VTklGT1JNXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XHJcbiAgICAgICAgaWQ6IFwiVGV4dHVyZVwiLFxyXG4gICAgICAgIGtpbmQ6IEtJTkRTLlRFWFRVUkUsXHJcbiAgICAgICAgb2JqZWN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBudWxsLFxyXG4gICAgICAgICAgICBzdGF0aWM6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnN0YW5jZTogVGV4dHVyZUluc3RhbmNlXHJcbiAgICB9KTtcclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24obnMpe1xyXG5cclxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xyXG4gICAgdmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKS5TeW50YXg7XHJcbiAgICB2YXIgVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vdG9vbHMuanNcIik7XHJcbiAgICB2YXIgQU5OTyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTztcclxuXHJcbiAgICB2YXIgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcclxuXHJcbiAgICB2YXIgVmVjMkluc3RhbmNlID0ge1xyXG4gICAgICAgIG5vcm1hbGl6ZToge1xyXG4gICAgICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgJ25vcm1hbGl6ZScsIDApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmbGlwOiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAnLScsIDApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkb3Q6IHtcclxuICAgICAgICAgICAgY2FsbEV4cDogVG9vbHMuVmVjLmNyZWF0ZUZ1bmN0aW9uQ2FsbC5iaW5kKG51bGwsICdkb3QnLCAyKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVmbGVjdDoge1xyXG4gICAgICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgJ3JlZmxlY3QnLCAyKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVuZ3RoOiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5nZW5lcmF0ZUxlbmd0aENhbGxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBUb29scy5WZWMuYXR0YWNoU3dpenpsZXMoVmVjMkluc3RhbmNlLCAyLCBUb29scy5WZWMuY3JlYXRlU3dpenpsZSwgVG9vbHMuVmVjLmNyZWF0ZVN3aXp6bGVPcGVyYXRvcik7XHJcbiAgICBUb29scy5WZWMuYXR0YWNoT3BlcmF0b3JzKFZlYzJJbnN0YW5jZSwgMiwge1xyXG4gICAgICAgIGFkZDogJysnLFxyXG4gICAgICAgIHN1YjogJy0nLFxyXG4gICAgICAgIG11bDogJyonLFxyXG4gICAgICAgIGRpdjogJy8nLFxyXG4gICAgICAgIG1vZDogJyUnXHJcbiAgICB9KVxyXG5cclxuXHJcbiAgICBUb29scy5leHRlbmQobnMsIHtcclxuICAgICAgICBpZDogXCJWZWMyXCIsXHJcbiAgICAgICAga2luZDogS0lORFMuRkxPQVQyLFxyXG4gICAgICAgIG9iamVjdDoge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogVG9vbHMuVmVjLmdlbmVyYXRlQ29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIHN0YXRpYzoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIGluc3RhbmNlOiBWZWMySW5zdGFuY2VcclxuICAgIH0pO1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbihucyl7XHJcblxyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZXMuanNcIik7XHJcbiAgICB2YXIgU3ludGF4ID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLlN5bnRheDtcclxuICAgIHZhciBUb29scyA9IHJlcXVpcmUoXCIuLi8uLi90b29scy5qc1wiKTtcclxuICAgIHZhciBBTk5PID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvYW5ub3RhdGlvbi5qc1wiKS5BTk5PO1xyXG5cclxuICAgIHZhciBUWVBFUyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEtJTkRTID0gU2hhZGUuT0JKRUNUX0tJTkRTO1xyXG5cclxuICAgIHZhciBWZWMzSW5zdGFuY2UgPSB7XHJcbiAgICAgICAgbm9ybWFsaXplOiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAnbm9ybWFsaXplJywgMClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZsaXA6IHtcclxuICAgICAgICAgICAgY2FsbEV4cDogVG9vbHMuVmVjLmNyZWF0ZUZ1bmN0aW9uQ2FsbC5iaW5kKG51bGwsICctJywgMClcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRvdDoge1xyXG4gICAgICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgJ2RvdCcsIDMpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWZsZWN0OiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAncmVmbGVjdCcsIDMpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZWZyYWN0OiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IGZ1bmN0aW9uIChub2RlLCBhcmdzLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldGEgPSBub2RlLmFyZ3VtZW50cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsKFwicmVmcmFjdFwiLCAzLCBub2RlLCBhcmdzLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgQU5OTyhldGEpLnNldFR5cGUoVFlQRVMuTlVNQkVSKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcmd1bWVudHMucHVzaChldGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVuZ3RoOiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5nZW5lcmF0ZUxlbmd0aENhbGxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNyb3NzOiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCBcImNyb3NzXCIsIDMpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVG9vbHMuVmVjLmF0dGFjaFN3aXp6bGVzKFZlYzNJbnN0YW5jZSwgMywgVG9vbHMuVmVjLmNyZWF0ZVN3aXp6bGUsIFRvb2xzLlZlYy5jcmVhdGVTd2l6emxlT3BlcmF0b3IpO1xyXG4gICAgVG9vbHMuVmVjLmF0dGFjaE9wZXJhdG9ycyhWZWMzSW5zdGFuY2UsIDMsIHtcclxuICAgICAgICBhZGQ6ICcrJyxcclxuICAgICAgICBzdWI6ICctJyxcclxuICAgICAgICBtdWw6ICcqJyxcclxuICAgICAgICBkaXY6ICcvJyxcclxuICAgICAgICBtb2Q6ICclJ1xyXG4gICAgfSlcclxuXHJcblxyXG4gICAgVG9vbHMuZXh0ZW5kKG5zLCB7XHJcbiAgICAgICAgaWQ6IFwiVmVjM1wiLFxyXG4gICAgICAgIGtpbmQ6IEtJTkRTLkZMT0FUMyxcclxuICAgICAgICBvYmplY3Q6IHtcclxuICAgICAgICAgICAgY29uc3RydWN0b3I6IFRvb2xzLlZlYy5nZW5lcmF0ZUNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBzdGF0aWM6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnN0YW5jZTogVmVjM0luc3RhbmNlXHJcbiAgICB9KTtcclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24obnMpe1xyXG5cclxuICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpO1xyXG4gICAgdmFyIFN5bnRheCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKS5TeW50YXg7XHJcbiAgICB2YXIgVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vdG9vbHMuanNcIik7XHJcbiAgICB2YXIgQU5OTyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTztcclxuXHJcbiAgICB2YXIgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcclxuXHJcbiAgICB2YXIgVmVjNEluc3RhbmNlID0ge1xyXG4gICAgICAgIG5vcm1hbGl6ZToge1xyXG4gICAgICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgJ25vcm1hbGl6ZScsIDApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmbGlwOiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5jcmVhdGVGdW5jdGlvbkNhbGwuYmluZChudWxsLCAnLScsIDApXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkb3Q6IHtcclxuICAgICAgICAgICAgY2FsbEV4cDogVG9vbHMuVmVjLmNyZWF0ZUZ1bmN0aW9uQ2FsbC5iaW5kKG51bGwsICdkb3QnLCA0KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVmbGVjdDoge1xyXG4gICAgICAgICAgICBjYWxsRXhwOiBUb29scy5WZWMuY3JlYXRlRnVuY3Rpb25DYWxsLmJpbmQobnVsbCwgJ3JlZmxlY3QnLCA0KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVuZ3RoOiB7XHJcbiAgICAgICAgICAgIGNhbGxFeHA6IFRvb2xzLlZlYy5nZW5lcmF0ZUxlbmd0aENhbGxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBUb29scy5WZWMuYXR0YWNoU3dpenpsZXMoVmVjNEluc3RhbmNlLCA0LCBUb29scy5WZWMuY3JlYXRlU3dpenpsZSwgVG9vbHMuVmVjLmNyZWF0ZVN3aXp6bGVPcGVyYXRvcik7XHJcbiAgICBUb29scy5WZWMuYXR0YWNoT3BlcmF0b3JzKFZlYzRJbnN0YW5jZSwgNCwge1xyXG4gICAgICAgIGFkZDogJysnLFxyXG4gICAgICAgIHN1YjogJy0nLFxyXG4gICAgICAgIG11bDogJyonLFxyXG4gICAgICAgIGRpdjogJy8nLFxyXG4gICAgICAgIG1vZDogJyUnXHJcbiAgICB9KVxyXG5cclxuXHJcbiAgICBUb29scy5leHRlbmQobnMsIHtcclxuICAgICAgICBpZDogXCJWZWM0XCIsXHJcbiAgICAgICAga2luZDogS0lORFMuRkxPQVQ0LFxyXG4gICAgICAgIG9iamVjdDoge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcjogVG9vbHMuVmVjLmdlbmVyYXRlQ29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIHN0YXRpYzoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIGluc3RhbmNlOiBWZWM0SW5zdGFuY2VcclxuICAgIH0pO1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxyXG4gICAgICAgIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2NvbW1vbi5qc1wiKSxcclxuICAgICAgICBGdW5jdGlvbkFubm90YXRpb24gPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hbm5vdGF0aW9uLmpzXCIpLkZ1bmN0aW9uQW5ub3RhdGlvbixcclxuICAgICAgICBTaGFkZSA9IHJlcXVpcmUoXCIuLy4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVHlwZXMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBhbmFseXNlcyA9IHJlcXVpcmUoJ2FuYWx5c2VzJyksXHJcbiAgICAgICAgVG9vbHMgPSByZXF1aXJlKCcuLi90b29scy5qcycpLFxyXG4gICAgICAgIFN5c3RlbSA9IHJlcXVpcmUoJy4vcmVnaXN0cnkvc3lzdGVtLmpzJyksXHJcbiAgICAgICAgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XHJcblxyXG5cclxuICAgIHZhciBDb250ZXh0ID0gcmVxdWlyZShcIi4vcmVnaXN0cnkvXCIpLkdMVHJhbnNmb3JtQ29udGV4dDtcclxuXHJcblxyXG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XHJcbiAgICB2YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XHJcbiAgICB2YXIgQU5OTyA9IGNvbW1vbi5BTk5PO1xyXG4gICAgdmFyIE1hcCA9IGNvbW1vbi5NYXA7XHJcbiAgICB2YXIgU2V0ID0gYW5hbHlzZXMuU2V0O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgdGhlIEpTIEFTVCB0byBhbiBBU1QgcmVwcmVzZW50YXRpb24gY29udmVuaWVudFxyXG4gICAgICogZm9yIGNvZGUgZ2VuZXJhdGlvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBHTEFTVFRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKHJvb3QsIG1haW5JZCwgdmVydGV4U2hhZGVyLCBvcHQpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXcgQ29udGV4dChyb290LCBtYWluSWQsIHZlcnRleFNoYWRlciwgb3B0KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5pZm9ybURlcGVuZGVuY3lNYXAodW5pZm9ybUV4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgdmFyIG5hbWUsIHVleHBTZXQsIGRlcGVuZGVuY2llcywgZGVwZW5kZW5jeSwgZGwsIGRlcGVuZGVuY3lNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgZm9yIChuYW1lIGluIHVuaWZvcm1FeHByZXNzaW9ucykge1xyXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSB1bmlmb3JtRXhwcmVzc2lvbnNbbmFtZV0uZGVwZW5kZW5jaWVzO1xyXG4gICAgICAgICAgICBkbCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChkbC0tKSB7XHJcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2RsXTtcclxuICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmN5TWFwLmhhcyhkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVleHBTZXQgPSBkZXBlbmRlbmN5TWFwLmdldChkZXBlbmRlbmN5KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWV4cFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TWFwLnNldChkZXBlbmRlbmN5LCB1ZXhwU2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHVleHBTZXQuYWRkKG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXBlbmRlbmN5TWFwO1xyXG4gICAgfVxyXG5cclxuICAgIEJhc2UuZXh0ZW5kKEdMQVNUVHJhbnNmb3JtZXIucHJvdG90eXBlLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0dMVHJhbnNmb3JtU2NvcGV9IHNjb3BlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVnaXN0ZXJUaGlzT2JqZWN0OiBmdW5jdGlvbiAoc2NvcGUpIHtcclxuICAgICAgICAgICAgdmFyIHRoaXNPYmplY3QgPSBzY29wZS5nZXRCaW5kaW5nQnlOYW1lKFwidGhpc1wiKTtcclxuICAgICAgICAgICAgaWYgKHRoaXNPYmplY3QgJiYgdGhpc09iamVjdC5pc09iamVjdCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXNPYmplY3QuZ2V0Tm9kZUluZm8oKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wID0gQU5OTyh7fSwgcHJvcGVydGllc1tuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wLmlzRGVyaXZlZCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuYmxvY2tlZE5hbWVzLnB1c2goVG9vbHMuZ2V0TmFtZUZvclN5c3RlbShuYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBTeXN0ZW0uZGVyaXZlZFBhcmFtZXRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBCYXNlLmRlZXBFeHRlbmQocHJvcGVydGllc1twcm9wZXJ0eV0sIFN5c3RlbS5kZXJpdmVkUGFyYW1ldGVyc1twcm9wZXJ0eV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEJhc2UuZXh0ZW5kKHRoaXMuY29udGV4dC5zeXN0ZW1QYXJhbWV0ZXJzLCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICBjcmVhdGVVbmlmb3JtU2V0dGVyRnVuY3Rpb246IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIC8vIFJldmVyc2UgdW5pZm9ybSBleHByZXNzaW9uIGRlcGVuZGVuY2llc1xyXG4gICAgICAgICAgICB2YXIgY19kZXBlbmRlbmN5TWFwID0gY3JlYXRlVW5pZm9ybURlcGVuZGVuY3lNYXAocGFyYW1ldGVycy51ZXhwKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZW52TmFtZXMsIHN5c05hbWVzLCBpbnB1dENvbGxlY3Rpb24sIGNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSwgYmFzZSwgb3ZlcnJpZGUsIHNyY05hbWUsIGRlc3ROYW1lLCB1bCwgdW5pZm9ybUxpc3Q7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW52TmFtZXMgJiYgaW5wdXRDb2xsZWN0aW9uLmVudkJhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpID0gZW52TmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBpbnB1dENvbGxlY3Rpb24uZW52QmFzZTtcclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZSA9IGlucHV0Q29sbGVjdGlvbi5lbnZPdmVycmlkZTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY05hbWUgPSBlbnZOYW1lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY19kZXBlbmRlbmN5TWFwLmhhcyhzcmNOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pZm9ybUxpc3QgPSBjX2RlcGVuZGVuY3lNYXAuZ2V0KHNyY05hbWUpLnZhbHVlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWwgPSB1bmlmb3JtTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSh1bC0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cE5hbWUgPSB1bmlmb3JtTGlzdFt1bF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJhbWV0ZXJzLnVleHBbZXhwTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZXhwcmVzc2lvbi5zZXR0ZXIuY2FsbChTaGFkZSwgaW5wdXRDb2xsZWN0aW9uLmVudkJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKGV4cE5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0TmFtZSA9IFRvb2xzLmdldE5hbWVGb3JHbG9iYWwoZW52TmFtZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtZXRlcnMuc2hhZGVyW2Rlc3ROYW1lXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYihkZXN0TmFtZSwgb3ZlcnJpZGUgJiYgb3ZlcnJpZGVbc3JjTmFtZV0gIT09IHVuZGVmaW5lZCA/IG92ZXJyaWRlW3NyY05hbWVdIDogYmFzZVtzcmNOYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLnNoYWRlcltkZXN0TmFtZV0ua2luZCA9PT0gU2hhZGUuT0JKRUNUX0tJTkRTLlRFWFRVUkUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKGRlc3ROYW1lICsgXCJfd2lkdGhcIiwgb3ZlcnJpZGUgJiYgb3ZlcnJpZGVbc3JjTmFtZV0gIT09IHVuZGVmaW5lZCA/IG92ZXJyaWRlW3NyY05hbWVdLndpZHRoIDogYmFzZVtzcmNOYW1lXSAmJiBiYXNlW3NyY05hbWVdWzBdLndpZHRoIHx8IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoZGVzdE5hbWUgKyBcIl9oZWlnaHRcIiwgb3ZlcnJpZGUgJiYgb3ZlcnJpZGVbc3JjTmFtZV0gIT09IHVuZGVmaW5lZCA/IG92ZXJyaWRlW3NyY05hbWVdLmhlaWdodCA6IGJhc2Vbc3JjTmFtZV0gJiYgYmFzZVtzcmNOYW1lXVswXS5oZWlnaHQgfHwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzeXNOYW1lcyAmJiBpbnB1dENvbGxlY3Rpb24uc3lzQmFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBzeXNOYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGlucHV0Q29sbGVjdGlvbi5zeXNCYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjTmFtZSA9IHN5c05hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0TmFtZSA9IFRvb2xzLmdldE5hbWVGb3JTeXN0ZW0oc3lzTmFtZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYihkZXN0TmFtZSwgYmFzZVtzcmNOYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dCxcclxuICAgICAgICAgICAgICAgIHByb2dyYW0gPSBjb250ZXh0LnJvb3QsXHJcbiAgICAgICAgICAgICAgICBzY29wZSA9IGNvbnRleHQuY3JlYXRlU2NvcGUodGhpcy5jb250ZXh0LnJvb3QsIG51bGwsIFwiZ2xvYmFsXCIpLFxyXG4gICAgICAgICAgICAgICAgbmFtZSwgZGVjbGFyYXRpb247XHJcblxyXG4gICAgICAgICAgICBzY29wZS5yZWdpc3Rlckdsb2JhbHMoKTtcclxuICAgICAgICAgICAgY29udGV4dC5wdXNoU2NvcGUoc2NvcGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZWdpc3RlclRoaXNPYmplY3Qoc2NvcGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGFsc28gYmxvY2sgc3lzdGVtUGFyYW1ldGVycyBoZXJlLiBXZSBjYW4gYmxvY2sgYWxsIHN5c3RlbSBuYW1lcywgZXZlbiBpZiBub3QgdXNlZC5cclxuICAgICAgICAgICAgZm9yKG5hbWUgaW4gY29udGV4dC5nbG9iYWxQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYmxvY2tlZE5hbWVzLnB1c2goIFRvb2xzLmdldE5hbWVGb3JHbG9iYWwobmFtZSkgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKHByb2dyYW0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVzZWRQYXJhbWV0ZXJzID0gY29udGV4dC51c2VkUGFyYW1ldGVycztcclxuICAgICAgICAgICAgZm9yICh2YXIgY29udGFpbmVyIGluIHVzZWRQYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gdXNlZFBhcmFtZXRlcnNbY29udGFpbmVyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gY3JlYXRlVG9wRGVjbGFyYXRpb24obmFtZSwgdXNlZFBhcmFtZXRlcnNbY29udGFpbmVyXVtuYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gJiYgcHJvZ3JhbS5ib2R5LnVuc2hpZnQoZGVjbGFyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5pZm9ybVNldHRlciA9IHRoaXMuY3JlYXRlVW5pZm9ybVNldHRlckZ1bmN0aW9uKHVzZWRQYXJhbWV0ZXJzKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB1c2VyRGF0YSA9IEFOTk8ocHJvZ3JhbSkuZ2V0VXNlckRhdGEoKTtcclxuICAgICAgICAgICAgdXNlckRhdGEuaW50ZXJuYWxGdW5jdGlvbnMgPSBjb250ZXh0LmludGVybmFsRnVuY3Rpb25zO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHsgcHJvZ3JhbTogcHJvZ3JhbSwgdW5pZm9ybVNldHRlcjogdW5pZm9ybVNldHRlciwgaGVhZGVyczogY29udGV4dC5oZWFkZXJzfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QhfSBhc3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXBsYWNlOiBmdW5jdGlvbihhc3QpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgd2Fsay5Db250cm9sbGVyKCksXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBhc3QgPSBjb250cm9sbGVyLnJlcGxhY2UoYXN0LCB7XHJcblxyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguSWRlbnRpZmllcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRlcklkZW50aWZpZXIobm9kZSwgcGFyZW50LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguSWZTdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50ZXJJZlN0YXRlbWVudChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRlckZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24obm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKG5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlYXZlTWVtYmVyRXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5OZXdFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlYXZlTmV3RXhwcmVzc2lvbihub2RlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTG9naWNhbEV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVMb2dpY2FsRXhwcmVzc2lvbihub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQ2FsbEV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVDYWxsRXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5VbmFyeUV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVVbmFyeUV4cHJlc3Npb24obm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhdmVSZXR1cm5TdGF0ZW1lbnQobm9kZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkJpbmFyeUV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlQmluYXJ5RXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIGNvbnRleHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYXN0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlSW5mb1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHZhciBjcmVhdGVUb3BEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHR5cGVJbmZvKXtcclxuICAgICAgICB2YXIgcHJvcGVydHlMaXRlcmFsID0gIHsgdHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IG5hbWV9O1xyXG4gICAgICAgIHZhciBwcm9wZXJ0eUFubm90YXRpb24gPSAgQU5OTyhwcm9wZXJ0eUxpdGVyYWwpO1xyXG4gICAgICAgIHByb3BlcnR5QW5ub3RhdGlvbi5zZXRGcm9tRXh0cmEodHlwZUluZm8pO1xyXG5cclxuICAgICAgICBpZiAocHJvcGVydHlBbm5vdGF0aW9uLmlzTnVsbE9yVW5kZWZpbmVkKCkgfHwgcHJvcGVydHlBbm5vdGF0aW9uLmlzRGVyaXZlZCgpIHx8IHByb3BlcnR5QW5ub3RhdGlvbi5pc0Z1bmN0aW9uKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYoIHByb3BlcnR5QW5ub3RhdGlvbi5pc09mVHlwZShUeXBlcy5BUlJBWSkgJiYgdHlwZUluZm8uc3RhdGljU2l6ZSA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIHZhciBkZWNsID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbixcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcixcclxuICAgICAgICAgICAgICAgICAgICBpZDogcHJvcGVydHlMaXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgICAgIGluaXQ6IG51bGxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAga2luZDogXCJ2YXJcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGRlY2xBbm5vdGF0aW9uID0gIEFOTk8oZGVjbC5kZWNsYXJhdGlvbnNbMF0pO1xyXG4gICAgICAgIGRlY2xBbm5vdGF0aW9uLmNvcHkocHJvcGVydHlBbm5vdGF0aW9uKTtcclxuICAgICAgICByZXR1cm4gZGVjbDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGVudGVySWRlbnRpZmllciA9IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCwgc3RhdGUpe1xyXG4gICAgICAgIHZhciBibG9ja2VkTmFtZXMgPSBzdGF0ZS5ibG9ja2VkTmFtZXM7XHJcbiAgICAgICAgdmFyIGlkTmFtZU1hcCA9IHN0YXRlLmlkTmFtZU1hcDtcclxuXHJcbiAgICAgICAgaWYocGFyZW50LnR5cGUgPT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xyXG4gICAgICAgIGlmKGlkTmFtZU1hcFtuYW1lXSkge1xyXG4gICAgICAgICAgICBub2RlLm5hbWUgPSBpZE5hbWVNYXBbbmFtZV07XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3TmFtZSA9IFRvb2xzLmdlbmVyYXRlRnJlZU5hbWUobmFtZSwgYmxvY2tlZE5hbWVzKTtcclxuICAgICAgICBpZE5hbWVNYXBbbmFtZV0gPSBuZXdOYW1lO1xyXG4gICAgICAgIG5vZGUubmFtZSA9IG5ld05hbWU7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBhICFudW1iZXIgZXhwcmVzc2lvbiBpbnRvIGFuIGJpbmFyeSBleHByZXNzaW9uLCBudW1iZXIgPT0gMFxyXG4gICAgICogQHBhcmFtIG5vZGVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICB2YXIgbGVhdmVVbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgaWYobm9kZS5vcGVyYXRvciA9PSBcIiFcIikge1xyXG4gICAgICAgICAgICB2YXIgYXJndW1lbnQgPSBBTk5PKG5vZGUuYXJndW1lbnQpO1xyXG4gICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcclxuICAgICAgICAgICAgc3dpdGNoKGFyZ3VtZW50LmdldFR5cGUoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlcy5JTlQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVzLk5VTUJFUjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPT1cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbm9kZS5hcmd1bWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5MaXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFyZ3VtZW50LmdldFR5cGUoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHJldHVybiBpbiB0aGUgbWFpbiBmdW5jdGlvbnMgc2V0cyBnbF9GcmFnQ29sb3Igb3IgZGlzY2FyZCBpZiB0aGVcclxuICAgICAqIG1haW4gbWV0aG9kIHJldHVybnMgd2l0aG91dCBhcmd1bWVudFxyXG4gICAgICogQHBhcmFtIG5vZGVcclxuICAgICAqIEBwYXJhbSB7R0xUcmFuc2Zvcm1Db250ZXh0fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgdmFyIGxlYXZlUmV0dXJuU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBzY29wZSA9IGNvbnRleHQuZ2V0U2NvcGUoKSwgZnJhZ0NvbG9ycztcclxuXHJcbiAgICAgICAgaWYoIWNvbnRleHQuaW5NYWluRnVuY3Rpb24oKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAobm9kZS5hcmd1bWVudCkge1xyXG4gICAgICAgICAgICB2YXIgYXJndW1lbnQgPSBBTk5PKG5vZGUuYXJndW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnQuaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICAgICAgIGNvbnRleHQuYWRkSGVhZGVyKFwiI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZVwiKTtcclxuICAgICAgICAgICAgICAgZnJhZ0NvbG9ycyA9IHt0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsIGJvZHk6IFtdfTtcclxuICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudC5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhZ0NvbG9ycy5ib2R5LnB1c2goY3JlYXRlR0xGcmFnQ29sb3IoVG9vbHMuY2FzdFRvVmVjNChlbGVtZW50LCBzY29wZSksIGluZGV4LCBjb250ZXh0KSk7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZnJhZ0NvbG9ycyA9IGNyZWF0ZUdMRnJhZ0NvbG9yKFRvb2xzLmNhc3RUb1ZlYzQobm9kZS5hcmd1bWVudCwgc2NvcGUpLCB1bmRlZmluZWQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBib2R5OiBbIGZyYWdDb2xvcnMsIHsgdHlwZTogU3ludGF4LlJldHVyblN0YXRlbWVudCB9IF1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50LFxyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImRpc2NhcmRcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSB0aGUgbWFpbiBmdW5jdGlvbiBpbnRvIGEgR0xTTCBjb25mb3JtIG1haW4gZnVuY3Rpb25cclxuICAgICAqIHdpdGggc2lnbmF0dXJlICd2b2lkIG1haW4odm9pZCknXHJcbiAgICAgKiBAcGFyYW0gbm9kZVxyXG4gICAgICovXHJcbiAgICB2YXIgbGVhdmVNYWluRnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIGFubm8gPSBuZXcgRnVuY3Rpb25Bbm5vdGF0aW9uKG5vZGUpO1xyXG4gICAgICAgIGFubm8uc2V0UmV0dXJuSW5mbyh7IHR5cGU6IFR5cGVzLlVOREVGSU5FRCB9KTtcclxuXHJcbiAgICAgICAgLy8gTWFpbiBoYXMgbm8gcGFyYW1ldGVyc1xyXG4gICAgICAgIG5vZGUucGFyYW1zID0gW107XHJcbiAgICAgICAgLy8gUmVuYW1lIHRvICdtYWluJ1xyXG4gICAgICAgIG5vZGUuaWQubmFtZSA9IFwibWFpblwiO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2cobm9kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUdMRnJhZ0NvbG9yKHJlc3VsdCwgaW5kZXgsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgbmFtZTtcclxuICAgICAgICBpZihjb250ZXh0LnZlcnRleFNoYWRlcil7XHJcbiAgICAgICAgICAgIG5hbWUgPSBcImdsX1Bvc2l0aW9uXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoaW5kZXggIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG5hbWUgPSBcImdsX0ZyYWdEYXRhW1wiICsgaW5kZXggKyBcIl1cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgbmFtZSA9IFwiZ2xfRnJhZ0NvbG9yXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcclxuICAgICAgICAgICAgbGVmdDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJpZ2h0OiByZXN1bHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE5hbWVPZk5vZGUobm9kZSkge1xyXG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5uYW1lO1xyXG4gICAgICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE5hbWVPZk5vZGUobm9kZS5vYmplY3QpICsgXCIuXCIgKyBnZXROYW1lT2ZOb2RlKG5vZGUucHJvcGVydHkpO1xyXG4gICAgICAgICAgICBjYXNlIFN5bnRheC5OZXdFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE5hbWVPZk5vZGUobm9kZS5jYWxsZWUpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidW5rbm93bihcIiArIG5vZGUudHlwZSArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbm9kZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudFxyXG4gICAgICogQHBhcmFtIHtHTFRyYW5zZm9ybUNvbnRleHR9IGNvbnRleHRcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICB2YXIgbGVhdmVDYWxsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgc2NvcGUgPSBjb250ZXh0LmdldFNjb3BlKCk7XHJcblxyXG4gICAgICAgIC8qKiBGaWx0ZXIgb3V0IHVuZGVmaW5lZCBhcmd1bWVudHMsIHdlIGRvIHRoZSBzYW1lIGZvciB0aGUgZGVjbGFyYXRpb24gKi9cclxuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IG5vZGUuYXJndW1lbnRzLmZpbHRlcihmdW5jdGlvbihhKSB7IHJldHVybiAhQU5OTyhhKS5pc1VuZGVmaW5lZCgpfSk7XHJcblxyXG4gICAgICAgIC8vIElzIHRoaXMgYSBjYWxsIG9uIGFuIG9iamVjdD9cclxuICAgICAgICBpZiAobm9kZS5jYWxsZWUudHlwZSA9PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICB2YXIgY2FsbGVlUmVmZXJlbmNlID0gY29tbW9uLmdldFR5cGVJbmZvKG5vZGUuY2FsbGVlLCBzY29wZSk7XHJcbiAgICAgICAgICAgIGlmKCEoY2FsbGVlUmVmZXJlbmNlICYmIGNhbGxlZVJlZmVyZW5jZS5pc0Z1bmN0aW9uKCkpKVxyXG4gICAgICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihub2RlLCBcIlNvbWV0aGluZyB3ZW50IHdyb25nIGluIHR5cGUgaW5mZXJlbmNlLCBcIiArIG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSBub2RlLmNhbGxlZS5vYmplY3QsXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUgPSBub2RlLmNhbGxlZS5wcm9wZXJ0eS5uYW1lO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9iamVjdFJlZmVyZW5jZSA9IGNvbW1vbi5nZXRUeXBlSW5mbyhvYmplY3QsIHNjb3BlKTtcclxuICAgICAgICAgICAgaWYoIW9iamVjdFJlZmVyZW5jZSkgIHtcclxuICAgICAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJJbnRlcm5hbDogTm8gdHlwZSBpbmZvIGZvcjogXCIgKyBvYmplY3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgb2JqZWN0SW5mbyA9IHNjb3BlLmdldE9iamVjdEluZm9Gb3Iob2JqZWN0UmVmZXJlbmNlKTtcclxuICAgICAgICAgICAgaWYoIW9iamVjdEluZm8pIHsgLy8gRXZlcnkgb2JqZWN0IG5lZWRzIGFuIGluZm8sIG90aGVyd2lzZSB3ZSBkaWQgc29tZXRoaW5nIHdyb25nXHJcbiAgICAgICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiSW50ZXJuYWwgRXJyb3I6IE5vIG9iamVjdCByZWdpc3RlcmVkIGZvcjogXCIgKyBvYmplY3RSZWZlcmVuY2UuZ2V0VHlwZVN0cmluZygpICsgXCIsIFwiICsgZ2V0TmFtZU9mTm9kZShub2RlLmNhbGxlZS5vYmplY3QpK1wiLCBcIitub2RlLmNhbGxlZS5vYmplY3QudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9iamVjdEluZm8uaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5SGFuZGxlciA9IG9iamVjdEluZm9bcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlIYW5kbGVyLmNhbGxFeHAgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBjb21tb24uY3JlYXRlVHlwZUluZm8obm9kZS5hcmd1bWVudHMsIHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHlIYW5kbGVyLmNhbGxFeHAobm9kZSwgYXJncywgcGFyZW50LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIGxlYXZlTmV3RXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5ld0V4cHJlc3Npb24sIGNvbnRleHQpe1xyXG4gICAgICAgIHZhciBzY29wZSA9IGNvbnRleHQuZ2V0U2NvcGUoKTtcclxuICAgICAgICB2YXIgZW50cnkgPSBzY29wZS5nZXRCaW5kaW5nQnlOYW1lKG5ld0V4cHJlc3Npb24uY2FsbGVlLm5hbWUpO1xyXG4gICAgICAgIC8vY29uc29sZS5lcnJvcihlbnRyeSk7XHJcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5Lmhhc0NvbnN0cnVjdG9yKCkpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gZW50cnkuZ2V0Q29uc3RydWN0b3IoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yKG5ld0V4cHJlc3Npb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWZlcmVuY2VFcnJvcjogXCIgKyBuZXdFeHByZXNzaW9uLmNhbGxlZS5uYW1lICsgXCIgaXMgbm90IGRlZmluZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5vZGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRcclxuICAgICAqIEBwYXJhbSB7R0xUcmFuc2Zvcm1Db250ZXh0fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgdmFyIGxlYXZlTWVtYmVyRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gbm9kZS5wcm9wZXJ0eS5uYW1lLFxyXG4gICAgICAgICAgICBzY29wZSA9IGNvbnRleHQuZ2V0U2NvcGUoKSxcclxuICAgICAgICAgICAgcGFyYW1ldGVyTmFtZSxcclxuICAgICAgICAgICAgcHJvcGVydHlMaXRlcmFsO1xyXG5cclxuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uKG5vZGUsIHBhcmVudCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihBTk5PKG5vZGUpLmlzVW5pZm9ybUV4cHJlc3Npb24oKSkge1xyXG4gICAgICAgICAgICB2YXIgdWV4cCA9IGhhbmRsZVVuaWZvcm1FeHByZXNzaW9uKG5vZGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZih1ZXhwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVleHA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb2JqZWN0UmVmZXJlbmNlID0gY29tbW9uLmdldFR5cGVJbmZvKG5vZGUub2JqZWN0LCBzY29wZSk7XHJcblxyXG4gICAgICAgIGlmICghb2JqZWN0UmVmZXJlbmNlIHx8ICFvYmplY3RSZWZlcmVuY2UuaXNPYmplY3QoKSkge1xyXG4gICAgICAgICAgICBTaGFkZS50aHJvd0Vycm9yKG5vZGUsIFwiSW50ZXJuYWwgRXJyb3I6IE9iamVjdCBvZiBNZW1iZXIgZXhwcmVzc2lvbiBpcyBubyBvYmplY3QuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciBvYmplY3RJbmZvID0gc2NvcGUuZ2V0T2JqZWN0SW5mb0ZvcihvYmplY3RSZWZlcmVuY2UpO1xyXG4gICAgICAgIGlmKCFvYmplY3RJbmZvKSB7Ly8gRXZlcnkgb2JqZWN0IG5lZWRzIGFuIGluZm8sIG90aGVyd2lzZSB3ZSBkaWQgc29tZXRoaW5nIHdyb25nXHJcbiAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJJbnRlcm5hbCBFcnJvcjogTm8gb2JqZWN0IHJlZ2lzdGVyZWQgZm9yOiBcIiArIG9iamVjdFJlZmVyZW5jZS5nZXRUeXBlU3RyaW5nKCkgKyBKU09OLnN0cmluZ2lmeShub2RlLm9iamVjdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEluZm8uaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSlcclxuICAgICAgICAgICAgU2hhZGUudGhyb3dFcnJvcihub2RlLCBcIkludGVybmFsIEVycm9yOiBPYmplY3Qgb2YgdHlwZSBcIiArIG9iamVjdFJlZmVyZW5jZS5nZXRUeXBlU3RyaW5nKCkgKyBcIiBoYXMgbm8gcHJvcGVydHkgJ1wiICsgcHJvcGVydHlOYW1lICtcIidcIik7XHJcblxyXG4gICAgICAgIHZhciBwcm9wZXJ0eUhhbmRsZXIgPSBvYmplY3RJbmZvW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eUhhbmRsZXIucHJvcGVydHkgPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUhhbmRsZXIucHJvcGVydHkobm9kZSwgcGFyZW50LCBzY29wZSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdXNlZFBhcmFtZXRlcnMgPSBjb250ZXh0LnVzZWRQYXJhbWV0ZXJzO1xyXG4gICAgICAgIGlmKG9iamVjdFJlZmVyZW5jZS5pc0dsb2JhbCgpKSB7XHJcbiAgICAgICAgICAgIHBhcmFtZXRlck5hbWUgPSBUb29scy5nZXROYW1lRm9yR2xvYmFsKHByb3BlcnR5TmFtZSk7XHJcbiAgICAgICAgICAgIGlmKCF1c2VkUGFyYW1ldGVycy5zaGFkZXIuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHVzZWRQYXJhbWV0ZXJzLnNoYWRlcltwYXJhbWV0ZXJOYW1lXSA9IGNvbnRleHQuZ2xvYmFsUGFyYW1ldGVyc1twcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcm9wZXJ0eUxpdGVyYWwgPSAgeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogcGFyYW1ldGVyTmFtZX07XHJcbiAgICAgICAgICAgIEFOTk8ocHJvcGVydHlMaXRlcmFsKS5jb3B5KEFOTk8obm9kZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlMaXRlcmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5vYmplY3QudHlwZSA9PSBTeW50YXguVGhpc0V4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgcGFyYW1ldGVyTmFtZSA9IFRvb2xzLmdldE5hbWVGb3JTeXN0ZW0ocHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgICAgaWYoIXVzZWRQYXJhbWV0ZXJzLnN5c3RlbS5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXJOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgdXNlZFBhcmFtZXRlcnMuc3lzdGVtW3BhcmFtZXRlck5hbWVdID0gY29udGV4dC5zeXN0ZW1QYXJhbWV0ZXJzW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByb3BlcnR5TGl0ZXJhbCA9ICB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBwYXJhbWV0ZXJOYW1lfTtcclxuICAgICAgICAgICAgQU5OTyhwcm9wZXJ0eUxpdGVyYWwpLmNvcHkoQU5OTyhub2RlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUxpdGVyYWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbm9kZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudFxyXG4gICAgICogQHBhcmFtIHtHTEFTVFRyYW5zZm9ybWVyfSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIHZhciBoYW5kbGVDb21wdXRlZE1lbWJlckV4cHJlc3Npb24gPSBmdW5jdGlvbihub2RlLCBwYXJlbnQsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgb2JqZWN0UmVmZXJlbmNlID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLm9iamVjdCk7XHJcbiAgICAgICAgaWYgKCFvYmplY3RSZWZlcmVuY2UuaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJJbiBzaGFkZS5qcywgW10gYWNjZXNzIGlzIG9ubHkgYWxsb3dlZCBvbiBhcnJheXMuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvcGVydHlUeXBlID0gIGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5wcm9wZXJ0eSk7XHJcbiAgICAgICAgaWYoIXByb3BlcnR5VHlwZS5jYW5JbnQoKSl7XHJcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICBjYWxsZWU6IHt0eXBlOiBcIklkZW50aWZpZXJcIiwgbmFtZTogXCJpbnRcIn0sXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFsgbm9kZS5wcm9wZXJ0eV1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBBTk5PKG5vZGUucHJvcGVydHkpLnNldFR5cGUoVHlwZXMuSU5UKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50XHJcbiAgICAgKiBAcGFyYW0ge0dMQVNUVHJhbnNmb3JtZXJ9IGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgdmFyIGhhbmRsZUJpbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBjb250ZXh0KSB7XHJcbiAgICAgICAgLy8gSW4gR0wsIHdlIGNhbid0IG1peCB1cCBmbG9hdHMsIGludHMgYW5kIGJvb2wgZm9yIGJpbmFyeSBleHByZXNzaW9uc1xyXG4gICAgICAgIHZhciBsZWZ0ID0gY29udGV4dC5nZXRUeXBlSW5mbyhub2RlLmxlZnQpLFxyXG4gICAgICAgICAgICByaWdodCA9IGNvbnRleHQuZ2V0VHlwZUluZm8obm9kZS5yaWdodCk7XHJcblxyXG4gICAgICAgIGlmIChsZWZ0LmlzTnVtYmVyKCkgJiYgcmlnaHQuaXNJbnQoKSkge1xyXG4gICAgICAgICAgICBub2RlLnJpZ2h0ID0gVG9vbHMuY2FzdFRvRmxvYXQobm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0LmlzTnVtYmVyKCkgJiYgbGVmdC5pc0ludCgpKSB7XHJcbiAgICAgICAgICAgIG5vZGUubGVmdCA9IFRvb2xzLmNhc3RUb0Zsb2F0KG5vZGUubGVmdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobm9kZS5vcGVyYXRvciA9PSBcIiVcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gVG9vbHMuYmluYXJ5RXhwcmVzc2lvbjJGdW5jdGlvbkNhbGwobm9kZSwgXCJtb2RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKmZ1bmN0aW9uIGNhc3RUb0ludChhc3QsIGZvcmNlKSB7XHJcbiAgICAgICAgdmFyIGV4cCA9IEFOTk8oYXN0KTtcclxuXHJcbiAgICAgICAgaWYgKCFleHAuaXNJbnQoKSB8fCBmb3JjZSkgeyAgIC8vIENhc3RcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgIGNhbGxlZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaW50XCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFthc3RdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc3Q7XHJcbiAgICB9OyovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG4gICAgICogQHBhcmFtIHtHTFRyYW5zZm9ybUNvbnRleHR9IGNvbnRleHRcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICB2YXIgZW50ZXJGdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBzY29wZSA9IGNvbnRleHQuY3JlYXRlU2NvcGUobm9kZSwgY29udGV4dC5nZXRTY29wZSgpLCBub2RlLmlkLm5hbWUpO1xyXG4gICAgICAgIGNvbnRleHQucHVzaFNjb3BlKHNjb3BlKTtcclxuXHJcbiAgICAgICAgdmFyIG5ld1BhcmFtZXRlckxpc3QgPSBbXTtcclxuICAgICAgICAvLyBSZW1vdmUgcGFyYW1ldGVycyBvZiB0eXBlIHVuZGVmaW5lZCAodGhlc2UgYXJlIG5vdCB1c2VkIGFueXdheSlcclxuICAgICAgICBub2RlLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgZGVjbGFyZSB1bmRlZmluZWQgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICBpZighQU5OTyhhKS5pc1VuZGVmaW5lZCgpKXtcclxuICAgICAgICAgICAgICAgIG5ld1BhcmFtZXRlckxpc3QucHVzaChhKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZ0J5TmFtZShhLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYoIWJpbmRpbmcuaXNVbmRlZmluZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZERlY2xhcmF0aW9uKGEubmFtZSwgYmluZGluZywgbm9kZS5ib2R5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vZGUucGFyYW1zID0gbmV3UGFyYW1ldGVyTGlzdDtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG4gICAgICogQHBhcmFtIHtHTFRyYW5zZm9ybUNvbnRleHR9IGNvbnRleHRcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICB2YXIgbGVhdmVGdW5jdGlvbkRlY2xhcmF0aW9uID0gZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciB3YXNNYWluID0gY29udGV4dC5pbk1haW5GdW5jdGlvbigpO1xyXG4gICAgICAgIGNvbnRleHQucG9wU2NvcGUoKTtcclxuICAgICAgICBpZiAod2FzTWFpbilcclxuICAgICAgICAgICAgcmV0dXJuIGxlYXZlTWFpbkZ1bmN0aW9uKG5vZGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmFyIGVudGVySWZTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciB0ZXN0ID0gQU5OTyhub2RlLnRlc3QpO1xyXG5cclxuICAgICAgIGFzc2VydCghdGVzdC5oYXNTdGF0aWNWYWx1ZSgpLCBcIlN0YXRpYyB2YWx1ZSBpbiBJZlN0YXRlbWVudCB0ZXN0XCIpO1xyXG4gICAgICAgYXNzZXJ0KCF0ZXN0LmlzT2JqZWN0KCksIFwiT2JqZWN0IGluIElmU3RhdGVtZW50IHRlc3RcIik7XHJcblxyXG4gICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXHJcbiAgICAgICAgc3dpdGNoKHRlc3QuZ2V0VHlwZSgpKSB7XHJcbiAgICAgICAgICAgLy8gVHJhbnNmb3JtICdpZihudW1iZXIpJyBpbnRvICdpZihudW1iZXIgIT0gMCknXHJcbiAgICAgICAgICAgY2FzZSBUeXBlcy5JTlQ6XHJcbiAgICAgICAgICAgY2FzZSBUeXBlcy5OVU1CRVI6XHJcbiAgICAgICAgICAgICAgIG5vZGUudGVzdCA9IHtcclxuICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIT1cIixcclxuICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5vZGUudGVzdCxcclxuICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkxpdGVyYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGVzdC5nZXRUeXBlKClcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZWQgdG8gdHJhbnNmb3JtIHRydXRoIGV4cHJlc3Npb25zIGluIHJlYWwgYm9vbGVhbiBleHByZXNzaW9uLCBiZWNhdXNlIHNvbWV0aGluZyBsaWtlIGlmKDApIGlzXHJcbiAgICAgKiBub3QgYWxsb3dlZCBpbiBHTFNMXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5vZGVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICB2YXIgbGVhdmVMb2dpY2FsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgbGVmdCA9IEFOTk8obm9kZS5sZWZ0KTtcclxuICAgICAgICB2YXIgcmlnaHQgPSBBTk5PKG5vZGUucmlnaHQpO1xyXG5cclxuICAgICAgICBpZiAobGVmdC5pc0Jvb2woKSAmJiByaWdodC5pc0Jvb2woKSkge1xyXG4gICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIG9rYXksIG5vIG5lZWQgdG8gbW9kaWZ5IGFueXRoaW5nXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vdyB3ZSBoYXZlIHRvIGltcGxlbWVudCB0aGUgSlMgYm9vbGVhbiBzZW1hbnRpYyBmb3IgR0xTTFxyXG4gICAgICAgIGlmIChsZWZ0LmNhbk51bWJlcigpKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gIG5vZGUubGVmdDtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICB0ZXN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPT1cIixcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0ZXN0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5MaXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbGVmdC5pc051bWJlcigpID8gMC4wIDogbGVmdC5pc0ludCgpID8gMCA6IFwiZmFsc2VcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgOiBsZWZ0LmdldFR5cGUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1ZhbHVlOiBsZWZ0LmlzTnVtYmVyKCkgPyAwLjAgOiBsZWZ0LmlzSW50KCkgPyAwIDogXCJmYWxzZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhOiB7IHR5cGU6IFR5cGVzLkJPT0xFQU4gfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQ6IG5vZGUucmlnaHQsXHJcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGU6IHRlc3RcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBoYW5kbGVVbmlmb3JtRXhwcmVzc2lvbihub2RlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBleHAgPSBBTk5PKG5vZGUpLFxyXG4gICAgICAgICAgICAgICAgZXh0cmE7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXhwLmlzVW5pZm9ybUV4cHJlc3Npb24oKSAmJiAhKGV4cC5nZXRTb3VyY2UoKSA9PSBTaGFkZS5TT1VSQ0VTLlVOSUZPUk0pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdW5pZm9ybU5hbWUgPSBub2RlLnByb3BlcnR5Lm5hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQudXNlZFBhcmFtZXRlcnMudWV4cC5oYXNPd25Qcm9wZXJ0eSh1bmlmb3JtTmFtZSkpIHsgLy8gUmV1c2VcclxuICAgICAgICAgICAgICAgICAgICBleHRyYSA9IGNvbnRleHQudXNlZFBhcmFtZXRlcnMudWV4cFt1bmlmb3JtTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHVuaWZvcm1OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmFcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgbmV3IHVuaWZvcm0gZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgZXh0cmEgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZighY29udGV4dC51bmlmb3JtRXhwcmVzc2lvbnMuaGFzT3duUHJvcGVydHkodW5pZm9ybU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWw6IE5vIGluZm9ybWF0aW9uIGFib3V0IHVuaWZvcm0gZXhwcmVzc2lvbiBhdmFpbGFibGU6IFwiICsgU2hhZGUudG9KYXZhU2NyaXB0KG5vZGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4dHJhLnNldHRlciA9IGdlbmVyYXRlVW5pZm9ybVNldHRlcihleHAsIGNvbnRleHQudW5pZm9ybUV4cHJlc3Npb25zW3VuaWZvcm1OYW1lXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh1bmlmb3JtTmFtZSwgZXh0cmEuc2V0dGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBleHRyYS50eXBlID0gZXhwLmdldFR5cGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChleHAuaXNPYmplY3QoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLmtpbmQgPSBleHAuZ2V0S2luZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXh0cmEuc291cmNlID0gU2hhZGUuU09VUkNFUy5VTklGT1JNO1xyXG4gICAgICAgICAgICAgICAgZXh0cmEuZGVwZW5kZW5jaWVzID0gZXhwLmdldFVuaWZvcm1EZXBlbmRlbmNpZXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LnVzZWRQYXJhbWV0ZXJzLnVleHBbdW5pZm9ybU5hbWVdID0gZXh0cmE7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB1bmlmb3JtTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBleHRyYTogZXh0cmFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVVuaWZvcm1TZXR0ZXIodW5pZm9ybUFubm8sIGV4cHJlc3Npb25JbmZvKSB7XHJcbiAgICAgICAgdmFyIGNvZGUgPSBleHByZXNzaW9uSW5mby5jb2RlO1xyXG4gICAgICAgIGlmKHVuaWZvcm1Bbm5vLmlzT2JqZWN0KCkpXHJcbiAgICAgICAgICAgIGNvZGUgPSBcIihcIiArIGV4cHJlc3Npb25JbmZvLmNvZGUgKyBcIikuX3RvRmxvYXRBcnJheSgpXCI7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IFwicmV0dXJuIFwiICsgY29kZSArIFwiO1wiO1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJlbnZcIiwgc291cmNlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGREZWNsYXJhdGlvbihuYW1lLCB0eXBlSW5mbywgdGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIHRhcmdldENvbnRhaW5lciwgZGVjbGFyYXRpb247XHJcbiAgICAgICAgc3dpdGNoICh0YXJnZXQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFN5bnRheC5CbG9ja1N0YXRlbWVudDpcclxuICAgICAgICAgICAgICAgIHRhcmdldENvbnRhaW5lciA9IHRhcmdldC5ib2R5O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbDogYWRkRGVjbGFyYXRpb24gdG8gXCIgKyB0YXJnZXQudHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXRDb250YWluZXIubGVuZ3RoICYmIHRhcmdldENvbnRhaW5lclswXS50eXBlID09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgZGVjbGFyYXRpb24gPSB0YXJnZXRDb250YWluZXJbMF07XHJcbiAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMucHVzaChkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnNbMF0pKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLFxyXG4gICAgICAgICAgICAgICAga2luZDogXCJ2YXJcIixcclxuICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW11cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YXJnZXRDb250YWluZXIudW5zaGlmdChkZWNsYXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkZWNsYXJhdG9yID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yLFxyXG4gICAgICAgICAgICBpZDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGluaXQ6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIEFOTk8oZGVjbGFyYXRvcikuY29weSh0eXBlSW5mbyk7XHJcbiAgICAgICAgZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRvcik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEV4cG9ydHNcclxuICAgIG5zLkdMQVNUVHJhbnNmb3JtZXIgPSBHTEFTVFRyYW5zZm9ybWVyO1xyXG5cclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2NvbW1vbi5qc1wiKSxcclxuICAgICAgICBwYXJzZXIgPSByZXF1aXJlKCdlc3ByaW1hJyksXHJcbiAgICAgICAgU2hhZGUgPSByZXF1aXJlKFwiLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxyXG4gICAgICAgIFR5cGVzID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS2luZHMgPSBTaGFkZS5PQkpFQ1RfS0lORFMsXHJcbiAgICAgICAgYW5hbHl6ZXIgPSByZXF1aXJlKFwiLi4vLi4vYW5hbHl6ZS9hbmFseXplLmpzXCIpO1xyXG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XHJcbiAgICB2YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XHJcblxyXG4gICAgdmFyIFRlbXBsYXRlID0gcmVxdWlyZShcIi4vbGlnaHQtcGFzcy10ZW1wbGF0ZVwiKS5MaWdodFBhc3NUZW1wbGF0ZTtcclxuICAgIHZhciBBcmdTdG9yYWdlVHlwZSA9IHJlcXVpcmUoXCIuLi8uLi9yZXNvbHZlL3htbDNkLWdsc2wtZGVmZXJyZWQvY29sb3ItY2xvc3VyZS1zaWduYXR1cmUuanNcIikuQXJnU3RvcmFnZVR5cGU7XHJcblxyXG4gICAgdmFyIFBSRV9URVhUVVJFX0ZFVENIRVMgPSAyLFxyXG4gICAgICAgIFBPU0lUSU9OX0lTX0lOX0FSR1MgPSB0cnVlLFxyXG4gICAgICAgIFRFWENPT1JEX05BTUUgPSBcInRleGNvb3JkXCIsXHJcbiAgICAgICAgREVGRVJSRURfVEVYX1BSRUZJWCA9IFwiZGVmZXJyZWRcIixcclxuICAgICAgICBERUZFUlJFRF9WQUxVRV9QUkVGSVggPSBcImRlZmVycmVkXCI7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0SW5wdXRBcmdEZWNsYXJhdGlvbihjb2xvckNsb3N1cmVTaWduYXR1cmUpe1xyXG4gICAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSBbXTtcclxuICAgICAgICB2YXIgZGVmYXVsdEFyZ0NvdW50ID0gUE9TSVRJT05fSVNfSU5fQVJHUyA/IDMgOiAyO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb2xvckNsb3N1cmVTaWduYXR1cmUuYXJncy5sZW5ndGggLSBkZWZhdWx0QXJnQ291bnQ7ICsraSl7XHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9ucy5wdXNoKHsgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcixcclxuICAgICAgICAgICAgaWQ6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJjY1wiICsgY29sb3JDbG9zdXJlU2lnbmF0dXJlLmlkICsgXCJBcmdcIiArIGl9LFxyXG4gICAgICAgICAgICBpbml0OiBudWxsfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLFxyXG4gICAgICAgICAgICBraW5kOiBcInZhclwiLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGRlY2xhcmF0aW9uc1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVGV4TWV0aG9kQWNjZXNzKHRleElkLCBtZXRob2Qpe1xyXG4gICAgICAgIHJldHVybiB7dHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICBjYWxsZWU6IHsgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogREVGRVJSRURfVkFMVUVfUFJFRklYICsgdGV4SWQgfSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IG1ldGhvZH19LFxyXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtdfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgRmV0Y2hSZXNvbHZlciA9IHt9O1xyXG4gICAgRmV0Y2hSZXNvbHZlcltBcmdTdG9yYWdlVHlwZS5GTE9BVF0gPSBmdW5jdGlvbihhcmcpe1xyXG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWU7XHJcbiAgICAgICAgc3dpdGNoKGFyZy5jb21wb25lbnRJZHgpe1xyXG4gICAgICAgICAgICBjYXNlIDA6IGZ1bmN0aW9uTmFtZSA9IFwieFwiOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOiBmdW5jdGlvbk5hbWUgPSBcInlcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjogZnVuY3Rpb25OYW1lID0gXCJ6XCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6IGZ1bmN0aW9uTmFtZSA9IFwid1wiOyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRleE1ldGhvZEFjY2VzcyhhcmcudGV4SWR4LCBmdW5jdGlvbk5hbWUpO1xyXG4gICAgfVxyXG4gICAgRmV0Y2hSZXNvbHZlcltBcmdTdG9yYWdlVHlwZS5GTE9BVDJdID0gZnVuY3Rpb24oYXJnKXtcclxuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lO1xyXG4gICAgICAgIHN3aXRjaChhcmcuY29tcG9uZW50SWR4KXtcclxuICAgICAgICAgICAgY2FzZSAwOiBmdW5jdGlvbk5hbWUgPSBcInh5XCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6IGZ1bmN0aW9uTmFtZSA9IFwieXpcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjogZnVuY3Rpb25OYW1lID0gXCJ6d1wiOyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRleE1ldGhvZEFjY2VzcyhhcmcudGV4SWR4LCBmdW5jdGlvbk5hbWUpO1xyXG4gICAgfVxyXG4gICAgRmV0Y2hSZXNvbHZlcltBcmdTdG9yYWdlVHlwZS5GTE9BVDNdID0gZnVuY3Rpb24oYXJnKXtcclxuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lO1xyXG4gICAgICAgIHN3aXRjaChhcmcuY29tcG9uZW50SWR4KXtcclxuICAgICAgICAgICAgY2FzZSAwOiBmdW5jdGlvbk5hbWUgPSBcInh5elwiOyBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOiBmdW5jdGlvbk5hbWUgPSBcInl6d1wiOyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVRleE1ldGhvZEFjY2VzcyhhcmcudGV4SWR4LCBmdW5jdGlvbk5hbWUpO1xyXG4gICAgfVxyXG4gICAgRmV0Y2hSZXNvbHZlcltBcmdTdG9yYWdlVHlwZS5GTE9BVDRdID0gZnVuY3Rpb24oYXJnKXtcclxuICAgICAgICByZXR1cm4gY3JlYXRlVGV4TWV0aG9kQWNjZXNzKGFyZy50ZXhJZHgsIFwieHl6d1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRUZXh0dXJlU2FtcGxlcyhzdGF0ZW1lbnRzLCBjb2xvckNsb3N1cmVTaWduYXR1cmUpe1xyXG4gICAgICAgIGZvcih2YXIgaSA9IFBSRV9URVhUVVJFX0ZFVENIRVM7IGkgPCBjb2xvckNsb3N1cmVTaWduYXR1cmUudGV4dHVyZUNvdW50OyArK2kpe1xyXG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goXHJcbiAgICAgICAgICAgIHt0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHt0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sIG9wZXJhdG9yOiBcIj1cIixcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBERUZFUlJFRF9WQUxVRV9QUkVGSVggKyBpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHsgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IHt0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDoge3R5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcImVudlwifSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBERUZFUlJFRF9URVhfUFJFRklYICsgaSB9fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IFwic2FtcGxlMkRcIn19LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFt7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBURVhDT09SRF9OQU1FIH1dXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRBcmd1bWVudEZldGNoaW5nKHN0YXRlbWVudHMsIGNvbG9yQ2xvc3VyZVNpZ25hdHVyZSl7XHJcbiAgICAgICAgdmFyIGlkID0gY29sb3JDbG9zdXJlU2lnbmF0dXJlLmlkO1xyXG4gICAgICAgIHZhciBkZWZhdWx0QXJnQ291bnQgPSBQT1NJVElPTl9JU19JTl9BUkdTID8gMyA6IDI7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBjb2xvckNsb3N1cmVTaWduYXR1cmUuYXJncztcclxuICAgICAgICBmb3IodmFyIGkgPSBkZWZhdWx0QXJnQ291bnQ7IGkgPCBhcmdzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XHJcbiAgICAgICAgICAgIGlmKCFGZXRjaFJlc29sdmVyW2FyZy5zdG9yZVR5cGVdKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RvcmVUeXBlICdcIiArIGFyZy5zdG9yZVR5cGUgKyBcIicgbm90IHN1cHBvcnRlZCBpbiBsaWdodCBwYXNzIHNoYWRlclwiKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlRmV0Y2hBc3QgPSBGZXRjaFJlc29sdmVyW2FyZy5zdG9yZVR5cGVdKGFyZyk7XHJcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaCh7dHlwZTogU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB7dHlwZTogU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uLCBvcGVyYXRvcjogXCI9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcImNjXCIgKyBpZCArIFwiQXJnXCIgKyAoaSAtIGRlZmF1bHRBcmdDb3VudCl9LFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB2YWx1ZUZldGNoQXN0XHJcbiAgICAgICAgICAgICAgICAgICAgfX0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb2xvckNsb3N1cmVBcmdzKGlkLCBjY0VudHJ5KXtcclxuICAgICAgICB2YXIgZGVmYXVsdEFyZ0NvdW50ID0gUE9TSVRJT05fSVNfSU5fQVJHUyA/IDMgOiAyO1xyXG4gICAgICAgIHZhciBhcmdzID0gW10sIGFyZ0luZGljZXMgPSBjY0VudHJ5LmFyZ0luZGljZXM7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ0luZGljZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goe3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcImNjXCIgKyBpZCArIFwiQXJnXCIgKyAoYXJnSW5kaWNlc1tpXSAtIGRlZmF1bHRBcmdDb3VudCl9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyZ3M7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UmV0dXJuU3RhdGVtZW50KGNvbG9yQ2xvc3VyZVNpZ25hdHVyZSl7XHJcblxyXG4gICAgICAgIHZhciByZXR1cm5Bcmd1bWVudCA9IHsgdHlwZTogU3ludGF4Lk5ld0V4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIGNhbGxlZToge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcIlNoYWRlXCJ9LFxyXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtdfTtcclxuICAgICAgICB2YXIgY2NMaXN0ID0gY29sb3JDbG9zdXJlU2lnbmF0dXJlLmNvbG9yQ2xvc3VyZXM7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNjTGlzdC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gZ2V0Q29sb3JDbG9zdXJlQXJncyhjb2xvckNsb3N1cmVTaWduYXR1cmUuaWQsIGNjTGlzdFtpXSk7XHJcbiAgICAgICAgICAgIHJldHVybkFyZ3VtZW50ID0geyAgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZToge3R5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHJldHVybkFyZ3VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBjY0xpc3RbaV0ubmFtZX19LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJnc307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge3R5cGU6IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgIGFyZ3VtZW50OiByZXR1cm5Bcmd1bWVudH07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldElmU3RhdGVtZW50KGNvbG9yQ2xvc3VyZVNpZ25hdHVyZSl7XHJcbiAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcclxuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goZ2V0SW5wdXRBcmdEZWNsYXJhdGlvbihjb2xvckNsb3N1cmVTaWduYXR1cmUpKTtcclxuICAgICAgICBhZGRUZXh0dXJlU2FtcGxlcyhzdGF0ZW1lbnRzLCBjb2xvckNsb3N1cmVTaWduYXR1cmUpO1xyXG4gICAgICAgIGFkZEFyZ3VtZW50RmV0Y2hpbmcoc3RhdGVtZW50cywgY29sb3JDbG9zdXJlU2lnbmF0dXJlKTtcclxuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goZ2V0UmV0dXJuU3RhdGVtZW50KGNvbG9yQ2xvc3VyZVNpZ25hdHVyZSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gIHsgdHlwZTogU3ludGF4LklmU3RhdGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHRlc3Q6IHt0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbiwgb3BlcmF0b3I6IFwiPT1cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcImNjSWRcIn0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB7dHlwZTogU3ludGF4LkxpdGVyYWwsIHZhbHVlOiBjb2xvckNsb3N1cmVTaWduYXR1cmUuaWQgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVudDogeyB0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHN0YXRlbWVudHN9LFxyXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0ZTogbnVsbFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBucy5nZW5lcmF0ZUxpZ2h0UGFzc0FzdCA9IGZ1bmN0aW9uKGNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMpe1xyXG4gICAgICAgIHZhciBsaWdodFBhc3NBc3Q7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsaWdodFBhc3NBc3QgPSBwYXJzZXIucGFyc2UoVGVtcGxhdGUudG9TdHJpbmcoKSwgeyByYXc6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGUpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gcGFyc2luZyBvZiBsaWdodFBhc3MgdGVtcGxhdGVcIiwgZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZnVuY3Rpb25CbG9jayA9IGxpZ2h0UGFzc0FzdC5ib2R5WzBdLmJvZHk7XHJcbiAgICAgICAgLy9mdW5jdGlvbkJsb2NrLmJvZHkucHVzaChnZXRJbnB1dEFyZ0RlY2xhcmF0aW9uKGNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMpKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc29sdmVkSWZTdGF0ZW1lbnRzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBpZihyZXNvbHZlZElmU3RhdGVtZW50cy5pbmRleE9mKGNvbG9yQ2xvc3VyZVNpZ25hdHVyZXNbaV0uaWQpID09IC0xKXtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVkSWZTdGF0ZW1lbnRzLnB1c2goY29sb3JDbG9zdXJlU2lnbmF0dXJlc1tpXS5pZCk7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkJsb2NrLmJvZHkucHVzaChnZXRJZlN0YXRlbWVudChjb2xvckNsb3N1cmVTaWduYXR1cmVzW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBsaWdodFBhc3NBc3Q7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIG5zLmdlbmVyYXRlTGlnaHRQYXNzQWFzdCA9IGZ1bmN0aW9uKGNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMsIGluamVjdCl7XHJcbiAgICAgICAgdmFyIGFzdCA9IG5zLmdlbmVyYXRlTGlnaHRQYXNzQXN0KGNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMpO1xyXG4gICAgICAgIGlmKCFhc3QpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgb3B0ID0ge307XHJcbiAgICAgICAgb3B0LmVudHJ5ID0gXCJnbG9iYWwuc2hhZGVcIjtcclxuICAgICAgICBvcHQudmFsaWRhdGUgPSB0cnVlO1xyXG4gICAgICAgIG9wdC50aHJvd09uRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIG9wdC5pbXBsZW1lbnRhdGlvbiA9IFwieG1sM2QtZ2xzbC1mb3J3YXJkXCI7XHJcbiAgICAgICAgb3B0LmluamVjdCA9IGluamVjdDtcclxuICAgICAgICBvcHQubGlnaHRMb29wTm9TcGFjZVRyYW5zZm9ybSA9IHRydWU7XHJcbiAgICAgICAgb3B0LmxpZ2h0TG9vcFBvc2l0aW9uQXJnID0ge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcInBvc2l0aW9uXCJ9O1xyXG4gICAgICAgIG9wdC5saWdodExvb3BBbWJpZW50QXJnID0ge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcImFtYmllbnRJbnRlbnNpdHlcIn07XHJcbiAgICAgICAgdmFyIHJlc3VsdEFhc3QgPSBhbmFseXplci5hbmFseXplKGFzdCwge30sIG9wdCkuYXN0O1xyXG4gICAgICAgIHJldHVybiByZXN1bHRBYXN0O1xyXG4gICAgfVxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICBucy5MaWdodFBhc3NUZW1wbGF0ZSA9IGZ1bmN0aW9uIHNoYWRlKGVudil7XHJcbiAgICAgICAgdmFyIHRleGNvb3JkID0gdGhpcy5ub3JtYWxpemVkQ29vcmRzLnh5KCk7XHJcbiAgICAgICAgdmFyIGRlZmVycmVkMCA9IGVudi5kZWZlcnJlZDAuc2FtcGxlMkQodGV4Y29vcmQpLFxyXG4gICAgICAgICAgICBkZWZlcnJlZDEgPSBlbnYuZGVmZXJyZWQxLnNhbXBsZTJEKHRleGNvb3JkKSxcclxuICAgICAgICAgICAgZGVmZXJyZWQyLCBkZWZlcnJlZDMsIGRlZmVycmVkNCwgZGVmZXJyZWQ1LCBkZWZlcnJlZDYsIGRlZmVycmVkNztcclxuICAgICAgICB2YXIgY2NJZCA9IGRlZmVycmVkMC54KCk7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZGVmZXJyZWQwLnl6dygpO1xyXG4gICAgICAgIHZhciBhbWJpZW50SW50ZW5zaXR5ID0gZGVmZXJyZWQxLngoKTtcclxuICAgIH07XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciB3YWxrID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxyXG4gICAgICAgIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIiksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxyXG4gICAgICAgIGNvbW1vbiA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxyXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVHlwZUluZm8gPSByZXF1aXJlKFwiLi4vLi4vYmFzZS90eXBlaW5mby5qc1wiKS5UeXBlSW5mbyxcclxuICAgICAgICBTdGF0ZW1lbnRTcGxpdFRyYXZlcnNlciA9IHJlcXVpcmUoXCIuLi8uLi9hbmFseXplL3Nhbml0aXplci9zdGF0ZW1lbnQtc3BsaXQtdHJhdmVyc2VyXCIpLFxyXG4gICAgICAgIFR5cGVzID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS2luZHMgPSBTaGFkZS5PQkpFQ1RfS0lORFMsXHJcbiAgICAgICAgQU5OTyA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTztcclxuXHJcbiAgICB2YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XHJcbiAgICB2YXIgVmlzaXRvck9wdGlvbiA9IHdhbGsuVmlzaXRvck9wdGlvbjtcclxuXHJcbiAgICB2YXIgRnVuY3Rpb25BcmdXcml0ZUR1cGxpY2F0b3IgPSBmdW5jdGlvbihvcHQpIHtcclxuICAgICAgICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcclxuICAgIH07XHJcbiAgICBCYXNlLmV4dGVuZChGdW5jdGlvbkFyZ1dyaXRlRHVwbGljYXRvci5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24ocm9vdCkge1xyXG4gICAgICAgICAgICB3YWxrLnJlcGxhY2Uocm9vdCwge1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IHRoaXMuZW50ZXJOb2RlLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgICAgICBsZWF2ZTogdGhpcy5leGl0Tm9kZS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbnRlck5vZGU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaFNjb3BlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZEFyZ0Fzc2lnbm1lbnRzKG5vZGUuYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Qcm9ncmFtOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaFNjb3BlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguVmFyaWFibGVEZWNsYXJhdG9yOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRGVjbGFyZWRJZGVudGlmaWVyKG5vZGUuaWQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBleGl0Tm9kZTogZnVuY3Rpb24obm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHN3aXRjaChub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZUlkZW50aWZpZXIobm9kZSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb246XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Qcm9ncmFtOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVTY29wZShub2RlLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcHVzaFNjb3BlOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHsgZGVjbGFyZWQ6IFtdLCBhcmdzOiB7fX07XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gbm9kZS5wYXJhbXM7XHJcbiAgICAgICAgICAgIGlmKHBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmFyZ3NbcGFyYW1zW2ldLm5hbWVdID0ge25hbWU6IHBhcmFtc1tpXS5uYW1lLCByZXBsYWNlOiBudWxsLCBleHRyYTogQmFzZS5kZWVwRXh0ZW5kKHt9LCBwYXJhbXNbaV0uZXh0cmEpfTtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5kZWNsYXJlZC5wdXNoKHBhcmFtc1tpXS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNjb3BlU3RhY2sucHVzaChzY29wZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXNvbHZlU2NvcGU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIHZhciB0b0JlRGVjbGFyZWQgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc2NvcGUuYXJncykge1xyXG4gICAgICAgICAgICAgICAgaWYoc2NvcGUuYXJnc1trZXldLnJlcGxhY2UpIHRvQmVEZWNsYXJlZC5wdXNoKHNjb3BlLmFyZ3Nba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hZGRUb3BEZWNsYXJhdGlvbihub2RlLCB0b0JlRGVjbGFyZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFNjb3BlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZmluZEFyZ0Fzc2lnbm1lbnRzOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICAgIHdhbGsudHJhdmVyc2Uobm9kZSwge1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IHRoaXMuYXNzaWdubWVudFNlYXJjaEVudGVyLmJpbmQodGhpcylcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhc3NpZ25tZW50U2VhcmNoRW50ZXI6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5Qcm9ncmFtOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkZ1bmN0aW9uRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG5vZGUudHlwZSAhPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pIHJldHVybjtcclxuICAgICAgICAgICAgaWYobm9kZS5sZWZ0LnR5cGUgIT0gU3ludGF4LklkZW50aWZpZXIpIHJldHVybjtcclxuICAgICAgICAgICAgaWYoQU5OTyhub2RlKS5nZXRUeXBlKCkgIT0gVHlwZXMuT0JKRUNUKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uU2tpcDtcclxuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcy5nZXRTY29wZSgpO1xyXG4gICAgICAgICAgICB2YXIgdmFyTmFtZSA9IG5vZGUubGVmdC5uYW1lO1xyXG4gICAgICAgICAgICBpZihzY29wZS5hcmdzW3Zhck5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBpZighc2NvcGUuYXJnc1t2YXJOYW1lXS5yZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Zhck5hbWUgPSB0aGlzLmdldEZyZWVWYXJOYW1lKFwiX2Rlc3RfXCIgKyB2YXJOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERlY2xhcmVkSWRlbnRpZmllcihuZXdWYXJOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5hcmdzW3Zhck5hbWVdLnJlcGxhY2UgPSBuZXdWYXJOYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBWaXNpdG9yT3B0aW9uLlNraXA7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXI6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICBpZihwYXJlbnQudHlwZSA9PSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbiB8fCBwYXJlbnQudHlwZSA9PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uKSByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHRoaXMuZ2V0U2NvcGUoKTtcclxuICAgICAgICAgICAgdmFyIGFyZyA9IHNjb3BlLmFyZ3Nbbm9kZS5uYW1lXTtcclxuICAgICAgICAgICAgaWYoYXJnICYmIGFyZy5yZXBsYWNlKVxyXG4gICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gYXJnLnJlcGxhY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0RnJlZVZhck5hbWU6IGZ1bmN0aW9uKHZhck5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhck5hbWUsIGkgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSh0aGlzLmlzVmFyRGVjbGFyZWQocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFyTmFtZSArIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzVmFyRGVjbGFyZWQ6IGZ1bmN0aW9uKHZhck5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuc2NvcGVTdGFja1tpXS5kZWNsYXJlZC5pbmRleE9mKHZhck5hbWUpICE9IC0xKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWRkVG9wRGVjbGFyYXRpb246IGZ1bmN0aW9uKG5vZGUsIGRlY2xhcmF0aW9ucykge1xyXG4gICAgICAgICAgICBpZihkZWNsYXJhdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY2xhcmF0b3JzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgYXNzaWdubWVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkZWNsYXJhdGlvbnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBkZWNsYXJhdGlvbnNbaV0ucmVwbGFjZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYTogZGVjbGFyYXRpb25zW2ldLmV4dHJhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3NpZ25tZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogeyB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBkZWNsYXJhdGlvbnNbaV0ucmVwbGFjZX0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogZGVjbGFyYXRpb25zW2ldLm5hbWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbm5vRGVjbGFyYXRpb24gPSBBTk5PKGRlY2xhcmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBBTk5PKGFzc2lnbm1lbnQuZXhwcmVzc2lvbikuY29weShhbm5vRGVjbGFyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIEFOTk8oYXNzaWdubWVudC5leHByZXNzaW9uLmxlZnQpLmNvcHkoYW5ub0RlY2xhcmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBBTk5PKGFzc2lnbm1lbnQuZXhwcmVzc2lvbi5yaWdodCkuY29weShhbm5vRGVjbGFyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0b3JzLnB1c2goZGVjbGFyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzLnB1c2goYXNzaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRlc3Q7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLnR5cGUgPT0gU3ludGF4LlByb2dyYW0pXHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdCA9IG5vZGUuYm9keTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYobm9kZS5ib2R5LmJvZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdCA9IG5vZGUuYm9keS5ib2R5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGRlc3QubGVuZ3RoID09IDAgfHwgZGVzdFswXS50eXBlICE9IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdC51bnNoaWZ0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRvcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IFwidmFyXCJcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkZXN0WzBdLmRlY2xhcmF0aW9ucy5wdXNoLmFwcGx5KGRlc3RbMF0uZGVjbGFyYXRpb25zLCBkZWNsYXJhdG9ycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5vbkRlY2xhcmF0aW9uSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUobm9uRGVjbGFyYXRpb25JbmRleCA8IGRlc3QubGVuZ3RoICYmIGRlc3Rbbm9uRGVjbGFyYXRpb25JbmRleF0udHlwZSA9PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vbkRlY2xhcmF0aW9uSW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzLnVuc2hpZnQobm9uRGVjbGFyYXRpb25JbmRleCwgMCk7XHJcbiAgICAgICAgICAgICAgICBkZXN0LnNwbGljZS5hcHBseShkZXN0LCBhc3NpZ25tZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWRkRGVjbGFyZWRJZGVudGlmaWVyOiBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB0b3BTY29wZSA9IHRoaXMuZ2V0U2NvcGUoKTtcclxuICAgICAgICAgICAgaWYodG9wU2NvcGUuZGVjbGFyZWQuaW5kZXhPZihuYW1lKSA9PSAtMSlcclxuICAgICAgICAgICAgICAgIHRvcFNjb3BlLmRlY2xhcmVkLnB1c2gobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIHZhciBTaW5nbGVBc3NpZ25tZW50U3BsaXR0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBTdGF0ZW1lbnRTcGxpdFRyYXZlcnNlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBCYXNlLmNyZWF0ZUNsYXNzKFNpbmdsZUFzc2lnbm1lbnRTcGxpdHRlciwgU3RhdGVtZW50U3BsaXRUcmF2ZXJzZXIsIHtcclxuXHJcblxyXG4gICAgICAgIHN0YXRlbWVudFNwbGl0RW50ZXI6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZpc2l0b3JPcHRpb24uU2tpcDtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTmV3RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fdXNlZEluZGV4ID0gdGhpcy5nZXRTdGF0ZW1lbnRUbXBVc2VkQ291bnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzdGF0ZW1lbnRTcGxpdEV4aXQ6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5DYWxsRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4Lk5ld0V4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbEV4aXQobm9kZSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4Lk1lbWJlckV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVtYmVyRXhpdChub2RlLCBwYXJlbnQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtZW1iZXJFeGl0OiBmdW5jdGlvbihub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGVBbm5vID0gQU5OTyhub2RlKTtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlQW5uby5nZXRUeXBlKCksIGtpbmQgPSBub2RlQW5uby5nZXRLaW5kKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXNlZEluZGV4ID0gbm9kZS5fdXNlZEluZGV4O1xyXG4gICAgICAgICAgICBkZWxldGUgbm9kZS5fdXNlZEluZGV4O1xyXG5cclxuICAgICAgICAgICAgaWYocGFyZW50LnR5cGUgPT0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uICYmIHBhcmVudC5sZWZ0ID09IG5vZGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZihpc1BhcmVudE5vbkFycmF5QXNzaWdubWVudChwYXJlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gRXh0cmFjdCBhcnJheSBhY2Nlc3M6XHJcbiAgICAgICAgICAgIGlmKG5vZGUuY29tcHV0ZWQgJiYgQU5OTyhub2RlLm9iamVjdCkuZ2V0VHlwZSgpID09IFR5cGVzLkFSUkFZICYmIHRoaXMuaXNPYmplY3RSZXN1bHQodHlwZSwga2luZCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVkdWNlU3RhdGVtZW50VG1wVXNlZCh1c2VkSW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyTm9kZSA9IHRoaXMuYWRkQXNzaWdubWVudCh0eXBlLCBraW5kLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyTm9kZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2FsbEV4aXQ6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG5vZGVBbm5vID0gQU5OTyhub2RlKTtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlQW5uby5nZXRUeXBlKCksIGtpbmQgPSBub2RlQW5uby5nZXRLaW5kKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXNlZEluZGV4ID0gbm9kZS5fdXNlZEluZGV4O1xyXG4gICAgICAgICAgICBkZWxldGUgbm9kZS5fdXNlZEluZGV4O1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5DYWxsRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3VtZW50SW5mbyA9IHRoaXMuZ2V0T2JqZWN0QXJnc0luZm8obm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZihhcmd1bWVudEluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihhcmd1bWVudEluZm8uZXh0cmFjdEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ1R5cGUgPSBhcmd1bWVudEluZm8udHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ0tpbmQgPSBhcmd1bWVudEluZm8ua2luZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0ge3R5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGdldENhbGxlZU5hbWUoYXJnS2luZCl9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudEluZm8uYXJnc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBBTk5PKG5ld05vZGUpLnNldFR5cGUoYXJnVHlwZSwgYXJnS2luZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBBcmdJZGVudGlmaWVyID0gdGhpcy5hZGRBc3NpZ25tZW50KGFyZ1R5cGUsIGFyZ0tpbmQsIG5ld05vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50cy5zcGxpY2UoYXJndW1lbnRJbmZvLmFyZ0luZGV4LCBhcmd1bWVudEluZm8uYXJncy5sZW5ndGgsIHRtcEFyZ0lkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihhcmd1bWVudEluZm8uc3dpenpsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5jb252ZXJ0VG9Td2l6emxlKG5vZGUuY2FsbGVlLm9iamVjdCwgbm9kZS5hcmd1bWVudHMsIGFyZ3VtZW50SW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzT2JqZWN0UmVzdWx0KHR5cGUsIGtpbmQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcblxyXG4gICAgICAgICAgICBpZihpc1BhcmVudE5vbkFycmF5QXNzaWdubWVudChwYXJlbnQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcblxyXG5cclxuICAgICAgICAgICAgdGhpcy5yZWR1Y2VTdGF0ZW1lbnRUbXBVc2VkKHVzZWRJbmRleCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllck5vZGUgPSB0aGlzLmFkZEFzc2lnbm1lbnQodHlwZSwga2luZCwgbm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyTm9kZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjb252ZXJ0VG9Td2l6emxlOiBmdW5jdGlvbihvYmplY3QsIGFyZ3VtZW50cywgc3dpenpsZUluZm8pIHtcclxuICAgICAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN3aXp6bGVSZWFkKG9iamVjdCwgc3dpenpsZUluZm8pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU3dpenpsZVdyaXRlKG9iamVjdCwgYXJndW1lbnRzWzBdLCBzd2l6emxlSW5mbyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWRkQXNzaWdubWVudDogZnVuY3Rpb24odHlwZSwga2luZCwgcmlnaHQpIHtcclxuICAgICAgICAgICAgdmFyIHRtcE5hbWUgPSB0aGlzLmdldEZyZWVOYW1lKHR5cGUsIGtpbmQpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFzc2lnbm1lbnQgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IHRtcE5hbWV9LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFOTk8oYXNzaWdubWVudCkuY29weShBTk5PKHJpZ2h0KSk7XHJcbiAgICAgICAgICAgIEFOTk8oYXNzaWdubWVudC5sZWZ0KS5jb3B5KEFOTk8ocmlnaHQpKTtcclxuICAgICAgICAgICAgdGhpcy5hc3NpZ25tZW50c1RvQmVQcmVwZW5kZWQucHVzaChhc3NpZ25tZW50KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVyTm9kZSA9IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogdG1wTmFtZX07XHJcbiAgICAgICAgICAgIEFOTk8oaWRlbnRpZmllck5vZGUpLmNvcHkoQU5OTyhyaWdodCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gaWRlbnRpZmllck5vZGU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNPYmplY3RSZXN1bHQ6IGZ1bmN0aW9uKHR5cGUsIGtpbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT0gVHlwZXMuT0JKRUNUO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0T2JqZWN0QXJnc0luZm86IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBraW5kOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgYXJnSW5kZXg6IDAsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZXh0cmFjdEFyZ3M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc3dpenpsZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIHN3aXp6bGVPcGVyYXRvcjogbnVsbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFnZXROb2RlQXJndW1lbnRUeXBlQW5kSW5kZXgobm9kZSwgcmVzdWx0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2FsbGVlTmFtZShraW5kKSB7XHJcbiAgICAgICAgc3dpdGNoKGtpbmQpIHtcclxuICAgICAgICAgICAgY2FzZSBLaW5kcy5GTE9BVDI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJWZWMyXCI7XHJcbiAgICAgICAgICAgIGNhc2UgS2luZHMuRkxPQVQzOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiVmVjM1wiO1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUNDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlZlYzRcIjtcclxuICAgICAgICAgICAgY2FzZSBLaW5kcy5NQVRSSVgzOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTWF0M1wiO1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLk1BVFJJWDQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJNYXQ0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gS2luZCAnXCIgKyBraW5kICsgXCInLCBubyBjYWxsZWUgYXZhaWxhYmxlLlwiKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVN3aXp6bGVSZWFkKG9iamVjdCwgc3dpenpsZUluZm8pIHtcclxuICAgICAgICB2YXIgc3dpenpsZXMgPSBzd2l6emxlSW5mby5zd2l6emxlO1xyXG4gICAgICAgIGlmKHN3aXp6bGVzLmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnRDYWxsKG9iamVjdCwgc3dpenpsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0geyB0eXBlOiBTeW50YXguTmV3RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgY2FsbGVlOiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IFwiVmVjXCIgKyBzd2l6emxlcy5sZW5ndGh9LFxyXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtdfTtcclxuICAgICAgICBBTk5PKHJlc3VsdCkuc2V0VHlwZShUeXBlcy5PQkpFQ1QsIGdldE9iamVjdEtpbmRCeUNvbXBvbmVudENvdW50KHN3aXp6bGVzLmxlbmd0aCkpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzd2l6emxlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gc3dpenpsZXNbaV07XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcmd1bWVudHMucHVzaChjcmVhdGVDb21wb25lbnRDYWxsKG9iamVjdCwgY29tcG9uZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlU3dpenpsZVdyaXRlKG9iamVjdCwgYXJnT2JqLCBzd2l6emxlSW5mbykge1xyXG4gICAgICAgIHZhciBvYmplY3RLaW5kID0gQU5OTyhvYmplY3QpLmdldEtpbmQoKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0geyB0eXBlOiBTeW50YXguTmV3RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgY2FsbGVlOiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGdldENhbGxlZU5hbWUob2JqZWN0S2luZCkgfSxcclxuICAgICAgICAgICAgYXJndW1lbnRzOiBbXX07XHJcbiAgICAgICAgQU5OTyhyZXN1bHQpLmNvcHkoQU5OTyhvYmplY3QpKTtcclxuICAgICAgICB2YXIgY29tcG9uZW50cyA9IGdldE9iamVjdENvbXBvbmVudENvdW50KG9iamVjdEtpbmQpO1xyXG4gICAgICAgIHZhciBzd2l6emxlcyA9IHN3aXp6bGVJbmZvLnN3aXp6bGU7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudE1hcCA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzd2l6emxlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb21wb25lbnRNYXBbZ2V0Q29tcG9uZW50SW5kZXgoc3dpenpsZXNbaV0pXSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3VtZW50O1xyXG4gICAgICAgICAgICBpZihjb21wb25lbnRNYXBbaV0gPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudCA9IGNyZWF0ZUNvbXBvbmVudENhbGwob2JqZWN0LCBnZXRDb21wb25lbnROYW1lKGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gc3dpenpsZXMubGVuZ3RoID09IDEgPyBhcmdPYmogOiBjcmVhdGVDb21wb25lbnRDYWxsKGFyZ09iaiwgZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRNYXBbaV0pKTtcclxuICAgICAgICAgICAgICAgIGlmKHN3aXp6bGVJbmZvLnN3aXp6bGVPcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0geyB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHN3aXp6bGVJbmZvLnN3aXp6bGVPcGVyYXRvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY3JlYXRlQ29tcG9uZW50Q2FsbChvYmplY3QsIGdldENvbXBvbmVudE5hbWUoaSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogYXJndW1lbnR9O1xyXG4gICAgICAgICAgICAgICAgICAgIEFOTk8oYXJndW1lbnQpLmNvcHkoQU5OTyhhcmd1bWVudC5sZWZ0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cy5wdXNoKGFyZ3VtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRJbmRleChzd2l6emxlQ29tcG9uZW50KSB7XHJcbiAgICAgICAgc3dpdGNoKHN3aXp6bGVDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgY2FzZSBcInhcIjpcclxuICAgICAgICAgICAgY2FzZSBcInJcIiA6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgY2FzZSBcInlcIjpcclxuICAgICAgICAgICAgY2FzZSBcImdcIiA6XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgY2FzZSBcInpcIjpcclxuICAgICAgICAgICAgY2FzZSBcImJcIiA6XHJcbiAgICAgICAgICAgIGNhc2UgXCJwXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICAgICAgY2FzZSBcIndcIjpcclxuICAgICAgICAgICAgY2FzZSBcImFcIiA6XHJcbiAgICAgICAgICAgIGNhc2UgXCJxXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBTd2l6emxlIENvbXBvbmVudCAnXCIgKyBzd2l6emxlQ29tcG9uZW50ICsgXCInXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50SW5kZXgpIHtcclxuICAgICAgICBzd2l0Y2goY29tcG9uZW50SW5kZXgpIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieFwiO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ5XCI7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInpcIjtcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwid1wiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRDYWxsKG9iamVjdCwgY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29tcG9uZW50ID0gZ2V0Q29tcG9uZW50TmFtZShnZXRDb21wb25lbnRJbmRleChjb21wb25lbnQpKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge3R5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgY2FsbGVlOiB7IHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLCBvYmplY3Q6IG9iamVjdCxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGNvbXBvbmVudCB9fSxcclxuICAgICAgICAgICAgYXJndW1lbnRzOiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQU5OTyhyZXN1bHQpLnNldFR5cGUoVHlwZXMuTlVNQkVSKTtcclxuICAgICAgICBBTk5PKHJlc3VsdC5jYWxsZWUpLnNldFR5cGUoVHlwZXMuRlVOQ1RJT04pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNQYXJlbnROb25BcnJheUFzc2lnbm1lbnQobm9kZSkge1xyXG4gICAgICAgIGlmKG5vZGUudHlwZSAhPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgaWYobm9kZS5sZWZ0LnR5cGUgPT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24gJiYgQU5OTyhub2RlLmxlZnQub2JqZWN0KS5pc0FycmF5KCkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Tm9kZUFyZ3VtZW50VHlwZUFuZEluZGV4KG5vZGUsIHJlc3VsdCkge1xyXG4gICAgICAgIGlmKG5vZGUuY2FsbGVlLnR5cGUgIT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgb2JqZWN0S2luZCA9IEFOTk8obm9kZS5jYWxsZWUub2JqZWN0KS5nZXRLaW5kKCk7XHJcbiAgICAgICAgaWYob2JqZWN0S2luZCA9PSBLaW5kcy5BTlkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgb2JqQ29tcG9uZW50Q250ID0gZ2V0T2JqZWN0Q29tcG9uZW50Q291bnQob2JqZWN0S2luZCk7XHJcbiAgICAgICAgdmFyIHJlcXVpcmVkQ29tcG9uZW50cyA9IGdldEFyZ1R5cGVhbmRJbmRleChvYmpDb21wb25lbnRDbnQsIG5vZGUuY2FsbGVlLnByb3BlcnR5Lm5hbWUsIHJlc3VsdCk7XHJcbiAgICAgICAgaWYoIXJlcXVpcmVkQ29tcG9uZW50cylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5hcmdJbmRleDtcclxuICAgICAgICB2YXIgcHJvdmlkZWRDb21wb25lbnRzID0gMDtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIHdoaWxlKGluZGV4IDwgbm9kZS5hcmd1bWVudHMubGVuZ3RoICYmIHByb3ZpZGVkQ29tcG9uZW50cyA8IHJlcXVpcmVkQ29tcG9uZW50cykge1xyXG4gICAgICAgICAgICB2YXIgYXJnID0gbm9kZS5hcmd1bWVudHNbaW5kZXhdO1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcclxuICAgICAgICAgICAgcHJvdmlkZWRDb21wb25lbnRzICs9IGdldE9iamVjdENvbXBvbmVudENvdW50KEFOTk8oYXJnKS5nZXRLaW5kKCkpO1xyXG4gICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuZXh0cmFjdEFyZ3MgPSB0cnVlO1xyXG4gICAgICAgIGlmKHByb3ZpZGVkQ29tcG9uZW50cyA9PSAwKVxyXG4gICAgICAgICAgICByZXN1bHQuZXh0cmFjdEFyZ3MgPSBmYWxzZTtcclxuICAgICAgICBpZihwcm92aWRlZENvbXBvbmVudHMgPT0gcmVxdWlyZWRDb21wb25lbnRzICYmIGFyZ3MubGVuZ3RoID09IDEpXHJcbiAgICAgICAgICAgIHJlc3VsdC5leHRyYWN0QXJncyA9IGZhbHNlO1xyXG4gICAgICAgIHJlc3VsdC5hcmdzID0gYXJncztcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE9iamVjdENvbXBvbmVudENvdW50KG9iamVjdEtpbmQpIHtcclxuICAgICAgICBzd2l0Y2gob2JqZWN0S2luZCkge1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUMjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUMzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAzO1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUNDpcclxuICAgICAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgICAgICBjYXNlIEtpbmRzLk1BVFJJWDM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gOTtcclxuICAgICAgICAgICAgY2FzZSBLaW5kcy5NQVRSSVg0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE2O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7IC8vIG11c3QgYmUgbnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE9iamVjdEtpbmRCeUNvbXBvbmVudENvdW50KGNvbXBvbmVudENvdW50KSB7XHJcbiAgICAgICAgc3dpdGNoKGNvbXBvbmVudENvdW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBLaW5kcy5GTE9BVDI7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBLaW5kcy5GTE9BVDM7XHJcbiAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBLaW5kcy5GTE9BVDQ7XHJcbiAgICAgICAgICAgIGNhc2UgOTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBLaW5kcy5NQVRSSVgzO1xyXG4gICAgICAgICAgICBjYXNlIDE2OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEtpbmRzLk1BVFJJWDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gT2JqZWN0IENvdW50ICdcIiArIGNvbXBvbmVudENvdW50ICsgXCInLCBubyBraW5kIGF2YWlsYWJsZS5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QXJnVHlwZWFuZEluZGV4KG9iakNvbXBvbmVudENudCwgbWV0aG9kTmFtZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIGlucHV0Q29tcG9uZW50Q250ID0gMCwgb2Zmc2V0SW5kZXggPSAwO1xyXG4gICAgICAgIHN3aXRjaChtZXRob2ROYW1lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2FkZCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3N1Yic6XHJcbiAgICAgICAgICAgIGNhc2UgJ211bCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2Rpdic6XHJcbiAgICAgICAgICAgIGNhc2UgJ21vZCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3JlZmxlY3QnOlxyXG4gICAgICAgICAgICBjYXNlICdjcm9zcyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2RvdCcgOlxyXG4gICAgICAgICAgICAgICAgaW5wdXRDb21wb25lbnRDbnQgPSBvYmpDb21wb25lbnRDbnQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGVuZ3RoJyA6XHJcbiAgICAgICAgICAgICAgICBpbnB1dENvbXBvbmVudENudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbm9ybWFsaXplJyA6XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZsaXAnIDpcclxuICAgICAgICAgICAgICAgIGlucHV0Q29tcG9uZW50Q250ID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtdWxWZWMnOlxyXG4gICAgICAgICAgICAgICAgaW5wdXRDb21wb25lbnRDbnQgPSAob2JqQ29tcG9uZW50Q250ID09IDE2ID8gNCA6IDMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NvbCc6XHJcbiAgICAgICAgICAgICAgICBpbnB1dENvbXBvbmVudENudCA9IChvYmpDb21wb25lbnRDbnQgPT0gMTYgPyA0IDogMyk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRJbmRleCA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHZhciBzd2l6emxlTWF0Y2hlcyA9IG1ldGhvZE5hbWUubWF0Y2goL14oW3h5endyZ2Jhc3RwcV17MSw0fSkoQWRkfFN1YnxNdWx8RGl2KT8kLyk7XHJcbiAgICAgICAgICAgICAgICBpZihzd2l6emxlTWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Q29tcG9uZW50Q250ID0gc3dpenpsZU1hdGNoZXNbMV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zd2l6emxlID0gc3dpenpsZU1hdGNoZXNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHN3aXp6bGVNYXRjaGVzWzJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBZGRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zd2l6emxlT3BlcmF0b3IgPSBcIitcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiU3ViXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3dpenpsZU9wZXJhdG9yID0gXCItXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk11bFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN3aXp6bGVPcGVyYXRvciA9IFwiKlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJEaXZcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zd2l6emxlT3BlcmF0b3IgPSBcIi9cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIXJlc3VsdC5zd2l6emxlICYmIGlucHV0Q29tcG9uZW50Q250IDw9IDEpIHJldHVybiAwO1xyXG4gICAgICAgIGlmKGlucHV0Q29tcG9uZW50Q250ID4gMSl7XHJcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gVHlwZXMuT0JKRUNUO1xyXG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGdldE9iamVjdEtpbmRCeUNvbXBvbmVudENvdW50KGlucHV0Q29tcG9uZW50Q250KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBUeXBlcy5OVU1CRVI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5hcmdJbmRleCA9IG9mZnNldEluZGV4O1xyXG4gICAgICAgIHJldHVybiBpbnB1dENvbXBvbmVudENudDtcclxuICAgIH1cclxuXHJcbiAgICBucy5zaW1wbGlmeVN0YXRlbWVudHMgPSBmdW5jdGlvbiAoYWFzdCwgb3B0KSB7XHJcbiAgICAgICAgdmFyIGZ1bmNBcmdXcml0ZUR1cGxpY2F0b3IgPSBuZXcgRnVuY3Rpb25BcmdXcml0ZUR1cGxpY2F0b3Iob3B0KTtcclxuICAgICAgICBhYXN0ID0gZnVuY0FyZ1dyaXRlRHVwbGljYXRvci5leGVjdXRlKGFhc3QpO1xyXG5cclxuICAgICAgICB2YXIgc2luZ2xlQXNzaWdubWVudFNwbGl0dGVyID0gbmV3IFNpbmdsZUFzc2lnbm1lbnRTcGxpdHRlcihvcHQpO1xyXG4gICAgICAgIGFhc3QgPSBzaW5nbGVBc3NpZ25tZW50U3BsaXR0ZXIuZXhlY3V0ZShhYXN0KTtcclxuICAgICAgICByZXR1cm4gYWFzdDtcclxuICAgIH07XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciB3YWxrID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxyXG4gICAgICAgIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIiksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2luZGV4LmpzXCIpLFxyXG4gICAgICAgIGNvbW1vbiA9IHJlcXVpcmUoXCIuLy4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxyXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgVHlwZUluZm8gPSByZXF1aXJlKFwiLi4vLi4vYmFzZS90eXBlaW5mby5qc1wiKS5UeXBlSW5mbyxcclxuICAgICAgICBTdGF0ZW1lbnRTcGxpdFRyYXZlcnNlciA9IHJlcXVpcmUoXCIuLi8uLi9hbmFseXplL3Nhbml0aXplci9zdGF0ZW1lbnQtc3BsaXQtdHJhdmVyc2VyXCIpLFxyXG4gICAgICAgIFR5cGVzID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS2luZHMgPSBTaGFkZS5PQkpFQ1RfS0lORFMsXHJcbiAgICAgICAgQU5OTyA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTztcclxuXHJcbiAgICB2YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XHJcbiAgICB2YXIgVmlzaXRvck9wdGlvbiA9IHdhbGsuVmlzaXRvck9wdGlvbjtcclxuXHJcbiAgICB2YXIgU05JUFBFVF9DT05WRVJURVJfTU9ERSA9IHtcclxuICAgICAgICBKU19JVEVSQVRFOiAxLFxyXG4gICAgICAgIEpTX05PX0lURVJBVEU6IDIsXHJcbiAgICAgICAgR0xTTF9WUzogM1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU25pcHBldENvbm5lY3RvciA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIEJhc2UuZXh0ZW5kKFNuaXBwZXRDb25uZWN0b3IucHJvdG90eXBlLCB7XHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24oc25pcHBldExpc3QsIG1vZGUpe1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdGVJZGVudGlmaWVyOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZW52TmFtZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGJsb2NrZWROYW1lczogW10sXHJcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcklucHV0TmFtZU1hcDoge30sXHJcbiAgICAgICAgICAgICAgICBvdXRwdXROYW1lTWFwOiBbXSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdElucHV0TmFtZU1hcDogW10sXHJcbiAgICAgICAgICAgICAgICBtb2RlOiBtb2RlLFxyXG4gICAgICAgICAgICAgICAgZGVjbGFyZU5hbWVzOiBbXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBnYXRoZXJPdXRwdXROYW1lcyhzbmlwcGV0TGlzdCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuaXRlcmF0ZUlkZW50aWZpZXIgPSBnZXRGcmVlTmFtZShcImlcIiwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmKGNvbnRleHQubW9kZSA9PSBTTklQUEVUX0NPTlZFUlRFUl9NT0RFLkdMU0xfVlMpe1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5lbnZOYW1lID0gZ2V0RnJlZU5hbWUoXCJlbnZcIiwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGFzdCA9IGNvbm5lY3RTbmlwcGV0cyhzbmlwcGV0TGlzdCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGFzdCA9IGdldFByb2dyYW0oYXN0LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIGFzdDogYXN0LFxyXG4gICAgICAgICAgICAgICAgYXJnVHlwZXM6IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYWRkQXJnVHlwZXMocmVzdWx0LCBjb250ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmdW5jdGlvbiBnYXRoZXJPdXRwdXROYW1lcyhzbmlwcGV0TGlzdCwgY29udGV4dCl7XHJcbiAgICAgICAgdmFyIGkgPSBzbmlwcGV0TGlzdC5lbnRyaWVzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzbmlwcGV0TGlzdC5lbnRyaWVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgaiA9IGVudHJ5Lm91dHB1dEluZm8ubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShqLS0pe1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dEluZm8gPSBlbnRyeS5vdXRwdXRJbmZvW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYob3V0cHV0SW5mby5pc0ZpbmFsKCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0RnJlZU5hbWUob3V0cHV0SW5mby5uYW1lLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRyYW5zZmVySW5wdXROYW1lTWFwW2kgKyBcIl9cIiArIGpdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vdXRwdXROYW1lTWFwW291dHB1dEluZm8uZmluYWxPdXRwdXRJbmRleF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG91dHB1dEluZm8udHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29ubmVjdFNuaXBwZXRzKHNuaXBwZXRMaXN0LCBjb250ZXh0KXtcclxuICAgICAgICB2YXIgYXN0ID0geyB0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsIGJvZHk6IFtdfTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc25pcHBldExpc3QuZW50cmllcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHNuaXBwZXRMaXN0LmVudHJpZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBzbmlwcGVkQ29udGV4dCA9IHtcclxuICAgICAgICAgICAgICAgIG91dHB1dE1hcDogY3JlYXRlT3V0cHV0TWFwKGVudHJ5LCBpLCBjb250ZXh0KSxcclxuICAgICAgICAgICAgICAgIGlucHV0TWFwOiBjcmVhdGVJbnB1dE1hcChlbnRyeSwgY29udGV4dCksXHJcbiAgICAgICAgICAgICAgICB0ZW1wb3JhcnlNYXA6IHt9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFkZFNuaXBwZWRBc3QoYXN0LmJvZHksIGVudHJ5LCBzbmlwcGVkQ29udGV4dCwgY29udGV4dCApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXN0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFByb2dyYW0oYXN0LCBjb250ZXh0KXtcclxuICAgICAgICB2YXIgcGFyYW1zID0gW107XHJcbiAgICAgICAgaWYoY29udGV4dC5tb2RlID09IFNOSVBQRVRfQ09OVkVSVEVSX01PREUuR0xTTF9WUyl7XHJcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogY29udGV4dC5lbnZOYW1lfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbnRleHQub3V0cHV0TmFtZU1hcC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGNvbnRleHQub3V0cHV0TmFtZU1hcFtpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goe3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBuYW1lfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbnRleHQuZGlyZWN0SW5wdXROYW1lTWFwLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY29udGV4dC5kaXJlY3RJbnB1dE5hbWVNYXBbaV0ubmFtZTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogbmFtZX0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBib2R5ID0gYXN0O1xyXG4gICAgICAgIGlmKGNvbnRleHQubW9kZSA9PSBTTklQUEVUX0NPTlZFUlRFUl9NT0RFLkpTX0lURVJBVEUpe1xyXG4gICAgICAgICAgICB2YXIgaXRlck1heCA9IGdldEZyZWVOYW1lKFwibWF4SXRlclwiLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goe3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBpdGVyTWF4fSk7XHJcbiAgICAgICAgICAgIGJvZHkgPSB7IHR5cGU6IFN5bnRheC5CbG9ja1N0YXRlbWVudCxcclxuICAgICAgICAgICAgICAgIGJvZHk6IFtcclxuICAgICAgICAgICAgICAgICAgICB7dHlwZTogU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24sIFwia2luZFwiOiBcInZhclwiLCBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge3R5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBjb250ZXh0Lml0ZXJhdGVJZGVudGlmaWVyfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogaXRlck1heH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF19LFxyXG4gICAgICAgICAgICAgICAgICAgIHt0eXBlOiBTeW50YXguV2hpbGVTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3Q6IHt0eXBlOiBTeW50YXguVXBkYXRlRXhwcmVzc2lvbiwgb3BlcmF0b3I6IFwiLS1cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGNvbnRleHQuaXRlcmF0ZUlkZW50aWZpZXJ9fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRCb2R5RGVjbGFyYXRpb25zKGJvZHksIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFN5bnRheC5Qcm9ncmFtLCBib2R5OiBbe1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbixcclxuICAgICAgICAgICAgaWQ6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJtYWluXCJ9LFxyXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgICAgZGVmYXVsdHM6IFtdLFxyXG4gICAgICAgICAgICBib2R5OiBib2R5XHJcbiAgICAgICAgfV19O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkQXJnVHlwZXMocmVzdWx0LCBjb250ZXh0KXtcclxuICAgICAgICB2YXIgYXJnVHlwZXMgPSBbXTtcclxuICAgICAgICBpZihjb250ZXh0Lm1vZGUgPT0gU05JUFBFVF9DT05WRVJURVJfTU9ERS5HTFNMX1ZTKXtcclxuXHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJzID0ge307XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmRpY2VzID0ge30sXHJcbiAgICAgICAgICAgICAgICBpbnB1dEluZGljZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb250ZXh0Lm91dHB1dE5hbWVNYXAubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gY29udGV4dC5vdXRwdXROYW1lTWFwW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBCYXNlLmRlZXBFeHRlbmQoe30sIGVudHJ5LnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgdHlwZS5zb3VyY2UgPSBcInZlcnRleFwiO1xyXG4gICAgICAgICAgICAgICAgdHlwZS5vdXRwdXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlic1tlbnRyeS5uYW1lXSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRJbmRpY2VzW2VudHJ5Lm5hbWVdID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY29udGV4dC5kaXJlY3RJbnB1dE5hbWVNYXAubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gY29udGV4dC5kaXJlY3RJbnB1dE5hbWVNYXBbaV07XHJcbiAgICAgICAgICAgICAgICBpZighZW50cnkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBCYXNlLmRlZXBFeHRlbmQoe30sIGVudHJ5LnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgdHlwZS5zb3VyY2UgPSBlbnRyeS5pdGVyYXRlID8gXCJ2ZXJ0ZXhcIiA6IFwidW5pZm9ybVwiO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlic1tlbnRyeS5uYW1lXSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICBpbnB1dEluZGljZXNbZW50cnkubmFtZV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBlbnYgPSB7IFwiZXh0cmFcIiA6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiYW55XCIsIFwiZ2xvYmFsXCI6IHRydWUsIFwiaW5mb1wiOiBhdHRyaWJzIH19O1xyXG4gICAgICAgICAgICBhcmdUeXBlcy5wdXNoKGVudik7XHJcbiAgICAgICAgICAgIHJlc3VsdC5vdXRwdXRJbmRpY2VzID0gb3V0cHV0SW5kaWNlcztcclxuICAgICAgICAgICAgcmVzdWx0LmlucHV0SW5kaWNlcyA9IGlucHV0SW5kaWNlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbnRleHQub3V0cHV0TmFtZU1hcC5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICBhcmdUeXBlcy5wdXNoKHtleHRyYToge3R5cGU6IFwiYXJyYXlcIiwgZWxlbWVudHM6IEJhc2UuZGVlcEV4dGVuZCh7fSwgY29udGV4dC5vdXRwdXROYW1lTWFwW2ldLnR5cGUpIH19KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY29udGV4dC5kaXJlY3RJbnB1dE5hbWVNYXAubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBCYXNlLmRlZXBFeHRlbmQoe30sIGNvbnRleHQuZGlyZWN0SW5wdXROYW1lTWFwW2ldLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYoIWNvbnRleHQuZGlyZWN0SW5wdXROYW1lTWFwW2ldLmFycmF5QWNjZXNzKVxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB7dHlwZTogXCJhcnJheVwiLCBlbGVtZW50czogdHlwZSB9O1xyXG4gICAgICAgICAgICAgICAgYXJnVHlwZXMucHVzaCh7ZXh0cmE6IHR5cGUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJnVHlwZXMucHVzaCh7IGV4dHJhOiB7dHlwZTogXCJpbnRcIn19KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlc3VsdC5hcmdUeXBlcyA9IGFyZ1R5cGVzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEJvZHlEZWNsYXJhdGlvbnMoYm9keSwgY29udGV4dCl7XHJcbiAgICAgICAgaWYoY29udGV4dC5kZWNsYXJlTmFtZXMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgZGVjbCA9IHt0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbiwgXCJraW5kXCI6IFwidmFyXCIsXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW119O1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb250ZXh0LmRlY2xhcmVOYW1lcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gY29udGV4dC5kZWNsYXJlTmFtZXNbaV07XHJcbiAgICAgICAgICAgIGRlY2wuZGVjbGFyYXRpb25zLnB1c2goe3R5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogbmFtZX0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdDogbnVsbH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBib2R5LmJvZHkudW5zaGlmdChkZWNsKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTbmlwcGVkQXN0KGRlc3QsIGVudHJ5LCBzbmlwcGVkQ29udGV4dCwgY29udGV4dCl7XHJcbiAgICAgICAgdmFyIGFzdEJvZHkgPSB3YWxrLnJlcGxhY2UoZW50cnkuYXN0LmJvZHksIHtcclxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5JZGVudGlmaWVyIDogcmV0dXJuIGhhbmRsZUlkZW50aWZpZXJFeGl0KG5vZGUsIHBhcmVudCwgc25pcHBlZENvbnRleHQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRvcjogcmV0dXJuIGhhbmRsZURlY2xhcmF0b3JFeGl0KG5vZGUsIHBhcmVudCwgc25pcHBlZENvbnRleHQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkJsb2NrU3RhdGVtZW50OiByZXR1cm4gaGFuZGxlQmxvY2tFeGl0KG5vZGUsIHBhcmVudCwgc25pcHBlZENvbnRleHQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LlJldHVyblN0YXRlbWVudDogcmV0dXJuIGhhbmRsZVJldHVybkV4aXQobm9kZSwgcGFyZW50LCBzbmlwcGVkQ29udGV4dCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBkZXN0LnB1c2guYXBwbHkoZGVzdCwgYXN0Qm9keS5ib2R5KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlSWRlbnRpZmllckV4aXQobm9kZSwgcGFyZW50LCBzbmlwcGVkQ29udGV4dCwgY29udGV4dCl7XHJcbiAgICAgICAgaWYocGFyZW50LnR5cGUgPT0gU3ludGF4LlByb3BlcnR5ICYmIHBhcmVudC5rZXkgPT0gbm9kZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmKHBhcmVudC50eXBlID09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZihzbmlwcGVkQ29udGV4dC50ZW1wb3JhcnlNYXBbbm9kZS5uYW1lXSl7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmlwcGVkQ29udGV4dC50ZW1wb3JhcnlNYXBbbm9kZS5uYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoc25pcHBlZENvbnRleHQuaW5wdXRNYXBbbm9kZS5uYW1lXSl7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmlwcGVkQ29udGV4dC5pbnB1dE1hcFtub2RlLm5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhbmRsZURlY2xhcmF0b3JFeGl0KG5vZGUsIHBhcmVudCwgc25pcHBlZENvbnRleHQsIGNvbnRleHQpe1xyXG4gICAgICAgIHZhciBuYW1lID0gbm9kZS5pZC5uYW1lO1xyXG4gICAgICAgIHZhciB0bXBOYW1lID0gZ2V0RnJlZU5hbWUobmFtZSwgY29udGV4dCk7XHJcbiAgICAgICAgY29udGV4dC5kZWNsYXJlTmFtZXMucHVzaCh0bXBOYW1lKTtcclxuICAgICAgICBzbmlwcGVkQ29udGV4dC50ZW1wb3JhcnlNYXBbbmFtZV0gPSB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiB0bXBOYW1lfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUJsb2NrRXhpdChub2RlLCBwYXJlbnQsIHNuaXBwZWRDb250ZXh0LCBjb250ZXh0KXtcclxuICAgICAgICB2YXIgaSA9IG5vZGUuYm9keS5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUoaS0tKXtcclxuICAgICAgICAgICAgaWYobm9kZS5ib2R5W2ldLnR5cGUgPT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgbm9kZS5ib2R5LnNwbGljZShpLDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlUmV0dXJuRXhpdChub2RlLCBwYXJlbnQsIHNuaXBwZWRDb250ZXh0LCBjb250ZXh0KXtcclxuICAgICAgICBpZihub2RlLmFyZ3VtZW50LnR5cGUgIT0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb24pe1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0TmFtZTtcclxuICAgICAgICAgICAgZm9yKG91dHB1dE5hbWUgaW4gc25pcHBlZENvbnRleHQub3V0cHV0TWFwKSBicmVhaztcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlc3VsdEFzc2lnbm1lbnQob3V0cHV0TmFtZSwgbm9kZS5hcmd1bWVudCwgc25pcHBlZENvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0geyB0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsIGJvZHk6IFtdIH07XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gbm9kZS5hcmd1bWVudC5wcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICB2YXIgYWRkUmV0dXJuID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dE5hbWUgPSBwcm9wLmtleS5uYW1lIHx8IHByb3Aua2V5LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYob3V0cHV0TmFtZSA9PSBcIl9nbFBvc2l0aW9uXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbnRleHQubW9kZSA9PSBTTklQUEVUX0NPTlZFUlRFUl9NT0RFLkdMU0xfVlMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRSZXR1cm4gPSBwcm9wLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmJvZHkucHVzaChjcmVhdGVSZXN1bHRBc3NpZ25tZW50KG91dHB1dE5hbWUsIHByb3AudmFsdWUsIHNuaXBwZWRDb250ZXh0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoYWRkUmV0dXJuKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IGFkZFJldHVyblxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSZXN1bHRBc3NpZ25tZW50KG5hbWUsIHZhbHVlLCBzbmlwcGVkQ29udGV4dCl7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQsIGV4cHJlc3Npb246IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbiwgb3BlcmF0b3I6IFwiPVwiLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogQmFzZS5kZWVwRXh0ZW5kKHt9LCBzbmlwcGVkQ29udGV4dC5vdXRwdXRNYXBbbmFtZV0pLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnB1dE1hcChlbnRyeSwgY29udGV4dCl7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIHZhciBpbnB1dEluZm8gPSBlbnRyeS5pbnB1dEluZm8sXHJcbiAgICAgICAgICAgIHBhcmFtcyA9IGVudHJ5LmFzdC5wYXJhbXM7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0SW5mby5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBpbmZvID0gaW5wdXRJbmZvW2ldO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1OYW1lID0gcGFyYW1zW2ldLm5hbWU7XHJcbiAgICAgICAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gZ2V0SW5wdXRBc3QocGFyYW1OYW1lLCBpbmZvLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRJbnB1dEFzdChuYW1lLCBpbmZvLCBjb250ZXh0KXtcclxuICAgICAgICB2YXIgYWN0dWFsTmFtZSwgcHVyZVRyYW5zZmVyID0gZmFsc2U7XHJcbiAgICAgICAgaWYoaW5mby5pc1RyYW5zZmVySW5wdXQoKSl7XHJcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGNvbnRleHQudHJhbnNmZXJJbnB1dE5hbWVNYXBbaW5mby5nZXRUcmFuc2ZlcklucHV0S2V5KCldO1xyXG4gICAgICAgICAgICBhY3R1YWxOYW1lID0gZW50cnkubmFtZTtcclxuICAgICAgICAgICAgcHVyZVRyYW5zZmVyID0gIWVudHJ5LmZpbmFsT3V0cHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbmZvLmRpcmVjdElucHV0SW5kZXg7XHJcbiAgICAgICAgICAgIGlmKCFjb250ZXh0LmRpcmVjdElucHV0TmFtZU1hcFtpbmRleF0pe1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBpbmZvLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZihpbmZvLmFycmF5QWNjZXNzKXtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID0ge3R5cGU6IFwiYXJyYXlcIiwgZWxlbWVudHM6IHR5cGUsIHN0YXRpY1NpemU6IGluZm8uYXJyYXlTaXplIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpcmVjdElucHV0TmFtZU1hcFtpbmRleF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZ2V0RnJlZU5hbWUobmFtZSwgY29udGV4dCksXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlOiBpbmZvLml0ZXJhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlBY2Nlc3M6IGluZm8uYXJyYXlBY2Nlc3NcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0dWFsTmFtZSA9IGNvbnRleHQuZGlyZWN0SW5wdXROYW1lTWFwW2luZGV4XS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYXN0ID0ge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBhY3R1YWxOYW1lfTtcclxuICAgICAgICBpZighcHVyZVRyYW5zZmVyKXtcclxuICAgICAgICAgICAgYXN0ID0gZ2V0UGFyYW1BY2Nlc3NBc3QoYXN0LCBpbmZvLmFycmF5QWNjZXNzLCBpbmZvLml0ZXJhdGUsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFzdFxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZU91dHB1dE1hcChlbnRyeSwgb3BlcmF0b3JJbmRleCwgY29udGV4dCl7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIHZhciBvdXRwdXRJbmZvID0gZW50cnkub3V0cHV0SW5mbztcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3V0cHV0SW5mby5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBpbmZvID0gb3V0cHV0SW5mb1tpXTtcclxuICAgICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IG91dHB1dEluZm9baV0ubmFtZTtcclxuICAgICAgICAgICAgcmVzdWx0W3BhcmFtTmFtZV0gPSBnZXRPdXRwdXRBc3QocGFyYW1OYW1lLCBpbmZvLCBvcGVyYXRvckluZGV4LCBpLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRPdXRwdXRBc3QobmFtZSwgaW5mbywgb3BlcmF0b3JJbmRleCwgb3V0cHV0SW5kZXgsIGNvbnRleHQpe1xyXG4gICAgICAgIHZhciBhY3R1YWxOYW1lLCBmaW5hbDtcclxuICAgICAgICBpZihpbmZvLmlzRmluYWwoKSl7XHJcbiAgICAgICAgICAgIGZpbmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgYWN0dWFsTmFtZSA9IGNvbnRleHQub3V0cHV0TmFtZU1hcFtpbmZvLmZpbmFsT3V0cHV0SW5kZXhdLm5hbWU7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGFjdHVhbE5hbWUgPSBnZXRGcmVlTmFtZShuYW1lLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgY29udGV4dC50cmFuc2ZlcklucHV0TmFtZU1hcFtvcGVyYXRvckluZGV4ICsgXCJfXCIgKyBvdXRwdXRJbmRleF0gPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBhY3R1YWxOYW1lLFxyXG4gICAgICAgICAgICAgICAgZmluYWxPdXRwdXQ6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnRleHQuZGVjbGFyZU5hbWVzLnB1c2goYWN0dWFsTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhc3QgPSB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGFjdHVhbE5hbWV9O1xyXG4gICAgICAgIGlmKGZpbmFsKXtcclxuICAgICAgICAgICAgYXN0ID0gZ2V0UGFyYW1BY2Nlc3NBc3QoYXN0LCBmYWxzZSwgdHJ1ZSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhc3RcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRQYXJhbUFjY2Vzc0FzdChhc3QsIGFycmF5QWNjZXNzLCBpdGVyYXRlLCBjb250ZXh0KXtcclxuICAgICAgICBpZihjb250ZXh0Lm1vZGUgPT0gU05JUFBFVF9DT05WRVJURVJfTU9ERS5KU19JVEVSQVRFICYmICFhcnJheUFjY2Vzcyl7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLCBjb21wdXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IGFzdCwgcHJvcGVydHk6ICggaXRlcmF0ZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogY29udGV4dC5pdGVyYXRlSWRlbnRpZmllcn0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTogU3ludGF4LkxpdGVyYWwsIHZhbHVlOiAwLCByYXc6IFwiMFwifSlcclxuICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjb250ZXh0Lm1vZGUgPT0gU05JUFBFVF9DT05WRVJURVJfTU9ERS5HTFNMX1ZTKXtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGNvbnRleHQuZW52TmFtZX0sXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGFzdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRGcmVlTmFtZShuYW1lLCBjb250ZXh0KXtcclxuICAgICAgICB2YXIgdGVzdCA9IG5hbWUsIGkgPSAxO1xyXG4gICAgICAgIHdoaWxlKGNvbnRleHQuYmxvY2tlZE5hbWVzLmluZGV4T2YodGVzdCkgIT0gLTEpe1xyXG4gICAgICAgICAgICB0ZXN0ID0gbmFtZSArIFwiX1wiICsgKCsraSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQuYmxvY2tlZE5hbWVzLnB1c2godGVzdCk7XHJcbiAgICAgICAgcmV0dXJuIHRlc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgbnMuY29ubmVjdFNuaXBwZXRzID0gZnVuY3Rpb24gKHNuaXBwZWRMaXN0LCBvcHQpIHtcclxuICAgICAgICB2YXIgZnVuY0FyZ1dyaXRlRHVwbGljYXRvciA9IG5ldyBTbmlwcGV0Q29ubmVjdG9yKCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmNBcmdXcml0ZUR1cGxpY2F0b3IuZXhlY3V0ZShzbmlwcGVkTGlzdCwgb3B0Lm1vZGUgfHwgU05JUFBFVF9DT05WRVJURVJfTU9ERS5KU19JVEVSQVRFKTtcclxuICAgIH07XHJcbiAgICBucy5NT0RFID0gU05JUFBFVF9DT05WRVJURVJfTU9ERVxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgd2FsayA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKSxcclxuICAgICAgICBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpLFxyXG4gICAgICAgIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9pbmRleC5qc1wiKSxcclxuICAgICAgICBjb21tb24gPSByZXF1aXJlKFwiLi8uLi8uLi9iYXNlL2NvbW1vbi5qc1wiKTtcclxuXHJcbiAgICB2YXIgU25pcHBldExpc3QgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuZW50cmllcyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIEJhc2UuZXh0ZW5kKFNuaXBwZXRMaXN0LnByb3RvdHlwZSwge1xyXG4gICAgICAgIGFkZEVudHJ5OiBmdW5jdGlvbihlbnRyeSl7XHJcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5wdXNoKGVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgU25pcHBldEVudHJ5ID0gZnVuY3Rpb24oYXN0KXtcclxuICAgICAgICB0aGlzLmlucHV0SW5mbyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0cHV0SW5mbyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYXN0ID0gYXN0IHx8IG51bGw7XHJcbiAgICB9XHJcbiBcclxuICAgIFxyXG4gICAgQmFzZS5leHRlbmQoU25pcHBldEVudHJ5LnByb3RvdHlwZSwge1xyXG4gICAgICAgIHNldEFzdDogZnVuY3Rpb24oYXN0KXtcclxuICAgICAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRWZXJ0ZXhJbnB1dDogZnVuY3Rpb24odHlwZSwgZGlyZWN0SW5wdXRJbmRleCl7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IG5ldyBTbmlwcGV0SW5wdXQodHlwZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpbnB1dC5zZXREaXJlY3RJbnB1dChkaXJlY3RJbnB1dEluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dEluZm8ucHVzaChpbnB1dCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRVbmlmb3JtSW5wdXQ6IGZ1bmN0aW9uKHR5cGUsIGRpcmVjdElucHV0SW5kZXgpe1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBuZXcgU25pcHBldElucHV0KHR5cGUsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlucHV0LnNldERpcmVjdElucHV0KGRpcmVjdElucHV0SW5kZXgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0SW5mby5wdXNoKGlucHV0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFVuaWZvcm1BcnJheTogZnVuY3Rpb24odHlwZSwgZGlyZWN0SW5wdXRJbmRleCwgYXJyYXlTaXplKXtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gbmV3IFNuaXBwZXRJbnB1dCh0eXBlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlucHV0LnNldERpcmVjdElucHV0KGRpcmVjdElucHV0SW5kZXgsIGFycmF5U2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRJbmZvLnB1c2goaW5wdXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkVHJhbnNmZXJJbnB1dDogZnVuY3Rpb24odHlwZSwgdHJhbnNmZXJPcGVyYXRvckluZGV4LCB0cmFuc2Zlck91dHB1dEluZGV4KXtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gbmV3IFNuaXBwZXRJbnB1dCh0eXBlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlucHV0LnNldFRyYW5zZmVySW5wdXQodHJhbnNmZXJPcGVyYXRvckluZGV4LCB0cmFuc2Zlck91dHB1dEluZGV4KTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dEluZm8ucHVzaChpbnB1dCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRMb3N0T3V0cHV0OiBmdW5jdGlvbih0eXBlLCBuYW1lKXtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IG5ldyBTbmlwcGV0T3V0cHV0KHR5cGUsIG5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dEluZm8ucHVzaChvdXRwdXQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkRmluYWxPdXRwdXQ6IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIGluZGV4KXtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IG5ldyBTbmlwcGV0T3V0cHV0KHR5cGUsIG5hbWUpO1xyXG4gICAgICAgICAgICBvdXRwdXQuc2V0RmluYWxPdXRwdXRJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0SW5mby5wdXNoKG91dHB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIHZhciBTbmlwcGV0SW5wdXQgPSBmdW5jdGlvbih0eXBlLCBpdGVyYXRlLCBhcnJheUFjY2Vzcyl7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLml0ZXJhdGUgPSBpdGVyYXRlO1xyXG4gICAgICAgIHRoaXMuYXJyYXlBY2Nlc3MgPSBhcnJheUFjY2VzcztcclxuICAgICAgICB0aGlzLnRyYW5zZmVyT3BlcmF0b3JJbmRleCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnRyYW5zZmVyT3V0cHV0SW5kZXggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kaXJlY3RJbnB1dEluZGV4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuYXJyYXlTaXplID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIEJhc2UuZXh0ZW5kKFNuaXBwZXRJbnB1dC5wcm90b3R5cGUsIHtcclxuICAgICAgICBzZXREaXJlY3RJbnB1dDogZnVuY3Rpb24oZGlyZWN0SW5wdXRJbmRleCwgYXJyYXlTaXplKXtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zlck9wZXJhdG9ySW5kZXggPSB0aGlzLnRyYW5zZmVyT3V0cHV0SW5kZXggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0SW5wdXRJbmRleCA9IGRpcmVjdElucHV0SW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXlTaXplID0gYXJyYXlTaXplO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0VHJhbnNmZXJJbnB1dDogZnVuY3Rpb24odHJhbnNmZXJPcGVyYXRvckluZGV4LCB0cmFuc2Zlck91dHB1dEluZGV4KXtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zlck9wZXJhdG9ySW5kZXggPSB0cmFuc2Zlck9wZXJhdG9ySW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmZXJPdXRwdXRJbmRleCA9IHRyYW5zZmVyT3V0cHV0SW5kZXg7XHJcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0SW5wdXRJbmRleCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzVHJhbnNmZXJJbnB1dDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmZXJPcGVyYXRvckluZGV4ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRUcmFuc2ZlcklucHV0S2V5OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zlck9wZXJhdG9ySW5kZXggKyBcIl9cIiArIHRoaXMudHJhbnNmZXJPdXRwdXRJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgU25pcHBldE91dHB1dCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5maW5hbE91dHB1dEluZGV4ID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIEJhc2UuZXh0ZW5kKFNuaXBwZXRPdXRwdXQucHJvdG90eXBlLCB7XHJcbiAgICAgICAgc2V0RmluYWxPdXRwdXRJbmRleDogZnVuY3Rpb24oaW5kZXgpe1xyXG4gICAgICAgICAgICB0aGlzLmZpbmFsT3V0cHV0SW5kZXggPSBpbmRleDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzRmluYWw6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmFsT3V0cHV0SW5kZXggIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBucy5TbmlwcGV0TGlzdCA9IFNuaXBwZXRMaXN0O1xyXG4gICAgbnMuU25pcHBldEVudHJ5ID0gU25pcHBldEVudHJ5O1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxyXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4vLi4vLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBUeXBlcyA9IFNoYWRlLlRZUEVTLFxyXG4gICAgICAgIEtpbmRzID0gU2hhZGUuT0JKRUNUX0tJTkRTLFxyXG4gICAgICAgIFNwYWNlVHlwZSA9IFNoYWRlLlNwYWNlVHlwZSxcclxuICAgICAgICBWZWN0b3JUeXBlID0gU2hhZGUuVmVjdG9yVHlwZTtcclxuICAgIHZhciB3YWxrID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpO1xyXG4gICAgdmFyIFN5bnRheCA9IHdhbGsuU3ludGF4O1xyXG4gICAgdmFyIEFOTk8gPSBjb21tb24uQU5OTztcclxuXHJcblxyXG4gICAgbnMuZ2V0U3BhY2VUcmFuc2Zvcm1DYWxsID0gZnVuY3Rpb24oYXN0LCBzcGFjZSl7XHJcbiAgICAgICAgdmFyIGNhbGxFeHByZXNzaW9uID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIGNhbGxlZTogdGhpcy5nZXRTcGFjZUNvbnZlcnRGdW5jdGlvbihzcGFjZSksXHJcbiAgICAgICAgICAgIGFyZ3VtZW50czogWyB0aGlzLmdldFNwYWNlQ29udmVydEFyZyhzcGFjZSksIGFzdCBdXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2FsbEV4cHJlc3Npb247XHJcbiAgICB9O1xyXG5cclxuICAgIG5zLmdldFNwYWNlQ29udmVydEZ1bmN0aW9uID0gZnVuY3Rpb24oc3BhY2Upe1xyXG4gICAgICAgIHZhciB2ZWN0b3JUeXBlID0gU2hhZGUuZ2V0VmVjdG9yRnJvbVNwYWNlVmVjdG9yKHNwYWNlKTtcclxuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lO1xyXG4gICAgICAgIHN3aXRjaCh2ZWN0b3JUeXBlKXtcclxuICAgICAgICAgICAgY2FzZSBWZWN0b3JUeXBlLlBPSU5UOiBmdW5jdGlvbk5hbWUgPSBcInRyYW5zZm9ybVBvaW50XCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFZlY3RvclR5cGUuTk9STUFMOiBmdW5jdGlvbk5hbWUgPSBcInRyYW5zZm9ybURpcmVjdGlvblwiOyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIG9iamVjdDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcIlNwYWNlXCJ9LFxyXG4gICAgICAgICAgICBwcm9wZXJ0eTogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogZnVuY3Rpb25OYW1lIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIEFOTk8ocmVzdWx0KS5zZXRUeXBlKFR5cGVzLkZVTkNUSU9OKTtcclxuICAgICAgICBBTk5PKHJlc3VsdC5vYmplY3QpLnNldFR5cGUoVHlwZXMuT0JKRUNULCBLaW5kcy5BTlkpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgbnMuZ2V0U3BhY2VDb252ZXJ0QXJnID0gZnVuY3Rpb24oc3BhY2Upe1xyXG4gICAgICAgIHZhciBzcGFjZVR5cGUgPSBTaGFkZS5nZXRTcGFjZUZyb21TcGFjZVZlY3RvcihzcGFjZSk7XHJcbiAgICAgICAgdmFyIHNwYWNlTmFtZTtcclxuICAgICAgICBzd2l0Y2goc3BhY2VUeXBlKXtcclxuICAgICAgICAgICAgY2FzZSBTcGFjZVR5cGUuVklFVzogc3BhY2VOYW1lID0gXCJWSUVXXCI7IGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNwYWNlVHlwZS5XT1JMRDogc3BhY2VOYW1lID0gXCJXT1JMRFwiOyBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIG9iamVjdDogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJTcGFjZVwiICB9LFxyXG4gICAgICAgICAgICBwcm9wZXJ0eTogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogc3BhY2VOYW1lIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBCYXNlID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvaW5kZXguanNcIiksXHJcbiAgICAgICAgY29tbW9uID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29tbW9uLmpzXCIpLFxyXG4gICAgICAgIEZ1bmN0aW9uQW5ub3RhdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuRnVuY3Rpb25Bbm5vdGF0aW9uLFxyXG4gICAgICAgIFR5cGVJbmZvID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvdHlwZWluZm8uanNcIikuVHlwZUluZm8sXHJcbiAgICAgICAgU2hhZGUgPSByZXF1aXJlKFwiLi8uLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxyXG4gICAgICAgIGVzZ3JhcGggPSByZXF1aXJlKCdlc2dyYXBoJyksXHJcbiAgICAgICAgVHlwZXMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLaW5kcyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcclxuICAgIHZhciBzcGFjZUFuYWx5emVyID0gcmVxdWlyZShcIi4uLy4uL2FuYWx5emUvc3BhY2VfYW5hbHl6ZXIuanNcIiksXHJcbiAgICAgICAgU3BhY2VWZWN0b3JUeXBlID0gU2hhZGUuU3BhY2VWZWN0b3JUeXBlLFxyXG4gICAgICAgIFNwYWNlVHlwZSA9IFNoYWRlLlNwYWNlVHlwZSxcclxuICAgICAgICBWZWN0b3JUeXBlID0gU2hhZGUuVmVjdG9yVHlwZTtcclxuICAgIHZhciBTcGFjZVRyYW5zZm9ybVRvb2xzID0gcmVxdWlyZShcIi4vc3BhY2UtdHJhbnNmb3JtLXRvb2xzLmpzXCIpO1xyXG5cclxuXHJcblxyXG4gICAgdmFyIHdhbGsgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyk7XHJcbiAgICB2YXIgU3ludGF4ID0gd2Fsay5TeW50YXg7XHJcbiAgICB2YXIgQU5OTyA9IGNvbW1vbi5BTk5PO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgdGhlIEpTIEFTVCB0byBhbiBBU1QgcmVwcmVzZW50YXRpb24gY29udmVuaWVudFxyXG4gICAgICogZm9yIGNvZGUgZ2VuZXJhdGlvblxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBTcGFjZVRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKG1haW5JZCkge1xyXG4gICAgICAgIHRoaXMubWFpbklkID0gbWFpbklkO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBzcGFjZUluZm8oYXN0KXtcclxuICAgICAgICByZXR1cm4gYXN0LnNwYWNlSW5mbyB8fCB7fTtcclxuICAgIH1cclxuXHJcbiAgICBCYXNlLmV4dGVuZChTcGFjZVRyYW5zZm9ybWVyLnByb3RvdHlwZSwge1xyXG4gICAgICAgIHRyYW5zZm9ybUFhc3Q6IGZ1bmN0aW9uIChhYXN0LCBvcHQpIHtcclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBhYXN0O1xyXG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uU3BhY2VJbmZvID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25UcmFuZnNlckluZm8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5nbG9iYWxJZGVudGlmaWVycyA9IHRoaXMuZ2V0R2xvYmFsSWRlbnRpZmllcnMoYWFzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW52U3BhY2VzID0ge307XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUZ1bmN0aW9ucyhhYXN0KTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVHbG9iYWxPYmplY3QoYWFzdCwgdGhpcy5lbnZTcGFjZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnZTcGFjZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0IX0gYXN0XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QhfSBzdGF0ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRyYW5zZm9ybUZ1bmN0aW9uczogZnVuY3Rpb24oYWFzdCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGFhc3QgPSB3YWxrLnJlcGxhY2UoYWFzdCwge1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRW50ZXI6XCIsIG5vZGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguRnVuY3Rpb25EZWNsYXJhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVwbGFjZUZ1bmN0aW9uSW52b2NhdGlvbnMobm9kZS5ib2R5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXh0cmFjdFNwYWNlVHJhbnNmb3Jtcyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGFhc3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXBsYWNlRnVuY3Rpb25JbnZvY2F0aW9uczogZnVuY3Rpb24oZnVuY3Rpb25Cb2R5QWFzdCl7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgd2Fsay5yZXBsYWNlKGZ1bmN0aW9uQm9keUFhc3QsIHtcclxuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5DYWxsRXhwcmVzc2lvbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vZGUuY2FsbGVlLnR5cGUgPT0gU3ludGF4LklkZW50aWZpZXIgJiYgc2VsZi5mdW5jdGlvblNwYWNlSW5mb1tub2RlLmNhbGxlZS5uYW1lXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1UcmFuc2l0aW9ucyA9IHNlbGYuZnVuY3Rpb25TcGFjZUluZm9bbm9kZS5jYWxsZWUubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQXJncyA9IG5vZGUuYXJndW1lbnRzLCBuZXdBcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFyYW1UcmFuc2l0aW9ucy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtVCA9IHBhcmFtVHJhbnNpdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXBhcmFtVC5zcGFjZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQXJnc1twYXJhbVQuaWR4XSAhPT0gdW5kZWZpbmVkICYmIG5ld0FyZ3MucHVzaChvbGRBcmdzW3BhcmFtVC5pZHhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBcmdzLnB1c2goU3BhY2VUcmFuc2Zvcm1Ub29scy5nZXRTcGFjZVRyYW5zZm9ybUNhbGwob2xkQXJnc1twYXJhbVQuaWR4XSwgcGFyYW1ULnNwYWNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBuZXdBcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBleHRyYWN0U3BhY2VUcmFuc2Zvcm1zOiBmdW5jdGlvbihmdW5jdGlvbkFhc3Qpe1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMudXNlZElkZW50aWZpZXJzID0gdGhpcy5nZXRVc2VkSWRlbnRpZmllcnMoZnVuY3Rpb25BYXN0KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhbmFseXplUmVzdWx0ID0gc3BhY2VBbmFseXplci5hbmFseXplKGZ1bmN0aW9uQWFzdCwgdGhpcy5mdW5jdGlvblRyYW5mc2VySW5mbyk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lTWFwID0ge30sIGFkZERlY2xhcmF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmV4dHJhY3RFbnZTcGFjZXMoYW5hbHl6ZVJlc3VsdCwgbmFtZU1hcCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEZ1bmN0aW9uSGVhZGVyKGZ1bmN0aW9uQWFzdCwgYW5hbHl6ZVJlc3VsdCwgbmFtZU1hcCwgYWRkRGVjbGFyYXRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uQWFzdC5ib2R5ID0gd2Fsay5yZXBsYWNlKGZ1bmN0aW9uQWFzdC5ib2R5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJFbnRlcjpcIiwgbm9kZS50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihub2RlLnR5cGUgPT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3RhdGVtZW50ID0gc2VsZi5kdXBsaWNhdGVTcGFjZVN0YXRlbWVudChub2RlLCBuYW1lTWFwLCBhZGREZWNsYXJhdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXdTdGF0ZW1lbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3U3RhdGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3BhY2VJbmZvKG5vZGUpLmhhc1NwYWNlT3ZlcnJpZGVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXNvbHZlU3BhY2VVc2FnZShub2RlLCBTcGFjZVZlY3RvclR5cGUuT0JKRUNULCBuYW1lTWFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5hZGREZWNsYXJhdGlvbnMoZnVuY3Rpb25BYXN0LCBhZGREZWNsYXJhdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXBEZWNsYXJhdGlvbnMoZnVuY3Rpb25BYXN0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBleHRyYWN0RW52U3BhY2VzOiBmdW5jdGlvbihhbmFseXplUmVzdWx0LCBuYW1lTWFwKXtcclxuICAgICAgICAgICAgZm9yKHZhciBuYW1lIGluIGFuYWx5emVSZXN1bHQpe1xyXG4gICAgICAgICAgICAgICAgaWYobmFtZS5pbmRleE9mKFwiZW52LlwiKSA9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBuYW1lLnN1YnN0cig0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IGFuYWx5emVSZXN1bHRbbmFtZV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGotLSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IGFuYWx5emVSZXN1bHRbbmFtZV1bal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZU5hbWUgPSB0aGlzLmdldFNwYWNlTmFtZShuYW1lLCBzcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLmVudlNwYWNlc1twcm9wZXJ0eV0pIHRoaXMuZW52U3BhY2VzW3Byb3BlcnR5XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggIXRoaXMuZW52U3BhY2VzW3Byb3BlcnR5XS5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNwYWNlID09IHNwYWNlfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVudlNwYWNlc1twcm9wZXJ0eV0ucHVzaCh7IG5hbWU6IHNwYWNlTmFtZS5zcGxpdChcIi5cIilbMV0sIHNwYWNlOiBzcGFjZSB9ICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFuYW1lTWFwW25hbWVdKSBuYW1lTWFwW25hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVNYXBbbmFtZV1bc3BhY2VdID0gdGhpcy5nZXRTcGFjZU5hbWUobmFtZSwgc3BhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGluaXRGdW5jdGlvbkhlYWRlcjogZnVuY3Rpb24oZnVuY3Rpb25BYXN0LCBhbmFseXplUmVzdWx0LCBuYW1lTWFwLCBhZGREZWNsYXJhdGlvbnMpe1xyXG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0gW107XHJcbiAgICAgICAgICAgIHZhciBwYXJhbVRyYW5zaXRpb25zID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbkFhc3QucGFyYW1zLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IGZ1bmN0aW9uQWFzdC5wYXJhbXNbaV0sIHBhcmFtTmFtZSA9IHBhcmFtLm5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZihhbmFseXplUmVzdWx0W3BhcmFtTmFtZV0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBqID0gYW5hbHl6ZVJlc3VsdFtwYXJhbU5hbWVdLmxlbmd0aCwgaGFzT2JqZWN0U3BhY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZShqLS0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2UgPSBhbmFseXplUmVzdWx0W3BhcmFtTmFtZV1bal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNwYWNlICE9IFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1Qpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW5hbWVNYXBbcGFyYW1OYW1lXSkgbmFtZU1hcFtwYXJhbU5hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lTWFwW3BhcmFtTmFtZV1bc3BhY2VdID0gdGhpcy5nZXRTcGFjZU5hbWUocGFyYW1OYW1lLCBzcGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3UGFyYW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZU1hcFtwYXJhbU5hbWVdW3NwYWNlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFOTk8obmV3UGFyYW0pLmNvcHkoQU5OTyhwYXJhbSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW1zLnB1c2gobmV3UGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1UcmFuc2l0aW9ucy5wdXNoKHtpZHg6IGksIHNwYWNlOiBzcGFjZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPYmplY3RTcGFjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXMucHVzaChwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVRyYW5zaXRpb25zLnB1c2goe2lkeDogaX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFoYXNPYmplY3RTcGFjZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlY2xhcmF0aW9ucy5wdXNoKHBhcmFtTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbXMucHVzaChwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1UcmFuc2l0aW9ucy5wdXNoKHtpZHg6IGl9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbkFhc3QucGFyYW1zID0gbmV3UGFyYW1zO1xyXG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uU3BhY2VJbmZvW2Z1bmN0aW9uQWFzdC5pZC5uYW1lXSA9IHBhcmFtVHJhbnNpdGlvbnM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZHVwbGljYXRlU3BhY2VTdGF0ZW1lbnQ6IGZ1bmN0aW9uKHN0YXRlbWVudEFhc3QsIG5hbWVNYXAsIGFkZGVkRGVjbGFyYXRpb25zKXtcclxuICAgICAgICAgICAgdmFyIGR1cGxpY2F0ZWRTdGF0ZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHN0YXRlbWVudEFhc3QuZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgdmFyIHNJbmZvID0gc3BhY2VJbmZvKGNoaWxkKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdTcGFjZU5hbWVFbnRyaWVzID0ge307XHJcbiAgICAgICAgICAgIGlmKCFzSW5mby5maW5hbFNwYWNlcyl7XHJcbiAgICAgICAgICAgICAgICBuYW1lTWFwW3NJbmZvLmRlZl0gPSBuZXdTcGFjZU5hbWVFbnRyaWVzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzSW5mby5maW5hbFNwYWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNwYWNlKXtcclxuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY2hpbGQpKTtcclxuICAgICAgICAgICAgICAgIGlmKHNwYWNlICE9IFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QgJiYgIXRoaXMuaXNTcGFjZVByb3BhZ3JhdGlvblBvc3NpYmxlKHNJbmZvLCBzcGFjZSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVNwYWNlVXNhZ2UoZXhwcmVzc2lvbkNvcHksIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QsIG5hbWVNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25Db3B5LnJpZ2h0ID0gU3BhY2VUcmFuc2Zvcm1Ub29scy5nZXRTcGFjZVRyYW5zZm9ybUNhbGwoZXhwcmVzc2lvbkNvcHkucmlnaHQsIHNwYWNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlU3BhY2VVc2FnZShleHByZXNzaW9uQ29weSwgc3BhY2UsIG5hbWVNYXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZHVwbGljYXRlZFN0YXRlbWVudHMucHVzaCh7IHR5cGU6IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50LCBleHByZXNzaW9uOiBleHByZXNzaW9uQ29weSB9KTtcclxuICAgICAgICAgICAgICAgIGlmKHNwYWNlICE9IFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZU5hbWUgPSB0aGlzLmdldFNwYWNlTmFtZShzSW5mby5kZWYsIHNwYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihhZGRlZERlY2xhcmF0aW9ucy5pbmRleE9mKHNwYWNlTmFtZSkgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkRGVjbGFyYXRpb25zLnB1c2goc3BhY2VOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTcGFjZU5hbWVFbnRyaWVzW3NwYWNlXSA9IHNwYWNlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uQ29weS5sZWZ0Lm5hbWUgPSBzcGFjZU5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBuYW1lTWFwW3NJbmZvLmRlZl0gPSBuZXdTcGFjZU5hbWVFbnRyaWVzO1xyXG5cclxuICAgICAgICAgICAgaWYoZHVwbGljYXRlZFN0YXRlbWVudHMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmKGR1cGxpY2F0ZWRTdGF0ZW1lbnRzLmxlbmd0aCA9PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR1cGxpY2F0ZWRTdGF0ZW1lbnRzWzBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGJsb2NrU3RhdGVtZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxyXG4gICAgICAgICAgICAgICAgYm9keTogZHVwbGljYXRlZFN0YXRlbWVudHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrU3RhdGVtZW50XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZERlY2xhcmF0aW9uczogZnVuY3Rpb24oZnVuY3Rpb25BYXN0LCBhZGREZWNsYXJhdGlvbnMpe1xyXG4gICAgICAgICAgICB2YXIgaSA9IGZ1bmN0aW9uQWFzdC5wYXJhbXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZHggPSBhZGREZWNsYXJhdGlvbnMuaW5kZXhPZihmdW5jdGlvbkFhc3QucGFyYW1zW2ldLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYoaWR4ICE9IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIGFkZERlY2xhcmF0aW9ucy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhZGREZWNsYXJhdGlvbnMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0geyB0eXBlOiBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbiwga2luZDogXCJ2YXJcIiwgZGVjbGFyYXRpb25zOiBbXX07XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGFkZERlY2xhcmF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYWRkRGVjbGFyYXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNsID0ge3R5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0b3IsIGlkOiB7dHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IG5hbWV9LCBpbml0OiBudWxsfTtcclxuICAgICAgICAgICAgICAgICAgICBBTk5PKGRlY2wpLnNldFR5cGUoVHlwZXMuT0JKRUNULCBLaW5kcy5GTE9BVDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9ucy5kZWNsYXJhdGlvbnMucHVzaChkZWNsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQWFzdC5ib2R5LmJvZHkudW5zaGlmdChkZWNsYXJhdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNTcGFjZVByb3BhZ3JhdGlvblBvc3NpYmxlOiBmdW5jdGlvbihzSW5mbywgdGFyZ2V0U3BhY2Upe1xyXG4gICAgICAgICAgICBpZihzSW5mby5wcm9wYWdhdGVTZXQubGVuZ3RoID09IDApIC8vIFdlIG5lZWQgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgZGVwZW5kZW5jeS4gT3RoZXJ3aXNlIHdlIGNhbid0IHByb3BhZ2F0ZSB0aGUgc3BhY2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHZlY3RvclR5cGUgPSBTaGFkZS5nZXRWZWN0b3JGcm9tU3BhY2VWZWN0b3IodGFyZ2V0U3BhY2UpXHJcbiAgICAgICAgICAgIGlmKHZlY3RvclR5cGUgPT0gVmVjdG9yVHlwZS5OT1JNQUwgJiYgc0luZm8ubm9ybWFsU3BhY2VWaW9sYXRpb24pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKHZlY3RvclR5cGUgPT0gVmVjdG9yVHlwZS5QT0lOVCAmJiBzSW5mby5wb2ludFNwYWNlVmlvbGF0aW9uKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVzb2x2ZVNwYWNlVXNhZ2U6IGZ1bmN0aW9uKGFhc3QsIHRhcmdldFNwYWNlLCBuYW1lTWFwKXtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBhYXN0ID0gd2Fsay5yZXBsYWNlKGFhc3QsIHtcclxuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkVudGVyOlwiLCBub2RlLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LklkZW50aWZpZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0YXJnZXRTcGFjZSAhPSBTcGFjZVZlY3RvclR5cGUuT0JKRUNUICYmIHNwYWNlSW5mbyhub2RlKS5wcm9wYWdhdGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IG5hbWVNYXBbbm9kZS5uYW1lXVt0YXJnZXRTcGFjZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRhcmdldFNwYWNlICE9IFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QgJiYgc3BhY2VJbmZvKG5vZGUpLnByb3BhZ2F0ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVLZXkgPSBcImVudi5cIiArIG5vZGUucHJvcGVydHkubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVNYXBbbmFtZUtleV1bdGFyZ2V0U3BhY2VdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IG5hbWUuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydHkubmFtZSA9IHRva2VuWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNJbmZvID0gc3BhY2VJbmZvKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc0luZm8uc3BhY2VPdmVycmlkZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaXNTcGFjZVByb3BhZ3JhdGlvblBvc3NpYmxlKHNJbmZvLCBzSW5mby5zcGFjZU92ZXJyaWRlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZi5yZXNvbHZlU3BhY2VVc2FnZShub2RlLmFyZ3VtZW50c1sxXSwgc0luZm8uc3BhY2VPdmVycmlkZSwgbmFtZU1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYWFzdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRTcGFjZU5hbWU6IGZ1bmN0aW9uKG5hbWUsIHNwYWNlKXtcclxuICAgICAgICAgICAgaWYoc3BhY2UgPT0gU3BhY2VWZWN0b3JUeXBlLk9CSkVDVClcclxuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoZWNrR2xvYmFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmKG5hbWUuaW5kZXhPZihcImVudi5cIikgPT0gMCl7XHJcbiAgICAgICAgICAgICAgICBjaGVja0dsb2JhbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIoNCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoKHNwYWNlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgU3BhY2VWZWN0b3JUeXBlLlZJRVdfUE9JTlQgOiBuYW1lICs9IFwiX3Zwc1wiOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU3BhY2VWZWN0b3JUeXBlLldPUkxEX1BPSU5UIDogbmFtZSArPSBcIl93cHNcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFNwYWNlVmVjdG9yVHlwZS5WSUVXX05PUk1BTCA6IG5hbWUgKz0gXCJfdm5zXCI7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTcGFjZVZlY3RvclR5cGUuV09STERfTk9STUFMIDogbmFtZSArPSBcIl93bnNcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5hbWU7XHJcbiAgICAgICAgICAgIHZhciBpID0gMjtcclxuICAgICAgICAgICAgd2hpbGUoIChjaGVja0dsb2JhbCA/IHRoaXMuZ2xvYmFsSWRlbnRpZmllcnMgOiB0aGlzLnVzZWRJZGVudGlmaWVycyApLmluZGV4T2YocmVzdWx0KSAhPSAtMSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuYW1lICsgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGNoZWNrR2xvYmFsKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJlbnYuXCIgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0VXNlZElkZW50aWZpZXJzIDogZnVuY3Rpb24oZnVuY3Rpb25BYXN0KXtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICB3YWxrLnRyYXZlcnNlKGZ1bmN0aW9uQWFzdCwge1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRW50ZXI6XCIsIG5vZGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5JZGVudGlmaWVyKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHBhcmVudC50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIHBhcmVudC5wcm9wZXJ0eSA9PSBub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuaW5kZXhPZihub2RlLm5hbWUpID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0R2xvYmFsSWRlbnRpZmllcnMgOiBmdW5jdGlvbihwcm9ncmFtQWFzdCl7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgd2Fsay50cmF2ZXJzZShwcm9ncmFtQWFzdCwge1xyXG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiRW50ZXI6XCIsIG5vZGUudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uICYmIG5vZGUub2JqZWN0LmV4dHJhLmdsb2JhbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5pbmRleE9mKG5vZGUucHJvcGVydHkubmFtZSkgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub2RlLnByb3BlcnR5Lm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhblVwRGVjbGFyYXRpb25zOiBmdW5jdGlvbihmdW5jdGlvbkFhc3Qpe1xyXG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRvcnMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGJvZHkgPSBmdW5jdGlvbkFhc3QuYm9keS5ib2R5O1xyXG4gICAgICAgICAgICB2YXIgaSA9IGJvZHkubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpLS0pe1xyXG4gICAgICAgICAgICAgICAgaWYoYm9keVtpXS50eXBlID09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKXtcclxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdG9ycy5wdXNoLmFwcGx5KGRlY2xhcmF0b3JzLCBib2R5W2ldLmRlY2xhcmF0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5zcGxpY2UoaSwxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdXNlZElkZW50aWZpZXJzID0gdGhpcy5nZXRVc2VkSWRlbnRpZmllcnMoZnVuY3Rpb25BYXN0LmJvZHkpO1xyXG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB7IHR5cGU6IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uLCBraW5kOiBcInZhclwiLCBkZWNsYXJhdGlvbnM6IFtdfTtcclxuICAgICAgICAgICAgaSA9IGRlY2xhcmF0b3JzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUoaS0tKXtcclxuICAgICAgICAgICAgICAgIGlmKHVzZWRJZGVudGlmaWVycy5pbmRleE9mKGRlY2xhcmF0b3JzW2ldLmlkLm5hbWUpICE9IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMucHVzaChkZWNsYXJhdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICBib2R5LnVuc2hpZnQoZGVjbGFyYXRpb24pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVwZGF0ZUdsb2JhbE9iamVjdDogZnVuY3Rpb24oYWFzdCwgZW52U3BhY2VzKXtcclxuICAgICAgICAgICAgaWYoIWFhc3QuZ2xvYmFsUGFyYW1ldGVycylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdmFyIGdsb2JhbE9iamVjdDtcclxuICAgICAgICAgICAgZm9yKHZhciBmdW5jTmFtZSBpbiBhYXN0Lmdsb2JhbFBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhYXN0Lmdsb2JhbFBhcmFtZXRlcnNbZnVuY05hbWVdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSBhcmdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXJnc1tpXS5leHRyYS5nbG9iYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbE9iamVjdCA9IGFyZ3NbaV0uZXh0cmE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIWdsb2JhbE9iamVjdClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdmFyIG5ld0luZm8gPSB7fTtcclxuICAgICAgICAgICAgZm9yKHZhciBwcm9wTmFtZSBpbiBnbG9iYWxPYmplY3QuaW5mbyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGdsb2JhbE9iamVjdC5pbmZvW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmKCFlbnZTcGFjZXNbcHJvcE5hbWVdKXtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmZvW3Byb3BOYW1lXSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnlMaXN0ID0gZW52U3BhY2VzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbnRyeUxpc3QubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3B5RGF0YSA9IEJhc2UuZGVlcEV4dGVuZCh7fSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5mb1tlbnRyeUxpc3RbaV0ubmFtZV09IGNvcHlEYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdsb2JhbE9iamVjdC5pbmZvID0gbmV3SW5mbztcclxuICAgICAgICAgICAgd2Fsay50cmF2ZXJzZShhYXN0LCB7XHJcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJFbnRlcjpcIiwgbm9kZS50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihub2RlLmV4dHJhICYmIG5vZGUuZXh0cmEuZ2xvYmFsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5leHRyYS5pbmZvID0gbmV3SW5mbztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5zY29wZSAmJiBub2RlLnNjb3BlLmJpbmRpbmdzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBuYW1lIGluIG5vZGUuc2NvcGUuYmluZGluZ3Mpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5zY29wZS5iaW5kaW5nc1tuYW1lXS5leHRyYS5nbG9iYWwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2NvcGUuYmluZGluZ3NbbmFtZV0uZXh0cmEuaW5mbyA9IG5ld0luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRXhwb3J0c1xyXG4gICAgbnMuU3BhY2VUcmFuc2Zvcm1lciA9IG5ldyBTcGFjZVRyYW5zZm9ybWVyKCk7XHJcblxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgU3ludGF4ID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLlN5bnRheDtcclxuICAgIHZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UvaW5kZXguanNcIik7XHJcbiAgICB2YXIgQU5OTyA9IHJlcXVpcmUoXCIuLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTztcclxuICAgIHZhciBUeXBlSW5mbyA9IHJlcXVpcmUoXCIuLi9iYXNlL3R5cGVpbmZvLmpzXCIpLlR5cGVJbmZvO1xyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZXMuanNcIik7XHJcbiAgICB2YXIgVmVjQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlL3ZlYy5qc1wiKTtcclxuXHJcbiAgICB2YXIgVFlQRVMgPSBTaGFkZS5UWVBFUyxcclxuICAgICAgICBLSU5EUyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcclxuXHJcblxyXG5cclxuICAgIG5zLnJlbW92ZU1lbWJlckZyb21FeHByZXNzaW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcclxuICAgICAgICAgICAgbmFtZTogbm9kZS5wcm9wZXJ0eS5uYW1lXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5zLmdlbmVyYXRlRnJlZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBibG9ja2VkTmFtZXMpe1xyXG4gICAgICAgIHZhciBuZXdOYW1lID0gbmFtZS5yZXBsYWNlKC9fKy9nLCBcIl9cIiksIGkgPSAxO1xyXG4gICAgICAgIHdoaWxlKGJsb2NrZWROYW1lcy5pbmRleE9mKG5ld05hbWUpICE9IC0xKXtcclxuICAgICAgICAgICAgbmV3TmFtZSA9IChuYW1lICsgXCJfXCIgKyAoKytpKSkucmVwbGFjZSgvXysvZywgXCJfXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBibG9ja2VkTmFtZXMucHVzaChuZXdOYW1lKTtcclxuICAgICAgICByZXR1cm4gbmV3TmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBucy5nZXRJbnRlcm5hbEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uKHN0YXRlLCBrZXksIHR5cGUsIGRldGFpbHMpe1xyXG4gICAgICAgIGlmKCFzdGF0ZS5pbnRlcm5hbEZ1bmN0aW9uc1trZXldKXtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBucy5nZW5lcmF0ZUZyZWVOYW1lKGtleSwgc3RhdGUuYmxvY2tlZE5hbWVzKTtcclxuICAgICAgICAgICAgc3RhdGUuaW50ZXJuYWxGdW5jdGlvbnNba2V5XSA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgZGV0YWlsczogZGV0YWlsc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhdGUuaW50ZXJuYWxGdW5jdGlvbnNba2V5XS5uYW1lO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgbnMuYmluYXJ5RXhwcmVzc2lvbjJGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbihub2RlLCBuYW1lKSB7XHJcbiAgICAgICAgbm9kZS5yaWdodCA9IG5zLmNhc3RUb0Zsb2F0KG5vZGUucmlnaHQpO1xyXG4gICAgICAgIG5vZGUubGVmdCA9IG5zLmNhc3RUb0Zsb2F0KG5vZGUubGVmdCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICBjYWxsZWU6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVmdCxcclxuICAgICAgICAgICAgICAgIG5vZGUucmlnaHRcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZXh0cmE6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFRZUEVTLk5VTUJFUlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgVmVjID0ge1xyXG4gICAgICAgIGdldFZlY0FyZ3M6IGZ1bmN0aW9uKGFyZ3Mpe1xyXG4gICAgICAgICAgICBpZihhcmdzLmxlbmd0aCA9PSAwKXtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkxpdGVyYWxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiMFwiXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIEFOTk8ocmVzdWx0WzBdKS5zZXRUeXBlKFRZUEVTLk5VTUJFUik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdlbmVyYXRlVmVjRnJvbUFyZ3M6IGZ1bmN0aW9uKHZlY0NvdW50LCBhcmdzKXtcclxuICAgICAgICAgICAgaWYodmVjQ291bnQgPT0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xyXG4gICAgICAgICAgICBpZihhcmdzLmxlbmd0aCA9PSAwKXtcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBWZWMuZ2V0VmVjQXJncyhhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoYXJncy5sZW5ndGggPT0gMSAmJiBBTk5PKGFyZ3NbMF0pLmlzT2ZLaW5kKEtJTkRTWydGTE9BVCcgKyB2ZWNDb3VudF0pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTmV3RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgIGNhbGxlZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVmVjXCIgKyB2ZWNDb3VudFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJnc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBBTk5PKHJlc3VsdCkuc2V0VHlwZShUWVBFUy5PQkpFQ1QsIEtJTkRTWydGTE9BVCcgKyB2ZWNDb3VudF0pO1xyXG4gICAgICAgICAgICBBTk5PKHJlc3VsdC5jYWxsZWUpLnNldFR5cGUoVFlQRVMuRlVOQ1RJT04pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNyZWF0ZVN3aXp6bGU6IGZ1bmN0aW9uKHZlY0NvdW50LCBzd2l6emxlLCBub2RlLCBhcmdzLCBwYXJlbnQpe1xyXG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5jYWxsZWUuZXh0cmEgPSBub2RlLmV4dHJhO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2FsbGVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzaW5ndWxhciA9IHN3aXp6bGUubGVuZ3RoID09IDE7XHJcbiAgICAgICAgICAgIHZhciBhcmdPYmplY3QgPSBzaW5ndWxhciA/IG5vZGUuYXJndW1lbnRzWzBdIDogVmVjLmdlbmVyYXRlVmVjRnJvbUFyZ3Moc3dpenpsZS5sZW5ndGgsIG5vZGUuYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdmFyIHJlcGxhY2UgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTmV3RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgIGNhbGxlZToge1xyXG4gICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlZlY1wiICsgdmVjQ291bnRcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzd2l6emxlLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBpZHggPSBWZWNCYXNlLnN3aXp6bGVUb0luZGV4KHN3aXp6bGUuY2hhckF0KGkpKTtcclxuICAgICAgICAgICAgICAgIGluZGljZXNbaWR4XSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZlY0NvdW50OyArK2kpe1xyXG4gICAgICAgICAgICAgICAgaWYoaW5kaWNlc1tpXSAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlLmFyZ3VtZW50c1tpXSA9IHNpbmd1bGFyID8gYXJnT2JqZWN0IDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBhcmdPYmplY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFZlY0Jhc2UuaW5kZXhUb1N3aXp6bGUoaW5kaWNlc1tpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgcmVwbGFjZS5hcmd1bWVudHNbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG5vZGUuY2FsbGVlLm9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogVmVjQmFzZS5pbmRleFRvU3dpenpsZShpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBBTk5PKHJlcGxhY2UpLmNvcHkoQU5OTyhub2RlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlU3dpenpsZU9wZXJhdG9yOiBmdW5jdGlvbih2ZWNDb3VudCwgc3dpenpsZSwgb3BlcmF0b3IsIG5vZGUsIGFyZ3MsIHBhcmVudCl7XHJcbiAgICAgICAgICAgIHZhciBzaW5ndWxhciA9IHN3aXp6bGUubGVuZ3RoID09IDE7XHJcbiAgICAgICAgICAgIHZhciBhcmdPYmplY3QgPSBzaW5ndWxhciA/IG5vZGUuYXJndW1lbnRzWzBdIDogVmVjLmdlbmVyYXRlVmVjRnJvbUFyZ3Moc3dpenpsZS5sZW5ndGgsIG5vZGUuYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdmFyIHJlcGxhY2UgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTmV3RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgIGNhbGxlZToge1xyXG4gICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlZlY1wiICsgdmVjQ291bnRcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzd2l6emxlLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgICAgIHZhciBpZHggPSBWZWNCYXNlLnN3aXp6bGVUb0luZGV4KHN3aXp6bGUuY2hhckF0KGkpKTtcclxuICAgICAgICAgICAgICAgIGluZGljZXNbaWR4XSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZlY0NvdW50OyArK2kpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNWYWx1ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG5vZGUuY2FsbGVlLm9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogVmVjQmFzZS5pbmRleFRvU3dpenpsZShpKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZihpbmRpY2VzW2ldICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2UuYXJndW1lbnRzW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzaW5ndWxhciA/IGFyZ09iamVjdCA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBhcmdPYmplY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFZlY0Jhc2UuaW5kZXhUb1N3aXp6bGUoaW5kaWNlc1tpXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICByZXBsYWNlLmFyZ3VtZW50c1tpXSA9IHRoaXNWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEFOTk8ocmVwbGFjZSkuY29weShBTk5PKG5vZGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXR0YWNoU3dpenpsZXM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdmVjQ291bnQsIGNhbGxFeHAsIGNhbGxPcGVyYXRvckV4cCl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgcyA9IDA7IHMgPCBWZWNCYXNlLnN3aXp6bGVTZXRzLmxlbmd0aDsgKytzKXtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgY291bnQgPSAxOyBjb3VudCA8PSA0OyArK2NvdW50KXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5wb3codmVjQ291bnQsIGNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1heDsgKytpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtdLCB3aXRoU2V0dGVyID0gKGNvdW50IDw9IHZlY0NvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciAgaiA9IDA7IGogPCBjb3VudDsgKytqKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSB2YWwgJSB2ZWNDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsIC8gdmVjQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Kz0gVmVjQmFzZS5zd2l6emxlU2V0c1tzXVtpZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaW5kaWNlc1tpZHhdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhTZXR0ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzW2lkeF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW2tleV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsRXhwOiBjYWxsRXhwLmJpbmQobnVsbCwgdmVjQ291bnQsIGtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod2l0aFNldHRlciAmJiBjYWxsT3BlcmF0b3JFeHApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBvcGVyYXRvciBpbiBWZWNCYXNlLnN3aXp6bGVPcGVyYXRvcnMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcFN5bWJvbCA9IFZlY0Jhc2Uuc3dpenpsZU9wZXJhdG9yc1tvcGVyYXRvcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5ICsgb3BlcmF0b3JdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsRXhwOiBjYWxsT3BlcmF0b3JFeHAuYmluZChudWxsLCB2ZWNDb3VudCwga2V5LCBvcFN5bWJvbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY3JlYXRlT3BlcmF0b3I6IGZ1bmN0aW9uKHZlY0NvdW50LCBvcGVyYXRvciwgbm9kZSwgYXJncywgcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlciA9IFZlYy5nZW5lcmF0ZVZlY0Zyb21BcmdzKHZlY0NvdW50LCBub2RlLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHZhciByZXBsYWNlID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkJpbmFyeUV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogb3BlcmF0b3IsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBub2RlLmNhbGxlZS5vYmplY3QsXHJcbiAgICAgICAgICAgICAgICByaWdodDogb3RoZXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQU5OTyhyZXBsYWNlKS5jb3B5KEFOTk8obm9kZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhdHRhY2hPcGVyYXRvcnM6IGZ1bmN0aW9uKGluc3RhbmNlLCB2ZWNDb3VudCwgb3BlcmF0b3JzKXtcclxuICAgICAgICAgICAgZm9yKHZhciBuYW1lIGluIG9wZXJhdG9ycyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBvcGVyYXRvcnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsRXhwOiBWZWMuY3JlYXRlT3BlcmF0b3IuYmluZChudWxsLCB2ZWNDb3VudCwgb3BlcmF0b3IpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjcmVhdGVGdW5jdGlvbkNhbGw6IGZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgc2Vjb25kVmVjU2l6ZSwgbm9kZSwgYXJncywgcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciByZXBsYWNlID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgY2FsbGVlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU3ludGF4LklkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25OYW1lXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jYWxsZWUub2JqZWN0XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmKHNlY29uZFZlY1NpemUpe1xyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gVmVjLmdlbmVyYXRlVmVjRnJvbUFyZ3Moc2Vjb25kVmVjU2l6ZSwgbm9kZS5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZS5hcmd1bWVudHMucHVzaChvdGhlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQU5OTyhyZXBsYWNlKS5jb3B5KEFOTk8obm9kZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZW5lcmF0ZUxlbmd0aENhbGw6IGZ1bmN0aW9uKG5vZGUsIGFyZ3MsIHBhcmVudCl7XHJcbiAgICAgICAgICAgIGlmKGFyZ3MubGVuZ3RoID09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYy5jcmVhdGVGdW5jdGlvbkNhbGwoJ2xlbmd0aCcsIDAsIG5vZGUsIGFyZ3MsIHBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJyonLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IG5vZGUuY2FsbGVlLm9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICcvJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbm9kZS5hcmd1bWVudHNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBWZWMuY3JlYXRlRnVuY3Rpb25DYWxsKCdsZW5ndGgnLCAwLCBub2RlLCBhcmdzLCBwYXJlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIEFOTk8ocmVwbGFjZS5yaWdodCkuc2V0VHlwZShUWVBFUy5OVU1CRVIpO1xyXG4gICAgICAgICAgICAgICAgQU5OTyhyZXBsYWNlKS5jb3B5KEFOTk8obm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZW5lcmF0ZUNvbnN0cnVjdG9yOiBmdW5jdGlvbihub2RlKXtcclxuICAgICAgICAgICAgbm9kZS5hcmd1bWVudHMgPSBWZWMuZ2V0VmVjQXJncyhub2RlLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgTWF0ID0ge1xyXG4gICAgICAgIFRZUEVTOiB7XHJcbiAgICAgICAgICAgIFwiTWF0M1wiIDoge2tpbmQ6IEtJTkRTLk1BVFJJWDMsIGNvbEtpbmQ6IEtJTkRTLkZMT0FUMywgY29sQ291bnQ6IDMsIGdsc2xUeXBlOiBcIm1hdDNcIn0sXHJcbiAgICAgICAgICAgIFwiTWF0NFwiIDoge2tpbmQ6IEtJTkRTLk1BVFJJWDQsIGNvbEtpbmQ6IEtJTkRTLkZMT0FUNCwgY29sQ291bnQ6IDQsIGdsc2xUeXBlOiBcIm1hdDNcIn1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZW5lcmF0ZU1hdEZyb21BcmdzOiBmdW5jdGlvbihtYXROYW1lLCBhcmdzKXtcclxuICAgICAgICAgICAgaWYoYXJncy5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgICAgICAgICBhcmdzID0gVmVjLmdldFZlY0FyZ3MoYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGFyZ3MubGVuZ3RoID09IDEgJiYgQU5OTyhhcmdzWzBdKS5pc09mS2luZCggTWF0LlRZUEVTW21hdE5hbWVdLmtpbmQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTmV3RXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgIGNhbGxlZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG1hdE5hbWVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQU5OTyhyZXN1bHQpLnNldFR5cGUoVFlQRVMuT0JKRUNULCBNYXQuVFlQRVNbbWF0TmFtZV0ua2luZCk7XHJcbiAgICAgICAgICAgIEFOTk8ocmVzdWx0LmNhbGxlZSkuc2V0VHlwZShUWVBFUy5GVU5DVElPTik7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY3JlYXRlT3BlcmF0b3I6IGZ1bmN0aW9uKG1hdE5hbWUsIG9wZXJhdG9yLCBub2RlLCBhcmdzLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIG90aGVyID0gTWF0LmdlbmVyYXRlTWF0RnJvbUFyZ3MobWF0TmFtZSwgbm9kZS5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB2YXIgcmVwbGFjZSA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogbm9kZS5jYWxsZWUub2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG90aGVyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFOTk8ocmVwbGFjZSkuY29weShBTk5PKG5vZGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXR0YWNoT3BlcmF0b3JzOiBmdW5jdGlvbihpbnN0YW5jZSwgbWF0TmFtZSwgb3BlcmF0b3JzKXtcclxuICAgICAgICAgICAgZm9yKHZhciBuYW1lIGluIG9wZXJhdG9ycyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBvcGVyYXRvcnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsRXhwOiBNYXQuY3JlYXRlT3BlcmF0b3IuYmluZChudWxsLCBtYXROYW1lLCBvcGVyYXRvcilcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdlbmVyYXRlQ29sQ2FsbDogZnVuY3Rpb24obWF0TmFtZSwgbm9kZSwgYXJncywgcGFyZW50LCBzdGF0ZSl7XHJcbiAgICAgICAgICAgIHZhciBtZW1iZXJBY2Nlc3MgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgIG9iamVjdDogbm9kZS5jYWxsZWUub2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IG5vZGUuYXJndW1lbnRzWzBdLFxyXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQU5OTyhtZW1iZXJBY2Nlc3MpLnNldFR5cGUoVFlQRVMuT0JKRUNULCBNYXQuVFlQRVNbbWF0TmFtZV0uY29sS2luZCk7XHJcblxyXG4gICAgICAgICAgICBpZihhcmdzLmxlbmd0aCA9PSAxKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXJBY2Nlc3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHZhciBtZXRob2RLZXkgPSBcIl9cIiArIG1hdE5hbWUgKyBcIl9jb2xcIjtcclxuICAgICAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbnMuZ2V0SW50ZXJuYWxGdW5jdGlvbk5hbWUoc3RhdGUsIG1ldGhvZEtleSxcclxuICAgICAgICAgICAgICAgICAgICBcIk1hdENvbFwiLCB7Y29sVHlwZTogXCJ2ZWNcIiArIE1hdC5UWVBFU1ttYXROYW1lXS5jb2xDb3VudCwgbWF0VHlwZTogTWF0LlRZUEVTW21hdE5hbWVdLmdsc2xUeXBlfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgIHZhciByZXBsYWNlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICBjYWxsZWU6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogbWV0aG9kTmFtZX0sXHJcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2FsbGVlLm9iamVjdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudHNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnRzWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIEFOTk8ocmVwbGFjZSkuY29weShBTk5PKG5vZGUpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgbnMuVmVjID0gVmVjO1xyXG4gICAgbnMuTWF0ID0gTWF0O1xyXG5cclxuICAgIG5zLmNhc3RUb0Zsb2F0ID0gZnVuY3Rpb24gKGFzdCkge1xyXG4gICAgICAgIHZhciBleHAgPSBBTk5PKGFzdCk7XHJcblxyXG4gICAgICAgIGlmICghZXhwLmlzTnVtYmVyKCkpIHsgICAvLyBDYXN0XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICBjYWxsZWU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTeW50YXguSWRlbnRpZmllcixcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImZsb2F0XCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFthc3RdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFzdDtcclxuICAgIH1cclxuXHJcbiAgICBucy5nZXROYW1lRm9yU3lzdGVtID0gZnVuY3Rpb24oYmFzZU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gYmFzZU5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgbnMuZ2V0TmFtZUZvckdsb2JhbCA9IGZ1bmN0aW9uKGJhc2VOYW1lKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBcIl9lbnZfXCIgKyBiYXNlTmFtZTtcclxuICAgICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9fKy9nLCBcIl9cIik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG4gICAgICogQHBhcmFtICB7R0xUcmFuc2Zvcm1Db250ZXh0fSBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgbnMuY2FzdFRvVmVjNCA9IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIGV4cCA9IFR5cGVJbmZvLmNyZWF0ZUZvckNvbnRleHQobm9kZSwgY29udGV4dCk7XHJcblxyXG4gICAgICAgIGlmIChleHAuaXNPZktpbmQoS0lORFMuRkxPQVQ0KSB8fCBleHAuaXNPZktpbmQoS0lORFMuQ09MT1JfQ0xPU1VSRSkpXHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG5cclxuICAgICAgICBpZiAoZXhwLmlzT2ZLaW5kKEtJTkRTLkZMT0FUMykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5DYWxsRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgIGNhbGxlZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwidmVjNFwiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbbm9kZSwgeyB0eXBlOiBTeW50YXguTGl0ZXJhbCwgdmFsdWU6IDEuMCwgZXh0cmE6IHsgdHlwZTogVFlQRVMuTlVNQkVSfSB9XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNoYWRlLnRocm93RXJyb3Iobm9kZSwgXCJDYW4ndCBjYXN0IGZyb20gJ1wiICsgZXhwLmdldFR5cGVTdHJpbmcoKSArIFwiJyB0byB2ZWM0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIG5zLmV4dGVuZCA9IEJhc2UuZXh0ZW5kO1xyXG4gICAgbnMuY3JlYXRlQ2xhc3MgPSBCYXNlLmNyZWF0ZUNsYXNzO1xyXG5cclxufShleHBvcnRzKSlcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG4gICAgdmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VzcHJpbWEnKSxcclxuICAgICAgICBjb2RlZ2VuID0gcmVxdWlyZSgnZXNjb2RlZ2VuJyksXHJcbiAgICAgICAgcGFyYW1ldGVycyA9IHJlcXVpcmUoXCIuL2FuYWx5emUvcGFyYW1ldGVycy5qc1wiKSxcclxuICAgICAgICBpbnRlcmZhY2VzID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgICAgICBpbmZlcmVuY2UgPSByZXF1aXJlKFwiLi9hbmFseXplL3R5cGVpbmZlcmVuY2UvdHlwZWluZmVyZW5jZS5qc1wiKSxcclxuICAgICAgICBzYW5pdGl6ZXIgPSByZXF1aXJlKFwiLi9hbmFseXplL3Nhbml0aXplci9zYW5pdGl6ZXIuanNcIiksXHJcbiAgICAgICAgQmFzZSA9IHJlcXVpcmUoXCIuL2Jhc2UvaW5kZXguanNcIiksXHJcbiAgICAgICAgR0xTTENvbXBpbGVyID0gcmVxdWlyZShcIi4vZ2VuZXJhdGUvZ2xzbC9jb21waWxlci5qc1wiKS5HTFNMQ29tcGlsZXIsXHJcbiAgICAgICAgR0xNYXRyaXhDb21waWxlciA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlL2dsbWF0cml4L2NvbXBpbGVyLmpzXCIpLkdMTWF0cml4Q29tcGlsZXIsXHJcbiAgICAgICAgTGlnaHRQYXNzR2VuZXJhdG9yID0gcmVxdWlyZShcIi4vZ2VuZXJhdGUvbGlnaHQtcGFzcy9saWdodC1wYXNzLWdlbmVyYXRvci5qc1wiKSxcclxuICAgICAgICByZXNvbHZlciA9IHJlcXVpcmUoXCIuL3Jlc29sdmUvcmVzb2x2ZS5qc1wiKSxcclxuICAgICAgICBTcGFjZVRyYW5zZm9ybWVyID0gcmVxdWlyZShcIi4vZ2VuZXJhdGUvc3BhY2UvdHJhbnNmb3JtLmpzXCIpLlNwYWNlVHJhbnNmb3JtZXIsXHJcbiAgICAgICAgdmFsaWRhdG9yID0gcmVxdWlyZShcIi4vYW5hbHl6ZS92YWxpZGF0b3IuanNcIiksXHJcbiAgICAgICAgYW5hbHl6ZXIgPSByZXF1aXJlKFwiLi9hbmFseXplL2FuYWx5emUuanNcIiksXHJcbiAgICAgICAgU3BhY2VWZWN0b3JUeXBlID0gaW50ZXJmYWNlcy5TcGFjZVZlY3RvclR5cGUsXHJcbiAgICAgICAgU3BhY2VUeXBlID0gaW50ZXJmYWNlcy5TcGFjZVR5cGUsXHJcbiAgICAgICAgVmVjdG9yVHlwZSA9IGludGVyZmFjZXMuVmVjdG9yVHlwZSxcclxuICAgICAgICBTbmlwcGV0TGlzdCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlL3NuaXBwZXRzL3NuaXBwZXQtbGlzdC5qc1wiKS5TbmlwcGV0TGlzdCxcclxuICAgICAgICBTbmlwcGV0RW50cnkgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZS9zbmlwcGV0cy9zbmlwcGV0LWxpc3QuanNcIikuU25pcHBldEVudHJ5LFxyXG4gICAgICAgIFNuaXBwZXRDb25uZWN0b3IgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZS9zbmlwcGV0cy9zbmlwcGV0LWNvbm5lY3RvclwiKSxcclxuICAgICAgICBHbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbnRyaWIvZ2wtbWF0cml4LmpzXCIpO1xyXG5cclxuXHJcbiAgICByZXF1aXJlKFwiLi9jb250cmliL2dsLW1hdHJpeC1leHRlbmQuanNcIikuZXh0ZW5kKEdsTWF0cml4KTtcclxuXHJcblxyXG4gICAgdmFyIFdvcmtpbmdTZXQgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuYXN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmFhc3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb2Nlc3NpbmdEYXRhID0ge307XHJcbiAgICB9O1xyXG4gICAgQmFzZS5leHRlbmQoV29ya2luZ1NldC5wcm90b3R5cGUsIHtcclxuICAgICAgICBzZXRBc3Q6IGZ1bmN0aW9uKGFzdCl7XHJcbiAgICAgICAgICAgIHRoaXMuYXN0ID0gYXN0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKGNvZGUsIG9wdCl7XHJcbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICAgICAgdGhpcy5hc3QgPSBucy5wYXJzZShjb2RlLCBvcHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYW5hbHl6ZTogZnVuY3Rpb24oaW5qZWN0LCBpbXBsZW1lbnRhdGlvbiwgb3B0KXtcclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgICAgICBvcHQuZW50cnkgPSBvcHQuZW50cnkgfHwgXCJnbG9iYWwuc2hhZGVcIjtcclxuICAgICAgICAgICAgb3B0LnZhbGlkYXRlID0gb3B0LnZhbGlkYXRlICE9PSB1bmRlZmluZWQgPyBvcHQudmFsaWRhdGUgOiB0cnVlO1xyXG4gICAgICAgICAgICBvcHQudGhyb3dPbkVycm9yID0gb3B0LnRocm93T25FcnJvciAhPT0gdW5kZWZpbmVkID8gb3B0LnRocm93T25FcnJvciA6IHRydWU7XHJcbiAgICAgICAgICAgIG9wdC5pbXBsZW1lbnRhdGlvbiA9IGltcGxlbWVudGF0aW9uO1xyXG4gICAgICAgICAgICBvcHQuaW5qZWN0ID0gaW5qZWN0O1xyXG4gICAgICAgICAgICB0aGlzLmFhc3QgPSBhbmFseXplci5hbmFseXplKHRoaXMuYXN0LCB0aGlzLnByb2Nlc3NpbmdEYXRhLCBvcHQpLmFzdDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWFzdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFByb2Nlc3NpbmdEYXRhOiBmdW5jdGlvbihrZXkpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nRGF0YVtrZXldO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tcGlsZUZyYWdtZW50U2hhZGVyOiBmdW5jdGlvbihvcHQpe1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG5zLmNvbXBpbGVGcmFnbWVudFNoYWRlcih0aGlzLmFhc3QsIG9wdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuICAgIEJhc2UuZXh0ZW5kKG5zLCB7XHJcblxyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihhc3QsIG9wdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFzdCA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZShhc3QsIHtyYXc6IHRydWUsIGxvYzogb3B0LmxvYyB8fCBmYWxzZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXN0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuYWx5emUgdGhlIGdpdmVuIHNvdXJjZSBhbmQgZXh0cmFjdCBhbGwgdXNlZCBzaGFkZXIgYW5kIHN5c3RlbSBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufHN0cmluZ30gaW5wdXQgVGhlIGZ1bmN0aW9uIG9mIHNvdXJjZSBjb2RlIHRvIGFuYWx5emVcclxuICAgICAgICAgKiBAcGFyYW0gb3B0IE9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7e3NoYWRlclBhcmFtZXRlcnM6IEFycmF5LCBzeXN0ZW1QYXJhbWV0ZXJzOiBBcnJheX19XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uIChpbnB1dCwgb3B0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhc3QgPSBwYXJzZXIucGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5leHRyYWN0UGFyYW1ldGVycyhhc3QsIG9wdCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0U2FuaXRpemVkQXN0OiBmdW5jdGlvbihzdHIsIG9wdCl7XHJcbiAgICAgICAgICAgIHZhciBhc3QgPSB0aGlzLnBhcnNlKHN0ciwgb3B0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNhbml0aXplci5zYW5pdGl6ZShhc3QsIG9wdCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcGFyc2VBbmRJbmZlcmVuY2VFeHByZXNzaW9uOiBmdW5jdGlvbiAoYXN0LCBvcHQpIHtcclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgICAgICBvcHQuZW50cnkgPSBvcHQuZW50cnkgfHwgXCJnbG9iYWwuc2hhZGVcIjtcclxuICAgICAgICAgICAgb3B0LnZhbGlkYXRlID0gb3B0LnZhbGlkYXRlICE9PSB1bmRlZmluZWQgPyBvcHQudmFsaWRhdGUgOiB0cnVlO1xyXG4gICAgICAgICAgICBvcHQudGhyb3dPbkVycm9yID0gb3B0LnRocm93T25FcnJvciAhPT0gdW5kZWZpbmVkID8gb3B0LnRocm93T25FcnJvciA6IHRydWU7XHJcblxyXG4gICAgICAgICAgICBhc3QgPSBucy5wYXJzZShhc3QsIG9wdCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhbmFseXplci5hbmFseXplKGFzdCwge30sIG9wdCkuYXN0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFuYWx5emU6IGZ1bmN0aW9uKGFzdCwgb3B0KSB7XHJcbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICAgICAgYXN0ID0gbnMucGFyc2UoYXN0LCBvcHQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFuYWx5emVyLmFuYWx5emUoYXN0LCB7fSwgb3B0KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlc29sdmVDbG9zdXJlczogZnVuY3Rpb24oYXN0LCBpbXBsZW1lbnRhdGlvbiwgcHJvY2Vzc0RhdGEsIG9wdCkge1xyXG4gICAgICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhID0gcHJvY2Vzc0RhdGEgfHwge307XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlci5yZXNvbHZlQ2xvc3VyZXNQcmVUeXBlSW5mZXJlbmNlKGFzdCwgaW1wbGVtZW50YXRpb24sIHByb2Nlc3NEYXRhLCBvcHQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlc29sdmVTcGFjZXM6IGZ1bmN0aW9uKGFhc3QsIG9wdCl7XHJcbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIFNwYWNlVHJhbnNmb3JtZXIudHJhbnNmb3JtQWFzdChhYXN0LCBvcHQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldExpZ2h0UGFzc0Fhc3Q6IGZ1bmN0aW9uKGNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMsIGluamVjdCwgb3B0KXtcclxuICAgICAgICAgICAgcmV0dXJuIExpZ2h0UGFzc0dlbmVyYXRvci5nZW5lcmF0ZUxpZ2h0UGFzc0Fhc3QoY29sb3JDbG9zdXJlU2lnbmF0dXJlcywgaW5qZWN0KVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNvbXBpbGVGcmFnbWVudFNoYWRlcjogZnVuY3Rpb24oYWFzdCwgb3B0KXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHTFNMQ29tcGlsZXIoKS5jb21waWxlRnJhZ21lbnRTaGFkZXIoYWFzdCwgb3B0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b0phdmFTY3JpcHQ6IGZ1bmN0aW9uKGFhc3QsIG9wdCl7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuLmdlbmVyYXRlKGFhc3QsIG9wdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRTbmlwcGV0QXN0OiBmdW5jdGlvbihjb2RlKXtcclxuICAgICAgICAgICAgdmFyIGZ1bGxBc3Q7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZihjb2RlKSA9PSBcImZ1bmN0aW9uXCIpe1xyXG4gICAgICAgICAgICAgICAgY29kZSA9IFwiTUVUSE9EPVwiICsgY29kZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgZnVsbEFzdCA9IHRoaXMuZ2V0U2FuaXRpemVkQXN0KGNvZGUsIHt9KS5ib2R5WzBdLmV4cHJlc3Npb24ucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGZ1bGxBc3QgPSB0aGlzLmdldFNhbml0aXplZEFzdChCYXNlLmRlZXBFeHRlbmQoe30sIGNvZGUpLCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bGxBc3Q7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY29tcGlsZUpzUHJvZ3JhbTogZnVuY3Rpb24oc25pcHBldExpc3QsIHN5c3RlbVBhcmFtcywgZGVmYXVsdEl0ZXJhdGlvbil7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBTbmlwcGV0Q29ubmVjdG9yLmNvbm5lY3RTbmlwcGV0cyhzbmlwcGV0TGlzdCwge1xyXG4gICAgICAgICAgICAgICAgbW9kZTogZGVmYXVsdEl0ZXJhdGlvbiA/IFNuaXBwZXRDb25uZWN0b3IuTU9ERS5KU19JVEVSQVRFIDogU25pcHBldENvbm5lY3Rvci5NT0RFLkpTX05PX0lURVJBVEV9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhYXN0ID0gdGhpcy5wYXJzZUFuZEluZmVyZW5jZUV4cHJlc3Npb24ocmVzdWx0LmFzdCwge1xyXG4gICAgICAgICAgICAgICAgZW50cnk6IFwiZ2xvYmFsLm1haW5cIixcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaW5qZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0aGlzXCI6IHN5c3RlbVBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICBcImdsb2JhbC5tYWluXCI6IHJlc3VsdC5hcmdUeXBlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb21waWxlZCA9IG5ldyBHTE1hdHJpeENvbXBpbGVyKCkuY29tcGlsZShhYXN0LCB7fSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiBjb21waWxlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY29tcGlsZVZlcnRleFNoYWRlcjogZnVuY3Rpb24oc25pcHBldExpc3QsIHN5c3RlbVBhcmFtcyl7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBTbmlwcGV0Q29ubmVjdG9yLmNvbm5lY3RTbmlwcGV0cyhzbmlwcGV0TGlzdCwgeyBtb2RlOiBTbmlwcGV0Q29ubmVjdG9yLk1PREUuR0xTTF9WUyB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhYXN0ID0gdGhpcy5wYXJzZUFuZEluZmVyZW5jZUV4cHJlc3Npb24ocmVzdWx0LmFzdCwge1xyXG4gICAgICAgICAgICAgICAgZW50cnk6IFwiZ2xvYmFsLm1haW5cIixcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaW5qZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0aGlzXCI6IHN5c3RlbVBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICBcImdsb2JhbC5tYWluXCI6IHJlc3VsdC5hcmdUeXBlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnB1dEluZGljZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yKHZhciBpbnB1dE5hbWUgaW4gcmVzdWx0LmlucHV0SW5kaWNlcyl7XHJcbiAgICAgICAgICAgICAgICBpbnB1dEluZGljZXNbXCJfZW52X1wiICsgaW5wdXROYW1lXSA9ICByZXN1bHQuaW5wdXRJbmRpY2VzW2lucHV0TmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjb21waWxlZCA9IG5ldyBHTFNMQ29tcGlsZXIoKS5jb21waWxlVmVydGV4U2hhZGVyKGFhc3QsIHt9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbXBpbGVkLnNvdXJjZSxcclxuICAgICAgICAgICAgICAgIGlucHV0SW5kaWNlczogaW5wdXRJbmRpY2VzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgVFlQRVMgOiBpbnRlcmZhY2VzLlRZUEVTLFxyXG4gICAgICAgIE9CSkVDVF9LSU5EUyA6IGludGVyZmFjZXMuT0JKRUNUX0tJTkRTLFxyXG4gICAgICAgIFNPVVJDRVM6IGludGVyZmFjZXMuU09VUkNFUyxcclxuICAgICAgICBTUEFDRV9WRUNUT1JfVFlQRVM6IFNwYWNlVmVjdG9yVHlwZSxcclxuICAgICAgICBWZWMyOiBpbnRlcmZhY2VzLlZlYzIsXHJcbiAgICAgICAgVmVjMzogaW50ZXJmYWNlcy5WZWMzLFxyXG4gICAgICAgIFZlYzQ6IGludGVyZmFjZXMuVmVjNCxcclxuICAgICAgICBUZXh0dXJlOiBpbnRlcmZhY2VzLlRleHR1cmUsXHJcbiAgICAgICAgQ29sb3I6IGludGVyZmFjZXMuQ29sb3IsXHJcbiAgICAgICAgTWF0MzogaW50ZXJmYWNlcy5NYXQzLFxyXG4gICAgICAgIE1hdDQ6IGludGVyZmFjZXMuTWF0NCxcclxuICAgICAgICBXb3JraW5nU2V0OiBXb3JraW5nU2V0LFxyXG4gICAgICAgIFNuaXBwZXRMaXN0OiBTbmlwcGV0TGlzdCxcclxuICAgICAgICBTbmlwcGV0RW50cnk6IFNuaXBwZXRFbnRyeSxcclxuICAgICAgICBNYXRoOiBHbE1hdHJpeFxyXG5cclxufSk7XHJcbiAgICAvKipcclxuICAgICAqIExpYnJhcnkgdmVyc2lvbjpcclxuICAgICAqL1xyXG4gICAgbnMudmVyc2lvbiA9ICcwLjAuMSc7XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG4gICAgdmFyIEJhc2UgPSByZXF1aXJlKFwiLi9iYXNlL2luZGV4LmpzXCIpO1xyXG4gICAgdmFyIENvZGVHZW4gPSByZXF1aXJlKFwiZXNjb2RlZ2VuXCIpO1xyXG4gICAgdmFyIFZlY01hdGggPSByZXF1aXJlKFwiLi9iYXNlL3ZlY21hdGguanNcIikuVmVjTWF0aDtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW51bSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICB2YXIgVHlwZXMgPSBucy5UWVBFUyA9IHtcclxuICAgICAgICBBTlk6IFwiYW55XCIsXHJcbiAgICAgICAgSU5UOiBcImludFwiLFxyXG4gICAgICAgIE5VTUJFUjogXCJudW1iZXJcIixcclxuICAgICAgICBCT09MRUFOOiBcImJvb2xlYW5cIixcclxuICAgICAgICBPQkpFQ1Q6IFwib2JqZWN0XCIsXHJcbiAgICAgICAgQVJSQVk6IFwiYXJyYXlcIixcclxuICAgICAgICBOVUxMOiBcIm51bGxcIixcclxuICAgICAgICBVTkRFRklORUQ6IFwidW5kZWZpbmVkXCIsXHJcbiAgICAgICAgRlVOQ1RJT046IFwiZnVuY3Rpb25cIixcclxuICAgICAgICBTVFJJTkc6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgSU5WQUxJRDogXCJpbnZhbGlkXCJcclxuICAgIH1cclxuXHJcbiAgICB2YXIgS2luZHMgPSBucy5PQkpFQ1RfS0lORFMgPSB7XHJcbiAgICAgICAgQU5ZOiBcImFueVwiLFxyXG4gICAgICAgIEZMT0FUMjogXCJmbG9hdDJcIiwgLy8gdmlydHVhbCBraW5kc1xyXG4gICAgICAgIEZMT0FUMzogXCJmbG9hdDNcIiwgLy8gdmlydHVhbCBraW5kc1xyXG4gICAgICAgIEZMT0FUNDogXCJmbG9hdDRcIiwgLy8gdmlydHVhbCBraW5kc1xyXG4gICAgICAgIE5PUk1BTDogXCJub3JtYWxcIixcclxuICAgICAgICBNQVRSSVgzOiBcIm1hdHJpeDNcIixcclxuICAgICAgICBNQVRSSVg0OiBcIm1hdHJpeDRcIixcclxuICAgICAgICBURVhUVVJFOiBcInRleHR1cmVcIixcclxuICAgICAgICBDT0xPUl9DTE9TVVJFOiBcImNvbG9yX2Nsb3N1cmVcIlxyXG4gICAgfVxyXG5cclxuICAgIHZhciBTZW1hbnRpY3MgPSBucy5TRU1BTlRJQ1MgPSB7XHJcbiAgICAgICAgQ09MT1I6ICdjb2xvcicsXHJcbiAgICAgICAgTk9STUFMOiAnbm9ybWFsJyxcclxuICAgICAgICBTQ0FMQVJfMF9UT18xOiAnc2NhbGFyMFRvMScsXHJcbiAgICAgICAgVU5LTk9XTjogJ3Vua25vd24nXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3NzaWJsZSBTcGFjZXNcclxuICAgICAqIEBlbnVtXHJcbiAgICAgKi9cclxuICAgIHZhciBTcGFjZVR5cGUgPSBucy5TcGFjZVR5cGUgPSB7XHJcbiAgICAgICAgT0JKRUNUOiAwLFxyXG4gICAgICAgIFZJRVc6IDEsXHJcbiAgICAgICAgV09STEQ6IDIsXHJcbiAgICAgICAgUkVTVUxUOiA1XHJcbiAgICB9O1xyXG4gICAgdmFyIFZlY3RvclR5cGUgPSBucy5WZWN0b3JUeXBlID0ge1xyXG4gICAgICAgIE5PTkU6IDAsXHJcbiAgICAgICAgUE9JTlQ6IDEsXHJcbiAgICAgICAgTk9STUFMOiAyXHJcbiAgICB9O1xyXG4gICAgbnMuU3BhY2VWZWN0b3JUeXBlID0ge1xyXG4gICAgICAgIE9CSkVDVDogU3BhY2VUeXBlLk9CSkVDVCxcclxuICAgICAgICBWSUVXX1BPSU5UIDogU3BhY2VUeXBlLlZJRVcgKyAoVmVjdG9yVHlwZS5QT0lOVCA8PCAzKSxcclxuICAgICAgICBXT1JMRF9QT0lOVCA6IFNwYWNlVHlwZS5XT1JMRCArIChWZWN0b3JUeXBlLlBPSU5UIDw8IDMpLFxyXG4gICAgICAgIFZJRVdfTk9STUFMIDogU3BhY2VUeXBlLlZJRVcgKyAoVmVjdG9yVHlwZS5OT1JNQUwgPDwgMyksXHJcbiAgICAgICAgV09STERfTk9STUFMIDogU3BhY2VUeXBlLldPUkxEICsgKFZlY3RvclR5cGUuTk9STUFMIDw8IDMpLFxyXG4gICAgICAgIFJFU1VMVF9QT0lOVCA6IFNwYWNlVHlwZS5SRVNVTFQgKyAoVmVjdG9yVHlwZS5QT0lOVCA8PCAzKSxcclxuICAgICAgICBSRVNVTFRfTk9STUFMIDogU3BhY2VUeXBlLlJFU1VMVCArIChWZWN0b3JUeXBlLk5PUk1BTCA8PCAzKVxyXG4gICAgfTtcclxuICAgIG5zLmdldFZlY3RvckZyb21TcGFjZVZlY3RvciA9IGZ1bmN0aW9uKHNwYWNlVHlwZSl7XHJcbiAgICAgICAgcmV0dXJuIHNwYWNlVHlwZSA+PiAzO1xyXG4gICAgfVxyXG4gICAgbnMuZ2V0U3BhY2VGcm9tU3BhY2VWZWN0b3IgPSBmdW5jdGlvbihzcGFjZVR5cGUpe1xyXG4gICAgICAgIHJldHVybiBzcGFjZVR5cGUgJSA4O1xyXG4gICAgfVxyXG5cclxuICAgIG5zLlNPVVJDRVMgPSB7XHJcbiAgICAgICAgVU5JRk9STTogXCJ1bmlmb3JtXCIsXHJcbiAgICAgICAgVkVSVEVYOiBcInZlcnRleFwiLFxyXG4gICAgICAgIENPTlNUQU5UOiBcImNvbnN0YW50XCJcclxuICAgIH1cclxuXHJcbiAgICBucy5Db2xvckNsb3N1cmVzID0ge1xyXG4gICAgICAgIFwiZW1pc3NpdmVcIiA6IHtcclxuICAgICAgICAgICAgaW5wdXQ6IFtcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuT0JKRUNULCBraW5kOiBLaW5kcy5GTE9BVDMsIHNlbWFudGljOiBTZW1hbnRpY3MuQ09MT1J9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGlmZnVzZVwiIDoge1xyXG4gICAgICAgICAgICBpbnB1dDogW1xyXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IEtpbmRzLkZMT0FUMywgc2VtYW50aWM6IFNlbWFudGljcy5DT0xPUn0sXHJcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogS2luZHMuRkxPQVQzLCBzZW1hbnRpYzogU2VtYW50aWNzLk5PUk1BTH0sXHJcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk5VTUJFUiwgc2VtYW50aWM6IFNlbWFudGljcy5TQ0FMQVJfMF9UT18xLCBkZWZhdWx0VmFsdWU6IDAgfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInBob25nXCIgOiB7XHJcbiAgICAgICAgICAgIGlucHV0OiBbXHJcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogS2luZHMuRkxPQVQzLCBzZW1hbnRpYzogU2VtYW50aWNzLkNPTE9SfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuT0JKRUNULCBraW5kOiBLaW5kcy5GTE9BVDMsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuTlVNQkVSLCBzZW1hbnRpYzogU2VtYW50aWNzLlNDQUxBUl8wX1RPXzEsIGRlZmF1bHRWYWx1ZTogMH1cclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29va1RvcnJhbmNlOiB7XHJcbiAgICAgICAgICAgIGlucHV0OiBbXHJcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogS2luZHMuRkxPQVQzLCBzZW1hbnRpYzogU2VtYW50aWNzLkNPTE9SfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuT0JKRUNULCBraW5kOiBLaW5kcy5GTE9BVDMsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuTlVNQkVSLCBzZW1hbnRpYzogU2VtYW50aWNzLlNDQUxBUl8wX1RPXzEsIGRlZmF1bHRWYWx1ZTogMC4wfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuTlVNQkVSLCBzZW1hbnRpYzogU2VtYW50aWNzLlNDQUxBUl8wX1RPXzEsIGRlZmF1bHRWYWx1ZTogMC4wfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICB3YXJkOiB7XHJcbiAgICAgICAgICAgIGlucHV0OiBbXHJcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogS2luZHMuRkxPQVQzLCBzZW1hbnRpYzogU2VtYW50aWNzLkNPTE9SfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuT0JKRUNULCBraW5kOiBLaW5kcy5GTE9BVDMsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuT0JKRUNULCBraW5kOiBLaW5kcy5GTE9BVDMsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuTlVNQkVSLCBzZW1hbnRpYzogU2VtYW50aWNzLlNDQUxBUl8wX1RPXzEsIGRlZmF1bHRWYWx1ZTogMC4wfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuTlVNQkVSLCBzZW1hbnRpYzogU2VtYW50aWNzLlNDQUxBUl8wX1RPXzEsIGRlZmF1bHRWYWx1ZTogMC4wfVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2F0dGVyOiB7XHJcbiAgICAgICAgICAgIGlucHV0OiBbXHJcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk9CSkVDVCwga2luZDogS2luZHMuRkxPQVQzLCBzZW1hbnRpYzogU2VtYW50aWNzLkNPTE9SfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuT0JKRUNULCBraW5kOiBLaW5kcy5GTE9BVDMsIHNlbWFudGljOiBTZW1hbnRpY3MuTk9STUFMfSxcclxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHlwZXMuTlVNQkVSLCBzZW1hbnRpYzogU2VtYW50aWNzLlNDQUxBUl8wX1RPXzEsIGRlZmF1bHRWYWx1ZTogMH0sXHJcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk5VTUJFUiwgc2VtYW50aWM6IFNlbWFudGljcy5TQ0FMQVJfMF9UT18xLCBkZWZhdWx0VmFsdWU6IDB9XHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicmVmbGVjdFwiIDoge1xyXG4gICAgICAgICAgICBpbnB1dDogW1xyXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IEtpbmRzLkZMT0FUMywgc2VtYW50aWM6IFNlbWFudGljcy5OT1JNQUx9LFxyXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5OVU1CRVIsIHNlbWFudGljOiBTZW1hbnRpY3MuU0NBTEFSXzBfVE9fMSwgZGVmYXVsdFZhbHVlOiAxIH0sXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicmVmcmFjdFwiIDoge1xyXG4gICAgICAgICAgICBpbnB1dDogW1xyXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5PQkpFQ1QsIGtpbmQ6IEtpbmRzLkZMT0FUMywgc2VtYW50aWM6IFNlbWFudGljcy5OT1JNQUx9LFxyXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUeXBlcy5OVU1CRVIsIHNlbWFudGljOiBTZW1hbnRpY3MuU0NBTEFSXzBfVE9fMSwgZGVmYXVsdFZhbHVlOiAxIH0sXHJcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFR5cGVzLk5VTUJFUiwgc2VtYW50aWM6IFNlbWFudGljcy5VTktOT1dOLCBkZWZhdWx0VmFsdWU6IDEgfSxcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc0FycmF5KHYpe1xyXG4gICAgICAgIHJldHVybiB2IGluc3RhbmNlb2YgQXJyYXkgfHxcclxuICAgICAgICAgICAgdiBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxyXG4gICAgICAgICAgICB2IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5IHx8XHJcbiAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XHJcbiAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XHJcbiAgICAgICAgICAgIHYgaW5zdGFuY2VvZiBJbnQ4QXJyYXk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdEZyb21NYXRyaXgoZGVzdCwgbWF0U2l6ZSwgYXJncyl7XHJcbiAgICAgICAgaWYoYXJncy5sZW5ndGggPiAxKXtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICAgICAgaWYoYXJnc1tpXSBpbnN0YW5jZW9mIE1hdDMgfHwgYXJnc1tpXSBpbnN0YW5jZW9mIE1hdDQgfHwgYXJnc1tpXSBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiQ29uc3RydWN0aW5nIE1hdHJpeCBmcm9tIE1hdHJpeCBjYW4gb25seSB0YWtlIG9uZSBhcmd1bWVudFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFyZ3MubGVuZ3RoIDwgMSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmKGFyZ3MubGVuZ3RoID09IDEpe1xyXG4gICAgICAgICAgICB2YXIgc3JjTWF0ID0gYXJnc1swXTtcclxuICAgICAgICAgICAgdmFyIHNyY1NpemUgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYoc3JjTWF0IGluc3RhbmNlb2YgTWF0Mykgc3JjU2l6ZSA9IDM7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoc3JjTWF0IGluc3RhbmNlb2YgTWF0NCkgc3JjU2l6ZSA9IDQ7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoaXNBcnJheShzcmNNYXQpKSBzcmNTaXplID0gc3JjTWF0Lmxlbmd0aCA9PSAxNiA/IDQgOiAzO1xyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgeSA9IDA7IHkgPCBtYXRTaXplOyB5KyspXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggPSAwOyB4IDwgbWF0U2l6ZTsgeCsrKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzdElkeCA9IHkqbWF0U2l6ZSArIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoeCA8IHNyY1NpemUgJiYgeSA8IHNyY1NpemUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjSWR4ID0geSpzcmNTaXplICsgeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFtkZXN0SWR4XSA9IHNyY01hdFtzcmNJZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGRlc3RbZGVzdElkeF0gPSB4ID09IHkgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaWxsVmVjdG9yKGRlc3QsIHZlY1NpemUsIGFyZ3VtZW50cyl7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gZmFsc2U7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwICl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2ZWNTaXplOyArK2kpXHJcbiAgICAgICAgICAgICAgICBkZXN0W2ldID0gMDtcclxuICAgICAgICAgICAgaWYoY29sb3IpIGRlc3RbM10gPSAxO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiAhaXNOYU4oYXJndW1lbnRzWzBdKSl7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2ZWNTaXplOyArK2kpXHJcbiAgICAgICAgICAgICAgICBkZXN0W2ldID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICBpZihjb2xvcikgZGVzdFszXSA9IDE7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpZHggPSAwO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGlkeCA8IHZlY1NpemUgJiYgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBhcmc9IGFyZ3VtZW50c1tpXSwgY250ID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmKCFpc05hTihhcmcpKSBjbnQgPSAxO1xyXG4gICAgICAgICAgICBlbHNlIGlmKGFyZyBpbnN0YW5jZW9mIFZlYzIpIGNudCA9IDI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoYXJnIGluc3RhbmNlb2YgVmVjMykgY250ID0gMztcclxuICAgICAgICAgICAgZWxzZSBpZihhcmcgaW5zdGFuY2VvZiBWZWM0KSBjbnQgPSA0O1xyXG4gICAgICAgICAgICBlbHNlIGlmKGFyZyBpbnN0YW5jZW9mIE1hdDMpIGNudCA9IDk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoYXJnIGluc3RhbmNlb2YgTWF0NCkgY250ID0gMTY7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheShhcmcpIHx8ICh0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiICYmIFwiQllURVNfUEVSX0VMRU1FTlRcIiBpbiBhcmcpKSBjbnQgPSBhcmcubGVuZ3RoO1xyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmKGNudCA9PSAxKVxyXG4gICAgICAgICAgICAgICAgZGVzdFtpZHgrK10gPSBhcmcgfHwgMDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaWR4IDwgdmVjU2l6ZSAmJiBqIDwgY250OyArK2ope1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RbaWR4KytdID0gYXJnW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihpIDwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIG1hbnkgYXJndW1lbnRzIGZvciBcIiArIChjb2xvciA/IFwiQ29sb3JcIiA6IFwiVmVjXCIgKyB2ZWNTaXplKSArIFwiLlwiKTtcclxuICAgICAgICBpZihpZHggPCB2ZWNTaXplKXtcclxuICAgICAgICAgICAgaWYoY29sb3IgJiYgKGlkeCA9PSAzKSlcclxuICAgICAgICAgICAgICAgIGRlc3RbM10gPSAxO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb3IgXCIgKyAoY29sb3IgPyBcIkNvbG9yXCIgOiBcIlZlY1wiICsgdmVjU2l6ZSkgKyBcIi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBUT0RPOiBHZW5lcmF0ZSBTd2l6emxlIGZ1bmN0aW9uc1xyXG4gICAgdmFyIFNXSVpaTEVfS0VZUyA9IFtcclxuICAgICAgICBbJ3gnLCd5JywneicsJ3cnXSxcclxuICAgICAgICBbJ3InLCAnZycsICdiJywgJ2EnXSxcclxuICAgICAgICBbJ3MnLCAndCcsICdwJywgJ3EnXVxyXG4gICAgXVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFN3aXp6bGVzKHByb3RvdHlwZSwgdmVjQ291bnQsIG1hc2tDb3VudCwgd2l0aFNldHRlcil7XHJcbiAgICAgICAgdmFyIG1heCA9IE1hdGgucG93KHZlY0NvdW50LCBtYXNrQ291bnQpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW10sIGtleXMgPSBbXCJcIiwgXCJcIiwgXCJcIl0sIHZhbCA9IGksIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHNldHRlckFyZ3MgPSBbXSwgZ2VuZXJhdGVTZXR0ZXIgPSB3aXRoU2V0dGVyO1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbWFza0NvdW50OyArK2ope1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHZhbCAlIHZlY0NvdW50O1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGlkeCk7XHJcbiAgICAgICAgICAgICAgICBpZihnZW5lcmF0ZVNldHRlcil7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc2V0dGVyQXJnc1tpZHhdID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlckFyZ3NbaWR4XSA9ICdvdGhlclsnICsgaiArICddJztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlU2V0dGVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgU1dJWlpMRV9LRVlTLmxlbmd0aDsgKytrKXtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzW2tdICs9IFNXSVpaTEVfS0VZU1trXVtpZHhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsID0gTWF0aC5mbG9vcih2YWwgLyB2ZWNDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ3RoaXNbJysgaWR4ICsgJ10nICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmdW5jQXJncyA9IFwiXCI7XHJcbiAgICAgICAgICAgIHZhciBib2R5ID0gJyAgcmV0dXJuIGdldFZlYycgKyBtYXNrQ291bnQgKyAnKCcgKyBhcmdzLmpvaW4oXCIsIFwiKSArJyk7XFxuJztcclxuICAgICAgICAgICAgaWYoZ2VuZXJhdGVTZXR0ZXIpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGFzc2lnblNldHRlcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCB2ZWNDb3VudDsgKytqKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihzZXR0ZXJBcmdzW2pdID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnblNldHRlcnNbal0gPSAndGhpc1snICsgaiArICddJztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnblNldHRlcnNbal0gPSBzZXR0ZXJBcmdzW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoKG1hc2tDb3VudCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIDogZnVuY0FyZ3MgPSBcIngsIHlcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzIDogZnVuY0FyZ3MgPSBcIngsIHksIHpcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0IDogZnVuY0FyZ3MgPSBcIngsIHksIHosIHdcIjsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYm9keSA9IFwiICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApXFxuICBcIiArIGJvZHkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFwiICBlbHNle1xcblwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICBcIiAgICB2YXIgb3RoZXI9Z2V0VmVjXCIgKyBtYXNrQ291bnQgKyAnLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgXCIgICAgcmV0dXJuIGdldFZlY1wiICsgdmVjQ291bnQgKyAnKCcgKyBhc3NpZ25TZXR0ZXJzLmpvaW4oXCIsIFwiKSArICcpO1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFwiICB9XFxuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQ29kZSA9ICdmdW5jdGlvbignICsgZnVuY0FyZ3MgKyAgJyl7XFxuJyArIGJvZHkgKyAnfSc7XHJcbiAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBldmFsKFwiKFwiICsgZnVuY3Rpb25Db2RlICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW2tleXNbal1dID0gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoKGUpe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIENvbXBpbGluZyBDb2RlOlxcblwiICsgZnVuY3Rpb25Db2RlKTtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZ2VuZXJhdGVTZXR0ZXIpe1xyXG4gICAgICAgICAgICAgICAgYWRkU3dpenpsZU9wZXJhdG9yKHByb3RvdHlwZSwgdmVjQ291bnQsIG1hc2tDb3VudCwga2V5cywgXCJBZGRcIiwgXCIrXCIsIHNldHRlckFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkU3dpenpsZU9wZXJhdG9yKHByb3RvdHlwZSwgdmVjQ291bnQsIG1hc2tDb3VudCwga2V5cywgXCJTdWJcIiwgXCItXCIsIHNldHRlckFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkU3dpenpsZU9wZXJhdG9yKHByb3RvdHlwZSwgdmVjQ291bnQsIG1hc2tDb3VudCwga2V5cywgXCJNdWxcIiwgXCIqXCIsIHNldHRlckFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgYWRkU3dpenpsZU9wZXJhdG9yKHByb3RvdHlwZSwgdmVjQ291bnQsIG1hc2tDb3VudCwga2V5cywgXCJEaXZcIiwgXCIvXCIsIHNldHRlckFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkU3dpenpsZU9wZXJhdG9yKHByb3RvdHlwZSwgdmVjQ291bnQsIG1hc2tDb3VudCwga2V5cywgbWV0aG9kTmFtZSwgb3BlcmF0b3IsIHNldHRlckFyZ3Mpe1xyXG4gICAgICAgIHZhciBhc3NpZ25TZXR0ZXJzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHZlY0NvdW50OyArK2ope1xyXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gJ3RoaXNbJyArIGogKyAnXSc7XHJcbiAgICAgICAgICAgIGlmKHNldHRlckFyZ3Nbal0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGFzc2lnblNldHRlcnNbal0gPSBwcmVmaXg7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGFzc2lnblNldHRlcnNbal0gPSBwcmVmaXggKyBcIiBcIiArIG9wZXJhdG9yICsgXCIgXCIgKyBzZXR0ZXJBcmdzW2pdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYm9keSA9ICBcIiAgIHZhciBvdGhlcj1nZXRWZWNcIiArIG1hc2tDb3VudCArICcuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICBcIiAgIHJldHVybiBnZXRWZWNcIiArIHZlY0NvdW50ICsgJygnICsgYXNzaWduU2V0dGVycy5qb2luKFwiLCBcIikgKyAnKTtcXG4nXHJcblxyXG4gICAgICAgIHZhciBmdW5jdGlvbkNvZGUgPSAnZnVuY3Rpb24oKXtcXG4nICsgYm9keSArICd9JztcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBldmFsKFwiKFwiICsgZnVuY3Rpb25Db2RlICsgXCIpXCIpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsrailcclxuICAgICAgICAgICAgICAgIHByb3RvdHlwZVtrZXlzW2pdICsgbWV0aG9kTmFtZV0gPSByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGUpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgQ29tcGlsaW5nIENvZGU6XFxuXCIgKyBmdW5jdGlvbkNvZGUpO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoZSB2aXJ0dWFsIFZlYzIgdHlwZVxyXG4gICAgKiBAY29uc3RydWN0b3JcclxuICAgICovXHJcbiAgICB2YXIgVmVjMiA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICBmaWxsVmVjdG9yKHRoaXMsIDIsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFZlYzIoKSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgVmVjMilcclxuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcclxuICAgICAgICB2YXIgb2JqID0gbmV3IFZlYzIoKTtcclxuICAgICAgICBWZWMyLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG5cclxuICAgIFZlYzIucHJvdG90eXBlLl90b0Zsb2F0QXJyYXkgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciByZXMgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgICAgIHZhciBpID0gMjsgd2hpbGUoaS0tKSByZXNbaV0gPSB0aGlzW2ldO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgVmVjMi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oeCwgeSkgeyAvLyAwIGFyZ3VtZW50cyA9PiBpZGVudGl0eSBvciBlcnJvcj9cclxuICAgICAgICB2YXIgYWRkID0gZ2V0VmVjMi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzWzBdICsgYWRkWzBdLCB0aGlzWzFdICsgYWRkWzFdKTtcclxuICAgIH1cclxuICAgIFZlYzIucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICB2YXIgc3ViID0gZ2V0VmVjMi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzWzBdIC0gc3ViWzBdLCB0aGlzWzFdIC0gc3ViWzFdKTtcclxuICAgIH1cclxuICAgIFZlYzIucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRWZWMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXNbMF0gKiBvdGhlclswXSwgdGhpc1sxXSAqIG90aGVyWzFdKTtcclxuICAgIH1cclxuICAgIFZlYzIucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRWZWMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXNbMF0gLyBvdGhlclswXSwgdGhpc1sxXSAvIG90aGVyWzFdKTtcclxuICAgIH1cclxuICAgIFZlYzIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRWZWMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXNbMF0gJSBvdGhlclswXSwgdGhpc1sxXSAlIG90aGVyWzFdKTtcclxuICAgIH1cclxuICAgIFZlYzIucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRWZWMyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gKiBvdGhlclswXSArIHRoaXNbMV0gKiBvdGhlclsxXTtcclxuICAgIH1cclxuICAgIFZlYzIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMihNYXRoLmFicyh0aGlzWzBdKSwgTWF0aC5hYnModGhpc1sxXSkpO1xyXG4gICAgfVxyXG4gICAgVmVjMi5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24obGVuZ3RoKSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZG90KHRoaXMpKTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsKGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFZlYzIucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCgxKTtcclxuICAgIH1cclxuXHJcbiAgICBWZWMyLnByb3RvdHlwZS54eSA9IFZlYzIucHJvdG90eXBlLnJnID0gVmVjMi5wcm90b3R5cGUuc3QgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFZlYzIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBWZWMyLnByb3RvdHlwZS54ID0gVmVjMi5wcm90b3R5cGUuciA9IFZlYzIucHJvdG90eXBlLnMgPSBmdW5jdGlvbih4KSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnh5KHgsIHRoaXNbMV0pO1xyXG4gICAgfVxyXG4gICAgVmVjMi5wcm90b3R5cGUueSA9IFZlYzIucHJvdG90eXBlLmcgPSBWZWMyLnByb3RvdHlwZS50ID0gZnVuY3Rpb24oeSkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMV07XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54eSh0aGlzWzBdLCB5KTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRTd2l6emxlcyhWZWMyLnByb3RvdHlwZSwgMiwgMiwgdHJ1ZSk7XHJcbiAgICBhZGRTd2l6emxlcyhWZWMyLnByb3RvdHlwZSwgMiwgMywgZmFsc2UpO1xyXG4gICAgYWRkU3dpenpsZXMoVmVjMi5wcm90b3R5cGUsIDIsIDQsIGZhbHNlKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmlydHVhbCBWZWMzIHR5cGVcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICB2YXIgVmVjMyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcclxuICAgICAgICBmaWxsVmVjdG9yKHRoaXMsIDMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VmVjMygpIHtcclxuICAgICAgICBpZihhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBWZWMzKVxyXG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIHZhciBvYmogPSBuZXcgVmVjMygpO1xyXG4gICAgICAgIFZlYzMuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgVmVjMy5wcm90b3R5cGUuX3RvRmxvYXRBcnJheSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XHJcbiAgICAgICAgdmFyIGkgPSAzOyB3aGlsZShpLS0pIHJlc1tpXSA9IHRoaXNbaV07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICBWZWMzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0VmVjMy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzWzBdICsgb3RoZXJbMF0sIHRoaXNbMV0gKyBvdGhlclsxXSwgdGhpc1syXSArIG90aGVyWzJdKTtcclxuICAgIH1cclxuICAgIFZlYzMucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRWZWMzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXNbMF0gLSBvdGhlclswXSwgdGhpc1sxXSAtIG90aGVyWzFdLCB0aGlzWzJdIC0gb3RoZXJbMl0pO1xyXG4gICAgfVxyXG4gICAgVmVjMy5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oeCwgeSwgeikge1xyXG4gICAgICAgIHZhciBvdGhlciA9IGdldFZlYzMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpc1swXSAqIG90aGVyWzBdLCB0aGlzWzFdICogb3RoZXJbMV0sIHRoaXNbMl0gKiBvdGhlclsyXSk7XHJcbiAgICB9XHJcbiAgICBWZWMzLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0VmVjMy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzWzBdIC8gb3RoZXJbMF0sIHRoaXNbMV0gLyBvdGhlclsxXSwgdGhpc1syXSAvIG90aGVyWzJdKTtcclxuICAgIH1cclxuICAgIFZlYzMucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uKHgsIHksIHopIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRWZWMzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXNbMF0gJSBvdGhlclswXSwgdGhpc1sxXSAlIG90aGVyWzFdLCB0aGlzWzJdICUgb3RoZXJbMl0pO1xyXG4gICAgfVxyXG4gICAgVmVjMy5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKE1hdGguYWJzKHRoaXNbMF0pLCBNYXRoLmFicyh0aGlzWzFdKSwgTWF0aC5hYnModGhpc1syXSkpO1xyXG4gICAgfVxyXG4gICAgVmVjMy5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24oeCwgeSwgeikge1xyXG4gICAgICAgIHZhciBvdGhlciA9IGdldFZlYzMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpc1swXSAqIG90aGVyWzBdICsgdGhpc1sxXSAqIG90aGVyWzFdICsgdGhpc1syXSAqIG90aGVyWzJdO1xyXG4gICAgfVxyXG4gICAgVmVjMy5wcm90b3R5cGUuY3Jvc3MgPSBmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0VmVjMy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHZhciB4ID0gdGhpc1sxXSAqIG90aGVyWzJdIC0gb3RoZXJbMV0gKiB0aGlzWzJdO1xyXG4gICAgICAgIHZhciB5ID0gdGhpc1syXSAqIG90aGVyWzBdIC0gb3RoZXJbMl0gKiB0aGlzWzBdO1xyXG4gICAgICAgIHZhciB6ID0gdGhpc1swXSAqIG90aGVyWzFdIC0gb3RoZXJbMF0gKiB0aGlzWzFdO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTtcclxuICAgIH1cclxuICAgIFZlYzMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRvdCh0aGlzKSk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bChsZW5ndGggLyB0aGlzLmxlbmd0aCgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBWZWMzLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGgoMSk7XHJcbiAgICB9XHJcbiAgICBWZWMzLnByb3RvdHlwZS54eXogPSBWZWMzLnByb3RvdHlwZS5yZ2IgPSBWZWMzLnByb3RvdHlwZS5zdHAgPSBmdW5jdGlvbih4LCB5LCB6KSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTtcclxuICAgIH1cclxuICAgIFZlYzMucHJvdG90eXBlLnggPSBWZWMzLnByb3RvdHlwZS5yID0gVmVjMy5wcm90b3R5cGUucyA9IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHgsIHRoaXNbMV0sIHRoaXNbMl0pO1xyXG4gICAgfVxyXG4gICAgVmVjMy5wcm90b3R5cGUueSA9IFZlYzMucHJvdG90eXBlLmcgPSBWZWMzLnByb3RvdHlwZS50ID0gZnVuY3Rpb24oeSkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMV07XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpc1swXSwgeSwgdGhpc1syXSk7XHJcbiAgICB9XHJcbiAgICBWZWMzLnByb3RvdHlwZS56ID0gVmVjMy5wcm90b3R5cGUuYiA9IFZlYzMucHJvdG90eXBlLnAgPSBmdW5jdGlvbih6KSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1syXTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzWzBdLCB0aGlzWzFdLCB6KTtcclxuICAgIH1cclxuICAgIGFkZFN3aXp6bGVzKFZlYzMucHJvdG90eXBlLCAzLCAyLCB0cnVlKTtcclxuICAgIGFkZFN3aXp6bGVzKFZlYzMucHJvdG90eXBlLCAzLCAzLCB0cnVlKTtcclxuICAgIGFkZFN3aXp6bGVzKFZlYzMucHJvdG90eXBlLCAzLCA0LCBmYWxzZSk7XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZpcnR1YWwgVmVjNCB0eXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIFZlYzQgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XHJcbiAgICAgICAgZmlsbFZlY3Rvcih0aGlzLCA0LCBhcmd1bWVudHMpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VmVjNCgpIHtcclxuICAgICAgICBpZihhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBWZWM0KVxyXG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIHZhciBvYmogPSBuZXcgVmVjNCgpO1xyXG4gICAgICAgIFZlYzQuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgVmVjNC5wcm90b3R5cGUuX3RvRmxvYXRBcnJheSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XHJcbiAgICAgICAgdmFyIGkgPSA0OyB3aGlsZShpLS0pIHJlc1tpXSA9IHRoaXNbaV07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICBWZWM0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0VmVjNC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjNCh0aGlzWzBdICsgb3RoZXJbMF0sIHRoaXNbMV0gKyBvdGhlclsxXSwgdGhpc1syXSArIG90aGVyWzJdLCB0aGlzWzNdICsgb3RoZXJbM10pO1xyXG4gICAgfVxyXG4gICAgVmVjNC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xyXG4gICAgICAgIHZhciBvdGhlciA9IGdldFZlYzQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzQodGhpc1swXSAtIG90aGVyWzBdLCB0aGlzWzFdIC0gb3RoZXJbMV0sIHRoaXNbMl0gLSBvdGhlclsyXSwgdGhpc1szXSAtIG90aGVyWzNdKTtcclxuICAgIH1cclxuICAgIFZlYzQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRWZWM0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWM0KHRoaXNbMF0gKiBvdGhlclswXSwgdGhpc1sxXSAqIG90aGVyWzFdLCB0aGlzWzJdICogb3RoZXJbMl0sIHRoaXNbM10gKiBvdGhlclszXSk7XHJcbiAgICB9XHJcbiAgICBWZWM0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0VmVjNC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjNCh0aGlzWzBdIC8gb3RoZXJbMF0sIHRoaXNbMV0gLyBvdGhlclsxXSwgdGhpc1syXSAvIG90aGVyWzJdLCB0aGlzWzNdIC8gb3RoZXJbM10pO1xyXG4gICAgfVxyXG4gICAgVmVjNC5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xyXG4gICAgICAgIHZhciBvdGhlciA9IGdldFZlYzQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlYzQodGhpc1swXSAlIG90aGVyWzBdLCB0aGlzWzFdICUgb3RoZXJbMV0sIHRoaXNbMl0gJSBvdGhlclsyXSwgdGhpc1szXSAlIG90aGVyWzNdKTtcclxuICAgIH1cclxuICAgIFZlYzQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjNChNYXRoLmFicyh0aGlzWzBdKSwgTWF0aC5hYnModGhpc1sxXSksIE1hdGguYWJzKHRoaXNbMl0pLCBNYXRoLmFicyh0aGlzWzNdKSk7XHJcbiAgICB9XHJcbiAgICBWZWM0LnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0VmVjNC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzWzBdICogb3RoZXJbMF0gKyB0aGlzWzFdICogb3RoZXJbMV0gKyB0aGlzWzJdICogb3RoZXJbMl0gKyB0aGlzWzNdICogb3RoZXJbM107XHJcbiAgICB9XHJcbiAgICBWZWM0LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbihsZW5ndGgpIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kb3QodGhpcykpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVmVjNC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoKDEpO1xyXG4gICAgfVxyXG4gICAgVmVjNC5wcm90b3R5cGUueHl6dyA9IFZlYzQucHJvdG90eXBlLnJnYmEgPSBWZWM0LnByb3RvdHlwZS5zdHBxID0gZnVuY3Rpb24oeCwgeSwgeiwgdykge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0VmVjNC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgVmVjNC5wcm90b3R5cGUueCA9IFZlYzQucHJvdG90eXBlLnIgPSBWZWM0LnByb3RvdHlwZS5zID0gZnVuY3Rpb24oeCkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF07XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0VmVjNCh4LCB0aGlzWzFdLCB0aGlzWzJdLCB0aGlzWzNdKTtcclxuICAgIH1cclxuXHJcbiAgICBWZWM0LnByb3RvdHlwZS55ID0gVmVjNC5wcm90b3R5cGUuZyA9IFZlYzQucHJvdG90eXBlLnQgPSBmdW5jdGlvbih5KSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1sxXTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBnZXRWZWM0KHRoaXNbMF0sIHksIHRoaXNbMl0sIHRoaXNbM10pO1xyXG4gICAgfVxyXG4gICAgVmVjNC5wcm90b3R5cGUueiA9IFZlYzQucHJvdG90eXBlLmIgPSBWZWM0LnByb3RvdHlwZS5wID0gZnVuY3Rpb24oeikge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMl07XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0VmVjNCh0aGlzWzBdLCB0aGlzWzFdLCB6LCB0aGlzWzNdKTtcclxuICAgIH1cclxuICAgIFZlYzQucHJvdG90eXBlLncgPSBWZWM0LnByb3RvdHlwZS5hID0gVmVjNC5wcm90b3R5cGUucSA9IGZ1bmN0aW9uKHcpIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzWzNdO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGdldFZlYzQodGhpc1swXSwgdGhpc1sxXSwgdGhpc1syXSwgdyk7XHJcbiAgICB9XHJcbiAgICBhZGRTd2l6emxlcyhWZWM0LnByb3RvdHlwZSwgNCwgMiwgdHJ1ZSk7XHJcbiAgICBhZGRTd2l6emxlcyhWZWM0LnByb3RvdHlwZSwgNCwgMywgdHJ1ZSk7XHJcbiAgICBhZGRTd2l6emxlcyhWZWM0LnByb3RvdHlwZSwgNCwgNCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmlydHVhbCBDb2xvciB0eXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIENvbG9yID0gVmVjNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB2aXJ0dWFsIE1hdDMgdHlwZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBNYXQzID0gZnVuY3Rpb24obTExLCBtMTIsIG0xMywgbTIxLCBtMjIsIG0yMywgbTMxLCBtMzIsIG0zMykge1xyXG4gICAgICAgIGNvbnN0cnVjdEZyb21NYXRyaXgodGhpcywgMywgYXJndW1lbnRzKSB8fCBmaWxsVmVjdG9yKHRoaXMsIDksIGFyZ3VtZW50cylcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRNYXQzKCkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE1hdDMpXHJcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBNYXQzKCk7XHJcbiAgICAgICAgTWF0My5hcHBseShvYmosIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuXHJcbiAgICBNYXQzLnByb3RvdHlwZS5fdG9GbG9hdEFycmF5ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcmVzID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcclxuICAgICAgICB2YXIgaSA9IDk7IHdoaWxlKGktLSkgcmVzW2ldID0gdGhpc1tpXTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdDMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG0xMSwgbTEyLCBtMTMsIG0yMSwgbTIyLCBtMjMsIG0zMSwgbTMyLCBtMzMpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRNYXQzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXQzKHRoaXNbMF0gKyBvdGhlclswXSwgdGhpc1sxXSArIG90aGVyWzFdLCB0aGlzWzJdICsgb3RoZXJbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbM10gKyBvdGhlclszXSwgdGhpc1s0XSArIG90aGVyWzRdLCB0aGlzWzVdICsgb3RoZXJbNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbNl0gKyBvdGhlcls2XSwgdGhpc1s3XSArIG90aGVyWzddLCB0aGlzWzhdICsgb3RoZXJbOF0pO1xyXG4gICAgfVxyXG4gICAgTWF0My5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24obTExLCBtMTIsIG0xMywgbTIxLCBtMjIsIG0yMywgbTMxLCBtMzIsIG0zMykge1xyXG4gICAgICAgIHZhciBvdGhlciA9IGdldE1hdDMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdDModGhpc1swXSAtIG90aGVyWzBdLCB0aGlzWzFdIC0gb3RoZXJbMV0sIHRoaXNbMl0gLSBvdGhlclsyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1szXSAtIG90aGVyWzNdLCB0aGlzWzRdIC0gb3RoZXJbNF0sIHRoaXNbNV0gLSBvdGhlcls1XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1s2XSAtIG90aGVyWzZdLCB0aGlzWzddIC0gb3RoZXJbN10sIHRoaXNbOF0gLSBvdGhlcls4XSk7XHJcbiAgICB9XHJcbiAgICBNYXQzLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbihtMTEsIG0xMiwgbTEzLCBtMjEsIG0yMiwgbTIzLCBtMzEsIG0zMiwgbTMzKSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0TWF0My5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIC8vIFRPRE86IERvIGNvcnJlY3QgbWF0cml4IG11bHRpcGxpY2F0aW9uLi4uXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBNYXQzLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihtMTEsIG0xMiwgbTEzLCBtMjEsIG0yMiwgbTIzLCBtMzEsIG0zMiwgbTMzKSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0TWF0My5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWF0Myh0aGlzWzBdIC8gb3RoZXJbMF0sIHRoaXNbMV0gLyBvdGhlclsxXSwgdGhpc1syXSAvIG90aGVyWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzNdIC8gb3RoZXJbM10sIHRoaXNbNF0gLyBvdGhlcls0XSwgdGhpc1s1XSAvIG90aGVyWzVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzZdIC8gb3RoZXJbNl0sIHRoaXNbN10gLyBvdGhlcls3XSwgdGhpc1s4XSAvIG90aGVyWzhdKTtcclxuICAgIH1cclxuXHJcbiAgICBNYXQzLnByb3RvdHlwZS5jb2wgPSBmdW5jdGlvbihpZHgsIHgsIHksIHope1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSl7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzWzMqaWR4ICsgMF0sIHRoaXNbMyppZHggKyAxXSwgdGhpc1szKmlkeCArIDJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2V0VmVjMy5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgTWF0Myh0aGlzKTtcclxuICAgICAgICAgICAgY29weVszKmlkeCArIDBdID0gaW5wdXRbMF07XHJcbiAgICAgICAgICAgIGNvcHlbMyppZHggKyAxXSA9IGlucHV0WzFdO1xyXG4gICAgICAgICAgICBjb3B5WzMqaWR4ICsgMl0gPSBpbnB1dFsyXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBNYXQzLnByb3RvdHlwZS5tdWxWZWMgPSBmdW5jdGlvbih4LCB5LCB6KXtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRWZWMzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKFxyXG4gICAgICAgICAgICBvdGhlci5kb3QodGhpc1swXSwgdGhpc1sxXSwgdGhpc1syXSksXHJcbiAgICAgICAgICAgIG90aGVyLmRvdCh0aGlzWzNdLCB0aGlzWzRdLCB0aGlzWzVdKSxcclxuICAgICAgICAgICAgb3RoZXIuZG90KHRoaXNbNl0sIHRoaXNbN10sIHRoaXNbOF0pXHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZpcnR1YWwgTWF0MyB0eXBlXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgdmFyIE1hdDQgPSBmdW5jdGlvbihtMTEsIG0xMiwgbTEzLCBtMTQsIG0yMSwgbTIyLCBtMjMsIG0yNCwgbTMxLCBtMzIsIG0zMywgbTM0LCBtNDEsIG00MiwgbTQzLCBtNDQpIHtcclxuICAgICAgICBjb25zdHJ1Y3RGcm9tTWF0cml4KHRoaXMsIDQsIGFyZ3VtZW50cykgfHwgZmlsbFZlY3Rvcih0aGlzLCAxNiwgYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRNYXQ0KCkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE1hdDQpXHJcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBNYXQ0KCk7XHJcbiAgICAgICAgTWF0NC5hcHBseShvYmosIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuXHJcbiAgICBNYXQ0LnByb3RvdHlwZS5fdG9GbG9hdEFycmF5ID0gZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgcmVzID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcbiAgICAgICAgdmFyIGkgPSAxNjsgd2hpbGUoaS0tKSByZXNbaV0gPSB0aGlzW2ldO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obTExLCBtMTIsIG0xMywgbTE0LCBtMjEsIG0yMiwgbTIzLCBtMjQsIG0zMSwgbTMyLCBtMzMsIG0zNCwgbTQxLCBtNDIsIG00MywgbTQ0KSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0TWF0NC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWF0Myh0aGlzWzBdICsgb3RoZXJbMF0sIHRoaXNbMV0gKyBvdGhlclsxXSwgdGhpc1syXSArIG90aGVyWzJdLCB0aGlzWzNdICsgb3RoZXJbM10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbNF0gKyBvdGhlcls0XSwgdGhpc1s1XSArIG90aGVyWzVdLCB0aGlzWzZdICsgb3RoZXJbNl0sIHRoaXNbN10gKyBvdGhlcls3XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1s4XSArIG90aGVyWzhdLCB0aGlzWzldICsgb3RoZXJbOV0sIHRoaXNbMTBdICsgb3RoZXJbMTBdLCB0aGlzWzExXSArIG90aGVyWzExXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1sxMl0gKyBvdGhlclsxMl0sIHRoaXNbMTNdICsgb3RoZXJbMTNdLCB0aGlzWzE0XSArIG90aGVyWzE0XSwgdGhpc1sxNV0gKyBvdGhlclsxNV0pO1xyXG4gICAgfVxyXG4gICAgTWF0NC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24obTExLCBtMTIsIG0xMywgbTE0LCBtMjEsIG0yMiwgbTIzLCBtMjQsIG0zMSwgbTMyLCBtMzMsIG0zNCwgbTQxLCBtNDIsIG00MywgbTQ0KSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0TWF0NC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWF0Myh0aGlzWzBdIC0gb3RoZXJbMF0sIHRoaXNbMV0gLSBvdGhlclsxXSwgdGhpc1syXSAtIG90aGVyWzJdLCB0aGlzWzNdIC0gb3RoZXJbM10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbNF0gLSBvdGhlcls0XSwgdGhpc1s1XSAtIG90aGVyWzVdLCB0aGlzWzZdIC0gb3RoZXJbNl0sIHRoaXNbN10gLSBvdGhlcls3XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1s4XSAtIG90aGVyWzhdLCB0aGlzWzldIC0gb3RoZXJbOV0sIHRoaXNbMTBdIC0gb3RoZXJbMTBdLCB0aGlzWzExXSAtIG90aGVyWzExXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1sxMl0gLSBvdGhlclsxMl0sIHRoaXNbMTNdIC0gb3RoZXJbMTNdLCB0aGlzWzE0XSAtIG90aGVyWzE0XSwgdGhpc1sxNV0gLSBvdGhlclsxNV0pO1xyXG4gICAgfVxyXG4gICAgTWF0NC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24obTExLCBtMTIsIG0xMywgbTE0LCBtMjEsIG0yMiwgbTIzLCBtMjQsIG0zMSwgbTMyLCBtMzMsIG0zNCwgbTQxLCBtNDIsIG00MywgbTQ0KSB7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0TWF0NC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIC8vIFRPRE86IERvIGNvcnJlY3QgbWF0cml4IG11bHRpcGxpY2F0aW9uLi4uXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBNYXQ0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbihtMTEsIG0xMiwgbTEzLCBtMTQsIG0yMSwgbTIyLCBtMjMsIG0yNCwgbTMxLCBtMzIsIG0zMywgbTM0LCBtNDEsIG00MiwgbTQzLCBtNDQpIHtcclxuICAgICAgICB2YXIgb3RoZXIgPSBnZXRNYXQ0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXQzKHRoaXNbMF0gLyBvdGhlclswXSwgdGhpc1sxXSAvIG90aGVyWzFdLCB0aGlzWzJdIC8gb3RoZXJbMl0sIHRoaXNbM10gLyBvdGhlclszXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1s0XSAvIG90aGVyWzRdLCB0aGlzWzVdIC8gb3RoZXJbNV0sIHRoaXNbNl0gLyBvdGhlcls2XSwgdGhpc1s3XSAvIG90aGVyWzddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzhdIC8gb3RoZXJbOF0sIHRoaXNbOV0gLyBvdGhlcls5XSwgdGhpc1sxMF0gLyBvdGhlclsxMF0sIHRoaXNbMTFdIC8gb3RoZXJbMTFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzWzEyXSAvIG90aGVyWzEyXSwgdGhpc1sxM10gLyBvdGhlclsxM10sIHRoaXNbMTRdIC8gb3RoZXJbMTRdLCB0aGlzWzE1XSAvIG90aGVyWzE1XSk7XHJcbiAgICB9XHJcblxyXG4gICAgTWF0NC5wcm90b3R5cGUuY29sID0gZnVuY3Rpb24oaWR4LCB4LCB5LCB6LCB3KXtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDEpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlYzQodGhpc1s0KmlkeCArIDBdLCB0aGlzWzQqaWR4ICsgMV0sIHRoaXNbNCppZHggKyAyXSwgdGhpc1s0KmlkeCArIDNdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gZ2V0VmVjNC5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXcgTWF0NCh0aGlzKTtcclxuICAgICAgICAgICAgY29weVs0KmlkeCArIDBdID0gaW5wdXRbMF07XHJcbiAgICAgICAgICAgIGNvcHlbNCppZHggKyAxXSA9IGlucHV0WzFdO1xyXG4gICAgICAgICAgICBjb3B5WzQqaWR4ICsgMl0gPSBpbnB1dFsyXTtcclxuICAgICAgICAgICAgY29weVs0KmlkeCArIDNdID0gaW5wdXRbM107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgTWF0NC5wcm90b3R5cGUubXVsVmVjID0gZnVuY3Rpb24oeCwgeSwgeiwgdyl7XHJcbiAgICAgICAgdmFyIG90aGVyID0gZ2V0VmVjNC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjNChcclxuICAgICAgICAgICAgb3RoZXIuZG90KHRoaXNbMF0sIHRoaXNbMV0sIHRoaXNbMl0sIHRoaXNbM10pLFxyXG4gICAgICAgICAgICBvdGhlci5kb3QodGhpc1s0XSwgdGhpc1s1XSwgdGhpc1s2XSwgdGhpc1s3XSksXHJcbiAgICAgICAgICAgIG90aGVyLmRvdCh0aGlzWzhdLCB0aGlzWzldLCB0aGlzWzEwXSwgdGhpc1sxMV0pLFxyXG4gICAgICAgICAgICBvdGhlci5kb3QodGhpc1sxMl0sIHRoaXNbMTNdLCB0aGlzWzE0XSwgdGhpc1sxNV0pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmlydHVhbCBUZXR1cmUgdHlwZVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIHZhciBUZXh0dXJlID0gZnVuY3Rpb24oaW1hZ2UpIHtcclxuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgVGV4dHVyZS5wcm90b3R5cGUuc2FtcGxlMkQgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWM0KDAsIDAsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgU2hhZGUgPSB7fTtcclxuXHJcblxyXG4gICAgLy8gRXh0ZW5zaW9ucyBvZiBNYXRoLFxyXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGZvciBWZWN0b3JzXHJcbiAgICBNYXRoLmNsYW1wID0gZnVuY3Rpb24oeCwgbWluVmFsLCBtYXhWYWwpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoeCwgbWluVmFsKSwgbWF4VmFsKTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aC5zbW9vdGhzdGVwID0gZnVuY3Rpb24oZWRnZTEsIGVkZ2UyLCB4KSB7XHJcbiAgICAgICAgdmFyIHQgPSBNYXRoLmNsYW1wKCh4IC0gZWRnZTEpIC8gKGVkZ2UyIC0gZWRnZTEpLCAwLjAsIDEuMCk7XHJcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogKDMuMCAtIDIuMCAqIHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLnN0ZXAgPSBmdW5jdGlvbihlZGdlLCB4KSB7XHJcbiAgICAgICAgcmV0dXJuIHggPCBlZGdlID8gMCA6IDE7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGguZnJhY3QgPSBmdW5jdGlvbih4KSB7XHJcbiAgICAgICAgcmV0dXJuIHggLSBNYXRoLmZsb29yKHgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLm1peCA9IGZ1bmN0aW9uKHgseSxhKSB7XHJcbiAgICAgICAgdmFyIHNpbXBsZSA9IHR5cGVvZiB4ID09ICdudW1iZXInO1xyXG4gICAgICAgIHZhciBhc2ltcGxlID0gdHlwZW9mIGEgPT0gJ251bWJlcic7XHJcbiAgICAgICAgaWYoc2ltcGxlICYmIGFzaW1wbGUpXHJcbiAgICAgICAgICAgIHJldHVybiB4KigxLWEpICsgeSphO1xyXG4gICAgICAgIGlmIChhc2ltcGxlKVxyXG4gICAgICAgICAgICByZXR1cm4geC5tdWwoMS1hKS5hZGQoeS5tdWwoYSkpO1xyXG4gICAgICAgIHJldHVybiB4Lm11bChhLm11bCgtMSkuYWRkKDEpKS5hZGQoeS5tdWwoYSkpO1xyXG4gICAgfVxyXG5cclxuICAgIE1hdGguc2F0dXJhdGUgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmNsYW1wKHgsIDAuMCwgMS4wKTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5vZGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcclxuICAgICAqL1xyXG4gICAgbnMudGhyb3dFcnJvciA9IGZ1bmN0aW9uKG5vZGUsIG1zZykge1xyXG4gICAgICAgIHZhciBsb2MgPSBub2RlICYmIG5vZGUubG9jO1xyXG4gICAgICAgIGlmIChsb2MgJiYgbG9jLnN0YXJ0LmxpbmUpIHtcclxuICAgICAgICAgICAgbXNnID0gXCJMaW5lIFwiICsgbG9jLnN0YXJ0LmxpbmUgKyBcIjogXCIgKyBtc2c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1zZyArPSBcIjogXCIgKyBDb2RlR2VuLmdlbmVyYXRlKG5vZGUpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgICAgIGVycm9yLmxvYyA9IGxvYztcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICBucy50b0phdmFTY3JpcHQgPSBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIENvZGVHZW4uZ2VuZXJhdGUobm9kZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIG5zLlZlYzIgPSBWZWMyO1xyXG4gICAgbnMuVmVjMyA9IFZlYzM7XHJcbiAgICBucy5WZWM0ID0gVmVjNDtcclxuICAgIG5zLk1hdDMgPSBNYXQzO1xyXG4gICAgbnMuTWF0NCA9IE1hdDQ7XHJcbiAgICBucy5Db2xvciA9IENvbG9yO1xyXG4gICAgbnMuU2hhZGUgPSBTaGFkZTtcclxuICAgIG5zLlZlY01hdGggPSBWZWNNYXRoO1xyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgVHJhdmVyc2FsID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpLFxyXG4gICAgICAgIFN5bnRheCA9IFRyYXZlcnNhbC5TeW50YXgsXHJcbiAgICAgICAgcGFyc2VyID0gcmVxdWlyZSgnZXNwcmltYScpLFxyXG4gICAgICAgIFNoYWRlID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgQU5OTyA9IHJlcXVpcmUoXCIuLy4uL2Jhc2UvYW5ub3RhdGlvbi5qc1wiKS5BTk5PO1xyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUNhbGxFeHByZXNzaW9uKG5vZGUpIHtcclxuICAgICAgICB2YXIgY2FsbGVlID0gQU5OTyhub2RlLmNhbGxlZSk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJDYWxsXCIsIG5vZGUuY2FsbGVlLnByb3BlcnR5LCBjYWxsZWUuZ2V0VHlwZVN0cmluZygpLCBub2RlLmNhbGxlZS5vYmplY3QpXHJcbiAgICAgICAgaWYoY2FsbGVlLmlzT2ZLaW5kKFNoYWRlLk9CSkVDVF9LSU5EUy5DT0xPUl9DTE9TVVJFKSkge1xyXG4gICAgICAgICAgICBBTk5PKG5vZGUpLmNvcHkoY2FsbGVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTmV3RXhwcmVzc2lvbihub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUuY2FsbGVlLm5hbWUgPT0gXCJTaGFkZVwiKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0VHlwZShTaGFkZS5UWVBFUy5PQkpFQ1QsIFNoYWRlLk9CSkVDVF9LSU5EUy5DT0xPUl9DTE9TVVJFKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdCA9IEFOTk8obm9kZS5vYmplY3QpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBBTk5PKG5vZGUpO1xyXG4gICAgICAgIGlmIChvYmplY3QuaXNPZktpbmQoU2hhZGUuT0JKRUNUX0tJTkRTLkNPTE9SX0NMT1NVUkUpKSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9zdXJlTmFtZSA9IG5vZGUucHJvcGVydHkubmFtZTtcclxuICAgICAgICAgICAgaWYgKCFTaGFkZS5Db2xvckNsb3N1cmVzLmhhc093blByb3BlcnR5KGNsb3N1cmVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGNsb3N1cmUgZm9yIG5hbWUnXCIsIGNsb3N1cmVOYW1lLCBcIidcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlc3VsdC5jb3B5KG9iamVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5zLm1hcmtDb2xvckNsb3N1cmVzID0gZnVuY3Rpb24ocHJvZ3JhbUFhc3Qpe1xyXG4gICAgICAgIFRyYXZlcnNhbC50cmF2ZXJzZShwcm9ncmFtQWFzdCwge1xyXG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24obm9kZSwgcGFyZW50KXtcclxuICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU3ludGF4LkNhbGxFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2FsbEV4cHJlc3Npb24obm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTmV3RXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU5ld0V4cHJlc3Npb24obm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1lbWJlckV4cHJlc3Npb24obm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgdmFyIFRyYXZlcnNhbCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKSxcclxuICAgICAgICBTeW50YXggPSBUcmF2ZXJzYWwuU3ludGF4LFxyXG4gICAgICAgIHBhcnNlciA9IHJlcXVpcmUoJ2VzcHJpbWEnKTtcclxuXHJcbiAgICB2YXIgU2hhZGUgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlcy5qc1wiKSxcclxuICAgIFNwYWNlVmVjdG9yVHlwZSA9IFNoYWRlLlNwYWNlVmVjdG9yVHlwZSxcclxuICAgIFR5cGVzID0gU2hhZGUuVFlQRVMsXHJcbiAgICBLaW5kcyA9IFNoYWRlLk9CSkVDVF9LSU5EUztcclxuXHJcbiAgICBucy5nZXREZWZhdWx0VmFsdWUgPSBmdW5jdGlvbihjY0lucHV0RGVmaW5pdGlvbil7XHJcbiAgICAgICAgaWYoY2NJbnB1dERlZmluaXRpb24uZGVmYXVsdFZhbHVlID09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sb3JDbG9zdXJlIGlucHV0IGhhcyBub3QgZGVmYXVsdCB2YWx1ZSFcIik7XHJcblxyXG4gICAgICAgIGlmKGNjSW5wdXREZWZpbml0aW9uLnR5cGUgPT0gVHlwZXMuTlVNQkVSIHx8IGNjSW5wdXREZWZpbml0aW9uLnR5cGUgPT0gVHlwZXMuSU5UKXtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5MaXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNjSW5wdXREZWZpbml0aW9uLmRlZmF1bHRWYWx1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnJlbnRsdHkgZG9uJ3Qgc3VwcG9ydCBkZWZhdWx0IHZhbHVlcyBvZiB0eXBlIFwiICsgY2NJbnB1dERlZmluaXRpb24udHlwZSArIFwiIGFuZCBraW5kIFwiICsgY2NJbnB1dERlZmluaXRpb24ua2luZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIihmdW5jdGlvbiAobnMpIHtcclxuXHJcbiAgICB2YXIgQ29sb3JDbG9zdXJlTWFya2VyID0gcmVxdWlyZShcIi4vY29sb3JjbG9zdXJlLW1hcmtlci5qc1wiKTtcclxuXHJcbiAgICB2YXIgY19pbXBsZW1lbnRhdGlvbnMgPSB7fTtcclxuXHJcbiAgICB2YXIgcmVnaXN0ZXJMaWdodGluZ0ltcGxlbWVudGF0aW9uID0gbnMucmVnaXN0ZXJMaWdodGluZ0ltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIG9iaikge1xyXG4gICAgICAgIGNfaW1wbGVtZW50YXRpb25zW25hbWVdID0gb2JqO1xyXG4gICAgfTtcclxuXHJcbiAgICBucy5yZXNvbHZlQ2xvc3VyZXNQcmVUeXBlSW5mZXJlbmNlID0gZnVuY3Rpb24gKGFhc3QsIGltcGxlbWVudGF0aW9uTmFtZSwgcHJvY2Vzc2luZ0RhdGEsIG9wdCkge1xyXG4gICAgICAgIGlmICghaW1wbGVtZW50YXRpb25OYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhYXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZXJJbXBsID0gY19pbXBsZW1lbnRhdGlvbnNbaW1wbGVtZW50YXRpb25OYW1lXTtcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVySW1wbC5yZXNvbHZlUHJlVHlwZUluZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgQ29sb3JDbG9zdXJlTWFya2VyLm1hcmtDb2xvckNsb3N1cmVzKGFhc3QpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVySW1wbC5yZXNvbHZlUHJlVHlwZUluZmVyZW5jZShhYXN0LCBwcm9jZXNzaW5nRGF0YSwgb3B0KTtcclxuICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWFzdDtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhYXN0O1xyXG4gICAgfTtcclxuXHJcbiAgICBucy5yZXNvbHZlQ2xvc3VyZXNQb3N0VHlwZUluZmVyZW5jZSA9IGZ1bmN0aW9uIChhYXN0LCBpbXBsZW1lbnRhdGlvbk5hbWUsIHByb2Nlc3NpbmdEYXRhLCBvcHQpIHtcclxuICAgICAgICBpZiAoIWltcGxlbWVudGF0aW9uTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWFzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHJlc29sdmVySW1wbCA9IGNfaW1wbGVtZW50YXRpb25zW2ltcGxlbWVudGF0aW9uTmFtZV07XHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlckltcGwucmVzb2x2ZVBvc3RUeXBlSW5mZXJlbmNlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVySW1wbC5yZXNvbHZlUG9zdFR5cGVJbmZlcmVuY2UoYWFzdCwgcHJvY2Vzc2luZ0RhdGEsIG9wdCk7IGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBhYXN0O1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFhc3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIHJlZ2lzdGVyTGlnaHRpbmdJbXBsZW1lbnRhdGlvbihcInhtbDNkLWdsc2wtZm9yd2FyZFwiLCByZXF1aXJlKFwiLi94bWwzZC1nbHNsLWZvcndhcmRcIikpO1xyXG4gICAgcmVnaXN0ZXJMaWdodGluZ0ltcGxlbWVudGF0aW9uKFwieG1sM2QtZ2xzbC1kZWZlcnJlZFwiLCByZXF1aXJlKFwiLi94bWwzZC1nbHNsLWRlZmVycmVkXCIpKTtcclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgdmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9pbmRleC5qc1wiKSxcclxuICAgICAgICBUcmF2ZXJzYWwgPSByZXF1aXJlKCdlc3RyYXZlcnNlJyksXHJcbiAgICAgICAgU3ludGF4ID0gVHJhdmVyc2FsLlN5bnRheCxcclxuICAgICAgICBBTk5PID0gcmVxdWlyZShcIi4vLi4vLi4vYmFzZS9hbm5vdGF0aW9uLmpzXCIpLkFOTk8sXHJcbiAgICAgICAgRGVmZXJyZWRJbmZvID0gcmVxdWlyZShcIi4veG1sM2QtZGVmZXJyZWQuanNcIik7XHJcblxyXG4gICAgdmFyIFNoYWRlID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZXMuanNcIiksXHJcbiAgICAgICAgU3BhY2VWZWN0b3JUeXBlID0gU2hhZGUuU3BhY2VWZWN0b3JUeXBlLFxyXG4gICAgICAgIFR5cGVzID0gU2hhZGUuVFlQRVMsXHJcbiAgICAgICAgS2luZHMgPSBTaGFkZS5PQkpFQ1RfS0lORFM7XHJcblxyXG4gICAgdmFyIFNwYWNlVHJhbnNmb3JtVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vZ2VuZXJhdGUvc3BhY2Uvc3BhY2UtdHJhbnNmb3JtLXRvb2xzLmpzXCIpLFxyXG4gICAgICAgIENvbG9yQ2xvc3VyZVRvb2xzID0gcmVxdWlyZShcIi4uL2NvbG9yY2xvc3VyZS10b29scy5qc1wiKTtcclxuXHJcbiAgICB2YXIgQUREX1BPU0lUSU9OX1RPX0FSR1MgPSB0cnVlO1xyXG5cclxuICAgIHZhciBBcmdTdG9yYWdlVHlwZSA9IG5zLkFyZ1N0b3JhZ2VUeXBlID0ge1xyXG4gICAgICAgIEZMT0FUIDogJ2Zsb2F0JyxcclxuICAgICAgICBGTE9BVF9CWVRFOiAnZmxvYXRCeXRlJyxcclxuICAgICAgICBGTE9BVF9VQllURTogJ2Zsb2F0VUJ5dGUnLFxyXG4gICAgICAgIEZMT0FUMjogJ2Zsb2F0MicsXHJcbiAgICAgICAgRkxPQVQzOiAnZmxvYXQzJyxcclxuICAgICAgICBGTE9BVDNfTk9STUFMOiAnZmxvYXQzTm9ybWFsJyxcclxuICAgICAgICBGTE9BVDQ6ICdmbG9hdDQnXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIEFNQklFTlRfREVGSU5JVElPTiA9IHt0eXBlOiBUeXBlcy5OVU1CRVIsIHNlbWFudGljOiBTaGFkZS5TRU1BTlRJQ1MuU0NBTEFSXzBfVE9fMSwgZGVmYXVsdFZhbHVlOiAwIH07XHJcblxyXG5cclxuICAgIG5zLkNvbG9yQ2xvc3VyZVNpZ25hdHVyZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5pZCA9IDA7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuYXJncyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29sb3JDbG9zdXJlcyA9IFtdO1xyXG4gICAgfTtcclxuICAgIEJhc2UuZXh0ZW5kKG5zLkNvbG9yQ2xvc3VyZVNpZ25hdHVyZS5wcm90b3R5cGUsIHtcclxuICAgICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKHJldHVybkFhc3QsIHNjb3BlKXtcclxuICAgICAgICAgICAgdmFyIGNsb3N1cmVJbmZvID0gY29sbGVjdENsb3N1cmVJbmZvKHJldHVybkFhc3QpO1xyXG4gICAgICAgICAgICB2YXIgYXJnQWFzdCA9IGdhdGhlckNsb3N1cmVBcmdzKHRoaXMsIGNsb3N1cmVJbmZvLCBzY29wZSk7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlcyA9IGFsbG9jYXRlQXJndW1lbnRzVG9UZXh0dXJlcyh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IGdldFNpZ25hdHVyZUlkKHRoaXMpO1xyXG4gICAgICAgICAgICBhcmdBYXN0WzBdLnZhbHVlID0gdGhpcy5pZDsgLy8gU2V0IElEIGZvciBzaGFkZXIgaWQgYXNzaWdubWVudFxyXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVBYXN0KHRleHR1cmVzLCBhcmdBYXN0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBCYXNpYyBDb2xvckNsb3N1cmVTaWduYXR1cmUgQ3JlYXRlaW9uXHJcblxyXG4gICAgZnVuY3Rpb24gYWRkQ29sb3JDbG9zdXJlKGNjU2lnLCBjb2xvckNsb3N1cmVOYW1lLCBhcmdJbmRpY2VzLCBlbnZJbmRpY2VzKXtcclxuICAgICAgICBjY1NpZy5jb2xvckNsb3N1cmVzLnB1c2goe1xyXG4gICAgICAgICAgICBuYW1lOiBjb2xvckNsb3N1cmVOYW1lLFxyXG4gICAgICAgICAgICBhcmdJbmRpY2VzOiBhcmdJbmRpY2VzLFxyXG4gICAgICAgICAgICBlbnZJbmRpY2VzOiBlbnZJbmRpY2VzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkQXJndW1lbnQoY2NTaWcsIHR5cGUsIGtpbmQsIHN0b3JlVHlwZSl7XHJcbiAgICAgICAgdmFyIGlkID0gY2NTaWcuYXJncy5sZW5ndGg7XHJcbiAgICAgICAgY2NTaWcuYXJncy5wdXNoKHtcclxuICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBraW5kOiBraW5kLFxyXG4gICAgICAgICAgICBzdG9yZVR5cGU6IHN0b3JlVHlwZSxcclxuICAgICAgICAgICAgdGV4SWR4OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudElkeDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBiaXRJZHg6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBcmd1bWVudCBDb2xsZWN0aW9uXHJcblxyXG4gICAgZnVuY3Rpb24gY29sbGVjdENsb3N1cmVJbmZvKHJldHVybkFhc3Qpe1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICBUcmF2ZXJzYWwudHJhdmVyc2UocmV0dXJuQWFzdCwge1xyXG4gICAgICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTeW50YXguQ2FsbEV4cHJlc3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlLmNhbGxlZS50eXBlID09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBBTk5PKG5vZGUuY2FsbGVlLm9iamVjdCkuaXNPZktpbmQoS2luZHMuQ09MT1JfQ0xPU1VSRSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBub2RlLmNhbGxlZS5wcm9wZXJ0eS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBub2RlLmFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5uYW1lIDwgYi5uYW1lID8gLTEgOiBhLm5hbWUgPiBiLm5hbWUgPyAxIDogMH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2F0aGVyQ2xvc3VyZUFyZ3MoY2NTaWcsIGNsb3N1cmVJbmZvLCBzY29wZSl7XHJcbiAgICAgICAgdmFyIGFyZ0NhY2hlID0ge30sIGFyZ0Fhc3QgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGFyZ3VtZW50IGZvciBzaWduYXR1cmUgaWQ7XHJcbiAgICAgICAgZ2V0Q2FjaGVkQXJndW1lbnQoY2NTaWcsIHt0eXBlOiBUeXBlcy5JTlR9LCB7dHlwZTogXCJMaXRlcmFsXCIsIHZhbHVlOiBcIklEX1VOU1BFQ0lGSUVEXCJ9LCBhcmdDYWNoZSwgYXJnQWFzdCk7XHJcbiAgICAgICAgaWYoQUREX1BPU0lUSU9OX1RPX0FSR1MpXHJcbiAgICAgICAgICAgIGFkZFBvc2l0aW9uQXJndW1lbnQoY2NTaWcsIGFyZ0NhY2hlLCBhcmdBYXN0KTtcclxuICAgICAgICB2YXIgYW1iaWVudFZhbHVlID0geyB0eXBlOiBTeW50YXguTG9naWNhbEV4cHJlc3Npb24sIG9wZXJhdG9yIDogXCJ8fFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBnZXRFbnZBY2Nlc3MoXCJhbWJpZW50SW50ZW5zaXR5XCIsIEFNQklFTlRfREVGSU5JVElPTiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBDb2xvckNsb3N1cmVUb29scy5nZXREZWZhdWx0VmFsdWUoQU1CSUVOVF9ERUZJTklUSU9OKSB9O1xyXG5cclxuICAgICAgICBnZXRDYWNoZWRBcmd1bWVudChjY1NpZywgQU1CSUVOVF9ERUZJTklUSU9OLCBhbWJpZW50VmFsdWUsIGFyZ0NhY2hlLCBhcmdBYXN0KTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNsb3N1cmVJbmZvLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGNJbmZvID0gY2xvc3VyZUluZm9baV07XHJcbiAgICAgICAgICAgIHZhciBjbG9zdXJlRGVmaW5pdGlvbiA9IFNoYWRlLkNvbG9yQ2xvc3VyZXNbY0luZm8ubmFtZV07XHJcbiAgICAgICAgICAgIGlmKCFjbG9zdXJlRGVmaW5pdGlvbilcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gQ29sb3IgY2xvc3VyZSAnXCIgKyBjSW5mby5uYW1lICsgXCInXCIpO1xyXG4gICAgICAgICAgICB2YXIgYXJnSW5kaWNlcyA9IFtdLCB2YWx1ZTtcclxuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGNsb3N1cmVEZWZpbml0aW9uLmlucHV0Lmxlbmd0aDsgKytqKXtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dERlZmluaXRpb24gPSBjbG9zdXJlRGVmaW5pdGlvbi5pbnB1dFtqXTtcclxuICAgICAgICAgICAgICAgIGlmKGogPCBjSW5mby5hcmdzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNJbmZvLmFyZ3Nbal07XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBDb2xvckNsb3N1cmVUb29scy5nZXREZWZhdWx0VmFsdWUoaW5wdXREZWZpbml0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IERlZmVycmVkSW5mb1tjSW5mby5uYW1lXSAmJiBEZWZlcnJlZEluZm9bY0luZm8ubmFtZV0uaW5wdXRTcGFjZXNbal07XHJcbiAgICAgICAgICAgICAgICBhcmdJbmRpY2VzLnB1c2goZ2V0Q2FjaGVkQXJndW1lbnQoY2NTaWcsIGlucHV0RGVmaW5pdGlvbiwgdmFsdWUsIGFyZ0NhY2hlLCBhcmdBYXN0LCBzcGFjZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBlbnZJbmRpY2VzID0ge307XHJcbiAgICAgICAgICAgIGZvcih2YXIgcHJvcGVydHkgaW4gY2xvc3VyZURlZmluaXRpb24uZW52KXtcclxuICAgICAgICAgICAgICAgIHZhciBlbnZEZWZpbml0aW9uID0gY2xvc3VyZURlZmluaXRpb24uZW52W3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IERldGVybWluZSBpZiBlbnYgcHJvcGVydHkgaXMgdW5kZWZpbmVkIGFuZCB1c2UgZGVmYXVsdFZhbHVlIGluIHRoaXMgY2FzZTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0geyB0eXBlOiBTeW50YXguTG9naWNhbEV4cHJlc3Npb24sIG9wZXJhdG9yIDogXCJ8fFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBnZXRFbnZBY2Nlc3MocHJvcGVydHksIGVudkRlZmluaXRpb24pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogQ29sb3JDbG9zdXJlVG9vbHMuZ2V0RGVmYXVsdFZhbHVlKGVudkRlZmluaXRpb24pIH07XHJcbiAgICAgICAgICAgICAgICBlbnZJbmRpY2VzW3Byb3BlcnR5XSA9IGdldENhY2hlZEFyZ3VtZW50KGNjU2lnLCBlbnZEZWZpbml0aW9uLCB2YWx1ZSwgYXJnQ2FjaGUsIGFyZ0Fhc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFkZENvbG9yQ2xvc3VyZShjY1NpZywgY0luZm8ubmFtZSwgYXJnSW5kaWNlcywgZW52SW5kaWNlcyk7XHJcbiAgICAgICB9XHJcbiAgICAgICByZXR1cm4gYXJnQWFzdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRQb3NpdGlvbkFyZ3VtZW50KGNjU2lnLCBhcmdDYWNoZSwgYXJnQWFzdCl7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uTG9va3VwID0geyB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgb2JqZWN0OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcIl9lbnZcIn0sXHJcbiAgICAgICAgICAgIHByb3BlcnR5OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcInBvc2l0aW9uXCJ9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFOTk8ocG9zaXRpb25Mb29rdXApLnNldFR5cGUoVHlwZXMuT0JKRUNULCBLaW5kcy5GTE9BVDMpO1xyXG4gICAgICAgIC8vIEFOTk8ocG9zaXRpb25Mb29rdXAub2JqZWN0KS5zZXRUeXBlKFR5cGVzLk9CSkVDVCwgS2luZHMuQU5ZKTtcclxuICAgICAgICAvLyBBTk5PKHBvc2l0aW9uTG9va3VwLm9iamVjdCkuc2V0R2xvYmFsKHRydWUpO1xyXG4gICAgICAgIGdldENhY2hlZEFyZ3VtZW50KGNjU2lnLCB7dHlwZTogVHlwZXMuT0JKRUNULCBraW5kOiBLaW5kcy5GTE9BVDN9LCBwb3NpdGlvbkxvb2t1cCwgYXJnQ2FjaGUsIGFyZ0Fhc3QsXHJcbiAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5WSUVXX1BPSU5UKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDYWNoZWRBcmd1bWVudChjY1NpZywgaW5wdXREZWZpbml0aW9uLCBpbnB1dEFhc3QsIGFyZ0NhY2hlLCBhcmdBYXN0LCBzcGFjZSl7XHJcbiAgICAgICAgc3BhY2UgPSBzcGFjZSB8fCBTcGFjZVZlY3RvclR5cGUuT0JKRUNUO1xyXG4gICAgICAgIGlucHV0QWFzdCA9IHNwYWNlID8gU3BhY2VUcmFuc2Zvcm1Ub29scy5nZXRTcGFjZVRyYW5zZm9ybUNhbGwoaW5wdXRBYXN0LCBzcGFjZSkgOiBpbnB1dEFhc3Q7XHJcbiAgICAgICAgdmFyIGtleUFhc3QgPSBCYXNlLmRlZXBFeHRlbmQoe30sIGlucHV0QWFzdCk7XHJcbiAgICAgICAgY2xlYW5BYXN0KGtleUFhc3QpO1xyXG4gICAgICAgIHZhciBzdG9yYWdlVHlwZSA9IGdldFN0b3JhZ2VUeXBlKGlucHV0RGVmaW5pdGlvbik7XHJcbiAgICAgICAgdmFyIGtleSA9IHN0b3JhZ2VUeXBlICsgXCI7XCIgKyBKU09OLnN0cmluZ2lmeShrZXlBYXN0KTtcclxuICAgICAgICBpZihhcmdDYWNoZVtrZXldID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB2YXIgYXJnSWQgPSBhZGRBcmd1bWVudChjY1NpZywgaW5wdXREZWZpbml0aW9uLnR5cGUsIGlucHV0RGVmaW5pdGlvbi5raW5kLCBzdG9yYWdlVHlwZSk7XHJcbiAgICAgICAgICAgIGFyZ0NhY2hlW2tleV0gPSBhcmdJZDtcclxuICAgICAgICAgICAgYXJnQWFzdC5wdXNoKGlucHV0QWFzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcmdDYWNoZVtrZXldO1xyXG4gICAgfVxyXG4gICAgLyogUmVtb3ZlIGFsbCByYW5nZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGFhc3QgKi9cclxuICAgIGZ1bmN0aW9uIGNsZWFuQWFzdChhYXN0KXtcclxuICAgICAgICBmb3IodmFyIGkgaW4gYWFzdCl7XHJcbiAgICAgICAgICAgIGlmKGkgPT0gXCJyYW5nZVwiIHx8IGkgPT0gXCJsb2NcIil7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgYWFzdFtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHR5cGVvZiBhYXN0W2ldID09IFwib2JqZWN0XCIpe1xyXG4gICAgICAgICAgICAgICAgY2xlYW5BYXN0KGFhc3RbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFN0b3JhZ2VUeXBlKGNsb3N1cmVJbnB1dFR5cGUpe1xyXG4gICAgICAgIGlmKGNsb3N1cmVJbnB1dFR5cGUudHlwZSA9PSBUeXBlcy5OVU1CRVIgfHwgY2xvc3VyZUlucHV0VHlwZS50eXBlID09IFR5cGVzLklOVCl7XHJcbiAgICAgICAgICAgIHJldHVybiBBcmdTdG9yYWdlVHlwZS5GTE9BVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihjbG9zdXJlSW5wdXRUeXBlLnR5cGUgPT0gVHlwZXMuT0JKRUNUKXtcclxuICAgICAgICAgICAgc3dpdGNoKGNsb3N1cmVJbnB1dFR5cGUua2luZCl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEtpbmRzLkZMT0FUMjogcmV0dXJuIEFyZ1N0b3JhZ2VUeXBlLkZMT0FUMjtcclxuICAgICAgICAgICAgICAgIGNhc2UgS2luZHMuRkxPQVQzOiByZXR1cm4gQXJnU3RvcmFnZVR5cGUuRkxPQVQzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBLaW5kcy5GTE9BVDQ6IHJldHVybiBBcmdTdG9yYWdlVHlwZS5GTE9BVDQ7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmVycmVkIGlucHV0IG9mIHRoaXMga2luZCBub3Qgc3VwcG9ydGVkOiBcIiArIGNsb3N1cmVJbnB1dFR5cGUua2luZCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmVycmVkIGlucHV0IG9mIHRoaXMgdHlwZSBub3Qgc3VwcG9ydGVkOiBcIiArIGNsb3N1cmVJbnB1dFR5cGUudHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEVudkFjY2Vzcyhwcm9wZXJ0eSwgZGVmaW5pdGlvbil7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4Lk1lbWJlckV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgIG9iamVjdDoge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcIl9lbnZcIiB9LFxyXG4gICAgICAgICAgICBwcm9wZXJ0eToge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBwcm9wZXJ0eSB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFOTk8ocmVzdWx0KS5zZXRUeXBlKGRlZmluaXRpb24udHlwZSwgZGVmaW5pdGlvbi5raW5kKTtcclxuICAgICAgICAvLyB2YXIgb2JqQW5ubyA9IEFOTk8ocmVzdWx0Lm9iamVjdCk7XHJcbiAgICAgICAgLy8gb2JqQW5uby5zZXRUeXBlKFR5cGVzLk9CSkVDVCwgS2luZHMuQU5ZKTtcclxuICAgICAgICAvLyBvYmpBbm5vLnNldEdsb2JhbCh0cnVlKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBBcmd1bWVudCBBbGxvY2F0aW9uXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGFsbG9jYXRlQXJndW1lbnRzVG9UZXh0dXJlcyhjY1NpZyl7XHJcbiAgICAgICAgdmFyIGFyZ0NvcHkgPSBjY1NpZy5hcmdzLnNsaWNlKCBBRERfUE9TSVRJT05fVE9fQVJHUyA/IDMgOiAyKTtcclxuICAgICAgICBhcmdDb3B5LnNvcnQoZnVuY3Rpb24oYSwgYil7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRTdG9yYWdlU2l6ZShhLnN0b3JlVHlwZSkgLSBnZXRTdG9yYWdlU2l6ZShiLnN0b3JlVHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXJnQ29weS5wdXNoKGNjU2lnLmFyZ3NbQUREX1BPU0lUSU9OX1RPX0FSR1MgPyAyIDogMV0pOyAvLyBBbWJpZW50IGNvbWVzIHRoaXJkLlxyXG4gICAgICAgIGlmKEFERF9QT1NJVElPTl9UT19BUkdTKVxyXG4gICAgICAgICAgICBhcmdDb3B5LnB1c2goY2NTaWcuYXJnc1sxXSk7IC8vIFBPU0lUSU9OIGNvbWVzIHNlY29uZC5cclxuICAgICAgICBhcmdDb3B5LnB1c2goY2NTaWcuYXJnc1swXSk7IC8vIElEIGFyZ3VtZW50IGFsd2F5cyBjb21lcyBmaXJzdCAoYW5kIHRodXM6IGxhc3QgaW4gdGhpcyBhcnJheSlcclxuICAgICAgICB2YXIgdGV4dHVyZXMgPSBbXTtcclxuICAgICAgICB2YXIgaSA9IGFyZ0NvcHkubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKGktLSl7XHJcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdDb3B5W2ldO1xyXG4gICAgICAgICAgICBhc3NpZ25UZXh0dXJlU2xvdChhcmcsIHRleHR1cmVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2NTaWcudGV4dHVyZUNvdW50ID0gdGV4dHVyZXMubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzc2lnblRleHR1cmVTbG90KGFyZywgdGV4dHVyZXMpe1xyXG4gICAgICAgIHZhciBzaXplID0gZ2V0U3RvcmFnZVNpemUoYXJnLnN0b3JlVHlwZSk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRleHR1cmVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgdmFyIHRleCA9IHRleHR1cmVzW2ldO1xyXG4gICAgICAgICAgICBpZihzaXplIDwgMzIpe1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2UgY3VycmVudGx5IGRvbid0IHN1cHBvcnQgc3RvcmluZyBvZiB2YWx1ZXMgc21hbGxlciB0aGFuIDMyIGJpdFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHRleC51c2VkQ29tcG9uZW50cyArIHNpemUgLyAzMiA8PSA0KXtcclxuICAgICAgICAgICAgICAgIGFyZy50ZXhJZHggPSBpO1xyXG4gICAgICAgICAgICAgICAgYXJnLmNvbXBvbmVudElkeCA9IHRleC51c2VkQ29tcG9uZW50cztcclxuICAgICAgICAgICAgICAgIGFyZy5iaXRJZHggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGV4LnVzZWRDb21wb25lbnRzICs9IHNpemUgLyAzMjtcclxuICAgICAgICAgICAgICAgIHRleC51c2VkQml0cyA9IDA7XHJcbiAgICAgICAgICAgICAgICB0ZXguc3RvcmVkQXJncy5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYXJnLnRleElkeCA9IHRleHR1cmVzLmxlbmd0aDtcclxuICAgICAgICBhcmcuY29tcG9uZW50SWR4ID0gMDtcclxuICAgICAgICBhcmcuYml0SWR4ID0gMDtcclxuICAgICAgICBpZihzaXplIDwgMzIpe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBjdXJyZW50bHkgZG9uJ3Qgc3VwcG9ydCBzdG9yaW5nIG9mIHZhbHVlcyBzbWFsbGVyIHRoYW4gMzIgYml0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHVzZWRDb21wb25lbnRzOiBzaXplIC8gMzIsXHJcbiAgICAgICAgICAgICAgICB1c2VkQml0czogMCxcclxuICAgICAgICAgICAgICAgIHN0b3JlZEFyZ3M6IFthcmddXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTdG9yYWdlU2l6ZShzdG9yZVR5cGUpe1xyXG4gICAgICAgIHN3aXRjaChzdG9yZVR5cGUpe1xyXG4gICAgICAgICAgICBjYXNlIEFyZ1N0b3JhZ2VUeXBlLkZMT0FUOiByZXR1cm4gMzI7XHJcbiAgICAgICAgICAgIGNhc2UgQXJnU3RvcmFnZVR5cGUuRkxPQVRfQllURTogcmV0dXJuIDg7XHJcbiAgICAgICAgICAgIGNhc2UgQXJnU3RvcmFnZVR5cGUuRkxPQVRfVUJZVEU6IHJldHVybiA4O1xyXG4gICAgICAgICAgICBjYXNlIEFyZ1N0b3JhZ2VUeXBlLkZMT0FUMjogcmV0dXJuIDY0O1xyXG4gICAgICAgICAgICBjYXNlIEFyZ1N0b3JhZ2VUeXBlLkZMT0FUMzogcmV0dXJuIDk2O1xyXG4gICAgICAgICAgICBjYXNlIEFyZ1N0b3JhZ2VUeXBlLkZMT0FUM19OT1JNQUw6IHJldHVybiAyNDtcclxuICAgICAgICAgICAgY2FzZSBBcmdTdG9yYWdlVHlwZS5GTE9BVDQ6IHJldHVybiAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBDb2xvckNsb3N1cmVTaWduYXR1cmUgSURcclxuXHJcbiAgICB2YXIgY19TaWduYXR1cmVOZXh0SWQgPSAwO1xyXG4gICAgdmFyIGNfU2lnbmF0dXJlSURDYWNoZSA9IHt9O1xyXG5cclxuICAgIG5zLkNvbG9yQ2xvc3VyZVNpZ25hdHVyZS5jbGVhcklkQ2FjaGUgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgIGNfU2lnbmF0dXJlTmV4dElkID0gMDtcclxuICAgICAgICBjX1NpZ25hdHVyZUlEQ2FjaGUgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTaWduYXR1cmVJZChjY1NpZyl7XHJcbiAgICAgICAgdmFyIGtleSA9IFwiXCI7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNjU2lnLmFyZ3MubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgYXJnID0gY2NTaWcuYXJnc1tpXTtcclxuICAgICAgICAgICAga2V5ICs9IGdldEFyZ3VtZW50S2V5KGFyZykgKyBcIjtcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBjY1NpZy5jb2xvckNsb3N1cmVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGNsb3N1cmUgPSBjY1NpZy5jb2xvckNsb3N1cmVzW2ldO1xyXG4gICAgICAgICAgICBrZXkgKz0gY2xvc3VyZS5uYW1lICsgXCIsXCIgKyBjbG9zdXJlLmFyZ0luZGljZXMuam9pbihcIixcIik7XHJcbiAgICAgICAgICAgIGZvcih2YXIgcHJvcCBpbiBjbG9zdXJlLmVudkluZGljZXMpe1xyXG4gICAgICAgICAgICAgICAga2V5ICs9IFwiLFwiICsgcHJvcCArIFwiPlwiICsgY2xvc3VyZS5lbnZJbmRpY2VzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGNfU2lnbmF0dXJlSURDYWNoZVtrZXldID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBjX1NpZ25hdHVyZUlEQ2FjaGVba2V5XSA9IGNfU2lnbmF0dXJlTmV4dElkO1xyXG4gICAgICAgICAgICBjX1NpZ25hdHVyZU5leHRJZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY19TaWduYXR1cmVJRENhY2hlW2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QXJndW1lbnRLZXkoYXJnKXtcclxuICAgICAgICByZXR1cm4gYXJnLnR5cGUgKyBcIixcIiArIGFyZy5raW5kICsgXCIsXCIgKyBhcmcuc3RvcmVUeXBlICsgXCIsXCIgKyBhcmcudGV4SWR4ICsgXCIsXCJcclxuICAgICAgICAgICAgKyBhcmcuY29tcG9uZW50SWR4ICsgXCIsXCIgKyBhcmcuYml0SWR4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFhc3QgZ2VuZXJhdGlvblxyXG5cclxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQWFzdCh0ZXh0dXJlcywgYXJnQWFzdCl7XHJcbiAgICAgICAgdmFyIGFycmF5RXhwcmVzc2lvbiA9IHsgdHlwZTogU3ludGF4LkFycmF5RXhwcmVzc2lvbiwgZWxlbWVudHM6IFtdfTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGV4dHVyZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgdmVjdG9yRXhwcmVzc2lvbiA9IGdlbmVyYXRlVmVjdG9yQWFzdCh0ZXh0dXJlc1tpXSwgYXJnQWFzdCk7XHJcbiAgICAgICAgICAgIGFycmF5RXhwcmVzc2lvbi5lbGVtZW50cy5wdXNoKHZlY3RvckV4cHJlc3Npb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBTk5PKGFycmF5RXhwcmVzc2lvbikuc2V0VHlwZShUeXBlcy5BUlJBWSk7XHJcblxyXG4gICAgICAgIHZhciByZXR1cm5TdGF0ZW1lbnQgPSB7dHlwZTogU3ludGF4LlJldHVyblN0YXRlbWVudCwgYXJndW1lbnQ6IGFycmF5RXhwcmVzc2lvbn07XHJcbiAgICAgICAgcmV0dXJuIHJldHVyblN0YXRlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVZlY3RvckFhc3QodGV4dHVyZSwgYXJnQWFzdCl7XHJcbiAgICAgICAgdmFyIHZlY0FyZ3MgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGV4dHVyZS5zdG9yZWRBcmdzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGFyZyA9IHRleHR1cmUuc3RvcmVkQXJnc1tpXTtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBnZXRTdG9yYWdlU2l6ZShhcmcuc3RvcmVUeXBlKTtcclxuICAgICAgICAgICAgaWYoc2l6ZSA8IDMyKXtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlIGN1cnJlbnRseSBkb24ndCBzdXBwb3J0IHN0b3Jpbmcgb2YgdmFsdWVzIHNtYWxsZXIgdGhhbiAzMiBiaXRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHZlY0FyZ3MucHVzaChhcmdBYXN0W2FyZy5pZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihpID0gdGV4dHVyZS51c2VkQ29tcG9uZW50czsgaSA8IDQ7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciB6ZXJvTGl0ZXJhbCA9IHsgdHlwZTogU3ludGF4LkxpdGVyYWwsIHZhbHVlOiBcIjBcIiB9O1xyXG4gICAgICAgICAgICAvLyBBTk5PKHplcm9MaXRlcmFsKS5zZXRUeXBlKFR5cGVzLklOVCk7XHJcbiAgICAgICAgICAgIHZlY0FyZ3MucHVzaCh6ZXJvTGl0ZXJhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSB7IHR5cGU6IFN5bnRheC5OZXdFeHByZXNzaW9uLCBjYWxsZWU6IHsgdHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IFwiVmVjNFwifSwgYXJndW1lbnRzOiB2ZWNBcmdzfTtcclxuICAgICAgICAvLyBBTk5PKHJlc3VsdCkuc2V0VHlwZShUeXBlcy5PQkpFQ1QsIEtpbmRzLkZMT0FUNCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBDbG9zdXJlcyA9IHJlcXVpcmUoXCIuL3htbDNkLWRlZmVycmVkLmpzXCIpLFxyXG4gICAgICAgIFRyYXZlcnNhbCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKSxcclxuICAgICAgICBTeW50YXggPSBUcmF2ZXJzYWwuU3ludGF4LFxyXG4gICAgICAgIHBhcnNlciA9IHJlcXVpcmUoJ2VzcHJpbWEnKSxcclxuICAgICAgICBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxyXG4gICAgICAgIEFOTk8gPSByZXF1aXJlKFwiLi8uLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTyxcclxuICAgICAgICBzYW5pdGl6ZXIgPSByZXF1aXJlKFwiLi8uLi8uLi9hbmFseXplL3Nhbml0aXplci9zYW5pdGl6ZXIuanNcIiksXHJcbiAgICAgICAgQ29sb3JDbG9zdXJlU2lnbmF0dXJlID0gcmVxdWlyZShcIi4vY29sb3ItY2xvc3VyZS1zaWduYXR1cmUuanNcIikuQ29sb3JDbG9zdXJlU2lnbmF0dXJlO1xyXG5cclxuXHJcbiAgICBucy5yZXNvbHZlUHJlVHlwZUluZmVyZW5jZSA9IGZ1bmN0aW9uIChhYXN0LCBwcm9jZXNzRGF0YSwgb3B0KSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0ge1xyXG4gICAgICAgICAgICBjb2xvckNsb3N1cmVTaWduYXR1cmVzOiBbXSxcclxuICAgICAgICAgICAgaW5NYWluOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGdsb2JhbFNjcm9wZSA9IGFhc3Quc2NvcGU7XHJcbiAgICAgICAgYWFzdCA9IFRyYXZlcnNhbC5yZXBsYWNlKGFhc3QsIHtcclxuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBQcm9wZXJseSBkZXRlcm1pbmUgaWYgd2UgYXJlIGluIG1haW4gZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5pZC5uYW1lID09IFwic2hhZGVcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmluTWFpbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5GdW5jdGlvbkRlY2xhcmF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBQcm9wZXJseSBkZXRlcm1pbmUgaWYgd2UgYXJlIGluIG1haW4gZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5pZC5uYW1lID09IFwic2hhZGVcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmluTWFpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0YXRlLmluTWFpbil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gbmV3IENvbG9yQ2xvc3VyZVNpZ25hdHVyZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gc2lnbmF0dXJlLmNvbnN0cnVjdChub2RlLCBnbG9iYWxTY3JvcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29sb3JDbG9zdXJlU2lnbmF0dXJlcy5wdXNoKHNpZ25hdHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHByb2Nlc3NEYXRhWydjb2xvckNsb3N1cmVTaWduYXR1cmVzJ10gPSBzdGF0ZS5jb2xvckNsb3N1cmVTaWduYXR1cmVzO1xyXG5cclxuICAgICAgICByZXR1cm4gYWFzdDtcclxuICAgIH1cclxuXHJcbn0oZXhwb3J0cykpO1xyXG4iLCIoZnVuY3Rpb24gKG5zKSB7XHJcblxyXG4gICAgICAgIHZhciBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxyXG4gICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUgPSBTaGFkZS5TcGFjZVZlY3RvclR5cGU7XHJcblxyXG4gICAgICAgIG5zLmVtaXNzaXZlID0ge1xyXG4gICAgICAgICAgICBpbnB1dFNwYWNlczogW1xyXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBucy5kaWZmdXNlID0ge1xyXG4gICAgICAgICAgICBpbnB1dFNwYWNlczogW1xyXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5WSUVXX05PUk1BTCxcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1RcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbnMucGhvbmcgPSB7XHJcbiAgICAgICAgICAgIGlucHV0U3BhY2VzOiBbXHJcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuT0JKRUNULFxyXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLlZJRVdfTk9STUFMLFxyXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBucy5jb29rVG9ycmFuY2UgPSB7XHJcbiAgICAgICAgICAgIGlucHV0U3BhY2VzOiBbXHJcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuT0JKRUNULFxyXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLlZJRVdfTk9STUFMLFxyXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1RcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbnMud2FyZCA9IHtcclxuICAgICAgICAgICAgaW5wdXRTcGFjZXM6IFtcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuVklFV19OT1JNQUwsXHJcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuVklFV19OT1JNQUwsXHJcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuT0JKRUNULFxyXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVFxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBucy5zY2F0dGVyID0ge1xyXG4gICAgICAgICAgICBpbnB1dFNwYWNlczogW1xyXG4gICAgICAgICAgICAgICAgU3BhY2VWZWN0b3JUeXBlLk9CSkVDVCxcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5WSUVXX05PUk1BTCxcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1RcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbnMucmVmbGVjdCA9IHtcclxuICAgICAgICAgICAgaW5wdXRTcGFjZXM6IFtcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5WSUVXX05PUk1BTCxcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1RcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbnMucmVmcmFjdCA9IHtcclxuICAgICAgICAgICAgaW5wdXRTcGFjZXM6IFtcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5WSUVXX05PUk1BTCxcclxuICAgICAgICAgICAgICAgIFNwYWNlVmVjdG9yVHlwZS5PQkpFQ1QsXHJcbiAgICAgICAgICAgICAgICBTcGFjZVZlY3RvclR5cGUuT0JKRUNUXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgIHZhciBDbG9zdXJlc0ltcGwgPSByZXF1aXJlKFwiLi94bWwzZC1mb3J3YXJkLmpzXCIpLFxyXG4gICAgICAgIExpZ2h0TG9vcCA9IHJlcXVpcmUoXCIuL2xpZ2h0LWxvb3AuanNcIikuTGlnaHRMb29wLFxyXG4gICAgICAgIFRyYXZlcnNhbCA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKSxcclxuICAgICAgICBTeW50YXggPSBUcmF2ZXJzYWwuU3ludGF4LFxyXG4gICAgICAgIHBhcnNlciA9IHJlcXVpcmUoJ2VzcHJpbWEnKSxcclxuICAgICAgICBTaGFkZSA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2VzLmpzXCIpLFxyXG4gICAgICAgIEFOTk8gPSByZXF1aXJlKFwiLi8uLi8uLi9iYXNlL2Fubm90YXRpb24uanNcIikuQU5OTyxcclxuICAgICAgICBzYW5pdGl6ZXIgPSByZXF1aXJlKFwiLi8uLi8uLi9hbmFseXplL3Nhbml0aXplci9zYW5pdGl6ZXIuanNcIik7XHJcblxyXG4gICAgdmFyIFNwYWNlVHJhbnNmb3JtVG9vbHMgPSByZXF1aXJlKFwiLi4vLi4vZ2VuZXJhdGUvc3BhY2Uvc3BhY2UtdHJhbnNmb3JtLXRvb2xzLmpzXCIpLFxyXG4gICAgICAgIENvbG9yQ2xvc3VyZVRvb2xzID0gcmVxdWlyZShcIi4uL2NvbG9yY2xvc3VyZS10b29scy5qc1wiKTtcclxuXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zQ2xvc3VyZShhcnIsIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gYXJyLnNvbWUoZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuaWQubmFtZSA9PSBuYW1lO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEluamVjdEFkZGl0aW9uKGRlc3ROYW1lLCBmdW5jdGlvbk5hbWUsIGlucHV0UHJlLCBjY05hbWUsIGNvbG9yQ2xvc3VyZUluZGV4ICl7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXRQcmUubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogaW5wdXRQcmVbaV19KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlucHV0c0NudCA9IFNoYWRlLkNvbG9yQ2xvc3VyZXNbY2NOYW1lXS5pbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0c0NudDsgKytpKXtcclxuICAgICAgICAgICAgYXJncy5wdXNoKHsgdHlwZTogU3ludGF4LklkZW50aWZpZXIsIG5hbWU6IGdldENvbG9yQ2xvc3VyZUlucHV0QXJnKGNvbG9yQ2xvc3VyZUluZGV4LCBpKX0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCxcclxuICAgICAgICAgICAgZXhwcmVzc2lvbjogeyB0eXBlOiBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBkZXN0TmFtZX0sXHJcbiAgICAgICAgICAgICAgICByaWdodDogeyB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVlOiB7IHR5cGU6IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogZGVzdE5hbWV9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eToge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBcImFkZFwifVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbeyB0eXBlOiBTeW50YXguQ2FsbEV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZToge3R5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBmdW5jdGlvbk5hbWV9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgIH19XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDb2xvckNsb3N1cmVJbmplY3QoY2NOYW1lLCBmdW5jdGlvbk1lbWJlciwgc3RhdGUpe1xyXG4gICAgICAgIGlmKCFDbG9zdXJlc0ltcGxbY2NOYW1lXSlcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSBmb3IgQ29sb3JDbG9zdXJlICdcIiArIGNjTmFtZSArIFwiJ1wiICk7XHJcbiAgICAgICAgaWYoIUNsb3N1cmVzSW1wbFtjY05hbWVdW2Z1bmN0aW9uTWVtYmVyXSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGNjTmFtZSArIFwiX1wiICsgZnVuY3Rpb25NZW1iZXI7XHJcbiAgICAgICAgaWYgKCFjb250YWluc0Nsb3N1cmUoc3RhdGUubmV3RnVuY3Rpb25zLCBmdW5jdGlvbk5hbWUpKXtcclxuICAgICAgICAgICAgdmFyIGNsb3N1cmVJbXBsZW1lbnRhdGlvbiA9IENsb3N1cmVzSW1wbFtjY05hbWVdW2Z1bmN0aW9uTWVtYmVyXTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBjbG9zdXJlQVNUID0gcGFyc2VyLnBhcnNlKGNsb3N1cmVJbXBsZW1lbnRhdGlvbi50b1N0cmluZygpLCB7IHJhdzogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIGNsb3N1cmVBU1QgPSBzYW5pdGl6ZXIuc2FuaXRpemUoY2xvc3VyZUFTVCk7XHJcbiAgICAgICAgICAgICAgICBjbG9zdXJlQVNULmJvZHlbMF0uaWQubmFtZSA9IGZ1bmN0aW9uTmFtZTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLm5ld0Z1bmN0aW9ucy5wdXNoKGNsb3N1cmVBU1QuYm9keVswXSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBhbmFseXNpcyBvZiBjbG9zdXJlICdcIiwgY2NOYW1lICsgXCI+XCIgKyBmdW5jdGlvbk1lbWJlciwgXCInXCIsIGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGluamVjdEJyZGZFbnRyeShjY05hbWVzLCBzdGF0ZSl7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkJsb2NrU3RhdGVtZW50LFxyXG4gICAgICAgICAgICBib2R5OiBbXVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNjTmFtZXMubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgZk5hbWUsIGNjTmFtZSA9IGNjTmFtZXNbaV07XHJcbiAgICAgICAgICAgIGlmKGZOYW1lID0gZ2V0Q29sb3JDbG9zdXJlSW5qZWN0KGNjTmFtZSwgXCJnZXREaWZmdXNlXCIsIHN0YXRlKSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYm9keS5wdXNoKGdldEluamVjdEFkZGl0aW9uKFwia2RcIiwgZk5hbWUsIFtcIkxcIiwgXCJWXCJdLCBjY05hbWUsIGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihmTmFtZSA9IGdldENvbG9yQ2xvc3VyZUluamVjdChjY05hbWUsIFwiZ2V0U3BlY3VsYXJcIiwgc3RhdGUpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5LnB1c2goZ2V0SW5qZWN0QWRkaXRpb24oXCJrc1wiLCBmTmFtZSwgW1wiTFwiLCBcIlZcIl0sIGNjTmFtZSwgaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5qZWN0QW1iaWVudEVudHJ5KGNjTmFtZXMsIHN0YXRlKXtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgIGJvZHk6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2NOYW1lcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBmTmFtZSwgY2NOYW1lID0gY2NOYW1lc1tpXTtcclxuICAgICAgICAgICAgaWYoZk5hbWUgPSBnZXRDb2xvckNsb3N1cmVJbmplY3QoY2NOYW1lLCBcImdldEFtYmllbnRcIiwgc3RhdGUpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5LnB1c2goZ2V0SW5qZWN0QWRkaXRpb24oXCJhbWJpZW50Q29sb3JcIiwgZk5hbWUsIFtcImFtYmllbnRJbnRlbnNpdHlcIl0sIGNjTmFtZSwgaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5qZWN0RW1pc3NpdmVFbnRyeShjY05hbWVzLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN5bnRheC5CbG9ja1N0YXRlbWVudCxcclxuICAgICAgICAgICAgYm9keTogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjY05hbWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGZOYW1lLCBjY05hbWUgPSBjY05hbWVzW2ldO1xyXG4gICAgICAgICAgICBpZihmTmFtZSA9IGdldENvbG9yQ2xvc3VyZUluamVjdChjY05hbWUsIFwiZ2V0RW1pc3NpdmVcIiwgc3RhdGUpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5LnB1c2goZ2V0SW5qZWN0QWRkaXRpb24oXCJlbWlzc2l2ZUNvbG9yXCIsIGZOYW1lLCBbXSwgY2NOYW1lLCBpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbmplY3RSZWZyYWN0UmVmbGVjdEVudHJ5KGNjTmFtZXMsIHN0YXRlKXtcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBTeW50YXguQmxvY2tTdGF0ZW1lbnQsXHJcbiAgICAgICAgICAgIGJvZHk6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2NOYW1lcy5sZW5ndGg7ICsraSl7XHJcbiAgICAgICAgICAgIHZhciBmTmFtZSwgY2NOYW1lID0gY2NOYW1lc1tpXTtcclxuICAgICAgICAgICAgaWYoZk5hbWUgPSBnZXRDb2xvckNsb3N1cmVJbmplY3QoY2NOYW1lLCBcImdldFJlZnJhY3RcIiwgc3RhdGUpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5LnB1c2goZ2V0SW5qZWN0QWRkaXRpb24oXCJyZWZyYWN0Q29sb3JcIiwgZk5hbWUsIFtcInBvc2l0aW9uXCJdLCBjY05hbWUsIGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihmTmFtZSA9IGdldENvbG9yQ2xvc3VyZUluamVjdChjY05hbWUsIFwiZ2V0UmVmbGVjdFwiLCBzdGF0ZSkpe1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmJvZHkucHVzaChnZXRJbmplY3RBZGRpdGlvbihcInJlZmxlY3RDb2xvclwiLCBmTmFtZSwgW1wicG9zaXRpb25cIl0sIGNjTmFtZSwgaSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5qZWN0Q29sb3JDbG9zdXJlQ2FsbHMobGlnaHRMb29wRnVuY3Rpb24sIGNjTmFtZXMsIHN0YXRlKXtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gVHJhdmVyc2FsLnJlcGxhY2UobGlnaHRMb29wRnVuY3Rpb24uYm9keSwge1xyXG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24obm9kZSwgcGFyZW50KXtcclxuICAgICAgICAgICAgICAgIGlmKG5vZGUudHlwZSA9PSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCAmJiBub2RlLmV4cHJlc3Npb24udHlwZSA9PSBTeW50YXguTGl0ZXJhbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKG5vZGUuZXhwcmVzc2lvbi52YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCUkRGX0VOVFJZXCI6IHJldHVybiBpbmplY3RCcmRmRW50cnkoY2NOYW1lcywgc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQU1CSUVOVF9FTlRSWVwiOiByZXR1cm4gaW5qZWN0QW1iaWVudEVudHJ5KGNjTmFtZXMsIHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVNSVNTSVZFX0VOVFJZXCI6IHJldHVybiBpbmplY3RFbWlzc2l2ZUVudHJ5KGNjTmFtZXMsIHN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlJFRlJBQ1RfUkVGTEVDVF9FTlRSWVwiOiByZXR1cm4gaW5qZWN0UmVmcmFjdFJlZmxlY3RFbnRyeShjY05hbWVzLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldENvbG9yQ2xvc3VyZUlucHV0QXJnKGNjSW5kZXgsIGlucHV0SW5kZXgpe1xyXG4gICAgICAgIHJldHVybiBcIl9jY1wiICsgY2NJbmRleCArIFwiSW5wdXRcIiArIGlucHV0SW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlnaHRMb29wRnVuY3Rpb24obGlnaHRMb29wRnVuY3Rpb25OYW1lLCBjY05hbWVzLCBzdGF0ZSl7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGxpZ2h0TG9vcEFzdCA9IHBhcnNlci5wYXJzZShMaWdodExvb3AudG9TdHJpbmcoKSwgeyByYXc6IHRydWUgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gYW5hbHlzaXMgb2YgdGhlIGxpZ2h0TG9vcFwiLCBlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZnVuY3Rpb25BYXN0ID0gbGlnaHRMb29wQXN0LmJvZHlbMF07XHJcbiAgICAgICAgZnVuY3Rpb25BYXN0LmlkLm5hbWUgPSBsaWdodExvb3BGdW5jdGlvbk5hbWU7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjY05hbWVzLmxlbmd0aDsgKytpKXtcclxuICAgICAgICAgICAgdmFyIGNjTmFtZSA9IGNjTmFtZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBjY0lucHV0ID0gU2hhZGUuQ29sb3JDbG9zdXJlc1tjY05hbWVdLmlucHV0O1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgY2NJbnB1dC5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkFhc3QucGFyYW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGdldENvbG9yQ2xvc3VyZUlucHV0QXJnKGksailcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluamVjdENvbG9yQ2xvc3VyZUNhbGxzKGZ1bmN0aW9uQWFzdCwgY2NOYW1lcywgc3RhdGUpO1xyXG5cclxuICAgICAgICBsaWdodExvb3BBc3QgPSBzYW5pdGl6ZXIuc2FuaXRpemUobGlnaHRMb29wQXN0KTtcclxuICAgICAgICByZXR1cm4gbGlnaHRMb29wQXN0LmJvZHlbMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TGlnaHRMb29wRnVuY3Rpb24oY29sb3JDbG9zdXJlTGlzdCwgc3RhdGUpe1xyXG4gICAgICAgIHZhciBjY05hbWVzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbG9yQ2xvc3VyZUxpc3QubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIGNjTmFtZXMucHVzaChjb2xvckNsb3N1cmVMaXN0W2ldLm5hbWUpO1xyXG4gICAgICAgIHZhciBsaWdodExvb3BGdW5jdGlvbk5hbWUgPSBcImxpZ2h0TG9vcF9cIiArIGNjTmFtZXMuam9pbihcIl9cIik7XHJcbiAgICAgICAgaWYgKCFjb250YWluc0Nsb3N1cmUoc3RhdGUubmV3RnVuY3Rpb25zLCBsaWdodExvb3BGdW5jdGlvbk5hbWUpKXtcclxuICAgICAgICAgICAgc3RhdGUubmV3RnVuY3Rpb25zLnB1c2goY3JlYXRlTGlnaHRMb29wRnVuY3Rpb24obGlnaHRMb29wRnVuY3Rpb25OYW1lLCBjY05hbWVzLCBzdGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGlnaHRMb29wRnVuY3Rpb25OYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUNhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlLCBjb2xvckNsb3N1cmVMaXN0KSB7XHJcbiAgICAgICAgdmFyIGNhbGxlZSA9IEFOTk8obm9kZS5jYWxsZWUpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQ2FsbFwiLCBub2RlLmNhbGxlZS5wcm9wZXJ0eSwgY2FsbGVlLmdldFR5cGVTdHJpbmcoKSwgbm9kZS5jYWxsZWUub2JqZWN0KVxyXG4gICAgICAgIGlmKGNhbGxlZS5pc09mS2luZChTaGFkZS5PQkpFQ1RfS0lORFMuQ09MT1JfQ0xPU1VSRSkpIHtcclxuICAgICAgICAgICAgY29sb3JDbG9zdXJlTGlzdC5wdXNoKHsgbmFtZTogbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSwgYXJnczogbm9kZS5hcmd1bWVudHMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lbWJlckV4cHJlc3Npb24obm9kZSwgc3RhdGUsIHBhcmVudCkge1xyXG4gICAgICAgIHZhciBvYmplY3QgPSBBTk5PKG5vZGUub2JqZWN0KTtcclxuICAgICAgICBpZiAob2JqZWN0LmlzT2ZLaW5kKFNoYWRlLk9CSkVDVF9LSU5EUy5DT0xPUl9DTE9TVVJFKSkge1xyXG4gICAgICAgICAgICB2YXIgY2xvc3VyZU5hbWUgPSBub2RlLnByb3BlcnR5Lm5hbWU7XHJcbiAgICAgICAgICAgIGlmICghQ2xvc3VyZXNJbXBsLmhhc093blByb3BlcnR5KGNsb3N1cmVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGltcGxlbWVudGF0aW9uIGZvciBjbG9zdXJlICdcIiwgY2xvc3VyZU5hbWUsIFwiJ1wiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2xvc3VyZUxpc3QocmV0dXJuQWFzdCwgc3RhdGUpe1xyXG4gICAgICAgIHZhciBjb2xvckNsb3N1cmVMaXN0ID0gW107XHJcbiAgICAgICAgVHJhdmVyc2FsLnRyYXZlcnNlKHJldHVybkFhc3QsIHtcclxuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XHJcbiAgICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5DYWxsRXhwcmVzc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlLCBjb2xvckNsb3N1cmVMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5NZW1iZXJFeHByZXNzaW9uOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlTWVtYmVyRXhwcmVzc2lvbihub2RlLCBzdGF0ZSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbG9yQ2xvc3VyZUxpc3Quc29ydChmdW5jdGlvbiAoYSwgYil7IHJldHVybiBhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IGEubmFtZSA+IGIubmFtZSA/IDEgOiAwIH0pO1xyXG4gICAgICAgIHJldHVybiBjb2xvckNsb3N1cmVMaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTGlnaHRMb29wQ2FsbChsaWdodExvb3BGdW5jdGlvbiwgY29sb3JDbG9zdXJlTGlzdCwgc3RhdGUpe1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcblxyXG4gICAgICAgIHZhciBwb3NBcmcgPSBzdGF0ZS5wb3NpdGlvbkFyZztcclxuICAgICAgICBpZighc3RhdGUubm9TcGFjZVRyYW5zZm9ybSlcclxuICAgICAgICAgICAgcG9zQXJnID0gU3BhY2VUcmFuc2Zvcm1Ub29scy5nZXRTcGFjZVRyYW5zZm9ybUNhbGwocG9zQXJnLCBTaGFkZS5TcGFjZVZlY3RvclR5cGUuVklFV19QT0lOVCk7XHJcbiAgICAgICAgYXJncy5wdXNoKHBvc0FyZylcclxuICAgICAgICBhcmdzLnB1c2goc3RhdGUuYW1iaWVudEFyZyk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvbG9yQ2xvc3VyZUxpc3QubGVuZ3RoOyArK2kpe1xyXG4gICAgICAgICAgICB2YXIgY2NFbnRyeSA9IGNvbG9yQ2xvc3VyZUxpc3RbaV07XHJcbiAgICAgICAgICAgIHZhciBjY0lucHV0ID0gU2hhZGUuQ29sb3JDbG9zdXJlc1tjY0VudHJ5Lm5hbWVdLmlucHV0O1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgY2NJbnB1dC5sZW5ndGg7ICsrail7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gY2NFbnRyeS5hcmdzW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYoIWFyZylcclxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBDb2xvckNsb3N1cmVUb29scy5nZXREZWZhdWx0VmFsdWUoY2NJbnB1dFtqXSk7XHJcbiAgICAgICAgICAgICAgICBpZihjY0lucHV0W2pdLnNlbWFudGljID09IFNoYWRlLlNFTUFOVElDUy5OT1JNQUwgJiYgIXN0YXRlLm5vU3BhY2VUcmFuc2Zvcm0pXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gU3BhY2VUcmFuc2Zvcm1Ub29scy5nZXRTcGFjZVRyYW5zZm9ybUNhbGwoYXJnLCBTaGFkZS5TcGFjZVZlY3RvclR5cGUuVklFV19OT1JNQUwpO1xyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogU3ludGF4LkNhbGxFeHByZXNzaW9uLFxyXG4gICAgICAgICAgICBjYWxsZWU6IHt0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogbGlnaHRMb29wRnVuY3Rpb259LFxyXG4gICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3NcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhbmRsZVJldHVyblN0YXRlbWVudChyZXR1cm5BYXN0LCBzdGF0ZSl7XHJcbiAgICAgICAgdmFyIGxpc3QgPSBnZXRDbG9zdXJlTGlzdChyZXR1cm5BYXN0LCBzdGF0ZSk7XHJcbiAgICAgICAgaWYobGlzdC5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBsaWdodExvb3BGdW5jdGlvbiA9IGdldExpZ2h0TG9vcEZ1bmN0aW9uKGxpc3QsIHN0YXRlKTtcclxuICAgICAgICB2YXIgbGlnaExvb3BDYWxsID0gZ2VuZXJhdGVMaWdodExvb3BDYWxsKGxpZ2h0TG9vcEZ1bmN0aW9uLCBsaXN0LCBzdGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuQWFzdC5hcmd1bWVudCA9IGxpZ2hMb29wQ2FsbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZVJldHVyblN0YXRlbWVudHMocHJvZ3JhbUFhc3QsIHN0YXRlKXtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gVHJhdmVyc2FsLnJlcGxhY2UocHJvZ3JhbUFhc3QsIHtcclxuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudCl7XHJcbiAgICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFN5bnRheC5SZXR1cm5TdGF0ZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV0dXJuU3RhdGVtZW50KG5vZGUsIHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RW52UGFyYW1ldGVyKHByb3BlcnR5KXtcclxuICAgICAgICByZXR1cm4geyB0eXBlOiBTeW50YXguTWVtYmVyRXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgIG9iamVjdDogeyB0eXBlOiBTeW50YXguSWRlbnRpZmllciwgbmFtZTogXCJfZW52XCIgfSxcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB7IHR5cGU6IFN5bnRheC5JZGVudGlmaWVyLCBuYW1lOiBwcm9wZXJ0eX19O1xyXG4gICAgfVxyXG5cclxuICAgIG5zLnJlc29sdmVQcmVUeXBlSW5mZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgcHJvY2Vzc0RhdGEsIG9wdCkge1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcclxuICAgICAgICAgICAgcG9zaXRpb25Bcmc6IG9wdCAmJiBvcHQubGlnaHRMb29wUG9zaXRpb25BcmcgfHwgbnVsbCxcclxuICAgICAgICAgICAgYW1iaWVudEFyZzogb3B0ICYmIG9wdC5saWdodExvb3BBbWJpZW50QXJnIHx8IG51bGwsXHJcbiAgICAgICAgICAgIG5vU3BhY2VUcmFuc2Zvcm06IG9wdCAmJiBvcHQubGlnaHRMb29wTm9TcGFjZVRyYW5zZm9ybSB8fCBmYWxzZSxcclxuICAgICAgICAgICAgcHJvZ3JhbTogYXN0LFxyXG4gICAgICAgICAgICBuZXdGdW5jdGlvbnM6IFtdXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCFzdGF0ZS5wb3NpdGlvbkFyZylcclxuICAgICAgICAgICAgc3RhdGUucG9zaXRpb25BcmcgPSBnZXRFbnZQYXJhbWV0ZXIoXCJwb3NpdGlvblwiKTtcclxuICAgICAgICBpZighc3RhdGUuYW1iaWVudEFyZylcclxuICAgICAgICAgICAgc3RhdGUuYW1iaWVudEFyZyA9IHsgdHlwZTogU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uLCBvcGVyYXRvcjogXCJ8fFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBnZXRFbnZQYXJhbWV0ZXIoXCJhbWJpZW50SW50ZW5zaXR5XCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDoge3R5cGU6IFN5bnRheC5MaXRlcmFsLCB2YWx1ZTogMH0gfTtcclxuXHJcbiAgICAgICAgYXN0ID0gcmVwbGFjZVJldHVyblN0YXRlbWVudHMoYXN0LCBzdGF0ZSk7XHJcblxyXG4gICAgICAgIHN0YXRlLm5ld0Z1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG5ld0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLnByb2dyYW0uYm9keS51bnNoaWZ0KG5ld0Z1bmN0aW9uKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gYXN0O1xyXG4gICAgfVxyXG5cclxufShleHBvcnRzKSk7XHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIHdpdGggSmV0QnJhaW5zIFdlYlN0b3JtLlxyXG4gKiBVc2VyOiBsYWNoc2VuXHJcbiAqIERhdGU6IDEyLzE3LzEzXHJcbiAqIFRpbWU6IDE6MjEgUE1cclxuICogVG8gY2hhbmdlIHRoaXMgdGVtcGxhdGUgdXNlIEZpbGUgfCBTZXR0aW5ncyB8IEZpbGUgVGVtcGxhdGVzLlxyXG4gKi9cclxuKGZ1bmN0aW9uIChucykge1xyXG5cclxubnMuTGlnaHRMb29wID0gZnVuY3Rpb24gTGlnaHRMb29wKHBvc2l0aW9uLCBhbWJpZW50SW50ZW5zaXR5KXtcclxuICAgIHZhciBWID0gcG9zaXRpb24uZmxpcCgpLm5vcm1hbGl6ZSgpLCBkaXN0LCBhdHRlbjtcclxuICAgIHZhciBrZENvbXBsZXRlID0gbmV3IFZlYzMoMCwwLDApLCBrc0NvbXBsZXRlID0gbmV3IFZlYzMoMCwwLDApO1xyXG4gICAgaWYgKHRoaXMuTUFYX1BPSU5UTElHSFRTKVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLk1BWF9QT0lOVExJR0hUUzsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBvaW50TGlnaHRPbltpXSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgIHZhciBMID0gdGhpcy52aWV3TWF0cml4Lm11bFZlYyh0aGlzLnBvaW50TGlnaHRQb3NpdGlvbltpXSwgMS4wKS54eXooKTtcclxuICAgICAgICBMID0gTC5zdWIocG9zaXRpb24pO1xyXG4gICAgICAgIGRpc3QgPSBMLmxlbmd0aCgpO1xyXG4gICAgICAgIEwgPSBMLm5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICB2YXIga2QgPSBuZXcgVmVjMygwLDAsMCksIGtzID0gbmV3IFZlYzMoMCwwLDApO1xyXG4gICAgICAgIFwiQlJERl9FTlRSWVwiO1xyXG5cclxuICAgICAgICBhdHRlbiA9IDEuMCAvICh0aGlzLnBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS54KCkgKyB0aGlzLnBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS55KCkgKiBkaXN0ICsgdGhpcy5wb2ludExpZ2h0QXR0ZW51YXRpb25baV0ueigpICogZGlzdCAqIGRpc3QpO1xyXG4gICAgICAgIGtkID0ga2QubXVsKHRoaXMucG9pbnRMaWdodEludGVuc2l0eVtpXSkubXVsKGF0dGVuKTtcclxuICAgICAgICBrcyA9IGtzLm11bCh0aGlzLnBvaW50TGlnaHRJbnRlbnNpdHlbaV0pLm11bChhdHRlbik7XHJcbiAgICAgICAga2RDb21wbGV0ZSA9IGtkQ29tcGxldGUuYWRkKGtkKTtcclxuICAgICAgICBrc0NvbXBsZXRlID0ga3NDb21wbGV0ZS5hZGQoa3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuTUFYX0RJUkVDVElPTkFMTElHSFRTKVxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuTUFYX0RJUkVDVElPTkFMTElHSFRTOyBpKyspIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGlyZWN0aW9uYWxMaWdodE9uW2ldKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgTCA9IHRoaXMudmlld01hdHJpeC5tdWxWZWModGhpcy5kaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW2ldLCAwKS54eXooKTtcclxuICAgICAgICBMID0gTC5mbGlwKCkubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgIHZhciBrZCA9IG5ldyBWZWMzKDAsMCwwKSwga3MgPSBuZXcgVmVjMygwLDAsMCk7XHJcbiAgICAgICAgXCJCUkRGX0VOVFJZXCI7XHJcblxyXG4gICAgICAgIGtkID0ga2QubXVsKHRoaXMuZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVtpXSk7XHJcbiAgICAgICAga3MgPSBrcy5tdWwodGhpcy5kaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5W2ldKTtcclxuICAgICAgICBrZENvbXBsZXRlID0ga2RDb21wbGV0ZS5hZGQoa2QpO1xyXG4gICAgICAgIGtzQ29tcGxldGUgPSBrc0NvbXBsZXRlLmFkZChrcyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5NQVhfU1BPVExJR0hUUylcclxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLk1BWF9TUE9UTElHSFRTOyBpKyspIHtcclxuICAgICAgICBpZiAodGhpcy5zcG90TGlnaHRPbltpXSkge1xyXG4gICAgICAgICAgICBMID0gdGhpcy52aWV3TWF0cml4Lm11bFZlYyh0aGlzLnNwb3RMaWdodFBvc2l0aW9uW2ldLCAxLjApLnh5eigpO1xyXG4gICAgICAgICAgICBMID0gTC5zdWIocG9zaXRpb24pO1xyXG4gICAgICAgICAgICBkaXN0ID0gTC5sZW5ndGgoKTtcclxuICAgICAgICAgICAgTCA9IEwubm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbERpcmVjdGlvbiA9IHRoaXMudmlld01hdHJpeC5tdWxWZWModGhpcy5zcG90TGlnaHREaXJlY3Rpb25baV0uZmxpcCgpLCAwKS54eXooKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTC5kb3QobERpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGlmKGFuZ2xlID4gdGhpcy5zcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVbaV0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZCA9IG5ldyBWZWMzKDAsMCwwKSwga3MgPSBuZXcgVmVjMygwLDAsMCk7XHJcbiAgICAgICAgICAgICAgICBcIkJSREZfRU5UUllcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IDEuMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNwb3RMaWdodENhc3RTaGFkb3dbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd3BvcyA9IHRoaXMudmlld0ludmVyc2VNYXRyaXgubXVsVmVjKHBvc2l0aW9uLCAxLjApLnh5eigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbHNQb3MgPSB0aGlzLnNwb3RMaWdodE1hdHJpeFtpXS5tdWxWZWMobmV3IFZlYzQod3BvcywgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJzcGVjdGl2ZURpdlBvcyA9IGxzUG9zLnh5eigpLmRpdihsc1Bvcy53KCkpLm11bCgwLjUpLmFkZCgwLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsc0RlcHRoID0gcGVyc3BlY3RpdmVEaXZQb3MueigpIC0gdGhpcy5zcG90TGlnaHRTaGFkb3dCaWFzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlnaHR1diA9IHBlcnNwZWN0aXZlRGl2UG9zLnh5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdFNoaWZ0ID0gbmV3IFZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXhTaXplID0gbmV3IFZlYzIoTWF0aC5tYXgodGhpcy5jb29yZHMueCgpLCB0aGlzLmNvb3Jkcy55KCkpKS5tdWwoMik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleGVsU2l6ZSA9IG5ldyBWZWMyKDEuMCwgMS4wKS5kaXYodGV4U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBNYXRoLmZyYWN0KGxpZ2h0dXYubXVsKHRleFNpemUpLmFkZCgwLjUpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudHJvaWRVViA9IE1hdGguZmxvb3IobGlnaHR1di5tdWwodGV4U2l6ZSkuYWRkKDAuNSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRyb2lkVVYgPSBjZW50cm9pZFVWLmRpdih0ZXhTaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxiID0gdGhpcy5zcG90TGlnaHRTaGFkb3dNYXBbaV0uc2FtcGxlMkQoY2VudHJvaWRVVi5hZGQodGV4ZWxTaXplLm11bChuZXcgVmVjMigwLjAsIDAuMCkpKSkuZG90KGJpdFNoaWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGIgPj0gbHNEZXB0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGIgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYiA9IDAuMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGx0ID0gdGhpcy5zcG90TGlnaHRTaGFkb3dNYXBbaV0uc2FtcGxlMkQoY2VudHJvaWRVVi5hZGQodGV4ZWxTaXplLm11bChuZXcgVmVjMigwLjAsIDEuMCkpKSkuZG90KGJpdFNoaWZ0KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsdCA+PSBsc0RlcHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsdCA9IDEuMDtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0ID0gMC4wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmIgPSB0aGlzLnNwb3RMaWdodFNoYWRvd01hcFtpXS5zYW1wbGUyRChjZW50cm9pZFVWLmFkZCh0ZXhlbFNpemUubXVsKG5ldyBWZWMyKDEuMCwgMC4wKSkpKS5kb3QoYml0U2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYiA+PSBsc0RlcHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYiA9IDEuMDtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJiID0gMC4wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcnQgPSB0aGlzLnNwb3RMaWdodFNoYWRvd01hcFtpXS5zYW1wbGUyRChjZW50cm9pZFVWLmFkZCh0ZXhlbFNpemUubXVsKG5ldyBWZWMyKDEuMCwgMS4wKSkpKS5kb3QoYml0U2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydCA+PSBsc0RlcHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBydCA9IDEuMDtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ0ID0gMC4wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IE1hdGgubWl4KGxiLCBsdCwgZi55KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gTWF0aC5taXgocmIsIHJ0LCBmLnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IE1hdGgubWl4KGEsIGIsIGYueCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc29mdG5lc3MgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICBpZihhbmdsZSA8IHRoaXMuc3BvdExpZ2h0Q29zU29mdEZhbGxvZmZBbmdsZVtpXSlcclxuICAgICAgICAgICAgICAgICAgICBzb2Z0bmVzcyA9IChhbmdsZSAtIHRoaXMuc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlW2ldKSAvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVbaV0gLSAgdGhpcy5zcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGF0dGVuID0gMS4wIC8gKHRoaXMuc3BvdExpZ2h0QXR0ZW51YXRpb25baV0ueCgpICsgdGhpcy5zcG90TGlnaHRBdHRlbnVhdGlvbltpXS55KCkgKiBkaXN0ICsgdGhpcy5zcG90TGlnaHRBdHRlbnVhdGlvbltpXS56KCkgKiBkaXN0ICogZGlzdCk7XHJcbiAgICAgICAgICAgICAgICBrZCA9IGtkLm11bCh0aGlzLnNwb3RMaWdodEludGVuc2l0eVtpXSkubXVsKGF0dGVuICogc29mdG5lc3MgKiBjKTtcclxuICAgICAgICAgICAgICAgIGtzID0ga3MubXVsKHRoaXMuc3BvdExpZ2h0SW50ZW5zaXR5W2ldKS5tdWwoYXR0ZW4gKiBzb2Z0bmVzcyAqIGMpO1xyXG4gICAgICAgICAgICAgICAga2RDb21wbGV0ZSA9IGtkQ29tcGxldGUuYWRkKGtkKTtcclxuICAgICAgICAgICAgICAgIGtzQ29tcGxldGUgPSBrc0NvbXBsZXRlLmFkZChrcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgYW1iaWVudENvbG9yID0gbmV3IFZlYzMoMCwwLDApO1xyXG4gICAgXCJBTUJJRU5UX0VOVFJZXCI7XHJcbiAgICBrZENvbXBsZXRlID0ga2RDb21wbGV0ZS5hZGQoYW1iaWVudENvbG9yKTtcclxuICAgIHZhciBlbWlzc2l2ZUNvbG9yID0gbmV3IFZlYzMoMCwgMCwgMCk7XHJcbiAgICBcIkVNSVNTSVZFX0VOVFJZXCJcclxuICAgIGlmICh0aGlzLnNzYW9NYXApIHtcclxuICAgICAgICBrZENvbXBsZXRlID0ga2RDb21wbGV0ZS5tdWwoMSAtIHRoaXMuc3Nhb01hcC5zYW1wbGUyRCh0aGlzLm5vcm1hbGl6ZWRDb29yZHMpLnIoKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVmcmFjdENvbG9yID0gbmV3IFZlYzMoMCwgMCwgMCk7XHJcbiAgICB2YXIgcmVmbGVjdENvbG9yID0gbmV3IFZlYzMoMCwgMCwgMCk7XHJcbiAgICBcIlJFRlJBQ1RfUkVGTEVDVF9FTlRSWVwiXHJcbiAgICByZXR1cm4gTWF0aC5wb3cobmV3IFZlYzQoZW1pc3NpdmVDb2xvci5hZGQoa2RDb21wbGV0ZS5hZGQoa3NDb21wbGV0ZSkpLmFkZChyZWZyYWN0Q29sb3IpLmFkZChyZWZsZWN0Q29sb3IpLCAxLjApLCBuZXcgVmVjNCgxLzIuMikpO1xyXG59XHJcblxyXG59KGV4cG9ydHMpKTtcclxuIiwiKGZ1bmN0aW9uIChucykge1xyXG5cclxuICAgICAgICBucy5lbWlzc2l2ZSA9IHtcclxuICAgICAgICAgICAgZ2V0RW1pc3NpdmU6IGZ1bmN0aW9uIGdldEVtaXNzaXZlKGNvbG9yKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG5zLmRpZmZ1c2UgPSB7XHJcbiAgICAgICAgICAgIGdldERpZmZ1c2U6IGZ1bmN0aW9uIGdldERpZmZ1c2UoTCwgViwgY29sb3IsIE4sIHJvdWdobmVzcyl7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHJvdWdobmVzcyBpcyBkZWZpbmVkIHdlIHVzZSBPcmVuIE5heWFyIGJyZGYuXHJcbiAgICAgICAgICAgICAgICB2YXIgYSwgYiwgTmRvdFYsIHRoZXRhT3V0LCBwaGlPdXQsIHRoZXRhSW47XHJcbiAgICAgICAgICAgICAgICB2YXIgY29zUGhpRGlmZiwgYWxwaGEsIGJldGE7XHJcbiAgICAgICAgICAgICAgICB2YXIgTmRvdEwgPSBNYXRoLnNhdHVyYXRlKE4uZG90KEwpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMYW1iZXJ0aWFuIHJlZmxlY3Rpb24gaXMgY29uc3RhbnQgb3ZlciB0aGUgaGVtaXNwaGVyZS5cclxuICAgICAgICAgICAgICAgIHZhciBicmRmID0gMS4wO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyb3VnaG5lc3MgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IDEuMCAtIChyb3VnaG5lc3MgKiByb3VnaG5lc3MpIC8gKDIgKiAocm91Z2huZXNzICogcm91Z2huZXNzICsgMC4zMykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSAwLjQ1ICogKHJvdWdobmVzcyAqIHJvdWdobmVzcykgLyAocm91Z2huZXNzICogcm91Z2huZXNzICsgMC4wOSk7XHJcbiAgICAgICAgICAgICAgICAgICAgTmRvdFYgPSBOLmRvdChWKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGV0YU91dCA9IE1hdGguYWNvcyhOZG90Vik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGhpT3V0ID0gVi5zdWIoTi5tdWwoTmRvdFYpKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGV0YUluID0gTWF0aC5hY29zKE5kb3RMKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3NQaGlEaWZmID0gcGhpT3V0LmRvdChMLnN1YihOLm11bChOZG90TCkpLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IE1hdGgubWF4KHRoZXRhT3V0LCB0aGV0YUluKTtcclxuICAgICAgICAgICAgICAgICAgICBiZXRhID0gTWF0aC5taW4odGhldGFPdXQsIHRoZXRhSW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZGYgPSAoYSArIGIgKiBNYXRoLnNhdHVyYXRlKGNvc1BoaURpZmYpICogTWF0aC5zaW4oYWxwaGEpICogTWF0aC50YW4oYmV0YSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJkZiAqPSBOZG90TDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvci5tdWwoYnJkZik7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBnZXRBbWJpZW50OiBmdW5jdGlvbiBnZXRBbWJpZW50KGFtYmllbnRJbnRlbnNpdHksIGNvbG9yLCBOLCByb3VnaG5lc3Mpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yLm11bChhbWJpZW50SW50ZW5zaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG5zLnBob25nID0ge1xyXG4gICAgICAgICAgICBnZXRTcGVjdWxhcjogZnVuY3Rpb24gZ2V0U3BlY3VsYXIoTCwgViwgY29sb3IsIE4sIHNoaW5pbmVzcyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgUiA9IEwucmVmbGVjdChOKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBleWVWZWN0b3IgPSBWLmZsaXAoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvci5tdWwoTWF0aC5wb3coTWF0aC5tYXgoUi5kb3QoZXllVmVjdG9yKSwwLjApLCBzaGluaW5lc3MqMTI4LjApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG5zLmNvb2tUb3JyYW5jZSA9IHtcclxuICAgICAgICAgICAgZ2V0U3BlY3VsYXI6IGZ1bmN0aW9uIGdldFNwZWN1bGFyKEwsIFYsIGNvbG9yLCBOLCBpb3IsIHJvdWdobmVzcyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgUjAgPSBNYXRoLnBvdygoMSAtIGlvcikgLyAoMSArIGlvciksIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIEggPSBWLmFkZChMKS5ub3JtYWxpemUoKSxcclxuICAgICAgICAgICAgICAgICAgICBOZG90SCA9IE4uZG90KEgpLFxyXG4gICAgICAgICAgICAgICAgICAgIE5kb3RMID0gTWF0aC5zYXR1cmF0ZShOLmRvdChMKSksXHJcbiAgICAgICAgICAgICAgICAgICAgSGRvdE4gPSBILmRvdChOKSxcclxuICAgICAgICAgICAgICAgICAgICBIZG90TCA9IEguZG90KEwpLFxyXG4gICAgICAgICAgICAgICAgICAgIEhkb3RWID0gSC5kb3QoViksXHJcbiAgICAgICAgICAgICAgICAgICAgTmRvdFYgPSBOLmRvdChWKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCZWNrbWFubiBkaXN0cmlidXRpb25cclxuICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IE1hdGguYWNvcyhOZG90SCksXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtZXJhdG9yID0gTWF0aC5leHAoLU1hdGgucG93KE1hdGgudGFuKGFscGhhKSAvIHJvdWdobmVzcywgMikpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbm9taW5hdG9yID0gTWF0aC5wb3cocm91Z2huZXNzLCAyKSAqIE1hdGgucG93KE5kb3RILCA0KSxcclxuICAgICAgICAgICAgICAgICAgICBkID0gIE1hdGgubWF4KDAsIG51bWVyYXRvciAvIGRlbm9taW5hdG9yKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZW9tZXRyaWMgYXR0ZW51YXRpb25cclxuICAgICAgICAgICAgICAgIHZhciBHMSA9IDIgKiBIZG90TiAqIE5kb3RWIC8gSGRvdFYsXHJcbiAgICAgICAgICAgICAgICAgICAgRzIgPSAyICogSGRvdE4gKiBOZG90TCAvIEhkb3RWLFxyXG4gICAgICAgICAgICAgICAgICAgIGcgPSAgTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oRzEsIEcyKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBNYXRoLm1heCgwLCBSMCArICgxIC0gUjApICogTWF0aC5wb3coMSAtIE5kb3RILCA1KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJyZGYgPSBkICogZyAqIGYgLyAoTWF0aC5QSSAqIE5kb3RWKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvci5tdWwoYnJkZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBucy53YXJkID0ge1xyXG4gICAgICAgICAgICBnZXRTcGVjdWxhcjogZnVuY3Rpb24gZ2V0U3BlY3VsYXIoTCwgViwgY29sb3IsIE4sIFQsIGF4LCBheSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgSCA9IEwuYWRkKFYpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIEIgPSBOLmNyb3NzKFQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIE5kb3RWID0gTi5kb3QoVik7XHJcbiAgICAgICAgICAgICAgICB2YXIgTmRvdEwgPSBNYXRoLnNhdHVyYXRlKE4uZG90KEwpKTtcclxuICAgICAgICAgICAgICAgIHZhciBOZG90SCA9IE4uZG90KEgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIEhkb3RUID0gSC5kb3QoVCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgSGRvdEIgPSBILmRvdChCKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSAxIC8gKDQgKiBNYXRoLlBJICogYXggKiBheSAqIE1hdGguc3FydChOZG90TCAqIE5kb3RWKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmV0YSA9IC0oTWF0aC5wb3coSGRvdFQgLyBheCwgMikgKyBNYXRoLnBvdyhIZG90QiAvIGF5LCAyKSkgLyAoTmRvdEggKiBOZG90SCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2Vjb25kID0gTWF0aC5leHAoYmV0YSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnJkZiA9IE1hdGgubWF4KDAsIGZpcnN0ICogc2Vjb25kKSAqIE5kb3RMO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvci5tdWwoYnJkZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBucy5zY2F0dGVyID0ge1xyXG4gICAgICAgICAgICBnZXRTcGVjdWxhcjogZnVuY3Rpb24gZ2V0U3BlY3VsYXIoTCwgViwgY29sb3IsIE4sIHdyYXAsIHNjYXR0ZXJXaWR0aCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgTmRvdEwgPSBNYXRoLnNhdHVyYXRlKE4uZG90KEwpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgTmRvdExXcmFwID0gKE5kb3RMICsgd3JhcCkgLyAoMSArIHdyYXApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYXR0ZXIgPSBNYXRoLnNtb290aHN0ZXAoMC4wLCBzY2F0dGVyV2lkdGgsIE5kb3RMV3JhcCkgKiBNYXRoLnNtb290aHN0ZXAoc2NhdHRlcldpZHRoICogMi4wLCBzY2F0dGVyV2lkdGgsIE5kb3RMV3JhcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yLm11bChzY2F0dGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG5zLnJlZmxlY3QgPSB7XHJcbiAgICAgICAgICAgIGdldFJlZmxlY3Q6IGZ1bmN0aW9uIGdldFJlZmxlY3QocG9zaXRpb24sIE4sIGZhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgTiA9IHRoaXMudmlld0ludmVyc2VNYXRyaXgubXVsVmVjKE4sIDApLnh5eigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIEkgPSB0aGlzLnZpZXdJbnZlcnNlTWF0cml4Lm11bFZlYyhwb3NpdGlvbiwgMS4wKS54eXooKS5zdWIodGhpcy5jYW1lcmFQb3NpdGlvbikubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVmbGVjdGlvbjNEID0gSS5yZWZsZWN0KE4pLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlZmxlY3Rpb24yRCA9IG5ldyBWZWMyKChNYXRoLmF0YW4yKC1yZWZsZWN0aW9uM0QueigpLCByZWZsZWN0aW9uM0QueCgpKSArIE1hdGguUEkpIC8gKDIgKiBNYXRoLlBJKSwgKE1hdGguYXNpbihyZWZsZWN0aW9uM0QueSgpKSArIE1hdGguUEkgLyAyLjApIC8gTWF0aC5QSSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3codGhpcy5lbnZpcm9ubWVudC5zYW1wbGUyRChyZWZsZWN0aW9uMkQpLnJnYigpLCBuZXcgVmVjMygyLjIpKS5tdWwoZmFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG5zLnJlZnJhY3QgPSB7XHJcbiAgICAgICAgICAgIGdldFJlZnJhY3Q6IGZ1bmN0aW9uIGdldFJlZnJhY3QocG9zaXRpb24sIE4sIGV0YSwgZmFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBOID0gdGhpcy52aWV3SW52ZXJzZU1hdHJpeC5tdWxWZWMoTiwgMCkueHl6KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgSSA9IHRoaXMudmlld0ludmVyc2VNYXRyaXgubXVsVmVjKHBvc2l0aW9uLCAxLjApLnh5eigpLnN1Yih0aGlzLmNhbWVyYVBvc2l0aW9uKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIHZhciByZWZyYWN0aW9uM0QgPSBJLnJlZnJhY3QoTiwgZXRhKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIHZhciByZWZyYWN0aW9uMkQgPSBuZXcgVmVjMigoTWF0aC5hdGFuMigtcmVmcmFjdGlvbjNELnooKSwgcmVmcmFjdGlvbjNELngoKSkgKyBNYXRoLlBJKSAvICgyICogTWF0aC5QSSksIChNYXRoLmFzaW4ocmVmcmFjdGlvbjNELnkoKSkgKyBNYXRoLlBJIC8gMi4wKSAvIE1hdGguUEkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMuZW52aXJvbm1lbnQuc2FtcGxlMkQocmVmcmFjdGlvbjJEKS5yZ2IoKSwgbmV3IFZlYzMoMi4yKSkubXVsKGZhY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxufShleHBvcnRzKSk7XHJcbiJdfQ==
